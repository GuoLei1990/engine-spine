var IntersectInfo;
(function(IntersectInfo2) {
  IntersectInfo2[IntersectInfo2["EXCLUDE"] = 0] = "EXCLUDE";
  IntersectInfo2[IntersectInfo2["INTERSECT"] = 1] = "INTERSECT";
  IntersectInfo2[IntersectInfo2["INCLUDE"] = 2] = "INCLUDE";
})(IntersectInfo || (IntersectInfo = {}));

function pointDistanceToPlane(plane, pt) {
  return plane.x * pt.x + plane.y * pt.y + plane.z * pt.z + plane.w;
}
function getMaxScaleByModelMatrix(modelMatrix) {
  let m = modelMatrix.elements;
  let scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
  let scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
  let scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
  return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
}

class MathUtil {
  static clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }
  static equals(a, b) {
    return Math.abs(a - b) <= MathUtil.zeroTolerance;
  }
  static isPowerOf2(v) {
    return (v & v - 1) === 0;
  }
  static radianToDegree(r) {
    return r * MathUtil.radToDegreeFactor;
  }
  static degreeToRadian(d) {
    return d * MathUtil.degreeToRadFactor;
  }
}
MathUtil.zeroTolerance = 1e-6;
MathUtil.radToDegreeFactor = 180 / Math.PI;
MathUtil.degreeToRadFactor = Math.PI / 180;

class Vector3 {
  static add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
  }
  static subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
    out.z = left.z - right.z;
  }
  static multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
    out.z = left.z * right.z;
  }
  static divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
    out.z = left.z / right.z;
  }
  static dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z;
  }
  static cross(left, right, out) {
    const ax = left.x;
    const ay = left.y;
    const az = left.z;
    const bx = right.x;
    const by = right.y;
    const bz = right.z;
    out.x = ay * bz - az * by;
    out.y = az * bx - ax * bz;
    out.z = ax * by - ay * bx;
  }
  static distance(a, b) {
    const x = b.x - a.x;
    const y = b.y - a.y;
    const z = b.z - a.z;
    return Math.sqrt(x * x + y * y + z * z);
  }
  static distanceSquared(a, b) {
    const x = b.x - a.x;
    const y = b.y - a.y;
    const z = b.z - a.z;
    return x * x + y * y + z * z;
  }
  static equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);
  }
  static lerp(start, end, t, out) {
    const {x, y, z} = start;
    out.x = x + (end.x - x) * t;
    out.y = y + (end.y - y) * t;
    out.z = z + (end.z - z) * t;
  }
  static max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
    out.z = Math.max(left.z, right.z);
  }
  static min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
    out.z = Math.min(left.z, right.z);
  }
  static negate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
  }
  static normalize(a, out) {
    const {x, y, z} = a;
    let len = Math.sqrt(x * x + y * y + z * z);
    if (len > 0) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
    }
  }
  static scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
  }
  static transformNormal(v, m, out) {
    const {x, y, z} = v;
    const e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8];
    out.y = x * e[1] + y * e[5] + z * e[9];
    out.z = x * e[2] + y * e[6] + z * e[10];
  }
  static transformToVec3(v, m, out) {
    const {x, y, z} = v;
    const e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
  }
  static transformToVec4(v, m, out) {
    const {x, y, z} = v;
    const e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
    out.w = x * e[3] + y * e[7] + z * e[11] + e[15];
  }
  static transformCoordinate(v, m, out) {
    const {x, y, z} = v;
    const e = m.elements;
    let w = x * e[3] + y * e[7] + z * e[11] + e[15];
    w = 1 / w;
    out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;
    out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;
    out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;
  }
  static transformByQuat(v, q, out) {
    const {x, y, z} = v;
    const qx = q.x;
    const qy = q.y;
    const qz = q.z;
    const qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    out.x = ix * qw - iw * qx - iy * qz + iz * qy;
    out.y = iy * qw - iw * qy - iz * qx + ix * qz;
    out.z = iz * qw - iw * qz - ix * qy + iy * qx;
  }
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  setValue(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setValueByArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  add(right) {
    this.x += right.x;
    this.y += right.y;
    this.z += right.z;
    return this;
  }
  subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    this.z -= right.z;
    return this;
  }
  multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    this.z *= right.z;
    return this;
  }
  divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    this.z /= right.z;
    return this;
  }
  length() {
    const {x, y, z} = this;
    return Math.sqrt(x * x + y * y + z * z);
  }
  lengthSquared() {
    const {x, y, z} = this;
    return x * x + y * y + z * z;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  normalize() {
    Vector3.normalize(this, this);
    return this;
  }
  scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    return this;
  }
  toArray(out, outOffset = 0) {
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    return out;
  }
  transformNormal(m) {
    Vector3.transformNormal(this, m, this);
    return this;
  }
  transformToVec3(m) {
    Vector3.transformToVec3(this, m, this);
    return this;
  }
  transformCoordinate(m) {
    Vector3.transformCoordinate(this, m, this);
    return this;
  }
  transformByQuat(q) {
    Vector3.transformByQuat(this, q, this);
    return this;
  }
}
Vector3._zero = new Vector3(0, 0, 0);
Vector3._one = new Vector3(1, 1, 1);
Vector3._tempVector3 = new Vector3();

class BoundingSphere {
  constructor(minLocal, maxLocal, modelMatrix) {
    this.center = new Vector3();
    this.radius = 0;
    this.centerWorld = new Vector3();
    this.radiusWorld = 0;
    let distance = Vector3.distance(minLocal, maxLocal);
    this.radius = distance * 0.5;
    Vector3.add(minLocal, maxLocal, this.center);
    this.center.scale(0.5);
    this.updateByModelMatrix(modelMatrix);
  }
  updateByModelMatrix(modelMatrix) {
    Vector3.transformCoordinate(this.center, modelMatrix, this.centerWorld);
    this.radiusWorld = this.radius * getMaxScaleByModelMatrix(modelMatrix);
  }
  intersectsFrustum(frustumPlanes) {
    for (let i = 0; i < 6; i++) {
      const distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);
      if (distance < -this.radiusWorld) {
        return IntersectInfo.EXCLUDE;
      }
      if (distance < this.radiusWorld) {
        return IntersectInfo.INTERSECT;
      }
    }
    return IntersectInfo.INCLUDE;
  }
  isInFrustum(frustumPlanes) {
    for (let i = 0; i < 6; i++) {
      const distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);
      if (distance < -this.radiusWorld) {
        return false;
      }
    }
    return true;
  }
}

class BoundingBox {
  constructor(minWorld, maxWorld) {
    this.min = new Vector3();
    this.max = new Vector3();
    this.update(minWorld, maxWorld);
  }
  update(minWorld, maxWorld) {
    minWorld.cloneTo(this.min);
    maxWorld.cloneTo(this.max);
  }
  setFromCenterAndSize(center, size) {
    let halfSize = new Vector3();
    Vector3.scale(size, 0.5, halfSize);
    Vector3.subtract(center, halfSize, this.min);
    Vector3.add(center, halfSize, this.max);
  }
  intersectsFrustum(frustumPlanes) {
    const {min, max} = this;
    const p1 = new Vector3();
    const p2 = new Vector3();
    for (let i = 0; i < 6; i++) {
      const plane = frustumPlanes[i];
      p1.x = plane.x > 0 ? min.x : max.x;
      p2.x = plane.x > 0 ? max.x : min.x;
      p1.y = plane.y > 0 ? min.y : max.y;
      p2.y = plane.y > 0 ? max.y : min.y;
      p1.z = plane.z > 0 ? min.z : max.z;
      p2.z = plane.z > 0 ? max.z : min.z;
      const d1 = pointDistanceToPlane(plane, p1);
      const d2 = pointDistanceToPlane(plane, p2);
      if (d1 < 0 && d2 < 0) {
        return IntersectInfo.EXCLUDE;
      }
      if (d1 < 0 || d2 < 0) {
        return IntersectInfo.INTERSECT;
      }
    }
    return IntersectInfo.INCLUDE;
  }
  isInFrustum(frustumPlanes) {
    const min = this.min;
    const max = this.max;
    const p = new Vector3();
    for (let i = 0; i < 6; i++) {
      const plane = frustumPlanes[i];
      p.x = plane.x > 0 ? max.x : min.x;
      p.y = plane.y > 0 ? max.y : min.y;
      p.z = plane.z > 0 ? max.z : min.z;
      if (pointDistanceToPlane(plane, p) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new BoundingBox(this.min, this.max);
  }
  cloneTo(out) {
    this.min.cloneTo(out.min);
    this.max.cloneTo(out.max);
  }
}

class Matrix3x3 {
  constructor(m11 = 1, m12 = 0, m13 = 0, m21 = 0, m22 = 1, m23 = 0, m31 = 0, m32 = 0, m33 = 1) {
    this.elements = new Float32Array(9);
    const e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
  }
  static add(left, right, out) {
    const le = left.elements;
    const re = right.elements;
    const oe = out.elements;
    oe[0] = le[0] + re[0];
    oe[1] = le[1] + re[1];
    oe[2] = le[2] + re[2];
    oe[3] = le[3] + re[3];
    oe[4] = le[4] + re[4];
    oe[5] = le[5] + re[5];
    oe[6] = le[6] + re[6];
    oe[7] = le[7] + re[7];
    oe[8] = le[8] + re[8];
  }
  static subtract(left, right, out) {
    const le = left.elements;
    const re = right.elements;
    const oe = out.elements;
    oe[0] = le[0] - re[0];
    oe[1] = le[1] - re[1];
    oe[2] = le[2] - re[2];
    oe[3] = le[3] - re[3];
    oe[4] = le[4] - re[4];
    oe[5] = le[5] - re[5];
    oe[6] = le[6] - re[6];
    oe[7] = le[7] - re[7];
    oe[8] = le[8] - re[8];
  }
  static multiply(left, right, out) {
    const le = left.elements;
    const re = right.elements;
    const oe = out.elements;
    const l11 = le[0], l12 = le[1], l13 = le[2];
    const l21 = le[3], l22 = le[4], l23 = le[5];
    const l31 = le[6], l32 = le[7], l33 = le[8];
    const r11 = re[0], r12 = re[1], r13 = re[2];
    const r21 = re[3], r22 = re[4], r23 = re[5];
    const r31 = re[6], r32 = re[7], r33 = re[8];
    oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
    oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
    oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
    oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
    oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
    oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
    oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
    oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
    oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
  }
  static equals(left, right) {
    const le = left.elements;
    const re = right.elements;
    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
  }
  static rotationQuaternion(q, out) {
    const oe = out.elements;
    const {x, y, z, w} = q;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    oe[0] = 1 - yy - zz;
    oe[3] = yx - wz;
    oe[6] = zx + wy;
    oe[1] = yx + wz;
    oe[4] = 1 - xx - zz;
    oe[7] = zy - wx;
    oe[2] = zx - wy;
    oe[5] = zy + wx;
    oe[8] = 1 - xx - yy;
  }
  static scaling(s, out) {
    const oe = out.elements;
    oe[0] = s.x;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = s.y;
    oe[5] = 0;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 1;
  }
  static translation(trans, out) {
    const oe = out.elements;
    oe[0] = 1;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 1;
    oe[5] = 0;
    oe[6] = trans.x;
    oe[7] = trans.y;
    oe[8] = 1;
  }
  static invert(a, out) {
    const ae = a.elements;
    const oe = out.elements;
    const a11 = ae[0], a12 = ae[1], a13 = ae[2];
    const a21 = ae[3], a22 = ae[4], a23 = ae[5];
    const a31 = ae[6], a32 = ae[7], a33 = ae[8];
    const b12 = a33 * a22 - a23 * a32;
    const b22 = -a33 * a21 + a23 * a31;
    const b32 = a32 * a21 - a22 * a31;
    let det = a11 * b12 + a12 * b22 + a13 * b32;
    if (!det) {
      return;
    }
    det = 1 / det;
    oe[0] = b12 * det;
    oe[1] = (-a33 * a12 + a13 * a32) * det;
    oe[2] = (a23 * a12 - a13 * a22) * det;
    oe[3] = b22 * det;
    oe[4] = (a33 * a11 - a13 * a31) * det;
    oe[5] = (-a23 * a11 + a13 * a21) * det;
    oe[6] = b32 * det;
    oe[7] = (-a32 * a11 + a12 * a31) * det;
    oe[8] = (a22 * a11 - a12 * a21) * det;
  }
  static normalMatrix(mat4, out) {
    const ae = mat4.elements;
    const oe = out.elements;
    const a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
    const a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
    const a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
    const a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
    const b00 = a11 * a22 - a12 * a21;
    const b01 = a11 * a23 - a13 * a21;
    const b02 = a11 * a24 - a14 * a21;
    const b03 = a12 * a23 - a13 * a22;
    const b04 = a12 * a24 - a14 * a22;
    const b05 = a13 * a24 - a14 * a23;
    const b06 = a31 * a42 - a32 * a41;
    const b07 = a31 * a43 - a33 * a41;
    const b08 = a31 * a44 - a34 * a41;
    const b09 = a32 * a43 - a33 * a42;
    const b10 = a32 * a44 - a34 * a42;
    const b11 = a33 * a44 - a34 * a43;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
  }
  static rotate(a, r, out) {
    const ae = a.elements;
    const oe = out.elements;
    const s = Math.sin(r);
    const c = Math.cos(r);
    const a11 = ae[0], a12 = ae[1], a13 = ae[2];
    const a21 = ae[3], a22 = ae[4], a23 = ae[5];
    const a31 = ae[6], a32 = ae[7], a33 = ae[8];
    oe[0] = c * a11 + s * a21;
    oe[1] = c * a12 + s * a22;
    oe[2] = c * a13 + s * a23;
    oe[3] = c * a21 - s * a11;
    oe[4] = c * a22 - s * a12;
    oe[5] = c * a23 - s * a13;
    oe[6] = a31;
    oe[7] = a32;
    oe[8] = a33;
  }
  static scale(m, s, out) {
    const {x, y} = s;
    const ae = m.elements;
    const oe = out.elements;
    oe[0] = x * ae[0];
    oe[1] = x * ae[1];
    oe[2] = x * ae[2];
    oe[3] = y * ae[3];
    oe[4] = y * ae[4];
    oe[5] = y * ae[5];
    oe[6] = ae[6];
    oe[7] = ae[7];
    oe[8] = ae[8];
  }
  static translate(m, trans, out) {
    const {x, y} = trans;
    const ae = m.elements;
    const oe = out.elements;
    const a11 = ae[0], a12 = ae[1], a13 = ae[2];
    const a21 = ae[3], a22 = ae[4], a23 = ae[5];
    const a31 = ae[6], a32 = ae[7], a33 = ae[8];
    oe[0] = a11;
    oe[1] = a12;
    oe[2] = a13;
    oe[3] = a21;
    oe[4] = a22;
    oe[5] = a23;
    oe[6] = x * a11 + y * a21 + a31;
    oe[7] = x * a12 + y * a22 + a32;
    oe[8] = x * a13 + y * a23 + a33;
  }
  static transpose(a, out) {
    const ae = a.elements;
    const oe = out.elements;
    if (out === a) {
      const a12 = ae[1];
      const a13 = ae[2];
      const a23 = ae[5];
      oe[1] = ae[3];
      oe[2] = ae[6];
      oe[3] = a12;
      oe[5] = ae[7];
      oe[6] = a13;
      oe[7] = a23;
    } else {
      oe[0] = ae[0];
      oe[1] = ae[3];
      oe[2] = ae[6];
      oe[3] = ae[1];
      oe[4] = ae[4];
      oe[5] = ae[7];
      oe[6] = ae[2];
      oe[7] = ae[5];
      oe[8] = ae[8];
    }
  }
  setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    const e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
    return this;
  }
  setValueByArray(array, offset = 0) {
    const srce = this.elements;
    for (let i = 0; i < 12; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  }
  setValueByMatrix(a) {
    const ae = a.elements;
    const e = this.elements;
    e[0] = ae[0];
    e[1] = ae[1];
    e[2] = ae[2];
    e[3] = ae[4];
    e[4] = ae[5];
    e[5] = ae[6];
    e[6] = ae[8];
    e[7] = ae[9];
    e[8] = ae[10];
    return this;
  }
  toArray(out, outOffset = 0) {
    const e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
  }
  clone() {
    const e = this.elements;
    let ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    return ret;
  }
  cloneTo(out) {
    const e = this.elements;
    const oe = out.elements;
    oe[0] = e[0];
    oe[1] = e[1];
    oe[2] = e[2];
    oe[3] = e[3];
    oe[4] = e[4];
    oe[5] = e[5];
    oe[6] = e[6];
    oe[7] = e[7];
    oe[8] = e[8];
    return out;
  }
  add(right) {
    Matrix3x3.add(this, right, this);
    return this;
  }
  subtract(right) {
    Matrix3x3.subtract(this, right, this);
    return this;
  }
  multiply(right) {
    Matrix3x3.multiply(this, right, this);
    return this;
  }
  determinant() {
    const e = this.elements;
    const a11 = e[0], a12 = e[1], a13 = e[2];
    const a21 = e[3], a22 = e[4], a23 = e[5];
    const a31 = e[6], a32 = e[7], a33 = e[8];
    const b12 = a33 * a22 - a23 * a32;
    const b22 = -a33 * a21 + a23 * a31;
    const b32 = a32 * a21 - a22 * a31;
    return a11 * b12 + a12 * b22 + a13 * b32;
  }
  identity() {
    const e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
    return this;
  }
  invert() {
    Matrix3x3.invert(this, this);
    return this;
  }
  rotate(r) {
    Matrix3x3.rotate(this, r, this);
    return this;
  }
  scale(s) {
    Matrix3x3.scale(this, s, this);
    return this;
  }
  translate(trans) {
    Matrix3x3.translate(this, trans, this);
    return this;
  }
  transpose() {
    Matrix3x3.transpose(this, this);
    return this;
  }
}

class Quaternion {
  static add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
    out.w = left.w + right.w;
  }
  static multiply(left, right, out) {
    const ax = left.x, ay = left.y, az = left.z, aw = left.w;
    const bx = right.x, by = right.y, bz = right.z, bw = right.w;
    out.x = ax * bw + aw * bx + ay * bz - az * by;
    out.y = ay * bw + aw * by + az * bx - ax * bz;
    out.z = az * bw + aw * bz + ax * by - ay * bx;
    out.w = aw * bw - ax * bx - ay * by - az * bz;
  }
  static conjugate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = a.w;
  }
  static dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  }
  static equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
  }
  static rotationAxisAngle(axis, rad, out) {
    const normalAxis = Quaternion._tempVector3;
    Vector3.normalize(axis, normalAxis);
    rad *= 0.5;
    const s = Math.sin(rad);
    out.x = normalAxis.x * s;
    out.y = normalAxis.y * s;
    out.z = normalAxis.z * s;
    out.w = Math.cos(rad);
  }
  static rotationEuler(x, y, z, out) {
    Quaternion.rotationYawPitchRoll(y, x, z, out);
  }
  static rotationYawPitchRoll(yaw, pitch, roll, out) {
    const halfRoll = roll * 0.5;
    const halfPitch = pitch * 0.5;
    const halfYaw = yaw * 0.5;
    const sinRoll = Math.sin(halfRoll);
    const cosRoll = Math.cos(halfRoll);
    const sinPitch = Math.sin(halfPitch);
    const cosPitch = Math.cos(halfPitch);
    const sinYaw = Math.sin(halfYaw);
    const cosYaw = Math.cos(halfYaw);
    const cosYawPitch = cosYaw * cosPitch;
    const sinYawPitch = sinYaw * sinPitch;
    out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
    out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
  }
  static rotationMatrix3x3(m, out) {
    const me = m.elements;
    const m11 = me[0], m12 = me[1], m13 = me[2];
    const m21 = me[3], m22 = me[4], m23 = me[5];
    const m31 = me[6], m32 = me[7], m33 = me[8];
    const scale = m11 + m22 + m33;
    let sqrt, half;
    if (scale > 0) {
      sqrt = Math.sqrt(scale + 1);
      out.w = sqrt * 0.5;
      sqrt = 0.5 / sqrt;
      out.x = (m23 - m32) * sqrt;
      out.y = (m31 - m13) * sqrt;
      out.z = (m12 - m21) * sqrt;
    } else if (m11 >= m22 && m11 >= m33) {
      sqrt = Math.sqrt(1 + m11 - m22 - m33);
      half = 0.5 / sqrt;
      out.x = 0.5 * sqrt;
      out.y = (m12 + m21) * half;
      out.z = (m13 + m31) * half;
      out.w = (m23 - m32) * half;
    } else if (m22 > m33) {
      sqrt = Math.sqrt(1 + m22 - m11 - m33);
      half = 0.5 / sqrt;
      out.x = (m21 + m12) * half;
      out.y = 0.5 * sqrt;
      out.z = (m32 + m23) * half;
      out.w = (m31 - m13) * half;
    } else {
      sqrt = Math.sqrt(1 + m33 - m11 - m22);
      half = 0.5 / sqrt;
      out.x = (m13 + m31) * half;
      out.y = (m23 + m32) * half;
      out.z = 0.5 * sqrt;
      out.w = (m12 - m21) * half;
    }
  }
  static invert(a, out) {
    const {x, y, z, w} = a;
    const dot = x * x + y * y + z * z + w * w;
    if (dot > MathUtil.zeroTolerance) {
      const invDot = 1 / dot;
      out.x = -x * invDot;
      out.y = -y * invDot;
      out.z = -z * invDot;
      out.w = w * invDot;
    }
  }
  static lerp(start, end, t, out) {
    const inv = 1 - t;
    if (Quaternion.dot(start, end) >= 0) {
      out.x = start.x * inv + end.x * t;
      out.y = start.y * inv + end.y * t;
      out.z = start.z * inv + end.z * t;
      out.w = start.w * inv + end.w * t;
    } else {
      out.x = start.x * inv - end.x * t;
      out.y = start.y * inv - end.y * t;
      out.z = start.z * inv - end.z * t;
      out.w = start.w * inv - end.w * t;
    }
    out.normalize();
  }
  static slerp(start, end, t, out) {
    const ax = start.x;
    const ay = start.y;
    const az = start.z;
    const aw = start.w;
    let bx = end.x;
    let by = end.y;
    let bz = end.z;
    let bw = end.w;
    let scale0, scale1;
    let cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > MathUtil.zeroTolerance) {
      const omega = Math.acos(cosom);
      const sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out.x = scale0 * ax + scale1 * bx;
    out.y = scale0 * ay + scale1 * by;
    out.z = scale0 * az + scale1 * bz;
    out.w = scale0 * aw + scale1 * bw;
  }
  static normalize(a, out) {
    const {x, y, z, w} = a;
    let len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }
  }
  static rotationX(rad, out) {
    rad *= 0.5;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out.x = s;
    out.y = 0;
    out.z = 0;
    out.w = c;
  }
  static rotationY(rad, out) {
    rad *= 0.5;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out.x = 0;
    out.y = s;
    out.z = 0;
    out.w = c;
  }
  static rotationZ(rad, out) {
    rad *= 0.5;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out.x = 0;
    out.y = 0;
    out.z = s;
    out.w = c;
  }
  static rotateX(q, rad, out) {
    const {x, y, z, w} = q;
    rad *= 0.5;
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);
    out.x = x * bw + w * bx;
    out.y = y * bw + z * bx;
    out.z = z * bw - y * bx;
    out.w = w * bw - x * bx;
  }
  static rotateY(q, rad, out) {
    const {x, y, z, w} = q;
    rad *= 0.5;
    const by = Math.sin(rad);
    const bw = Math.cos(rad);
    out.x = x * bw - z * by;
    out.y = y * bw + w * by;
    out.z = z * bw + x * by;
    out.w = w * bw - y * by;
  }
  static rotateZ(q, rad, out) {
    const {x, y, z, w} = q;
    rad *= 0.5;
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);
    out.x = x * bw + y * bz;
    out.y = y * bw - x * bz;
    out.z = z * bw + w * bz;
    out.w = w * bw - z * bz;
  }
  static scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
    out.w = a.w * s;
  }
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  setValue(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setValueByArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  conjugate() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }
  getAxisAngle(out) {
    const {x, y, z} = this;
    const length = x * x + y * y + z * z;
    if (length < MathUtil.zeroTolerance) {
      out.x = 1;
      out.y = 0;
      out.z = 0;
      return 0;
    } else {
      const inv = 1 / length;
      out.x = this.x * inv;
      out.y = this.y * inv;
      out.z = this.z * inv;
      return Math.acos(this.w) * 2;
    }
  }
  identity() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 1;
    return this;
  }
  length() {
    const {x, y, z, w} = this;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  lengthSquared() {
    const {x, y, z, w} = this;
    return x * x + y * y + z * z + w * w;
  }
  normalize() {
    Quaternion.normalize(this, this);
    return this;
  }
  toEuler(out) {
    this.toYawPitchRoll(out);
    const t = out.x;
    out.x = out.y;
    out.y = t;
    return out;
  }
  toYawPitchRoll(out) {
    const {x, y, z, w} = this;
    const xx = x * x;
    const yy = y * y;
    const zz = z * z;
    const xy = x * y;
    const zw = z * w;
    const zx = z * x;
    const yw = y * w;
    const yz = y * z;
    const xw = x * w;
    out.y = Math.asin(2 * (xw - yz));
    if (Math.cos(out.y) > MathUtil.zeroTolerance) {
      out.z = Math.atan2(2 * (xy + zw), 1 - 2 * (zz + xx));
      out.x = Math.atan2(2 * (zx + yw), 1 - 2 * (yy + xx));
    } else {
      out.z = Math.atan2(-2 * (xy - zw), 1 - 2 * (yy + zz));
      out.x = 0;
    }
    return out;
  }
  toArray(out, outOffset = 0) {
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
    out[outOffset + 3] = this.w;
  }
  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }
  cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    out.w = this.w;
    return out;
  }
  rotateX(rad) {
    Quaternion.rotateX(this, rad, this);
    return this;
  }
  rotateY(rad) {
    Quaternion.rotateY(this, rad, this);
    return this;
  }
  rotateZ(rad) {
    Quaternion.rotateZ(this, rad, this);
    return this;
  }
  rotationAxisAngle(axis, rad) {
    Quaternion.rotationAxisAngle(axis, rad, this);
    return this;
  }
  multiply(quat) {
    Quaternion.multiply(this, quat, this);
    return this;
  }
  invert() {
    Quaternion.invert(this, this);
    return this;
  }
  dot(quat) {
    return Quaternion.dot(this, quat);
  }
  lerp(quat, t) {
    Quaternion.lerp(this, quat, t, this);
    return this;
  }
}
Quaternion._tempVector3 = new Vector3();

class Matrix {
  constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1) {
    this.elements = new Float32Array(16);
    const e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
  }
  static multiply(left, right, out) {
    const le = left.elements;
    const re = right.elements;
    const oe = out.elements;
    const l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3];
    const l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7];
    const l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11];
    const l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
    const r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3];
    const r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7];
    const r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11];
    const r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
    oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
    oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
    oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
    oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
    oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
    oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
    oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
    oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
    oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
    oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
    oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
    oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
    oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
    oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
    oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
    oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
  }
  static equals(left, right) {
    const le = left.elements;
    const re = right.elements;
    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
  }
  static rotationQuaternion(q, out) {
    const oe = out.elements;
    const {x, y, z, w} = q;
    let x2 = x + x;
    let y2 = y + y;
    let z2 = z + z;
    let xx = x * x2;
    let yx = y * x2;
    let yy = y * y2;
    let zx = z * x2;
    let zy = z * y2;
    let zz = z * z2;
    let wx = w * x2;
    let wy = w * y2;
    let wz = w * z2;
    oe[0] = 1 - yy - zz;
    oe[1] = yx + wz;
    oe[2] = zx - wy;
    oe[3] = 0;
    oe[4] = yx - wz;
    oe[5] = 1 - xx - zz;
    oe[6] = zy + wx;
    oe[7] = 0;
    oe[8] = zx + wy;
    oe[9] = zy - wx;
    oe[10] = 1 - xx - yy;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  }
  static rotationAxisAngle(axis, r, out) {
    const oe = out.elements;
    let {x, y, z} = axis;
    let len = Math.sqrt(x * x + y * y + z * z);
    let s, c, t;
    if (Math.abs(len) < MathUtil.zeroTolerance) {
      return;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    oe[0] = x * x * t + c;
    oe[1] = y * x * t + z * s;
    oe[2] = z * x * t - y * s;
    oe[3] = 0;
    oe[4] = x * y * t - z * s;
    oe[5] = y * y * t + c;
    oe[6] = z * y * t + x * s;
    oe[7] = 0;
    oe[8] = x * z * t + y * s;
    oe[9] = y * z * t - x * s;
    oe[10] = z * z * t + c;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  }
  static rotationTranslation(q, trans, out) {
    Matrix.rotationQuaternion(q, out);
    const oe = out.elements;
    oe[12] = trans.x;
    oe[13] = trans.y;
    oe[14] = trans.z;
  }
  static affineTransformation(scale, rotation, trans, out) {
    const oe = out.elements;
    const {x, y, z, w} = rotation;
    let x2 = x + x;
    let y2 = y + y;
    let z2 = z + z;
    let xx = x * x2;
    let xy = x * y2;
    let xz = x * z2;
    let yy = y * y2;
    let yz = y * z2;
    let zz = z * z2;
    let wx = w * x2;
    let wy = w * y2;
    let wz = w * z2;
    let sx = scale.x;
    let sy = scale.y;
    let sz = scale.z;
    oe[0] = (1 - (yy + zz)) * sx;
    oe[1] = (xy + wz) * sx;
    oe[2] = (xz - wy) * sx;
    oe[3] = 0;
    oe[4] = (xy - wz) * sy;
    oe[5] = (1 - (xx + zz)) * sy;
    oe[6] = (yz + wx) * sy;
    oe[7] = 0;
    oe[8] = (xz + wy) * sz;
    oe[9] = (yz - wx) * sz;
    oe[10] = (1 - (xx + yy)) * sz;
    oe[11] = 0;
    oe[12] = trans.x;
    oe[13] = trans.y;
    oe[14] = trans.z;
    oe[15] = 1;
  }
  static scaling(s, out) {
    const oe = out.elements;
    oe[0] = s.x;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = s.y;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = s.z;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  }
  static translation(trans, out) {
    const oe = out.elements;
    oe[0] = 1;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = 1;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = 1;
    oe[11] = 0;
    oe[12] = trans.x;
    oe[13] = trans.y;
    oe[14] = trans.z;
    oe[15] = 1;
  }
  static invert(a, out) {
    const ae = a.elements;
    const oe = out.elements;
    const a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
    const a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
    const a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
    const a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
    const b00 = a11 * a22 - a12 * a21;
    const b01 = a11 * a23 - a13 * a21;
    const b02 = a11 * a24 - a14 * a21;
    const b03 = a12 * a23 - a13 * a22;
    const b04 = a12 * a24 - a14 * a22;
    const b05 = a13 * a24 - a14 * a23;
    const b06 = a31 * a42 - a32 * a41;
    const b07 = a31 * a43 - a33 * a41;
    const b08 = a31 * a44 - a34 * a41;
    const b09 = a32 * a43 - a33 * a42;
    const b10 = a32 * a44 - a34 * a42;
    const b11 = a33 * a44 - a34 * a43;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
    oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
    oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
    oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
    oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
    oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
    oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
  }
  static lookAt(eye, target, up, out) {
    const oe = out.elements;
    const xAxis = Matrix._tempVec30;
    const yAxis = Matrix._tempVec31;
    const zAxis = Matrix._tempVec32;
    Vector3.subtract(eye, target, zAxis);
    zAxis.normalize();
    Vector3.cross(up, zAxis, xAxis);
    xAxis.normalize();
    Vector3.cross(zAxis, xAxis, yAxis);
    oe[0] = xAxis.x;
    oe[1] = yAxis.x;
    oe[2] = zAxis.x;
    oe[3] = 0;
    oe[4] = xAxis.y;
    oe[5] = yAxis.y;
    oe[6] = zAxis.y;
    oe[7] = 0;
    oe[8] = xAxis.z;
    oe[9] = yAxis.z;
    oe[10] = zAxis.z;
    oe[11] = 0;
    oe[12] = -Vector3.dot(xAxis, eye);
    oe[13] = -Vector3.dot(yAxis, eye);
    oe[14] = -Vector3.dot(zAxis, eye);
    oe[15] = 1;
  }
  static ortho(left, right, bottom, top, near, far, out) {
    const oe = out.elements;
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    oe[0] = -2 * lr;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = -2 * bt;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = 2 * nf;
    oe[11] = 0;
    oe[12] = (left + right) * lr;
    oe[13] = (top + bottom) * bt;
    oe[14] = (far + near) * nf;
    oe[15] = 1;
  }
  static perspective(fovy, aspect, near, far, out) {
    const oe = out.elements;
    const f = 1 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    oe[0] = f / aspect;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = f;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = (far + near) * nf;
    oe[11] = -1;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 2 * far * near * nf;
    oe[15] = 0;
  }
  static rotateAxisAngle(m, axis, r, out) {
    let {x, y, z} = axis;
    let len = Math.sqrt(x * x + y * y + z * z);
    if (Math.abs(len) < MathUtil.zeroTolerance) {
      return;
    }
    const me = m.elements;
    const oe = out.elements;
    let s, c, t;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    let a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
    let a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
    let a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
    let b11 = x * x * t + c;
    let b12 = y * x * t + z * s;
    let b13 = z * x * t - y * s;
    let b21 = x * y * t - z * s;
    let b22 = y * y * t + c;
    let b23 = z * y * t + x * s;
    let b31 = x * z * t + y * s;
    let b32 = y * z * t - x * s;
    let b33 = z * z * t + c;
    oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
    oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
    oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
    oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
    oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
    oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
    oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
    oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
    oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
    oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
    oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
    oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
    if (m !== out) {
      oe[12] = me[12];
      oe[13] = me[13];
      oe[14] = me[14];
      oe[15] = me[15];
    }
  }
  static scale(m, s, out) {
    const me = m.elements;
    const oe = out.elements;
    const {x, y, z} = s;
    oe[0] = me[0] * x;
    oe[1] = me[1] * x;
    oe[2] = me[2] * x;
    oe[3] = me[3] * x;
    oe[4] = me[4] * y;
    oe[5] = me[5] * y;
    oe[6] = me[6] * y;
    oe[7] = me[7] * y;
    oe[8] = me[8] * z;
    oe[9] = me[9] * z;
    oe[10] = me[10] * z;
    oe[11] = me[11] * z;
    oe[12] = me[12];
    oe[13] = me[13];
    oe[14] = me[14];
    oe[15] = me[15];
  }
  static translate(m, v, out) {
    const me = m.elements;
    const oe = out.elements;
    const {x, y, z} = v;
    if (m === out) {
      oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
      oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
      oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
      oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
    } else {
      const a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
      const a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
      const a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
      oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
      oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
      oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
      oe[12] = a11 * x + a21 * y + a31 * z + me[12];
      oe[13] = a12 * x + a22 * y + a32 * z + me[13];
      oe[14] = a13 * x + a23 * y + a33 * z + me[14];
      oe[15] = a14 * x + a24 * y + a34 * z + me[15];
    }
  }
  static transpose(a, out) {
    const ae = a.elements;
    const oe = out.elements;
    if (out === a) {
      const a12 = ae[1];
      const a13 = ae[2];
      const a14 = ae[3];
      const a23 = ae[6];
      const a24 = ae[7];
      const a34 = ae[11];
      oe[1] = ae[4];
      oe[2] = ae[8];
      oe[3] = ae[12];
      oe[4] = a12;
      oe[6] = ae[9];
      oe[7] = ae[13];
      oe[8] = a13;
      oe[9] = a23;
      oe[11] = ae[14];
      oe[12] = a14;
      oe[13] = a24;
      oe[14] = a34;
    } else {
      oe[0] = ae[0];
      oe[1] = ae[4];
      oe[2] = ae[8];
      oe[3] = ae[12];
      oe[4] = ae[1];
      oe[5] = ae[5];
      oe[6] = ae[9];
      oe[7] = ae[13];
      oe[8] = ae[2];
      oe[9] = ae[6];
      oe[10] = ae[10];
      oe[11] = ae[14];
      oe[12] = ae[3];
      oe[13] = ae[7];
      oe[14] = ae[11];
      oe[15] = ae[15];
    }
  }
  setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    const e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
    return this;
  }
  setValueByArray(array, offset = 0) {
    const srce = this.elements;
    for (let i = 0; i < 16; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  }
  toArray(out, outOffset = 0) {
    const e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
    out[outOffset + 9] = e[9];
    out[outOffset + 10] = e[10];
    out[outOffset + 11] = e[11];
    out[outOffset + 12] = e[12];
    out[outOffset + 13] = e[13];
    out[outOffset + 14] = e[14];
    out[outOffset + 15] = e[15];
  }
  clone() {
    const e = this.elements;
    let ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
    return ret;
  }
  cloneTo(out) {
    const e = this.elements;
    const oe = out.elements;
    oe[0] = e[0];
    oe[1] = e[1];
    oe[2] = e[2];
    oe[3] = e[3];
    oe[4] = e[4];
    oe[5] = e[5];
    oe[6] = e[6];
    oe[7] = e[7];
    oe[8] = e[8];
    oe[9] = e[9];
    oe[10] = e[10];
    oe[11] = e[11];
    oe[12] = e[12];
    oe[13] = e[13];
    oe[14] = e[14];
    oe[15] = e[15];
    return out;
  }
  multiply(right) {
    Matrix.multiply(this, right, this);
    return this;
  }
  determinant() {
    const e = this.elements;
    const a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
    const a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
    const a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
    const a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
    const b00 = a11 * a22 - a12 * a21;
    const b01 = a11 * a23 - a13 * a21;
    const b02 = a11 * a24 - a14 * a21;
    const b03 = a12 * a23 - a13 * a22;
    const b04 = a12 * a24 - a14 * a22;
    const b05 = a13 * a24 - a14 * a23;
    const b06 = a31 * a42 - a32 * a41;
    const b07 = a31 * a43 - a33 * a41;
    const b08 = a31 * a44 - a34 * a41;
    const b09 = a32 * a43 - a33 * a42;
    const b10 = a32 * a44 - a34 * a42;
    const b11 = a33 * a44 - a34 * a43;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  decompose(pos, q, s) {
    const rm = Matrix._tempMat30;
    const e = this.elements;
    const rme = rm.elements;
    const m11 = e[0];
    const m12 = e[1];
    const m13 = e[2];
    const m14 = e[3];
    const m21 = e[4];
    const m22 = e[5];
    const m23 = e[6];
    const m24 = e[7];
    const m31 = e[8];
    const m32 = e[9];
    const m33 = e[10];
    const m34 = e[11];
    pos.x = e[12];
    pos.y = e[13];
    pos.z = e[14];
    const xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
    const ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
    const zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
    const sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    const sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    const sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    s.x = sx;
    s.y = sy;
    s.z = sz;
    if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
      q.identity();
      return false;
    } else {
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      rme[0] = m11 * invSX;
      rme[1] = m12 * invSX;
      rme[2] = m13 * invSX;
      rme[3] = m21 * invSY;
      rme[4] = m22 * invSY;
      rme[5] = m23 * invSY;
      rme[6] = m31 * invSZ;
      rme[7] = m32 * invSZ;
      rme[8] = m33 * invSZ;
      Quaternion.rotationMatrix3x3(rm, q);
      return true;
    }
  }
  getRotation(out) {
    const e = this.elements;
    let trace = e[0] + e[5] + e[10];
    if (trace > MathUtil.zeroTolerance) {
      let S = Math.sqrt(trace + 1) * 2;
      out.w = 0.25 * S;
      out.x = (e[6] - e[9]) / S;
      out.y = (e[8] - e[2]) / S;
      out.z = (e[1] - e[4]) / S;
    } else if (e[0] > e[5] && e[0] > e[10]) {
      let S = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;
      out.w = (e[6] - e[9]) / S;
      out.x = 0.25 * S;
      out.y = (e[1] + e[4]) / S;
      out.z = (e[8] + e[2]) / S;
    } else if (e[5] > e[10]) {
      let S = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;
      out.w = (e[8] - e[2]) / S;
      out.x = (e[1] + e[4]) / S;
      out.y = 0.25 * S;
      out.z = (e[6] + e[9]) / S;
    } else {
      let S = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;
      out.w = (e[1] - e[4]) / S;
      out.x = (e[8] + e[2]) / S;
      out.y = (e[6] + e[9]) / S;
      out.z = 0.25 * S;
    }
    return out;
  }
  getScaling(out) {
    const e = this.elements;
    const m11 = e[0], m12 = e[1], m13 = e[2];
    const m21 = e[4], m22 = e[5], m23 = e[6];
    const m31 = e[8], m32 = e[9], m33 = e[10];
    out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  getTranslation(out) {
    const e = this.elements;
    out.x = e[12];
    out.y = e[13];
    out.z = e[14];
    return out;
  }
  identity() {
    const e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 1;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
    e[9] = 0;
    e[10] = 1;
    e[11] = 0;
    e[12] = 0;
    e[13] = 0;
    e[14] = 0;
    e[15] = 1;
    return this;
  }
  invert() {
    Matrix.invert(this, this);
    return this;
  }
  rotateAxisAngle(axis, r) {
    Matrix.rotateAxisAngle(this, axis, r, this);
    return this;
  }
  scale(s) {
    Matrix.scale(this, s, this);
    return this;
  }
  translate(v) {
    Matrix.translate(this, v, this);
    return this;
  }
  transpose() {
    Matrix.transpose(this, this);
    return this;
  }
}
Matrix._tempVec30 = new Vector3();
Matrix._tempVec31 = new Vector3();
Matrix._tempVec32 = new Vector3();
Matrix._tempMat30 = new Matrix3x3();
Matrix._tempMat40 = new Matrix();
Matrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

class OBB {
  constructor(minLocal, maxLocal, modelMatrix) {
    this.min = new Vector3();
    this.max = new Vector3();
    this.corners = [];
    this.minWorld = new Vector3();
    this.maxWorld = new Vector3();
    this.cornersWorld = [];
    minLocal.cloneTo(this.min);
    maxLocal.cloneTo(this.max);
    this.corners = this.getCornersFromMinMax(minLocal, maxLocal);
    this.updateByModelMatrix(modelMatrix);
  }
  getCornersFromMinMax(min, max) {
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const corners = [
      new Vector3(minX, minY, minZ),
      new Vector3(maxX, maxY, maxZ),
      new Vector3(maxX, minY, minZ),
      new Vector3(minX, maxY, minZ),
      new Vector3(minX, minY, maxZ),
      new Vector3(maxX, maxY, minZ),
      new Vector3(minX, maxY, maxZ),
      new Vector3(maxX, minY, maxZ)
    ];
    return corners;
  }
  updateByModelMatrix(modelMatrix) {
    const min = this.minWorld;
    const max = this.maxWorld;
    min.setValue(Infinity, Infinity, Infinity);
    max.setValue(-Infinity, -Infinity, -Infinity);
    for (let i = 0; i < 8; ++i) {
      const corner = this.corners[i];
      const cornerWorld = OBB._tempVec3;
      Vector3.transformCoordinate(corner, modelMatrix, cornerWorld);
      Vector3.min(min, cornerWorld, min);
      Vector3.max(max, cornerWorld, max);
      this.cornersWorld[i] = new Vector3();
      cornerWorld.cloneTo(this.cornersWorld[i]);
    }
  }
  intersectsFrustum(frustumPlanes) {
    const cornersWorld = this.cornersWorld;
    for (let i = 0; i < 6; i++) {
      const plane = frustumPlanes[i];
      let isInPlane = false;
      for (let j = 0; j < 8; j++) {
        if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {
          isInPlane = true;
        } else if (isInPlane) {
          return IntersectInfo.INTERSECT;
        }
      }
      if (!isInPlane) {
        return IntersectInfo.EXCLUDE;
      }
    }
    return IntersectInfo.INCLUDE;
  }
  isInFrustum(frustumPlanes) {
    const cornersWorld = this.cornersWorld;
    for (let i = 0; i < 6; i++) {
      const plane = frustumPlanes[i];
      let isInPlane = false;
      for (let j = 0; j < 8; j++) {
        if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {
          isInPlane = true;
          break;
        }
      }
      if (!isInPlane) {
        return false;
      }
    }
    return true;
  }
}
OBB._tempVec3 = new Vector3();

class Ray {
  constructor(origin, direction) {
    this.origin = new Vector3();
    this.direction = new Vector3();
    origin && origin.cloneTo(this.origin);
    direction && direction.cloneTo(this.direction);
  }
  intersectPlane(point, normal) {
    const origin = this.origin;
    const denom = Vector3.dot(normal, this.direction);
    if (Math.abs(denom) > 1e-6) {
      const p0l0 = new Vector3();
      Vector3.subtract(point, origin, p0l0);
      const t = Vector3.dot(p0l0, normal) / denom;
      if (t >= 0) {
        return t;
      }
    }
    return false;
  }
  getPoint(distance) {
    const point = new Vector3();
    Vector3.scale(this.direction, distance, point);
    return point.add(this.origin);
  }
  intersectSphere(center, radius) {
    const dir = this.direction;
    const L = new Vector3();
    Vector3.subtract(this.origin, center, L);
    const a = Vector3.dot(dir, dir);
    const b = 2 * Vector3.dot(dir, L);
    const c = Vector3.dot(L, L) - radius * radius;
    const s = this._solveQuadratic(a, b, c);
    if (s) {
      return s[0];
    } else {
      return false;
    }
  }
  intersectAABB(max, min) {
    const dir = this.direction;
    const orig = this.origin;
    const invdir = new Vector3(1 / dir.x, 1 / dir.y, 1 / dir.z);
    const bounds = [min, max];
    const sign = [dir.x < 0 ? 1 : 0, dir.y < 0 ? 1 : 0, dir.z < 0 ? 1 : 0];
    let tmin = (bounds[sign[0]].x - orig.x) * invdir.x;
    let tmax = (bounds[1 - sign[0]].x - orig.x) * invdir.x;
    const tymin = (bounds[sign[1]].y - orig.y) * invdir.y;
    const tymax = (bounds[1 - sign[1]].y - orig.y) * invdir.y;
    if (tmin > tymax || tymin > tmax) {
      return false;
    }
    if (tymin > tmin) {
      tmin = tymin;
    }
    if (tymax < tmax) {
      tmax = tymax;
    }
    const tzmin = (bounds[sign[2]].z - orig.z) * invdir.z;
    const tzmax = (bounds[1 - sign[2]].z - orig.z) * invdir.z;
    if (tmin > tzmax || tzmin > tmax) {
      return false;
    }
    if (tzmin > tmin) {
      tmin = tzmin;
    }
    if (tzmax < tmax) {
      tmax = tzmax;
    }
    let t = tmin;
    if (t < 0) {
      t = tmax;
      if (t < 0) {
        return false;
      }
    }
    return t;
  }
  _solveQuadratic(a, b, c) {
    const discr = b * b - 4 * a * c;
    if (discr < 0) {
      return false;
    } else if (discr == 0) {
      const x = -0.5 * b / a;
      return [x, x];
    } else {
      const r = Math.sqrt(discr);
      const q = b > 0 ? -0.5 * (b + r) : -0.5 * (b - r);
      const x0 = q / a;
      const x1 = c / q;
      if (x0 <= x1) {
        return [x0, x1];
      } else {
        return [x1, x0];
      }
    }
  }
}

class RaycastHit {
  constructor() {
    this.distance = Number.MAX_VALUE;
    this.collider = null;
    this.point = null;
  }
}

const ESP = MathUtil.zeroTolerance;
class Spherical {
  constructor(radius, phi, theta) {
    this.radius = radius !== void 0 ? radius : 1;
    this.phi = phi !== void 0 ? phi : 0;
    this.theta = theta !== void 0 ? theta : 0;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  makeSafe() {
    this.phi = MathUtil.clamp(this.phi, ESP, Math.PI - ESP);
    return this;
  }
  setFromVec3(v3) {
    this.radius = v3.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(v3.x, v3.z);
      this.phi = Math.acos(MathUtil.clamp(v3.y / this.radius, -1, 1));
    }
    return this;
  }
  setToVec3(v3) {
    const sinPhiRadius = Math.sin(this.phi) * this.radius;
    v3.x = sinPhiRadius * Math.sin(this.theta);
    v3.y = Math.cos(this.phi) * this.radius;
    v3.z = sinPhiRadius * Math.cos(this.theta);
    return this;
  }
}

class Vector2 {
  static add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
  }
  static subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
  }
  static multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
  }
  static divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
  }
  static dot(left, right) {
    return left.x * right.x + left.y * right.y;
  }
  static distance(left, right) {
    const x = right.x - left.x;
    const y = right.y - left.y;
    return Math.sqrt(x * x + y * y);
  }
  static distanceSquared(left, right) {
    const x = right.x - left.x;
    const y = right.y - left.y;
    return x * x + y * y;
  }
  static equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);
  }
  static lerp(left, right, t, out) {
    const {x, y} = left;
    out.x = x + (right.x - x) * t;
    out.y = y + (right.y - y) * t;
  }
  static max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
  }
  static min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
  }
  static negate(left, out) {
    out.x = -left.x;
    out.y = -left.y;
  }
  static normalize(left, out) {
    const {x, y} = left;
    let len = Math.sqrt(x * x + y * y);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
    }
  }
  static scale(left, s, out) {
    out.x = left.x * s;
    out.y = left.y * s;
  }
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  setValue(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setValueByArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  add(right) {
    this.x += right.x;
    this.y += right.y;
    return this;
  }
  subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    return this;
  }
  multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    return this;
  }
  divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    return this;
  }
  length() {
    const {x, y} = this;
    return Math.sqrt(x * x + y * y);
  }
  lengthSquared() {
    const {x, y} = this;
    return x * x + y * y;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  normalize() {
    Vector2.normalize(this, this);
    return this;
  }
  scale(s) {
    this.x *= s;
    this.y *= s;
    return this;
  }
  toArray(out, outOffset = 0) {
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    return out;
  }
}
Vector2._zero = new Vector2(0, 0);
Vector2._one = new Vector2(1, 1);

class Vector4 {
  static add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
    out.w = left.w + right.w;
  }
  static subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
    out.z = left.z - right.z;
    out.w = left.w - right.w;
  }
  static multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
    out.z = left.z * right.z;
    out.w = left.w * right.w;
  }
  static divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
    out.z = left.z / right.z;
    out.w = left.w / right.w;
  }
  static dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  }
  static distance(a, b) {
    const x = b.x - a.x;
    const y = b.y - a.y;
    const z = b.z - a.z;
    const w = b.w - a.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  static distanceSquared(a, b) {
    const x = b.x - a.x;
    const y = b.y - a.y;
    const z = b.z - a.z;
    const w = b.w - a.w;
    return x * x + y * y + z * z + w * w;
  }
  static equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
  }
  static lerp(start, end, t, out) {
    const {x, y, z, w} = start;
    out.x = x + (end.x - x) * t;
    out.y = y + (end.y - y) * t;
    out.z = z + (end.z - z) * t;
    out.w = w + (end.w - w) * t;
  }
  static max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
    out.z = Math.max(left.z, right.z);
    out.w = Math.max(left.w, right.w);
  }
  static min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
    out.z = Math.min(left.z, right.z);
    out.w = Math.min(left.w, right.w);
  }
  static negate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = -a.w;
  }
  static normalize(a, out) {
    const {x, y, z, w} = a;
    let len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }
  }
  static scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
    out.w = a.w * s;
  }
  static transform(v, m, out) {
    const {x, y, z, w} = v;
    const e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];
    out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];
  }
  static transformByQuat(v, q, out) {
    const {x, y, z, w} = v;
    const qx = q.x;
    const qy = q.y;
    const qz = q.z;
    const qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    out.x = ix * qw - iw * qx - iy * qz + iz * qy;
    out.y = iy * qw - iw * qy - iz * qx + ix * qz;
    out.z = iz * qw - iw * qz - ix * qy + iy * qx;
    out.w = w;
  }
  constructor(x = 0, y = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  setValue(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setValueByArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  add(right) {
    this.x += right.x;
    this.y += right.y;
    this.z += right.z;
    this.w += right.w;
    return this;
  }
  subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    this.z -= right.z;
    this.w -= right.w;
    return this;
  }
  multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    this.z *= right.z;
    this.w *= right.w;
    return this;
  }
  divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    this.z /= right.z;
    this.w /= right.w;
    return this;
  }
  length() {
    const {x, y, z, w} = this;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  }
  lengthSquared() {
    const {x, y, z, w} = this;
    return x * x + y * y + z * z + w * w;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  normalize() {
    Vector4.normalize(this, this);
    return this;
  }
  scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    this.w *= s;
    return this;
  }
  toArray(out, outOffset = 0) {
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
    out[outOffset + 3] = this.w;
  }
  clone() {
    let ret = new Vector4(this.x, this.y, this.z, this.w);
    return ret;
  }
  cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    out.w = this.w;
    return out;
  }
}
Vector4._zero = new Vector4(0, 0, 0, 0);
Vector4._one = new Vector4(1, 1, 1, 1);

export { BoundingBox, BoundingSphere, MathUtil, Matrix, Matrix3x3, OBB, Quaternion, Ray, RaycastHit, Spherical, Vector2, Vector3, Vector4 };
//# sourceMappingURL=module.js.map
