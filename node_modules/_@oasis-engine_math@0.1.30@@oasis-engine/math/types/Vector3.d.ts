import { IClone } from "@oasis-engine/design";
import { Matrix } from "./Matrix";
import { Quaternion } from "./Quaternion";
import { Vector4 } from "./Vector4";
/**
 * 三维向量。
 */
export declare class Vector3 implements IClone {
    /** @internal 零向量。*/
    static readonly _zero: Vector3;
    /** @internal 一向量。*/
    static readonly _one: Vector3;
    /** @internal */
    static readonly _tempVector3: Vector3;
    /**
     * 将两个向量相加。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 向量相加结果
     */
    static add(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 将两个向量相减。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的相减结果
     */
    static subtract(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 将两个向量相乘。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的相乘结果
     */
    static multiply(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 将两个三维向量相除。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的相除结果
     */
    static divide(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 计算两个三维向量的点积。
     * @param left - 左向量
     * @param right - 右向量
     * @returns 两个向量的点积
     */
    static dot(left: Vector3, right: Vector3): number;
    /**
     * 计算两个三维向量的叉乘。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的叉乘结果
     */
    static cross(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 计算两个三维向量的距离。
     * @param a - 向量
     * @param b - 向量
     * @returns 两个向量的距离
     */
    static distance(a: Vector3, b: Vector3): number;
    /**
     * 计算两个三维向量的距离的平方。
     * @param a - 向量
     * @param b - 向量
     * @returns 两个向量的距离的平方
     */
    static distanceSquared(a: Vector3, b: Vector3): number;
    /**
     * 判断两个三维向量的值是否相等。
     * @param left - 向量
     * @param right - 向量
     * @returns 两个向量是否相等，是返回 true，否则返回 false
     */
    static equals(left: Vector3, right: Vector3): boolean;
    /**
     * 插值三维向量。
     * @param start - 向量
     * @param end - 向量
     * @param t - 插值比例
     * @param out - 插值结果
     */
    static lerp(start: Vector3, end: Vector3, t: number, out: Vector3): void;
    /**
     * 分别取两个三维向量 x、y 的最大值计算新的三维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */
    static max(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 分别取两个三维向量 x、y 的最小值计算新的三维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */
    static min(left: Vector3, right: Vector3, out: Vector3): void;
    /**
     * 将向量 a 反转的结果输出到 out。
     * @param a - 向量
     * @param out - 向量反转的结果
     */
    static negate(a: Vector3, out: Vector3): void;
    /**
     * 将向量 a 归一化的结果输出到 out。
     * @param a - 向量
     * @param out - 向量归一化的结果
     */
    static normalize(a: Vector3, out: Vector3): void;
    /**
     * 将向量 a 缩放的结果输出到 out。
     * @param a - 向量
     * @param s - 缩放因子
     * @param out - 向量缩放的结果
     */
    static scale(a: Vector3, s: number, out: Vector3): void;
    /**
     * 通过4x4矩阵将一个三维向量进行法线转换到另一个三维向量。
     * @remarks
     * 法线变换假设 w 分量为零，这导致矩阵的第四行和第四列并不使用。
     * 最终得出的结果是一个没有位置变换的向量，但是其他变换属性均被应用。
     * 通常这对法线向量来说比较友好，因为法线向量纯粹代表方向。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */
    static transformNormal(v: Vector3, m: Matrix, out: Vector3): void;
    /**
     * 通过4x4矩阵将一个三维向量转换到另一个三维向量。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */
    static transformToVec3(v: Vector3, m: Matrix, out: Vector3): void;
    /**
     * 通过4x4矩阵将一个三维向量转换到一个四维向量。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */
    static transformToVec4(v: Vector3, m: Matrix, out: Vector4): void;
    /**
     * 通过4x4矩阵将一个三维向量转换到另一个三维向量。
     *
     * @remarks
     * 坐标变换价值 w 分量为一，从变换得到的四维向量的每个分量都除以 w 分量。
     * 这导致变换结果的 w 分量为一,向量变为齐次向量。
     * 齐次向量在坐标变换中使用，w 分量可以安全的忽略。
     *
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量，此向量为齐次
     */
    static transformCoordinate(v: Vector3, m: Matrix, out: Vector3): void;
    /**
     * 通过四元数将一个三维向量转换到另一个三维向量。
     * @param v - 向量
     * @param q - 四元数
     * @param out - 通过矩阵转换后的向量
     */
    static transformByQuat(v: Vector3, q: Quaternion, out: Vector3): void;
    /** 向量的 X 分量。*/
    x: number;
    /** 向量的 Y 分量。*/
    y: number;
    /** 向量的 Z 分量。*/
    z: number;
    /**
     * 创建一个 Vector3 实例。
     * @param x - 向量的 X 分量，默认值 0
     * @param y - 向量的 Y 分量，默认值 0
     * @param z - 向量的 Z 分量，默认值 0
     */
    constructor(x?: number, y?: number, z?: number);
    /**
     * 设置 x, y, z 的值，并返回当前向量。
     * @param x - 向量的 X 分量
     * @param y - 向量的 Y 分量
     * @param z - 向量的 Z 分量
     * @returns 当前向量
     */
    setValue(x: number, y: number, z: number): Vector3;
    /**
     * 通过数组设置值，并返回当前向量。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前向量
     */
    setValueByArray(array: ArrayLike<number>, offset?: number): Vector3;
    /**
     * 将当前向量加上给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */
    add(right: Vector3): Vector3;
    /**
     * 将当前向量减去给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */
    subtract(right: Vector3): Vector3;
    /**
     * 将当前向量乘以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */
    multiply(right: Vector3): Vector3;
    /**
     * 将当前向量除以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */
    divide(right: Vector3): Vector3;
    /**
     * 计算一个三维向量的标量长度。
     * @returns 当前向量的标量长度
     */
    length(): number;
    /**
     * 计算一个三维向量的标量长度的平方。
     * @returns 当前向量的标量长度的平方
     */
    lengthSquared(): number;
    /**
     * 向量反转。
     * @returns 当前向量
     */
    negate(): Vector3;
    /**
     * 向量归一化。
     * @returns 当前向量
     */
    normalize(): Vector3;
    /**
     * 向量缩放。
     * @param s - 缩放因子
     * @returns 当前向量
     */
    scale(s: number): Vector3;
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */
    toArray(out: number[] | Float32Array | Float64Array, outOffset?: number): void;
    /**
     * 克隆并返回一个新的三维向量对象。
     * @returns 新的三维向量对象
     */
    clone(): Vector3;
    /**
     * 将当前向量值拷贝给 out 向量。
     * @param out - 目标向量
     */
    cloneTo(out: Vector3): Vector3;
    /**
     * 通过4x4矩阵将当前向量转换。
     * @remarks
     * 法线变换假设 w 分量为零，这导致矩阵的第四行和第四列并不使用。
     * 最终得出的结果是一个没有位置变换的向量，但是其他变换属性均被应用。
     * 通常这对法线向量来说比较友好，因为法线向量纯粹代表方向。
     * @param m - 转换矩阵
     * @returns 当前向量
     */
    transformNormal(m: Matrix): Vector3;
    /**
     * 通过4x4矩阵将当前向量转换。
     * @param m - 转换矩阵
     * @returns 当前向量
     */
    transformToVec3(m: Matrix): Vector3;
    /**
     * 通过4x4矩阵将当前向量转换。
     * @remarks
     * 坐标变换价值 w 分量为一，从变换得到的四维向量的每个分量都除以 w 分量。
     * 这导致变换结果的 w 分量为一,向量变为齐次向量。
     * 齐次向量在坐标变换中使用，w 分量可以安全的忽略。
  
     * @param m - 转换矩阵
     * @returns 当前向量
     */
    transformCoordinate(m: Matrix): Vector3;
    /**
     * 通过四元数将当前向量转换。
     * @param q - 四元数
     * @param out - 通过矩阵转换后的向量
     */
    transformByQuat(q: Quaternion): Vector3;
}
