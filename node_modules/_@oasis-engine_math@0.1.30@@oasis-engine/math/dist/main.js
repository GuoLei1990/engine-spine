'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/**
 * 数学工具类。
 */
var MathUtil = /*#__PURE__*/function () {
  function MathUtil() {
    _classCallCheck(this, MathUtil);
  }

  _createClass(MathUtil, null, [{
    key: "clamp",

    /** 单精度浮点零容差。 */

    /** 弧度转角度的转换因子。 */

    /** 角度转弧度的转换因子。 */

    /**
     * 求指定范围内的值。
     * @param v
     * @param min
     * @param max
     * @returns 范围内的值
     */
    value: function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }
    /**
     * 比较两个数是否相等(大小在零容差之内就算相等)。
     * @param a
     * @param b
     * @returns 两个数是否相等
     */

  }, {
    key: "equals",
    value: function equals(a, b) {
      return Math.abs(a - b) <= MathUtil.zeroTolerance;
    }
    /**
     * 判断一个数是否是 2 的幂。
     * @param v
     * @returns 传入的数是否是 2 的幂
     */

  }, {
    key: "isPowerOf2",
    value: function isPowerOf2(v) {
      return (v & v - 1) === 0;
    }
    /**
     * 弧度转角度。
     * @param r
     * @returns 角度
     */

  }, {
    key: "radianToDegree",
    value: function radianToDegree(r) {
      return r * MathUtil.radToDegreeFactor;
    }
    /**
     * 角度转弧度。
     * @param d
     * @returns 弧度
     */

  }, {
    key: "degreeToRadian",
    value: function degreeToRadian(d) {
      return d * MathUtil.degreeToRadFactor;
    }
  }]);

  return MathUtil;
}();
MathUtil.zeroTolerance = 1e-6;
MathUtil.radToDegreeFactor = 180 / Math.PI;
MathUtil.degreeToRadFactor = Math.PI / 180;

/**
 * 3x3矩阵，我们采用列矩阵的模式存储
 */
var Matrix3x3 = /*#__PURE__*/function () {
  _createClass(Matrix3x3, null, [{
    key: "add",

    /**
     * 将两个矩阵相加。
     * @param left - 左矩阵
     * @param right - 右矩阵
     * @param out - 矩阵相加的结果
     */
    value: function add(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      oe[0] = le[0] + re[0];
      oe[1] = le[1] + re[1];
      oe[2] = le[2] + re[2];
      oe[3] = le[3] + re[3];
      oe[4] = le[4] + re[4];
      oe[5] = le[5] + re[5];
      oe[6] = le[6] + re[6];
      oe[7] = le[7] + re[7];
      oe[8] = le[8] + re[8];
    }
    /**
     * 将两个矩阵相减。
     * @param left - 左矩阵
     * @param right - 右矩阵
     * @param out - 矩阵相减的结果
     */

  }, {
    key: "subtract",
    value: function subtract(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      oe[0] = le[0] - re[0];
      oe[1] = le[1] - re[1];
      oe[2] = le[2] - re[2];
      oe[3] = le[3] - re[3];
      oe[4] = le[4] - re[4];
      oe[5] = le[5] - re[5];
      oe[6] = le[6] - re[6];
      oe[7] = le[7] - re[7];
      oe[8] = le[8] - re[8];
    }
    /**
     * 将两个矩阵相乘。
     * @param left - 左矩阵
     * @param right - 右矩阵
     * @param out - 矩阵相乘的结果
     */

  }, {
    key: "multiply",
    value: function multiply(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      var l11 = le[0],
          l12 = le[1],
          l13 = le[2];
      var l21 = le[3],
          l22 = le[4],
          l23 = le[5];
      var l31 = le[6],
          l32 = le[7],
          l33 = le[8];
      var r11 = re[0],
          r12 = re[1],
          r13 = re[2];
      var r21 = re[3],
          r22 = re[4],
          r23 = re[5];
      var r31 = re[6],
          r32 = re[7],
          r33 = re[8];
      oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
      oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
      oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
      oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
      oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
      oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
      oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
      oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
      oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
    }
    /**
     * 判断两个矩阵的值是否相等。
     * @param left - 左矩阵
     * @param right - 右矩阵
     * @returns 两个矩阵是否相等，是返回 true，否则返回 false
     */

  }, {
    key: "equals",
    value: function equals(left, right) {
      var le = left.elements;
      var re = right.elements;
      return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
    }
    /**
     * 从四元数转换为一个3x3矩阵。
     * @param q - 四元数
     * @param out - 转换后的3x3矩阵
     */

  }, {
    key: "rotationQuaternion",
    value: function rotationQuaternion(q, out) {
      var oe = out.elements;
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      oe[0] = 1 - yy - zz;
      oe[3] = yx - wz;
      oe[6] = zx + wy;
      oe[1] = yx + wz;
      oe[4] = 1 - xx - zz;
      oe[7] = zy - wx;
      oe[2] = zx - wy;
      oe[5] = zy + wx;
      oe[8] = 1 - xx - yy;
    }
    /**
     * 通过指定缩放生成3x3矩阵。
     * @param s - 缩放向量
     * @param out - 指定缩放后矩阵
     */

  }, {
    key: "scaling",
    value: function scaling(s, out) {
      var oe = out.elements;
      oe[0] = s.x;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = s.y;
      oe[5] = 0;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 1;
    }
    /**
     * 通过指定平移生成3x3矩阵。
     * @param trans - 平移向量
     * @param out - 指定平移后矩阵
     */

  }, {
    key: "translation",
    value: function translation(trans, out) {
      var oe = out.elements;
      oe[0] = 1;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 1;
      oe[5] = 0;
      oe[6] = trans.x;
      oe[7] = trans.y;
      oe[8] = 1;
    }
    /**
     * 计算矩阵 a 的逆矩阵，并将结果输出到 out。
     * @param a - 矩阵
     * @param out - 逆矩阵
     */

  }, {
    key: "invert",
    value: function invert(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2];
      var a21 = ae[3],
          a22 = ae[4],
          a23 = ae[5];
      var a31 = ae[6],
          a32 = ae[7],
          a33 = ae[8];
      var b12 = a33 * a22 - a23 * a32;
      var b22 = -a33 * a21 + a23 * a31;
      var b32 = a32 * a21 - a22 * a31;
      var det = a11 * b12 + a12 * b22 + a13 * b32;

      if (!det) {
        return;
      }

      det = 1.0 / det;
      oe[0] = b12 * det;
      oe[1] = (-a33 * a12 + a13 * a32) * det;
      oe[2] = (a23 * a12 - a13 * a22) * det;
      oe[3] = b22 * det;
      oe[4] = (a33 * a11 - a13 * a31) * det;
      oe[5] = (-a23 * a11 + a13 * a21) * det;
      oe[6] = b32 * det;
      oe[7] = (-a32 * a11 + a12 * a31) * det;
      oe[8] = (a22 * a11 - a12 * a21) * det;
    }
    /**
     * 从4x4矩阵中计算出3x3法线矩阵。
     * @remarks 计算过程为求逆矩阵的转置矩阵。
     * @param mat4 - 4x4矩阵
     * @param out - 3x3法线矩阵
     */

  }, {
    key: "normalMatrix",
    value: function normalMatrix(mat4, out) {
      var ae = mat4.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2],
          a14 = ae[3];
      var a21 = ae[4],
          a22 = ae[5],
          a23 = ae[6],
          a24 = ae[7];
      var a31 = ae[8],
          a32 = ae[9],
          a33 = ae[10],
          a34 = ae[11];
      var a41 = ae[12],
          a42 = ae[13],
          a43 = ae[14],
          a44 = ae[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
      oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
      oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
      oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
      oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
      oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
      oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
      oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
      oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    }
    /**
     * 将矩阵 a 按给定角度旋转，并将结果输出到 out。
     * @param a - 矩阵
     * @param r - 给定的旋转角度(单位：弧度)
     * @param out - 旋转后的矩阵
     */

  }, {
    key: "rotate",
    value: function rotate(a, r, out) {
      var ae = a.elements;
      var oe = out.elements;
      var s = Math.sin(r);
      var c = Math.cos(r);
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2];
      var a21 = ae[3],
          a22 = ae[4],
          a23 = ae[5];
      var a31 = ae[6],
          a32 = ae[7],
          a33 = ae[8];
      oe[0] = c * a11 + s * a21;
      oe[1] = c * a12 + s * a22;
      oe[2] = c * a13 + s * a23;
      oe[3] = c * a21 - s * a11;
      oe[4] = c * a22 - s * a12;
      oe[5] = c * a23 - s * a13;
      oe[6] = a31;
      oe[7] = a32;
      oe[8] = a33;
    }
    /**
     * 将矩阵 a 按给定向量 v 缩放，并将结果输出到 out。
     * @param m - 矩阵
     * @param s - 缩放向量
     * @param out - 缩放后的矩阵
     */

  }, {
    key: "scale",
    value: function scale(m, s, out) {
      var x = s.x,
          y = s.y;
      var ae = m.elements;
      var oe = out.elements;
      oe[0] = x * ae[0];
      oe[1] = x * ae[1];
      oe[2] = x * ae[2];
      oe[3] = y * ae[3];
      oe[4] = y * ae[4];
      oe[5] = y * ae[5];
      oe[6] = ae[6];
      oe[7] = ae[7];
      oe[8] = ae[8];
    }
    /**
     * 将矩阵 a 按给定向量 v 转换，并将结果输出到 out。
     * @param m - 矩阵
     * @param trans - 转换向量
     * @param out - 转换后的结果
     */

  }, {
    key: "translate",
    value: function translate(m, trans, out) {
      var x = trans.x,
          y = trans.y;
      var ae = m.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2];
      var a21 = ae[3],
          a22 = ae[4],
          a23 = ae[5];
      var a31 = ae[6],
          a32 = ae[7],
          a33 = ae[8];
      oe[0] = a11;
      oe[1] = a12;
      oe[2] = a13;
      oe[3] = a21;
      oe[4] = a22;
      oe[5] = a23;
      oe[6] = x * a11 + y * a21 + a31;
      oe[7] = x * a12 + y * a22 + a32;
      oe[8] = x * a13 + y * a23 + a33;
    }
    /**
     * 计算矩阵 a 的转置矩阵，并将结果输出到 out。
     * @param a - 矩阵
     * @param out - 转置矩阵
     */

  }, {
    key: "transpose",
    value: function transpose(a, out) {
      var ae = a.elements;
      var oe = out.elements;

      if (out === a) {
        var a12 = ae[1];
        var a13 = ae[2];
        var a23 = ae[5];
        oe[1] = ae[3];
        oe[2] = ae[6];
        oe[3] = a12;
        oe[5] = ae[7];
        oe[6] = a13;
        oe[7] = a23;
      } else {
        oe[0] = ae[0];
        oe[1] = ae[3];
        oe[2] = ae[6];
        oe[3] = ae[1];
        oe[4] = ae[4];
        oe[5] = ae[7];
        oe[6] = ae[2];
        oe[7] = ae[5];
        oe[8] = ae[8];
      }
    }
    /**
     * 矩阵元素数组，采用列矩阵的模式存储。
     * @remarks
     * elements[0] 表示第 1 列第 1 行 m11
     * elements[1] 表示第 1 列第 2 行 m12
     * elements[2] 表示第 1 列第 3 行 m13
     * elements[3] 表示第 2 列第 1 行 m21
     * 依次类推
     */

  }]);

  /**
   * 创建3x3矩阵实例，默认创建单位矩阵，采用列矩阵的模式存储。
   * @param m11 - 默认值1 column 1, row 1
   * @param m12 - 默认值0 column 1, row 2
   * @param m13 - 默认值0 column 1, row 3
   * @param m21 - 默认值0 column 2, row 1
   * @param m22 - 默认值1 column 2, row 2
   * @param m23 - 默认值0 column 2, row 3
   * @param m31 - 默认值0 column 3, row 1
   * @param m32 - 默认值0 column 3, row 2
   * @param m33 - 默认值1 column 3, row 3
   */
  function Matrix3x3() {
    var m11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var m12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var m13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var m21 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var m22 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var m23 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var m31 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var m32 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var m33 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;

    _classCallCheck(this, Matrix3x3);

    this.elements = new Float32Array(9);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
  }
  /**
   * 给矩阵设置值，并返回当前值。
   * @param m11
   * @param m12
   * @param m13
   * @param m21
   * @param m22
   * @param m23
   * @param m31
   * @param m32
   * @param m33
   * @returns 当前矩阵
   */


  _createClass(Matrix3x3, [{
    key: "setValue",
    value: function setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m21;
      e[4] = m22;
      e[5] = m23;
      e[6] = m31;
      e[7] = m32;
      e[8] = m33;
      return this;
    }
    /**
     * 通过数组设置值，并返回当前矩阵。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前矩阵
     */

  }, {
    key: "setValueByArray",
    value: function setValueByArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var srce = this.elements;

      for (var i = 0; i < 12; i++) {
        srce[i] = array[i + offset];
      }

      return this;
    }
    /**
     * 从4x4矩阵转换为一个3x3矩阵，upper-left 原则，即忽略第4行第4列。
     * @param a - 4x4矩阵
     * @returns 当前矩阵
     */

  }, {
    key: "setValueByMatrix",
    value: function setValueByMatrix(a) {
      var ae = a.elements;
      var e = this.elements;
      e[0] = ae[0];
      e[1] = ae[1];
      e[2] = ae[2];
      e[3] = ae[4];
      e[4] = ae[5];
      e[5] = ae[6];
      e[6] = ae[8];
      e[7] = ae[9];
      e[8] = ae[10];
      return this;
    }
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */

  }, {
    key: "toArray",
    value: function toArray(out) {
      var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var e = this.elements;
      out[outOffset] = e[0];
      out[outOffset + 1] = e[1];
      out[outOffset + 2] = e[2];
      out[outOffset + 3] = e[3];
      out[outOffset + 4] = e[4];
      out[outOffset + 5] = e[5];
      out[outOffset + 6] = e[6];
      out[outOffset + 7] = e[7];
      out[outOffset + 8] = e[8];
    }
    /**
     * 创建一个新的矩阵，并用当前矩阵值初始化。
     * @returns 一个新的矩阵，并且拷贝当前矩阵的值
     */

  }, {
    key: "clone",
    value: function clone() {
      var e = this.elements;
      var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
      return ret;
    }
    /**
     * 将当前矩阵值拷贝给 out 矩阵。
     * @param out - 目标矩阵
     */

  }, {
    key: "cloneTo",
    value: function cloneTo(out) {
      var e = this.elements;
      var oe = out.elements;
      oe[0] = e[0];
      oe[1] = e[1];
      oe[2] = e[2];
      oe[3] = e[3];
      oe[4] = e[4];
      oe[5] = e[5];
      oe[6] = e[6];
      oe[7] = e[7];
      oe[8] = e[8];
      return out;
    }
    /**
     * 将当前矩阵加上给定的向量 right，并返回当前矩阵。
     * @param right - 给定的向量，右操作数
     * @returns 当前矩阵
     */

  }, {
    key: "add",
    value: function add(right) {
      Matrix3x3.add(this, right, this);
      return this;
    }
    /**
     * 将当前矩阵减去给定的向量 right，并返回当前矩阵。
     * @param right - 给定的向量，右操作数
     * @returns 当前矩阵
     */

  }, {
    key: "subtract",
    value: function subtract(right) {
      Matrix3x3.subtract(this, right, this);
      return this;
    }
    /**
     * 将当前矩阵乘以给定的向量 right，并返回当前矩阵。
     * @param right - 给定的向量，右操作数
     * @returns 当前矩阵
     */

  }, {
    key: "multiply",
    value: function multiply(right) {
      Matrix3x3.multiply(this, right, this);
      return this;
    }
    /**
     * 计算3x3矩阵的行列式。
     * @returns 当前矩阵的行列式
     */

  }, {
    key: "determinant",
    value: function determinant() {
      var e = this.elements;
      var a11 = e[0],
          a12 = e[1],
          a13 = e[2];
      var a21 = e[3],
          a22 = e[4],
          a23 = e[5];
      var a31 = e[6],
          a32 = e[7],
          a33 = e[8];
      var b12 = a33 * a22 - a23 * a32;
      var b22 = -a33 * a21 + a23 * a31;
      var b32 = a32 * a21 - a22 * a31;
      return a11 * b12 + a12 * b22 + a13 * b32;
    }
    /**
     * 将矩阵设置为单位矩阵，并返回。
     * @returns 当前矩阵
     */

  }, {
    key: "identity",
    value: function identity() {
      var e = this.elements;
      e[0] = 1;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 1;
      e[5] = 0;
      e[6] = 0;
      e[7] = 0;
      e[8] = 1;
      return this;
    }
    /**
     * 计算当前矩阵的逆矩阵，并返回。
     * @returns 当前矩阵
     */

  }, {
    key: "invert",
    value: function invert() {
      Matrix3x3.invert(this, this);
      return this;
    }
    /**
     * 将当前矩阵按给定角度旋转，并返回。
     * @param r - 给定的旋转角度(单位：弧度)
     * @returns 当前矩阵
     */

  }, {
    key: "rotate",
    value: function rotate(r) {
      Matrix3x3.rotate(this, r, this);
      return this;
    }
    /**
     * 将当前矩阵按给定向量 v 缩放，并返回。
     * @param s - 缩放向量
     * @returns 当前矩阵
     */

  }, {
    key: "scale",
    value: function scale(s) {
      Matrix3x3.scale(this, s, this);
      return this;
    }
    /**
     * 将当前矩阵按给定向量 v 转换，并返回。
     * @param trans - 转换向量
     * @returns 当前矩阵
     */

  }, {
    key: "translate",
    value: function translate(trans) {
      Matrix3x3.translate(this, trans, this);
      return this;
    }
    /**
     * 计算当前矩阵的转置矩阵，并返回。
     * @returns 当前矩阵
     */

  }, {
    key: "transpose",
    value: function transpose() {
      Matrix3x3.transpose(this, this);
      return this;
    }
  }]);

  return Matrix3x3;
}();

/**
 * 三维向量。
 */
var Vector3 = /*#__PURE__*/function () {
  _createClass(Vector3, null, [{
    key: "add",

    /** @internal 零向量。*/

    /** @internal 一向量。*/

    /** @internal */

    /**
     * 将两个向量相加。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 向量相加结果
     */
    value: function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
      out.z = left.z + right.z;
    }
    /**
     * 将两个向量相减。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的相减结果
     */

  }, {
    key: "subtract",
    value: function subtract(left, right, out) {
      out.x = left.x - right.x;
      out.y = left.y - right.y;
      out.z = left.z - right.z;
    }
    /**
     * 将两个向量相乘。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的相乘结果
     */

  }, {
    key: "multiply",
    value: function multiply(left, right, out) {
      out.x = left.x * right.x;
      out.y = left.y * right.y;
      out.z = left.z * right.z;
    }
    /**
     * 将两个三维向量相除。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的相除结果
     */

  }, {
    key: "divide",
    value: function divide(left, right, out) {
      out.x = left.x / right.x;
      out.y = left.y / right.y;
      out.z = left.z / right.z;
    }
    /**
     * 计算两个三维向量的点积。
     * @param left - 左向量
     * @param right - 右向量
     * @returns 两个向量的点积
     */

  }, {
    key: "dot",
    value: function dot(left, right) {
      return left.x * right.x + left.y * right.y + left.z * right.z;
    }
    /**
     * 计算两个三维向量的叉乘。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个三维向量的叉乘结果
     */

  }, {
    key: "cross",
    value: function cross(left, right, out) {
      var ax = left.x;
      var ay = left.y;
      var az = left.z;
      var bx = right.x;
      var by = right.y;
      var bz = right.z;
      out.x = ay * bz - az * by;
      out.y = az * bx - ax * bz;
      out.z = ax * by - ay * bx;
    }
    /**
     * 计算两个三维向量的距离。
     * @param a - 向量
     * @param b - 向量
     * @returns 两个向量的距离
     */

  }, {
    key: "distance",
    value: function distance(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      return Math.sqrt(x * x + y * y + z * z);
    }
    /**
     * 计算两个三维向量的距离的平方。
     * @param a - 向量
     * @param b - 向量
     * @returns 两个向量的距离的平方
     */

  }, {
    key: "distanceSquared",
    value: function distanceSquared(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      return x * x + y * y + z * z;
    }
    /**
     * 判断两个三维向量的值是否相等。
     * @param left - 向量
     * @param right - 向量
     * @returns 两个向量是否相等，是返回 true，否则返回 false
     */

  }, {
    key: "equals",
    value: function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);
    }
    /**
     * 插值三维向量。
     * @param start - 向量
     * @param end - 向量
     * @param t - 插值比例
     * @param out - 插值结果
     */

  }, {
    key: "lerp",
    value: function lerp(start, end, t, out) {
      var x = start.x,
          y = start.y,
          z = start.z;
      out.x = x + (end.x - x) * t;
      out.y = y + (end.y - y) * t;
      out.z = z + (end.z - z) * t;
    }
    /**
     * 分别取两个三维向量 x、y 的最大值计算新的三维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */

  }, {
    key: "max",
    value: function max(left, right, out) {
      out.x = Math.max(left.x, right.x);
      out.y = Math.max(left.y, right.y);
      out.z = Math.max(left.z, right.z);
    }
    /**
     * 分别取两个三维向量 x、y 的最小值计算新的三维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */

  }, {
    key: "min",
    value: function min(left, right, out) {
      out.x = Math.min(left.x, right.x);
      out.y = Math.min(left.y, right.y);
      out.z = Math.min(left.z, right.z);
    }
    /**
     * 将向量 a 反转的结果输出到 out。
     * @param a - 向量
     * @param out - 向量反转的结果
     */

  }, {
    key: "negate",
    value: function negate(a, out) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
    }
    /**
     * 将向量 a 归一化的结果输出到 out。
     * @param a - 向量
     * @param out - 向量归一化的结果
     */

  }, {
    key: "normalize",
    value: function normalize(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z;
      var len = Math.sqrt(x * x + y * y + z * z);

      if (len > 0) {
        // TODO
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
      }
    }
    /**
     * 将向量 a 缩放的结果输出到 out。
     * @param a - 向量
     * @param s - 缩放因子
     * @param out - 向量缩放的结果
     */

  }, {
    key: "scale",
    value: function scale(a, s, out) {
      out.x = a.x * s;
      out.y = a.y * s;
      out.z = a.z * s;
    }
    /**
     * 通过4x4矩阵将一个三维向量进行法线转换到另一个三维向量。
     * @remarks
     * 法线变换假设 w 分量为零，这导致矩阵的第四行和第四列并不使用。
     * 最终得出的结果是一个没有位置变换的向量，但是其他变换属性均被应用。
     * 通常这对法线向量来说比较友好，因为法线向量纯粹代表方向。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transformNormal",
    value: function transformNormal(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8];
      out.y = x * e[1] + y * e[5] + z * e[9];
      out.z = x * e[2] + y * e[6] + z * e[10];
    }
    /**
     * 通过4x4矩阵将一个三维向量转换到另一个三维向量。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transformToVec3",
    value: function transformToVec3(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
      out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
      out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
    }
    /**
     * 通过4x4矩阵将一个三维向量转换到一个四维向量。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transformToVec4",
    value: function transformToVec4(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
      out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
      out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
      out.w = x * e[3] + y * e[7] + z * e[11] + e[15];
    }
    /**
     * 通过4x4矩阵将一个三维向量转换到另一个三维向量。
     *
     * @remarks
     * 坐标变换价值 w 分量为一，从变换得到的四维向量的每个分量都除以 w 分量。
     * 这导致变换结果的 w 分量为一,向量变为齐次向量。
     * 齐次向量在坐标变换中使用，w 分量可以安全的忽略。
     *
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量，此向量为齐次
     */

  }, {
    key: "transformCoordinate",
    value: function transformCoordinate(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var e = m.elements;
      var w = x * e[3] + y * e[7] + z * e[11] + e[15];
      w = 1.0 / w;
      out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;
      out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;
      out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;
    }
    /**
     * 通过四元数将一个三维向量转换到另一个三维向量。
     * @param v - 向量
     * @param q - 四元数
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transformByQuat",
    value: function transformByQuat(v, q, out) {
      var x = v.x,
          y = v.y,
          z = v.z;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w; // calculate quat * vec

      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

      out.x = ix * qw - iw * qx - iy * qz + iz * qy;
      out.y = iy * qw - iw * qy - iz * qx + ix * qz;
      out.z = iz * qw - iw * qz - ix * qy + iy * qx;
    }
    /** 向量的 X 分量。*/

  }]);

  /**
   * 创建一个 Vector3 实例。
   * @param x - 向量的 X 分量，默认值 0
   * @param y - 向量的 Y 分量，默认值 0
   * @param z - 向量的 Z 分量，默认值 0
   */
  function Vector3() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Vector3);

    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * 设置 x, y, z 的值，并返回当前向量。
   * @param x - 向量的 X 分量
   * @param y - 向量的 Y 分量
   * @param z - 向量的 Z 分量
   * @returns 当前向量
   */


  _createClass(Vector3, [{
    key: "setValue",
    value: function setValue(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    /**
     * 通过数组设置值，并返回当前向量。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前向量
     */

  }, {
    key: "setValueByArray",
    value: function setValueByArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    /**
     * 将当前向量加上给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "add",
    value: function add(right) {
      this.x += right.x;
      this.y += right.y;
      this.z += right.z;
      return this;
    }
    /**
     * 将当前向量减去给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "subtract",
    value: function subtract(right) {
      this.x -= right.x;
      this.y -= right.y;
      this.z -= right.z;
      return this;
    }
    /**
     * 将当前向量乘以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "multiply",
    value: function multiply(right) {
      this.x *= right.x;
      this.y *= right.y;
      this.z *= right.z;
      return this;
    }
    /**
     * 将当前向量除以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "divide",
    value: function divide(right) {
      this.x /= right.x;
      this.y /= right.y;
      this.z /= right.z;
      return this;
    }
    /**
     * 计算一个三维向量的标量长度。
     * @returns 当前向量的标量长度
     */

  }, {
    key: "length",
    value: function length() {
      var x = this.x,
          y = this.y,
          z = this.z;
      return Math.sqrt(x * x + y * y + z * z);
    }
    /**
     * 计算一个三维向量的标量长度的平方。
     * @returns 当前向量的标量长度的平方
     */

  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var x = this.x,
          y = this.y,
          z = this.z;
      return x * x + y * y + z * z;
    }
    /**
     * 向量反转。
     * @returns 当前向量
     */

  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    /**
     * 向量归一化。
     * @returns 当前向量
     */

  }, {
    key: "normalize",
    value: function normalize() {
      Vector3.normalize(this, this);
      return this;
    }
    /**
     * 向量缩放。
     * @param s - 缩放因子
     * @returns 当前向量
     */

  }, {
    key: "scale",
    value: function scale(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      return this;
    }
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */

  }, {
    key: "toArray",
    value: function toArray(out) {
      var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
      out[outOffset + 2] = this.z;
    }
    /**
     * 克隆并返回一个新的三维向量对象。
     * @returns 新的三维向量对象
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Vector3(this.x, this.y, this.z);
    }
    /**
     * 将当前向量值拷贝给 out 向量。
     * @param out - 目标向量
     */

  }, {
    key: "cloneTo",
    value: function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.z = this.z;
      return out;
    }
    /**
     * 通过4x4矩阵将当前向量转换。
     * @remarks
     * 法线变换假设 w 分量为零，这导致矩阵的第四行和第四列并不使用。
     * 最终得出的结果是一个没有位置变换的向量，但是其他变换属性均被应用。
     * 通常这对法线向量来说比较友好，因为法线向量纯粹代表方向。
     * @param m - 转换矩阵
     * @returns 当前向量
     */

  }, {
    key: "transformNormal",
    value: function transformNormal(m) {
      Vector3.transformNormal(this, m, this);
      return this;
    }
    /**
     * 通过4x4矩阵将当前向量转换。
     * @param m - 转换矩阵
     * @returns 当前向量
     */

  }, {
    key: "transformToVec3",
    value: function transformToVec3(m) {
      Vector3.transformToVec3(this, m, this);
      return this;
    }
    /**
     * 通过4x4矩阵将当前向量转换。
     * @remarks
     * 坐标变换价值 w 分量为一，从变换得到的四维向量的每个分量都除以 w 分量。
     * 这导致变换结果的 w 分量为一,向量变为齐次向量。
     * 齐次向量在坐标变换中使用，w 分量可以安全的忽略。
      * @param m - 转换矩阵
     * @returns 当前向量
     */

  }, {
    key: "transformCoordinate",
    value: function transformCoordinate(m) {
      Vector3.transformCoordinate(this, m, this);
      return this;
    }
    /**
     * 通过四元数将当前向量转换。
     * @param q - 四元数
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transformByQuat",
    value: function transformByQuat(q) {
      Vector3.transformByQuat(this, q, this);
      return this;
    }
  }]);

  return Vector3;
}();
Vector3._zero = new Vector3(0.0, 0.0, 0.0);
Vector3._one = new Vector3(1.0, 1.0, 1.0);
Vector3._tempVector3 = new Vector3();

/**
 * 四元数。
 */

var Quaternion = /*#__PURE__*/function () {
  _createClass(Quaternion, null, [{
    key: "add",

    /** @internal */

    /**
     * 将两个四元数相加。
     * @param left - 左四元数
     * @param right - 右四元数
     * @param out - 四元数相加结果
     */
    value: function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
      out.z = left.z + right.z;
      out.w = left.w + right.w;
    }
    /**
     * 将两个四元数相乘。
     * @param left - 左四元数
     * @param right - 右四元数
     * @param out - 四元数相乘结果
     */

  }, {
    key: "multiply",
    value: function multiply(left, right, out) {
      var ax = left.x,
          ay = left.y,
          az = left.z,
          aw = left.w;
      var bx = right.x,
          by = right.y,
          bz = right.z,
          bw = right.w;
      out.x = ax * bw + aw * bx + ay * bz - az * by;
      out.y = ay * bw + aw * by + az * bx - ax * bz;
      out.z = az * bw + aw * bz + ax * by - ay * bx;
      out.w = aw * bw - ax * bx - ay * by - az * bz;
    }
    /**
     * 计算共轭四元数。
     * @param a - 输入四元数
     * @param out - 输出的共轭四元数
     */

  }, {
    key: "conjugate",
    value: function conjugate(a, out) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      out.w = a.w;
    }
    /**
     * 计算两个四元数的点积。
     * @param left - 左四元数
     * @param right - 右四元数
     * @returns 两个四元数的点积
     */

  }, {
    key: "dot",
    value: function dot(left, right) {
      return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    }
    /**
     * 判断两个四元数是否相等。
     * @param left - 四元数
     * @param right - 四元数
     * @returns 两个四元数是否相等，是返回 true，否则返回 false
     */

  }, {
    key: "equals",
    value: function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
    }
    /**
     * 通过旋转的欧拉角设置四元数。
     * @param axis - 旋转轴向量
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 生成的四元数
     */

  }, {
    key: "rotationAxisAngle",
    value: function rotationAxisAngle(axis, rad, out) {
      var normalAxis = Quaternion._tempVector3;
      Vector3.normalize(axis, normalAxis);
      rad *= 0.5;
      var s = Math.sin(rad);
      out.x = normalAxis.x * s;
      out.y = normalAxis.y * s;
      out.z = normalAxis.z * s;
      out.w = Math.cos(rad);
    }
    /**
     * 根据 x,y,z 轴的旋转欧拉角(弧度)生成四元数，欧拉角顺序 pitch yaw roll。
     * @param x - 绕X轴旋转的弧度 pitch
     * @param y - 绕Y轴旋转的弧度 yaw
     * @param z - 绕Z轴旋转的弧度 roll
     * @param out - 生成的四元数
     */

  }, {
    key: "rotationEuler",
    value: function rotationEuler(x, y, z, out) {
      Quaternion.rotationYawPitchRoll(y, x, z, out);
    }
    /**
     * 根据 yaw、pitch、roll 生成四元数
     * @param yaw - 偏航角(单位弧度)
     * @param pitch - 俯仰角(单位弧度)
     * @param roll - 翻滚角(单位弧度)
     * @param out - 生成的四元数
     */

  }, {
    key: "rotationYawPitchRoll",
    value: function rotationYawPitchRoll(yaw, pitch, roll, out) {
      var halfRoll = roll * 0.5;
      var halfPitch = pitch * 0.5;
      var halfYaw = yaw * 0.5;
      var sinRoll = Math.sin(halfRoll);
      var cosRoll = Math.cos(halfRoll);
      var sinPitch = Math.sin(halfPitch);
      var cosPitch = Math.cos(halfPitch);
      var sinYaw = Math.sin(halfYaw);
      var cosYaw = Math.cos(halfYaw);
      var cosYawPitch = cosYaw * cosPitch;
      var sinYawPitch = sinYaw * sinPitch;
      out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
      out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
      out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
    }
    /**
     * 通过矩阵得出对应的四元数。
     * @param m - 3x3矩阵
     * @param out - 生成的四元数
     */

  }, {
    key: "rotationMatrix3x3",
    value: function rotationMatrix3x3(m, out) {
      var me = m.elements;
      var m11 = me[0],
          m12 = me[1],
          m13 = me[2];
      var m21 = me[3],
          m22 = me[4],
          m23 = me[5];
      var m31 = me[6],
          m32 = me[7],
          m33 = me[8];
      var scale = m11 + m22 + m33;
      var sqrt, half;

      if (scale > 0) {
        sqrt = Math.sqrt(scale + 1.0);
        out.w = sqrt * 0.5;
        sqrt = 0.5 / sqrt;
        out.x = (m23 - m32) * sqrt;
        out.y = (m31 - m13) * sqrt;
        out.z = (m12 - m21) * sqrt;
      } else if (m11 >= m22 && m11 >= m33) {
        sqrt = Math.sqrt(1.0 + m11 - m22 - m33);
        half = 0.5 / sqrt;
        out.x = 0.5 * sqrt;
        out.y = (m12 + m21) * half;
        out.z = (m13 + m31) * half;
        out.w = (m23 - m32) * half;
      } else if (m22 > m33) {
        sqrt = Math.sqrt(1.0 + m22 - m11 - m33);
        half = 0.5 / sqrt;
        out.x = (m21 + m12) * half;
        out.y = 0.5 * sqrt;
        out.z = (m32 + m23) * half;
        out.w = (m31 - m13) * half;
      } else {
        sqrt = Math.sqrt(1.0 + m33 - m11 - m22);
        half = 0.5 / sqrt;
        out.x = (m13 + m31) * half;
        out.y = (m23 + m32) * half;
        out.z = 0.5 * sqrt;
        out.w = (m12 - m21) * half;
      }
    }
    /**
     * 计算四元数的逆。
     * @param a - 四元数的逆
     * @param out - 四元数的逆
     */

  }, {
    key: "invert",
    value: function invert(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z,
          w = a.w;
      var dot = x * x + y * y + z * z + w * w;

      if (dot > MathUtil.zeroTolerance) {
        var invDot = 1.0 / dot;
        out.x = -x * invDot;
        out.y = -y * invDot;
        out.z = -z * invDot;
        out.w = w * invDot;
      }
    }
    /**
     * 插值四元数。
     * @param start - 左四元数
     * @param end - 右四元数
     * @param t - 插值比例 范围 0～1
     * @param out - 插值结果
     */

  }, {
    key: "lerp",
    value: function lerp(start, end, t, out) {
      var inv = 1.0 - t;

      if (Quaternion.dot(start, end) >= 0) {
        out.x = start.x * inv + end.x * t;
        out.y = start.y * inv + end.y * t;
        out.z = start.z * inv + end.z * t;
        out.w = start.w * inv + end.w * t;
      } else {
        out.x = start.x * inv - end.x * t;
        out.y = start.y * inv - end.y * t;
        out.z = start.z * inv - end.z * t;
        out.w = start.w * inv - end.w * t;
      }

      out.normalize();
    }
    /**
     * 球面插值四元数。
     * @param start - 左四元数
     * @param end - 右四元数
     * @param t - 插值比例
     * @param out - 插值结果
     */

  }, {
    key: "slerp",
    value: function slerp(start, end, t, out) {
      //CM: todo: 参照stride实现
      var ax = start.x;
      var ay = start.y;
      var az = start.z;
      var aw = start.w;
      var bx = end.x;
      var by = end.y;
      var bz = end.z;
      var bw = end.w;
      var scale0, scale1; // calc cosine

      var cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      } // calculate coefficients


      if (1.0 - cosom > MathUtil.zeroTolerance) {
        // standard case (slerp)
        var omega = Math.acos(cosom);
        var sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
      } // calculate final values


      out.x = scale0 * ax + scale1 * bx;
      out.y = scale0 * ay + scale1 * by;
      out.z = scale0 * az + scale1 * bz;
      out.w = scale0 * aw + scale1 * bw;
    }
    /**
     * 将一个四元数归一化。
     * @param a - 四元数
     * @param out - 四元数归一化的结果
     */

  }, {
    key: "normalize",
    value: function normalize(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z,
          w = a.w;
      var len = Math.sqrt(x * x + y * y + z * z + w * w);

      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
        out.w = w * len;
      }
    }
    /**
     * 绕 X 轴旋生成转四元数。
     * @param a - 四元数
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 旋转后的四元数
     */

  }, {
    key: "rotationX",
    value: function rotationX(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.x = s;
      out.y = 0;
      out.z = 0;
      out.w = c;
    }
    /**
     * 绕 Y 轴旋转生成四元数。
     * @param a - 四元数
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 旋转后的四元数
     */

  }, {
    key: "rotationY",
    value: function rotationY(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.x = 0;
      out.y = s;
      out.z = 0;
      out.w = c;
    }
    /**
     * 绕 Z 轴旋转生成四元数。
     * @param a - 四元数
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 旋转后的四元数
     */

  }, {
    key: "rotationZ",
    value: function rotationZ(rad, out) {
      rad *= 0.5;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.x = 0;
      out.y = 0;
      out.z = s;
      out.w = c;
    }
    /**
     * 四元数 q 绕 X 轴旋转。
     * @param q - 四元数
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 旋转后的四元数
     */

  }, {
    key: "rotateX",
    value: function rotateX(q, rad, out) {
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      rad *= 0.5;
      var bx = Math.sin(rad);
      var bw = Math.cos(rad);
      out.x = x * bw + w * bx;
      out.y = y * bw + z * bx;
      out.z = z * bw - y * bx;
      out.w = w * bw - x * bx;
    }
    /**
     * 四元数 q 绕 Y 轴旋转。
     * @param q - 四元数
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 旋转后的四元数
     */

  }, {
    key: "rotateY",
    value: function rotateY(q, rad, out) {
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      rad *= 0.5;
      var by = Math.sin(rad);
      var bw = Math.cos(rad);
      out.x = x * bw - z * by;
      out.y = y * bw + w * by;
      out.z = z * bw + x * by;
      out.w = w * bw - y * by;
    }
    /**
     * 四元数 q 绕 Z 轴旋转。
     * @param q - 四元数
     * @param rad - 旋转角度(单位：弧度)
     * @param out - 旋转后的四元数
     */

  }, {
    key: "rotateZ",
    value: function rotateZ(q, rad, out) {
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      rad *= 0.5;
      var bz = Math.sin(rad);
      var bw = Math.cos(rad);
      out.x = x * bw + y * bz;
      out.y = y * bw - x * bz;
      out.z = z * bw + w * bz;
      out.w = w * bw - z * bz;
    }
    /**
     * 将一个四元数缩放。
     * @param a - 四元数
     * @param s - 缩放因子
     * @param out - 四元数缩放的结果
     */

  }, {
    key: "scale",
    value: function scale(a, s, out) {
      out.x = a.x * s;
      out.y = a.y * s;
      out.z = a.z * s;
      out.w = a.w * s;
    }
    /** 四元数的 X 分量 */

  }]);

  /**
   * 创建四元数实例。
   * @param x - 四元数的 X 分量，默认值 0
   * @param y - 四元数的 Y 分量，默认值 0
   * @param z - 四元数的 Z 分量，默认值 0
   * @param w - 四元数的 W 分量，默认值 1
   */
  function Quaternion() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, Quaternion);

    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * 设置 x, y, z, w 的值。
   * @param x - 四元数的 X 分量
   * @param y - 四元数的 Y 分量
   * @param z - 四元数的 Z 分量
   * @param w - 四元数的 W 分量
   * @returns 当前四元数
   */


  _createClass(Quaternion, [{
    key: "setValue",
    value: function setValue(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    /**
     * 通过数组设置值，并返回当前四元数。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前四元数
     */

  }, {
    key: "setValueByArray",
    value: function setValueByArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    /**
     * 共轭四元数
     * @returns 当前四元数
     */

  }, {
    key: "conjugate",
    value: function conjugate() {
      this.x *= -1;
      this.y *= -1;
      this.z *= -1;
      return this;
    }
    /**
     * 获取四元数的旋转轴和旋转角度(单位：弧度)。
     * @param out - 四元数的旋转轴
     * @returns 当前四元数的旋转角度(单位：弧度)
     */

  }, {
    key: "getAxisAngle",
    value: function getAxisAngle(out) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var length = x * x + y * y + z * z;

      if (length < MathUtil.zeroTolerance) {
        out.x = 1;
        out.y = 0;
        out.z = 0;
        return 0;
      } else {
        var inv = 1.0 / length;
        out.x = this.x * inv;
        out.y = this.y * inv;
        out.z = this.z * inv;
        return Math.acos(this.w) * 2.0;
      }
    }
    /**
     * 将四元数设置为单位四元数。
     */

  }, {
    key: "identity",
    value: function identity() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
      return this;
    }
    /**
     * 计算一个四元数的标量长度。
     * @returns 当前四元数的标量长度
     */

  }, {
    key: "length",
    value: function length() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * 计算一个四元数的标量长度的平方。
     * @returns 当前四元数的标量长度的平方
     */

  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return x * x + y * y + z * z + w * w;
    }
    /**
     * 四元数归一化。
     * @returns 当前四元数
     */

  }, {
    key: "normalize",
    value: function normalize() {
      Quaternion.normalize(this, this);
      return this;
    }
    /**
     * 获取四元数的欧拉角(弧度)。
     * @param out - 四元数的欧拉角(弧度)
     * @returns 欧拉角 x->pitch y->yaw z->roll
     */

  }, {
    key: "toEuler",
    value: function toEuler(out) {
      this.toYawPitchRoll(out);
      var t = out.x;
      out.x = out.y;
      out.y = t;
      return out;
    }
    /**
     * 获取四元数的欧拉角(弧度)。
     * @param out - 四元数的欧拉角(弧度)
     * @returns 欧拉角 x->yaw y->pitch z->roll
     */

  }, {
    key: "toYawPitchRoll",
    value: function toYawPitchRoll(out) {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      var xx = x * x;
      var yy = y * y;
      var zz = z * z;
      var xy = x * y;
      var zw = z * w;
      var zx = z * x;
      var yw = y * w;
      var yz = y * z;
      var xw = x * w;
      out.y = Math.asin(2.0 * (xw - yz));

      if (Math.cos(out.y) > MathUtil.zeroTolerance) {
        out.z = Math.atan2(2.0 * (xy + zw), 1.0 - 2.0 * (zz + xx));
        out.x = Math.atan2(2.0 * (zx + yw), 1.0 - 2.0 * (yy + xx));
      } else {
        out.z = Math.atan2(-2.0 * (xy - zw), 1.0 - 2.0 * (yy + zz));
        out.x = 0.0;
      }

      return out;
    }
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */

  }, {
    key: "toArray",
    value: function toArray(out) {
      var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
      out[outOffset + 2] = this.z;
      out[outOffset + 3] = this.w;
    }
    /**
     * 创建一个新的四元数，并用当前四元数初始化。
     * @returns 一个新的四元数，并且拷贝当前四元数的值
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Quaternion(this.x, this.y, this.z, this.w);
    }
    /**
     * 将当前四元数值拷贝给 out 四元数。
     * @param out - 目标四元数
     */

  }, {
    key: "cloneTo",
    value: function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.z = this.z;
      out.w = this.w;
      return out;
    }
    /**
     * 绕 X 轴旋转。
     * @param rad - 旋转角度(单位：弧度)
     * @returns 当前四元数
     */

  }, {
    key: "rotateX",
    value: function rotateX(rad) {
      Quaternion.rotateX(this, rad, this);
      return this;
    }
    /**
     * 绕 Y 轴旋转。
     * @param rad - 旋转角度(单位：弧度)
     * @returns 当前四元数
     */

  }, {
    key: "rotateY",
    value: function rotateY(rad) {
      Quaternion.rotateY(this, rad, this);
      return this;
    }
    /**
     * 绕 Z 轴旋转。
     * @param rad - 旋转角度(单位：弧度)
     * @returns 当前四元数
     */

  }, {
    key: "rotateZ",
    value: function rotateZ(rad) {
      Quaternion.rotateZ(this, rad, this);
      return this;
    }
    /**
     * 通过旋转的欧拉角设置当前四元数。
     * @param axis - 旋转轴向量
     * @param rad - 旋转角度(单位：弧度)
     * @returns 当前四元数
     */

  }, {
    key: "rotationAxisAngle",
    value: function rotationAxisAngle(axis, rad) {
      Quaternion.rotationAxisAngle(axis, rad, this);
      return this;
    }
    /**
     * 与四元数相乘。
     * @param quat - 右四元数
     * @returns 当前四元数
     */

  }, {
    key: "multiply",
    value: function multiply(quat) {
      Quaternion.multiply(this, quat, this);
      return this;
    }
    /**
     * 计算四元数的逆。
     * @returns 当前四元数
     */

  }, {
    key: "invert",
    value: function invert() {
      Quaternion.invert(this, this);
      return this;
    }
    /**
     * 计算与四元数的点积。
     * @param quat - 右四元数
     * @returns 点击结果
     */

  }, {
    key: "dot",
    value: function dot(quat) {
      return Quaternion.dot(this, quat);
    }
    /**
     * 插值四元数。
     * @param quat - 右四元数
     * @param t - 插值比例 范围 0～1
     * @returns - 插值结果
     */

  }, {
    key: "lerp",
    value: function lerp(quat, t) {
      Quaternion.lerp(this, quat, t, this);
      return this;
    }
  }]);

  return Quaternion;
}();
Quaternion._tempVector3 = new Vector3();

/**
 * 4x4矩阵。
 */

var Matrix = /*#__PURE__*/function () {
  _createClass(Matrix, null, [{
    key: "multiply",

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal 单位矩阵。*/

    /**
     * 将两个矩阵相乘。
     * @param left - 左矩阵
     * @param right - 右矩阵
     * @param out - 矩阵相乘的结果
     */
    value: function multiply(left, right, out) {
      var le = left.elements;
      var re = right.elements;
      var oe = out.elements;
      var l11 = le[0],
          l12 = le[1],
          l13 = le[2],
          l14 = le[3];
      var l21 = le[4],
          l22 = le[5],
          l23 = le[6],
          l24 = le[7];
      var l31 = le[8],
          l32 = le[9],
          l33 = le[10],
          l34 = le[11];
      var l41 = le[12],
          l42 = le[13],
          l43 = le[14],
          l44 = le[15];
      var r11 = re[0],
          r12 = re[1],
          r13 = re[2],
          r14 = re[3];
      var r21 = re[4],
          r22 = re[5],
          r23 = re[6],
          r24 = re[7];
      var r31 = re[8],
          r32 = re[9],
          r33 = re[10],
          r34 = re[11];
      var r41 = re[12],
          r42 = re[13],
          r43 = re[14],
          r44 = re[15];
      oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
      oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
      oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
      oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
      oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
      oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
      oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
      oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
      oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
      oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
      oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
      oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
      oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
      oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
      oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
      oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    }
    /**
     * 判断两个矩阵的值是否相等。
     * @param left - 左矩阵
     * @param right - 右矩阵
     * @returns 两个矩阵是否相等，是返回 true，否则返回 false
     */

  }, {
    key: "equals",
    value: function equals(left, right) {
      var le = left.elements;
      var re = right.elements;
      return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
    }
    /**
     * 通过四元数生成旋转矩阵。
     * @param q - 四元数
     * @param out - 转换后的4x4矩阵
     */

  }, {
    key: "rotationQuaternion",
    value: function rotationQuaternion(q, out) {
      var oe = out.elements;
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      oe[0] = 1 - yy - zz;
      oe[1] = yx + wz;
      oe[2] = zx - wy;
      oe[3] = 0;
      oe[4] = yx - wz;
      oe[5] = 1 - xx - zz;
      oe[6] = zy + wx;
      oe[7] = 0;
      oe[8] = zx + wy;
      oe[9] = zy - wx;
      oe[10] = 1 - xx - yy;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }
    /**
     * 通过绕任意轴旋转生成4x4矩阵。
     * * @param axis - 旋转轴
     * @param r - 旋转角度
     * @param out - 指定旋转后矩阵
     */

  }, {
    key: "rotationAxisAngle",
    value: function rotationAxisAngle(axis, r, out) {
      //CM：stride实现
      var oe = out.elements;
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var len = Math.sqrt(x * x + y * y + z * z);
      var s, c, t;

      if (Math.abs(len) < MathUtil.zeroTolerance) {
        return;
      }

      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(r);
      c = Math.cos(r);
      t = 1 - c; // Perform rotation-specific matrix multiplication

      oe[0] = x * x * t + c;
      oe[1] = y * x * t + z * s;
      oe[2] = z * x * t - y * s;
      oe[3] = 0;
      oe[4] = x * y * t - z * s;
      oe[5] = y * y * t + c;
      oe[6] = z * y * t + x * s;
      oe[7] = 0;
      oe[8] = x * z * t + y * s;
      oe[9] = y * z * t - x * s;
      oe[10] = z * z * t + c;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }
    /**
     * 通过指定的旋转四元数,转换向量生成4x4矩阵。
     * @param q - 旋转四元数
     * @param trans - 转换向量
     * @param out - 生成的4x4矩阵
     */

  }, {
    key: "rotationTranslation",
    value: function rotationTranslation(q, trans, out) {
      Matrix.rotationQuaternion(q, out);
      var oe = out.elements;
      oe[12] = trans.x;
      oe[13] = trans.y;
      oe[14] = trans.z;
    }
    /**
     * 创建仿射矩阵。
     * @param scale - 缩放向量
     * @param rotation - 旋转四元数
     * @param trans - 转换向量
     * @param out - 生成的4x4矩阵
     */

  }, {
    key: "affineTransformation",
    value: function affineTransformation(scale, rotation, trans, out) {
      var oe = out.elements;
      var x = rotation.x,
          y = rotation.y,
          z = rotation.z,
          w = rotation.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var sx = scale.x;
      var sy = scale.y;
      var sz = scale.z;
      oe[0] = (1 - (yy + zz)) * sx;
      oe[1] = (xy + wz) * sx;
      oe[2] = (xz - wy) * sx;
      oe[3] = 0;
      oe[4] = (xy - wz) * sy;
      oe[5] = (1 - (xx + zz)) * sy;
      oe[6] = (yz + wx) * sy;
      oe[7] = 0;
      oe[8] = (xz + wy) * sz;
      oe[9] = (yz - wx) * sz;
      oe[10] = (1 - (xx + yy)) * sz;
      oe[11] = 0;
      oe[12] = trans.x;
      oe[13] = trans.y;
      oe[14] = trans.z;
      oe[15] = 1;
    }
    /**
     * 通过指定缩放生成4x4矩阵。
     * @param s - 缩放向量
     * @param out - 指定缩放后矩阵
     */

  }, {
    key: "scaling",
    value: function scaling(s, out) {
      var oe = out.elements;
      oe[0] = s.x;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = s.y;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = s.z;
      oe[11] = 0;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 0;
      oe[15] = 1;
    }
    /**
     * 通过指定平移生成4x4矩阵。
     * @param trans - 平移向量
     * @param out - 指定平移后矩阵
     */

  }, {
    key: "translation",
    value: function translation(trans, out) {
      var oe = out.elements;
      oe[0] = 1;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = 1;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = 1;
      oe[11] = 0;
      oe[12] = trans.x;
      oe[13] = trans.y;
      oe[14] = trans.z;
      oe[15] = 1;
    }
    /**
     * 计算矩阵 a 的逆矩阵，并将结果输出到 out。
     * @param a - 矩阵
     * @param out - 逆矩阵
     */

  }, {
    key: "invert",
    value: function invert(a, out) {
      var ae = a.elements;
      var oe = out.elements;
      var a11 = ae[0],
          a12 = ae[1],
          a13 = ae[2],
          a14 = ae[3];
      var a21 = ae[4],
          a22 = ae[5],
          a23 = ae[6],
          a24 = ae[7];
      var a31 = ae[8],
          a32 = ae[9],
          a33 = ae[10],
          a34 = ae[11];
      var a41 = ae[12],
          a42 = ae[13],
          a43 = ae[14],
          a44 = ae[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
      oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
      oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
      oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
      oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
      oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
      oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
      oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
      oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
      oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
      oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
      oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
      oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
      oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
      oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
      oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
    }
    /**
     * 计算观察矩阵，基于右手坐标系。
     * @param eye - 观察者视点位置
     * @param target - 视点目标
     * @param up - 向上向量
     * @param out - 观察矩阵
     */

  }, {
    key: "lookAt",
    value: function lookAt(eye, target, up, out) {
      var oe = out.elements;
      var xAxis = Matrix._tempVec30;
      var yAxis = Matrix._tempVec31;
      var zAxis = Matrix._tempVec32;
      Vector3.subtract(eye, target, zAxis);
      zAxis.normalize();
      Vector3.cross(up, zAxis, xAxis);
      xAxis.normalize();
      Vector3.cross(zAxis, xAxis, yAxis);
      oe[0] = xAxis.x;
      oe[1] = yAxis.x;
      oe[2] = zAxis.x;
      oe[3] = 0;
      oe[4] = xAxis.y;
      oe[5] = yAxis.y;
      oe[6] = zAxis.y;
      oe[7] = 0;
      oe[8] = xAxis.z;
      oe[9] = yAxis.z;
      oe[10] = zAxis.z;
      oe[11] = 0;
      oe[12] = -Vector3.dot(xAxis, eye);
      oe[13] = -Vector3.dot(yAxis, eye);
      oe[14] = -Vector3.dot(zAxis, eye);
      oe[15] = 1;
    }
    /**
     * 计算正交投影矩阵。
     * @param left - 视锥左边界
     * @param right - 视锥右边界
     * @param bottom - 视锥底边界
     * @param top - 视锥顶边界
     * @param near - 视锥近边界
     * @param far - 视锥远边界
     * @param out - 正交投影矩阵
     */

  }, {
    key: "ortho",
    value: function ortho(left, right, bottom, top, near, far, out) {
      var oe = out.elements;
      var lr = 1 / (left - right);
      var bt = 1 / (bottom - top);
      var nf = 1 / (near - far);
      oe[0] = -2 * lr;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = -2 * bt;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = 2 * nf;
      oe[11] = 0;
      oe[12] = (left + right) * lr;
      oe[13] = (top + bottom) * bt;
      oe[14] = (far + near) * nf;
      oe[15] = 1;
    }
    /**
     * 计算透视投影矩阵。
     * @param fovy - 视角
     * @param aspect - 视图的宽高比
     * @param near - 近裁面
     * @param far - 远裁面
     * @param out - 透视投影矩阵
     */

  }, {
    key: "perspective",
    value: function perspective(fovy, aspect, near, far, out) {
      var oe = out.elements;
      var f = 1.0 / Math.tan(fovy / 2);
      var nf = 1 / (near - far);
      oe[0] = f / aspect;
      oe[1] = 0;
      oe[2] = 0;
      oe[3] = 0;
      oe[4] = 0;
      oe[5] = f;
      oe[6] = 0;
      oe[7] = 0;
      oe[8] = 0;
      oe[9] = 0;
      oe[10] = (far + near) * nf;
      oe[11] = -1;
      oe[12] = 0;
      oe[13] = 0;
      oe[14] = 2 * far * near * nf;
      oe[15] = 0;
    }
    /**
     * 将矩阵 a 按给定角度旋转，并将结果输出到 out。
     * @param m - 矩阵
     * @param axis - 旋转轴
     * @param r - 给定的旋转角度
     * @param out - 旋转后的矩阵
     */

  }, {
    key: "rotateAxisAngle",
    value: function rotateAxisAngle(m, axis, r, out) {
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var len = Math.sqrt(x * x + y * y + z * z);

      if (Math.abs(len) < MathUtil.zeroTolerance) {
        return;
      }

      var me = m.elements;
      var oe = out.elements;
      var s, c, t;
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(r);
      c = Math.cos(r);
      t = 1 - c;
      var a11 = me[0],
          a12 = me[1],
          a13 = me[2],
          a14 = me[3];
      var a21 = me[4],
          a22 = me[5],
          a23 = me[6],
          a24 = me[7];
      var a31 = me[8],
          a32 = me[9],
          a33 = me[10],
          a34 = me[11]; // Construct the elements of the rotation matrix

      var b11 = x * x * t + c;
      var b12 = y * x * t + z * s;
      var b13 = z * x * t - y * s;
      var b21 = x * y * t - z * s;
      var b22 = y * y * t + c;
      var b23 = z * y * t + x * s;
      var b31 = x * z * t + y * s;
      var b32 = y * z * t - x * s;
      var b33 = z * z * t + c; // Perform rotation-specific matrix multiplication

      oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
      oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
      oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
      oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
      oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
      oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
      oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
      oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
      oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
      oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
      oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
      oe[11] = a14 * b31 + a24 * b32 + a34 * b33;

      if (m !== out) {
        // If the source and destination differ, copy the unchanged last row
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
      }
    }
    /**
     * 将矩阵 a 按给定向量 v 缩放，并将结果输出到 out。
     * @param m - 矩阵
     * @param s - 缩放向量
     * @param out - 缩放后的矩阵
     */

  }, {
    key: "scale",
    value: function scale(m, s, out) {
      var me = m.elements;
      var oe = out.elements;
      var x = s.x,
          y = s.y,
          z = s.z;
      oe[0] = me[0] * x;
      oe[1] = me[1] * x;
      oe[2] = me[2] * x;
      oe[3] = me[3] * x;
      oe[4] = me[4] * y;
      oe[5] = me[5] * y;
      oe[6] = me[6] * y;
      oe[7] = me[7] * y;
      oe[8] = me[8] * z;
      oe[9] = me[9] * z;
      oe[10] = me[10] * z;
      oe[11] = me[11] * z;
      oe[12] = me[12];
      oe[13] = me[13];
      oe[14] = me[14];
      oe[15] = me[15];
    }
    /**
     * 将矩阵 a 按给定向量 v 转换，并将结果输出到 out。
     * @param m - 矩阵
     * @param v - 转换向量
     * @param out - 转换后的结果
     */

  }, {
    key: "translate",
    value: function translate(m, v, out) {
      var me = m.elements;
      var oe = out.elements;
      var x = v.x,
          y = v.y,
          z = v.z;

      if (m === out) {
        oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
        oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
        oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
        oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
      } else {
        var a11 = me[0],
            a12 = me[1],
            a13 = me[2],
            a14 = me[3];
        var a21 = me[4],
            a22 = me[5],
            a23 = me[6],
            a24 = me[7];
        var a31 = me[8],
            a32 = me[9],
            a33 = me[10],
            a34 = me[11];
        oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
        oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
        oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
        oe[12] = a11 * x + a21 * y + a31 * z + me[12];
        oe[13] = a12 * x + a22 * y + a32 * z + me[13];
        oe[14] = a13 * x + a23 * y + a33 * z + me[14];
        oe[15] = a14 * x + a24 * y + a34 * z + me[15];
      }
    }
    /**
     * 计算矩阵 a 的转置矩阵，并将结果输出到 out。
     * @param a - 矩阵
     * @param out - 转置矩阵
     */

  }, {
    key: "transpose",
    value: function transpose(a, out) {
      var ae = a.elements;
      var oe = out.elements;

      if (out === a) {
        var a12 = ae[1];
        var a13 = ae[2];
        var a14 = ae[3];
        var a23 = ae[6];
        var a24 = ae[7];
        var a34 = ae[11];
        oe[1] = ae[4];
        oe[2] = ae[8];
        oe[3] = ae[12];
        oe[4] = a12;
        oe[6] = ae[9];
        oe[7] = ae[13];
        oe[8] = a13;
        oe[9] = a23;
        oe[11] = ae[14];
        oe[12] = a14;
        oe[13] = a24;
        oe[14] = a34;
      } else {
        oe[0] = ae[0];
        oe[1] = ae[4];
        oe[2] = ae[8];
        oe[3] = ae[12];
        oe[4] = ae[1];
        oe[5] = ae[5];
        oe[6] = ae[9];
        oe[7] = ae[13];
        oe[8] = ae[2];
        oe[9] = ae[6];
        oe[10] = ae[10];
        oe[11] = ae[14];
        oe[12] = ae[3];
        oe[13] = ae[7];
        oe[14] = ae[11];
        oe[15] = ae[15];
      }
    }
    /**
     * 矩阵元素数组，采用列矩阵的模式存储。
     * @remarks
     * elements[0] 表示第 1 列第 1 行 m11
     * elements[1] 表示第 1 列第 2 行 m12
     * elements[2] 表示第 1 列第 3 行 m13
     * elements[3] 表示第 1 列第 4 行 m14
     * elements[4] 表示第 2 列第 1 行 m21
     * 依次类推
     */

  }]);

  /**
   * 创建4x4矩阵实例，默认创建单位矩阵，采用列矩阵的模式存储。
   * @param m11 - 默认值 1，column 1, row 1
   * @param m12 - 默认值 0，column 1, row 2
   * @param m13 - 默认值 0，column 1, row 3
   * @param m14 - 默认值 0，column 1, row 4
   * @param m21 - 默认值 0，column 2, row 1
   * @param m22 - 默认值 1，column 2, row 2
   * @param m23 - 默认值 0，column 2, row 3
   * @param m24 - 默认值 0，column 2, row 4
   * @param m31 - 默认值 0，column 3, row 1
   * @param m32 - 默认值 0，column 3, row 2
   * @param m33 - 默认值 1，column 3, row 3
   * @param m34 - 默认值 0，column 3, row 4
   * @param m41 - 默认值 0，column 4, row 1
   * @param m42 - 默认值 0，column 4, row 2
   * @param m43 - 默认值 0，column 4, row 3
   * @param m44 - 默认值 1，column 4, row 4
   */
  function Matrix() {
    var m11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var m12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var m13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var m14 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var m21 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var m22 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var m23 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var m24 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var m31 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var m32 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var m33 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
    var m34 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
    var m41 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
    var m42 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
    var m43 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
    var m44 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;

    _classCallCheck(this, Matrix);

    this.elements = new Float32Array(16);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
  }
  /**
   * 给矩阵设置值，并返回当前值。
   * @param m11 - column 1, row 1
   * @param m12 - column 1, row 2
   * @param m13 - column 1, row 3
   * @param m14 - column 1, row 4
   * @param m21 - column 2, row 1
   * @param m22 - column 2, row 2
   * @param m23 - column 2, row 3
   * @param m24 - column 2, row 4
   * @param m31 - column 3, row 1
   * @param m32 - column 3, row 2
   * @param m33 - column 3, row 3
   * @param m34 - column 3, row 4
   * @param m41 - column 4, row 1
   * @param m42 - column 4, row 2
   * @param m43 - column 4, row 3
   * @param m44 - column 4, row 4
   * @returns 当前矩阵
   */


  _createClass(Matrix, [{
    key: "setValue",
    value: function setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m14;
      e[4] = m21;
      e[5] = m22;
      e[6] = m23;
      e[7] = m24;
      e[8] = m31;
      e[9] = m32;
      e[10] = m33;
      e[11] = m34;
      e[12] = m41;
      e[13] = m42;
      e[14] = m43;
      e[15] = m44;
      return this;
    }
    /**
     * 通过数组设置值，并返回当前矩阵。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前矩阵
     */

  }, {
    key: "setValueByArray",
    value: function setValueByArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var srce = this.elements;

      for (var i = 0; i < 16; i++) {
        srce[i] = array[i + offset];
      }

      return this;
    }
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */

  }, {
    key: "toArray",
    value: function toArray(out) {
      var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var e = this.elements;
      out[outOffset] = e[0];
      out[outOffset + 1] = e[1];
      out[outOffset + 2] = e[2];
      out[outOffset + 3] = e[3];
      out[outOffset + 4] = e[4];
      out[outOffset + 5] = e[5];
      out[outOffset + 6] = e[6];
      out[outOffset + 7] = e[7];
      out[outOffset + 8] = e[8];
      out[outOffset + 9] = e[9];
      out[outOffset + 10] = e[10];
      out[outOffset + 11] = e[11];
      out[outOffset + 12] = e[12];
      out[outOffset + 13] = e[13];
      out[outOffset + 14] = e[14];
      out[outOffset + 15] = e[15];
    }
    /**
     * 创建一个新的矩阵，并用当前矩阵值初始化。
     * @returns 一个新的矩阵，并且拷贝当前矩阵的值
     */

  }, {
    key: "clone",
    value: function clone() {
      var e = this.elements;
      var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
      return ret;
    }
    /**
     * 将当前矩阵值拷贝给 out 矩阵。
     * @param out - 目标矩阵
     */

  }, {
    key: "cloneTo",
    value: function cloneTo(out) {
      var e = this.elements;
      var oe = out.elements;
      oe[0] = e[0];
      oe[1] = e[1];
      oe[2] = e[2];
      oe[3] = e[3];
      oe[4] = e[4];
      oe[5] = e[5];
      oe[6] = e[6];
      oe[7] = e[7];
      oe[8] = e[8];
      oe[9] = e[9];
      oe[10] = e[10];
      oe[11] = e[11];
      oe[12] = e[12];
      oe[13] = e[13];
      oe[14] = e[14];
      oe[15] = e[15];
      return out;
    }
    /**
     * 将当前矩阵乘以给定的向量 right，并返回当前矩阵。
     * @param right - 给定的向量，右操作数
     * @returns 当前矩阵
     */

  }, {
    key: "multiply",
    value: function multiply(right) {
      Matrix.multiply(this, right, this);
      return this;
    }
    /**
     * 计算4x4矩阵的行列式。
     * @returns 当前矩阵的行列式
     */

  }, {
    key: "determinant",
    value: function determinant() {
      var e = this.elements;
      var a11 = e[0],
          a12 = e[1],
          a13 = e[2],
          a14 = e[3];
      var a21 = e[4],
          a22 = e[5],
          a23 = e[6],
          a24 = e[7];
      var a31 = e[8],
          a32 = e[9],
          a33 = e[10],
          a34 = e[11];
      var a41 = e[12],
          a42 = e[13],
          a43 = e[14],
          a44 = e[15];
      var b00 = a11 * a22 - a12 * a21;
      var b01 = a11 * a23 - a13 * a21;
      var b02 = a11 * a24 - a14 * a21;
      var b03 = a12 * a23 - a13 * a22;
      var b04 = a12 * a24 - a14 * a22;
      var b05 = a13 * a24 - a14 * a23;
      var b06 = a31 * a42 - a32 * a41;
      var b07 = a31 * a43 - a33 * a41;
      var b08 = a31 * a44 - a34 * a41;
      var b09 = a32 * a43 - a33 * a42;
      var b10 = a32 * a44 - a34 * a42;
      var b11 = a33 * a44 - a34 * a43; // Calculate the determinant

      return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    }
    /**
     * 将矩阵分解为平移向量、旋转四元数、缩放向量。
     * @param pos - 平移向量
     * @param q - 旋转四元数
     * @param s - 缩放向量
     */

  }, {
    key: "decompose",
    value: function decompose(pos, q, s) {
      var t = Matrix._tempMat40;
      this.cloneTo(t);
      var te = t.elements;
      pos.x = te[12];
      pos.y = te[13];
      pos.z = te[14];
      var sx = Math.sqrt(te[0] * te[0] + te[1] * te[1] + te[2] * te[2]);
      var sy = Math.sqrt(te[4] * te[4] + te[5] * te[5] + te[6] * te[6]);
      var sz = Math.sqrt(te[8] * te[8] + te[9] * te[9] + te[10] * te[10]);

      if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) ; else {
        // if determine is negative, we need to invert one scale
        var det = t.determinant();
        if (det < 0) sx = -sx; // scale the rotation part

        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        te[0] *= invSX;
        te[1] *= invSX;
        te[2] *= invSX;
        te[4] *= invSY;
        te[5] *= invSY;
        te[6] *= invSY;
        te[8] *= invSZ;
        te[9] *= invSZ;
        te[10] *= invSZ;
      }

      var m3 = Matrix._tempMat30;
      m3.setValueByMatrix(t);
      Quaternion.rotationMatrix3x3(m3, q);
      s.x = sx;
      s.y = sy;
      s.z = sz;
    }
    /**
     * 从矩阵中返回表示旋转的四元数。
     * @param a - 转换矩阵
     * @param out - 表示旋转的四元数
     * @returns 当前矩阵的旋转四元数
     */

  }, {
    key: "getRotation",
    value: function getRotation(out) {
      var e = this.elements;
      var trace = e[0] + e[5] + e[10];
      var S = 0;

      if (trace > MathUtil.zeroTolerance) {
        S = Math.sqrt(trace + 1.0) * 2;
        out.w = 0.25 * S;
        out.x = (e[6] - e[9]) / S;
        out.y = (e[8] - e[2]) / S;
        out.z = (e[1] - e[4]) / S;
      } else if (e[0] > e[5] && e[0] > e[10]) {
        S = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;
        out.w = (e[6] - e[9]) / S;
        out.x = 0.25 * S;
        out.y = (e[1] + e[4]) / S;
        out.z = (e[8] + e[2]) / S;
      } else if (e[5] > e[10]) {
        S = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;
        out.w = (e[8] - e[2]) / S;
        out.x = (e[1] + e[4]) / S;
        out.y = 0.25 * S;
        out.z = (e[6] + e[9]) / S;
      } else {
        S = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;
        out.w = (e[1] - e[4]) / S;
        out.x = (e[8] + e[2]) / S;
        out.y = (e[6] + e[9]) / S;
        out.z = 0.25 * S;
      }

      return out;
    }
    /**
     * 从矩阵中返回缩放向量。
     * @param out - 缩放向量
     * @returns 当前矩阵的缩放向量
     */

  }, {
    key: "getScaling",
    value: function getScaling(out) {
      //getScale()
      var e = this.elements;
      var m11 = e[0],
          m12 = e[1],
          m13 = e[2];
      var m21 = e[4],
          m22 = e[5],
          m23 = e[6];
      var m31 = e[8],
          m32 = e[9],
          m33 = e[10];
      out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
      out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
      out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
      return out;
    }
    /**
     * 从矩阵中返回转换向量。
     * @param out - 转换向量
     * @returns 当前矩阵的转换向量
     */

  }, {
    key: "getTranslation",
    value: function getTranslation(out) {
      var e = this.elements;
      out.x = e[12];
      out.y = e[13];
      out.z = e[14];
      return out;
    }
    /**
     * 将矩阵设置为单位矩阵。
     * @returns 当前矩阵
     */

  }, {
    key: "identity",
    value: function identity() {
      var e = this.elements;
      e[0] = 1;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 0;
      e[5] = 1;
      e[6] = 0;
      e[7] = 0;
      e[8] = 0;
      e[9] = 0;
      e[10] = 1;
      e[11] = 0;
      e[12] = 0;
      e[13] = 0;
      e[14] = 0;
      e[15] = 1;
      return this;
    }
    /**
     * 计算当前矩阵的逆矩阵，并返回。
     * @returns 当前矩阵
     */

  }, {
    key: "invert",
    value: function invert() {
      Matrix.invert(this, this);
      return this;
    }
    /**
     * 将当前矩阵按给定角度旋转，并返回。
     * @param axis - 旋转轴
     * @param r - 给定的旋转角度
     * @returns 当前矩阵
     */

  }, {
    key: "rotateAxisAngle",
    value: function rotateAxisAngle(axis, r) {
      Matrix.rotateAxisAngle(this, axis, r, this);
      return this;
    }
    /**
     * 将当前矩阵按给定向量 v 缩放，并返回。
     * @param s
     * @returns 当前矩阵
     */

  }, {
    key: "scale",
    value: function scale(s) {
      Matrix.scale(this, s, this);
      return this;
    }
    /**
     * 将当前矩阵按给定向量 v 转换，并返回。
     * @param v - 转换向量
     * @returns 当前矩阵
     */

  }, {
    key: "translate",
    value: function translate(v) {
      Matrix.translate(this, v, this);
      return this;
    }
    /**
     * 计算当前矩阵的转置矩阵，并返回。
     * @returns 当前矩阵
     */

  }, {
    key: "transpose",
    value: function transpose() {
      Matrix.transpose(this, this);
      return this;
    }
  }]);

  return Matrix;
}();
Matrix._tempVec30 = new Vector3();
Matrix._tempVec31 = new Vector3();
Matrix._tempVec32 = new Vector3();
Matrix._tempMat30 = new Matrix3x3();
Matrix._tempMat40 = new Matrix();
Matrix._identity = new Matrix(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);

/**
 * 二维向量。
 */

var Vector2 = /*#__PURE__*/function () {
  _createClass(Vector2, null, [{
    key: "add",

    /** @internal 零向量。*/

    /** @internal 一向量。*/

    /**
     * 将两个向量相加并输出结果至 out。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 向量相加结果
     */
    value: function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
    }
    /**
     * 将两个向量相减并输出结果至 out。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个二维向量的相减结果
     */

  }, {
    key: "subtract",
    value: function subtract(left, right, out) {
      out.x = left.x - right.x;
      out.y = left.y - right.y;
    }
    /**
     * 将两个向量相乘并输出结果至 out。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个二维向量的相乘结果
     */

  }, {
    key: "multiply",
    value: function multiply(left, right, out) {
      out.x = left.x * right.x;
      out.y = left.y * right.y;
    }
    /**
     * 将两个二维向量相除并输出结果至 out。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个二维向量的相除结果
     */

  }, {
    key: "divide",
    value: function divide(left, right, out) {
      out.x = left.x / right.x;
      out.y = left.y / right.y;
    }
    /**
     * 计算两个二维向量的点积。
     * @param left - 左向量
     * @param right - 右向量
     * @returns 两个向量的点积
     */

  }, {
    key: "dot",
    value: function dot(left, right) {
      return left.x * right.x + left.y * right.y;
    }
    /**
     * 计算两个二维向量的距离。
     * @param left - 向量
     * @param right - 向量
     * @returns 两个向量的距离
     */

  }, {
    key: "distance",
    value: function distance(left, right) {
      var x = right.x - left.x;
      var y = right.y - left.y;
      return Math.sqrt(x * x + y * y);
    }
    /**
     * 计算两个二维向量的距离的平方。
     * @param left - 向量
     * @param right - 向量
     * @returns 两个向量的距离的平方
     */

  }, {
    key: "distanceSquared",
    value: function distanceSquared(left, right) {
      var x = right.x - left.x;
      var y = right.y - left.y;
      return x * x + y * y;
    }
    /**
     * 判断两个二维向量的值是否相等。
     * @param left - 向量
     * @param right - 向量
     * @returns 两个向量是否相等，是返回 true，否则返回 false
     */

  }, {
    key: "equals",
    value: function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);
    }
    /**
     * 插值二维向量。
     * @param left - 左向量
     * @param right - 右向量
     * @param t - 插值比例
     * @param out - 插值结果
     */

  }, {
    key: "lerp",
    value: function lerp(left, right, t, out) {
      var x = left.x,
          y = left.y;
      out.x = x + (right.x - x) * t;
      out.y = y + (right.y - y) * t;
    }
    /**
     * 分别取两个二维向量 x、y 的最大值计算新的二维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */

  }, {
    key: "max",
    value: function max(left, right, out) {
      out.x = Math.max(left.x, right.x);
      out.y = Math.max(left.y, right.y);
    }
    /**
     * 分别取两个二维向量 x、y 的最小值计算新的二维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */

  }, {
    key: "min",
    value: function min(left, right, out) {
      out.x = Math.min(left.x, right.x);
      out.y = Math.min(left.y, right.y);
    }
    /**
     * 将向量 left 反转的结果输出到 out。
     * @param left - 向量
     * @param out - 向量反转的结果
     */

  }, {
    key: "negate",
    value: function negate(left, out) {
      out.x = -left.x;
      out.y = -left.y;
    }
    /**
     * 将向量 left 归一化的结果输出到 out。
     * @param left - 向量
     * @param out - 向量归一化的结果
     */

  }, {
    key: "normalize",
    value: function normalize(left, out) {
      var x = left.x,
          y = left.y;
      var len = Math.sqrt(x * x + y * y);

      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
      }
    }
    /**
     * 将向量 left 缩放的结果输出到 out。
     * @param left - 向量
     * @param scale - 缩放因子
     * @param out - 向量缩放的结果
     */

  }, {
    key: "scale",
    value: function scale(left, s, out) {
      out.x = left.x * s;
      out.y = left.y * s;
    }
    /** 向量的 X 分量。 */

  }]);

  /**
   * 创建一个 Vector2 实例。
   * @param x - 向量的 X 分量，默认值 0
   * @param y - 向量的 Y 分量，默认值 0
   */
  function Vector2() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Vector2);

    this.x = void 0;
    this.y = void 0;
    this.x = x;
    this.y = y;
  }
  /**
   * 设置 x, y 的值，并返回当前向量。
   * @param x - 向量的 X 分量
   * @param y - 向量的 Y 分量
   * @returns 当前向量
   */


  _createClass(Vector2, [{
    key: "setValue",
    value: function setValue(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    /**
     * 通过数组设置值，并返回当前向量。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前向量
     */

  }, {
    key: "setValueByArray",
    value: function setValueByArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    /**
     * 将当前向量加上给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "add",
    value: function add(right) {
      this.x += right.x;
      this.y += right.y;
      return this;
    }
    /**
     * 将当前向量减去给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "subtract",
    value: function subtract(right) {
      this.x -= right.x;
      this.y -= right.y;
      return this;
    }
    /**
     * 将当前向量乘以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "multiply",
    value: function multiply(right) {
      this.x *= right.x;
      this.y *= right.y;
      return this;
    }
    /**
     * 将当前向量除以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "divide",
    value: function divide(right) {
      this.x /= right.x;
      this.y /= right.y;
      return this;
    }
    /**
     * 计算一个二维向量的标量长度。
     * @returns 当前向量的标量长度
     */

  }, {
    key: "length",
    value: function length() {
      var x = this.x,
          y = this.y;
      return Math.sqrt(x * x + y * y);
    }
    /**
     * 计算一个二维向量的标量长度的平方。
     * @returns 当前向量的标量长度的平方
     */

  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var x = this.x,
          y = this.y;
      return x * x + y * y;
    }
    /**
     * 向量反转。
     * @returns 当前向量
     */

  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    /**
     * 当前向量归一化，并返回。
     * @returns 当前向量
     */

  }, {
    key: "normalize",
    value: function normalize() {
      Vector2.normalize(this, this);
      return this;
    }
    /**
     * 向量缩放。
     * @param s - 缩放因子
     * @returns 当前向量
     */

  }, {
    key: "scale",
    value: function scale(s) {
      this.x *= s;
      this.y *= s;
      return this;
    }
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */

  }, {
    key: "toArray",
    value: function toArray(out) {
      var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
    }
    /**
     * 克隆并返回一个新的二维向量对象。
     * @returns 新的二维向量对象
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Vector2(this.x, this.y);
    }
    /**
     * 将当前向量值拷贝给目标向量。
     * @param out - 目标向量
     */

  }, {
    key: "cloneTo",
    value: function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      return out;
    }
  }]);

  return Vector2;
}();
Vector2._zero = new Vector2(0.0, 0.0);
Vector2._one = new Vector2(1.0, 1.0);

/**
 * 四维向量。
 */
var Vector4 = /*#__PURE__*/function () {
  _createClass(Vector4, null, [{
    key: "add",

    /** @internal 零向量。*/

    /** @internal 一向量。*/

    /**
     * 将两个向量相加。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 向量相加结果
     */
    value: function add(left, right, out) {
      out.x = left.x + right.x;
      out.y = left.y + right.y;
      out.z = left.z + right.z;
      out.w = left.w + right.w;
    }
    /**
     * 将两个向量相减。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个四维向量的相减结果
     */

  }, {
    key: "subtract",
    value: function subtract(left, right, out) {
      out.x = left.x - right.x;
      out.y = left.y - right.y;
      out.z = left.z - right.z;
      out.w = left.w - right.w;
    }
    /**
     * 将两个向量相乘。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个四维向量的相乘结果
     */

  }, {
    key: "multiply",
    value: function multiply(left, right, out) {
      out.x = left.x * right.x;
      out.y = left.y * right.y;
      out.z = left.z * right.z;
      out.w = left.w * right.w;
    }
    /**
     * 将两个四维向量相除。
     * @param left - 左向量
     * @param right - 右向量
     * @param out - 两个四维向量的相除结果
     */

  }, {
    key: "divide",
    value: function divide(left, right, out) {
      out.x = left.x / right.x;
      out.y = left.y / right.y;
      out.z = left.z / right.z;
      out.w = left.w / right.w;
    }
    /**
     * 计算两个四维向量的点积。
     * @param left - 左向量
     * @param right - 右向量
     * @returns 两个向量的点积
     */

  }, {
    key: "dot",
    value: function dot(left, right) {
      return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    }
    /**
     * 计算两个四维向量的距离。
     * @param a - 向量
     * @param b - 向量
     * @returns 两个向量的距离
     */

  }, {
    key: "distance",
    value: function distance(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      var w = b.w - a.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * 计算两个四维向量的距离的平方。
     * @param a - 向量
     * @param b - 向量
     * @returns 两个向量的距离的平方
     */

  }, {
    key: "distanceSquared",
    value: function distanceSquared(a, b) {
      var x = b.x - a.x;
      var y = b.y - a.y;
      var z = b.z - a.z;
      var w = b.w - a.w;
      return x * x + y * y + z * z + w * w;
    }
    /**
     * 判断两个四维向量的值是否相等。
     * @param left - 向量
     * @param right - 向量
     * @returns 两个向量是否相等，是返回 true，否则返回 false
     */

  }, {
    key: "equals",
    value: function equals(left, right) {
      return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
    }
    /**
     * 插值四维向量。
     * @param start - 左向量
     * @param end - 右向量
     * @param t - 插值比例
     * @param out - 插值结果
     */

  }, {
    key: "lerp",
    value: function lerp(start, end, t, out) {
      var x = start.x,
          y = start.y,
          z = start.z,
          w = start.w;
      out.x = x + (end.x - x) * t;
      out.y = y + (end.y - y) * t;
      out.z = z + (end.z - z) * t;
      out.w = w + (end.w - w) * t;
    }
    /**
     * 分别取两个四维向量 x、y 的最大值计算新的四维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */

  }, {
    key: "max",
    value: function max(left, right, out) {
      out.x = Math.max(left.x, right.x);
      out.y = Math.max(left.y, right.y);
      out.z = Math.max(left.z, right.z);
      out.w = Math.max(left.w, right.w);
    }
    /**
     * 分别取两个四维向量 x、y 的最小值计算新的四维向量。
     * @param left - 向量
     * @param right - 向量
     * @param out - 结果向量
     */

  }, {
    key: "min",
    value: function min(left, right, out) {
      out.x = Math.min(left.x, right.x);
      out.y = Math.min(left.y, right.y);
      out.z = Math.min(left.z, right.z);
      out.w = Math.min(left.w, right.w);
    }
    /**
     * 将向量 a 反转的结果输出到 out。
     * @param a - 向量
     * @param out - 向量反转的结果
     */

  }, {
    key: "negate",
    value: function negate(a, out) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      out.w = -a.w;
    }
    /**
     * 将向量 a 归一化的结果输出到 out。
     * @param a - 向量
     * @param out - 向量归一化的结果
     */

  }, {
    key: "normalize",
    value: function normalize(a, out) {
      var x = a.x,
          y = a.y,
          z = a.z,
          w = a.w;
      var len = Math.sqrt(x * x + y * y + z * z + w * w);

      if (len > MathUtil.zeroTolerance) {
        len = 1 / len;
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
        out.w = w * len;
      }
    }
    /**
     * 将向量 a 缩放的结果输出到 out。
     * @param a - 向量
     * @param s - 缩放因子
     * @param out - 向量缩放的结果
     */

  }, {
    key: "scale",
    value: function scale(a, s, out) {
      out.x = a.x * s;
      out.y = a.y * s;
      out.z = a.z * s;
      out.w = a.w * s;
    }
    /**
     * 通过4x4矩阵将一个四维向量转换到另一个四维向量。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transform",
    value: function transform(v, m, out) {
      var x = v.x,
          y = v.y,
          z = v.z,
          w = v.w;
      var e = m.elements;
      out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];
      out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];
      out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];
      out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];
    }
    /**
     * 通过四元数将一个四维向量转换到另一个四维向量。
     * @param v - 向量
     * @param m - 转换矩阵
     * @param out - 通过矩阵转换后的向量
     */

  }, {
    key: "transformByQuat",
    value: function transformByQuat(v, q, out) {
      var x = v.x,
          y = v.y,
          z = v.z,
          w = v.w;
      var qx = q.x;
      var qy = q.y;
      var qz = q.z;
      var qw = q.w; // calculate quat * vec

      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

      out.x = ix * qw - iw * qx - iy * qz + iz * qy;
      out.y = iy * qw - iw * qy - iz * qx + ix * qz;
      out.z = iz * qw - iw * qz - ix * qy + iy * qx;
      out.w = w;
    }
    /** 向量的 X 分量。 */

  }]);

  /**
   * 创建一个 Vector4 实例。
   * @param x - 向量的 X 分量，默认值 0
   * @param y - 向量的 Y 分量，默认值 0
   * @param z - 向量的 Z 分量，默认值 0
   * @param w - 向量的 W 分量，默认值 0
   */
  function Vector4() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Vector4);

    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * 设置 x, y, z, w 的值，并返回当前向量。
   * @param x - 向量的 X 分量
   * @param y - 向量的 Y 分量
   * @param z - 向量的 Z 分量
   * @param w - 向量的 W 分量
   * @returns 当前向量
   */


  _createClass(Vector4, [{
    key: "setValue",
    value: function setValue(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    /**
     * 通过数组设置值，并返回当前向量。
     * @param array - 数组
     * @param offset - 数组偏移
     * @returns 当前向量
     */

  }, {
    key: "setValueByArray",
    value: function setValueByArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    /**
     * 将当前向量加上给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "add",
    value: function add(right) {
      this.x += right.x;
      this.y += right.y;
      this.z += right.z;
      this.w += right.w;
      return this;
    }
    /**
     * 将当前向量减去给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "subtract",
    value: function subtract(right) {
      this.x -= right.x;
      this.y -= right.y;
      this.z -= right.z;
      this.w -= right.w;
      return this;
    }
    /**
     * 将当前向量乘以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "multiply",
    value: function multiply(right) {
      this.x *= right.x;
      this.y *= right.y;
      this.z *= right.z;
      this.w *= right.w;
      return this;
    }
    /**
     * 将当前向量除以给定的向量 right，并返回当前向量。
     * @param right - 给定的向量
     * @returns 当前向量
     */

  }, {
    key: "divide",
    value: function divide(right) {
      this.x /= right.x;
      this.y /= right.y;
      this.z /= right.z;
      this.w /= right.w;
      return this;
    }
    /**
     * 计算一个四维向量的标量长度。
     * @returns 当前向量的标量长度
     */

  }, {
    key: "length",
    value: function length() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * 计算一个四维向量的标量长度的平方。
     * @returns 当前向量的标量长度的平方
     */

  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      return x * x + y * y + z * z + w * w;
    }
    /**
     * 向量反转。
     * @returns 当前向量
     */

  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    /**
     * 向量归一化。
     * @returns 当前向量
     */

  }, {
    key: "normalize",
    value: function normalize() {
      Vector4.normalize(this, this);
      return this;
    }
    /**
     * 向量缩放。
     * @param s - 缩放因子
     * @returns 当前向量
     */

  }, {
    key: "scale",
    value: function scale(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      this.w *= s;
      return this;
    }
    /**
     * 拷贝到数组。
     * @param out - 数组。
     * @param outOffset - 数组偏移。
     */

  }, {
    key: "toArray",
    value: function toArray(out) {
      var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      out[outOffset] = this.x;
      out[outOffset + 1] = this.y;
      out[outOffset + 2] = this.z;
      out[outOffset + 3] = this.w;
    }
    /**
     * 创建一个新的四维向量，并用当前向量值初始化。
     * @returns 一个新的向量，并且拷贝当前向量的值
     */

  }, {
    key: "clone",
    value: function clone() {
      var ret = new Vector4(this.x, this.y, this.z, this.w);
      return ret;
    }
    /**
     * 将当前向量值拷贝给 out 向量。
     * @param out - 目标向量
     */

  }, {
    key: "cloneTo",
    value: function cloneTo(out) {
      out.x = this.x;
      out.y = this.y;
      out.z = this.z;
      out.w = this.w;
      return out;
    }
  }]);

  return Vector4;
}();
Vector4._zero = new Vector4(0.0, 0.0, 0.0, 0.0);
Vector4._one = new Vector4(1.0, 1.0, 1.0, 1.0);

// 防止万向锁
var ESP = MathUtil.zeroTolerance; // 球面坐标

var Spherical = /*#__PURE__*/function () {
  function Spherical(radius, phi, theta) {
    _classCallCheck(this, Spherical);

    this.radius = void 0;
    this.phi = void 0;
    this.theta = void 0;
    this.radius = radius !== undefined ? radius : 1.0;
    this.phi = phi !== undefined ? phi : 0;
    this.theta = theta !== undefined ? theta : 0;
  }

  _createClass(Spherical, [{
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      this.phi = MathUtil.clamp(this.phi, ESP, Math.PI - ESP);
      return this;
    }
  }, {
    key: "setFromVec3",
    value: function setFromVec3(v3) {
      this.radius = v3.length();

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(v3.x, v3.z);
        this.phi = Math.acos(MathUtil.clamp(v3.y / this.radius, -1, 1));
      }

      return this;
    }
  }, {
    key: "setToVec3",
    value: function setToVec3(v3) {
      var sinPhiRadius = Math.sin(this.phi) * this.radius;
      v3.x = sinPhiRadius * Math.sin(this.theta);
      v3.y = Math.cos(this.phi) * this.radius;
      v3.z = sinPhiRadius * Math.cos(this.theta);
      return this;
    }
  }]);

  return Spherical;
}();

exports.MathUtil = MathUtil;
exports.Matrix = Matrix;
exports.Matrix3x3 = Matrix3x3;
exports.Quaternion = Quaternion;
exports.Spherical = Spherical;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
//# sourceMappingURL=main.js.map
