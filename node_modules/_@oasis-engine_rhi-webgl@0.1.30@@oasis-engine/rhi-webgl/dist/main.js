'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var o3Core = require('@alipay/o3-core');
var o3Math = require('@alipay/o3-math');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

/**
 * 引擎的资源对象所需要的 GL 资源对象的 Cache 管理
 * @private
 */
var GLAssetsCache = /*#__PURE__*/function () {
  function GLAssetsCache(rhi) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, GLAssetsCache);

    this._rhi = void 0;
    this._objectSet = void 0;
    this._checkList = void 0;
    this._nextID = void 0;
    this._enableCollect = void 0;
    this._rhi = rhi;
    this._objectSet = {}; // 所有资源对象的集合

    this._checkList = []; // 需要检测生命周期的对象列表

    this._nextID = 1; // 是否启用回收机制

    this._enableCollect = props.enableCollect === undefined ? true : !!props.enableCollect;
  }
  /**
   * 为一个引擎资源对象创建对应的 GL 资源对象
   * @param {object} asset
   * @param {class} ctor
   */


  _createClass(GLAssetsCache, [{
    key: "requireObject",
    value: function requireObject(asset, ctor) {
      var cachedObject = null; //-- 查找已有

      if (asset.cacheID) {
        cachedObject = this._objectSet[asset.cacheID];
      }

      if (!cachedObject || asset.needRecreate) {
        var cacheID = this._nextID++;
        var objectSet = this._objectSet; //-- 创新新的

        cachedObject = new ctor(this._rhi, asset);
        objectSet[cacheID] = cachedObject;
        cachedObject.cacheID = cacheID;
        cachedObject.asset = asset;
        asset.cacheID = cacheID;
        asset.needRecreate = false; //-- 处理运行时资源释放

        if (this._enableCollect && asset.type === o3Core.InternalAssetType.Cache) {
          this._checkList.push(cachedObject);
        }
      }

      cachedObject.activeFrame = this._rhi.frameCount;
      asset.glAsset = cachedObject;
      return cachedObject;
    }
    /**
     * 清除 Cache 中没有用到的 GL 资源对象
     */

  }, {
    key: "compact",
    value: function compact() {
      if (!this._enableCollect) return;
      var currentFrame = this._rhi.frameCount;
      var checkList = this._checkList;
      var objectSet = this._objectSet;

      for (var i = checkList.length - 1; i >= 0; i--) {
        var cachedObject = checkList[i];

        if (cachedObject.activeFrame < currentFrame) {
          delete objectSet[cachedObject.cacheID];
          checkList.splice(i, 1);
          cachedObject.finalize();
        }
      }
    }
    /**
     * 释放内部登记的所有对象
     */

  }, {
    key: "finalize",
    value: function finalize() {
      for (var name in this._objectSet) {
        var obj = this._objectSet[name];
        obj.finalize(true);
      }

      this._objectSet = {};
      this._checkList = [];
    }
  }]);

  return GLAssetsCache;
}();

/**
 * GL 能力统一管理
 * */
var GLCapability = /*#__PURE__*/function () {
  _createClass(GLCapability, [{
    key: "maxDrawBuffers",
    get: function get() {
      if (!this._maxDrawBuffers) {
        if (this.canIUse(o3Core.GLCapabilityType.drawBuffers)) {
          this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
        } else {
          this._maxDrawBuffers = 1;
        }
      }

      return this._maxDrawBuffers;
    }
    /**
     * 最大各向异性过滤等级。
     */

  }, {
    key: "maxAnisoLevel",
    get: function get() {
      if (!this._maxAnisoLevel) {
        var ext = this._rhi.requireExtension(o3Core.GLCapabilityType.textureFilterAnisotropic);

        this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
      }

      return this._maxAnisoLevel;
    }
    /**
     * 最大 MSAA 采样数量
     */

  }, {
    key: "maxAntiAliasing",
    get: function get() {
      if (!this._maxAntiAliasing) {
        var gl = this._rhi.gl;
        var canMSAA = this.canIUse(o3Core.GLCapabilityType.multipleSample);
        this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
      }

      return this._maxAntiAliasing;
    }
  }, {
    key: "rhi",
    get: function get() {
      return this._rhi;
    }
  }]);

  function GLCapability(rhi) {
    _classCallCheck(this, GLCapability);

    this._maxDrawBuffers = void 0;
    this._maxAnisoLevel = void 0;
    this._maxAntiAliasing = void 0;
    this._rhi = void 0;
    this.capabilityList = void 0;
    this._rhi = rhi;
    this.capabilityList = new Map();
    this.init(); // 抹平接口差异

    this.compatibleAllInterface();
  }
  /**
   * 查询能否使用某些 GL 能力
   * */


  _createClass(GLCapability, [{
    key: "canIUse",
    value: function canIUse(capabilityType) {
      return this.capabilityList.get(capabilityType);
    }
    /**
     * 查询能否使用某种压缩纹理格式
     * */

  }, {
    key: "canIUseCompressedTextureInternalFormat",
    value: function canIUseCompressedTextureInternalFormat(internalType) {
      var RGBA_ASTC_4X4_KHR = o3Core.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          RGBA_ASTC_12X12_KHR = o3Core.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          SRGB8_ALPHA8_ASTC_4X4_KHR = o3Core.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR,
          SRGB8_ALPHA8_ASTC_12X12_KHR = o3Core.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR,
          RGB_ETC1_WEBGL = o3Core.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          R11_EAC = o3Core.GLCompressedTextureInternalFormat.R11_EAC,
          SRGB8_ALPHA8_ETC2_EAC = o3Core.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC,
          RGB_PVRTC_4BPPV1_IMG = o3Core.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          RGBA_PVRTC_2BPPV1_IMG = o3Core.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          RGB_S3TC_DXT1_EXT = o3Core.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          RGBA_S3TC_DXT5_EXT = o3Core.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;

      if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
        return this.canIUse(o3Core.GLCapabilityType.astc);
      } else if (internalType === RGB_ETC1_WEBGL) {
        return this.canIUse(o3Core.GLCapabilityType.etc1);
      } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
        return this.canIUse(o3Core.GLCapabilityType.etc);
      } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
        return this.canIUse(o3Core.GLCapabilityType.pvrtc);
      } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
        return this.canIUse(o3Core.GLCapabilityType.s3tc);
      }

      return false;
    }
    /** 是否能使用更多骨骼关节 */

  }, {
    key: "init",

    /**
     *  初始化能力
     * */
    value: function init() {
      var cap = this.capabilityList;
      var isWebGL2 = this.rhi.isWebGL2;
      var requireExtension = this.rhi.requireExtension.bind(this.rhi);
      var standardDerivatives = o3Core.GLCapabilityType.standardDerivatives,
          shaderTextureLod = o3Core.GLCapabilityType.shaderTextureLod,
          elementIndexUint = o3Core.GLCapabilityType.elementIndexUint,
          depthTexture = o3Core.GLCapabilityType.depthTexture,
          vertexArrayObject = o3Core.GLCapabilityType.vertexArrayObject,
          instancedArrays = o3Core.GLCapabilityType.instancedArrays,
          multipleSample = o3Core.GLCapabilityType.multipleSample,
          drawBuffers = o3Core.GLCapabilityType.drawBuffers,
          astc = o3Core.GLCapabilityType.astc,
          astc_webkit = o3Core.GLCapabilityType.astc_webkit,
          etc = o3Core.GLCapabilityType.etc,
          etc_webkit = o3Core.GLCapabilityType.etc_webkit,
          etc1 = o3Core.GLCapabilityType.etc1,
          etc1_webkit = o3Core.GLCapabilityType.etc1_webkit,
          pvrtc = o3Core.GLCapabilityType.pvrtc,
          pvrtc_webkit = o3Core.GLCapabilityType.pvrtc_webkit,
          s3tc = o3Core.GLCapabilityType.s3tc,
          s3tc_webkit = o3Core.GLCapabilityType.s3tc_webkit,
          textureFloat = o3Core.GLCapabilityType.textureFloat,
          textureHalfFloat = o3Core.GLCapabilityType.textureHalfFloat,
          textureFloatLinear = o3Core.GLCapabilityType.textureFloatLinear,
          textureHalfFloatLinear = o3Core.GLCapabilityType.textureHalfFloatLinear,
          WEBGL_colorBufferFloat = o3Core.GLCapabilityType.WEBGL_colorBufferFloat,
          colorBufferFloat = o3Core.GLCapabilityType.colorBufferFloat,
          colorBufferHalfFloat = o3Core.GLCapabilityType.colorBufferHalfFloat,
          textureFilterAnisotropic = o3Core.GLCapabilityType.textureFilterAnisotropic;
      cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
      cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
      cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
      cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
      cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
      cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
      cap.set(multipleSample, isWebGL2);
      cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
      cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
      cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
      cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
      cap.set(textureHalfFloatLinear, !!requireExtension(textureHalfFloatLinear));
      cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
      cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
      cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
      cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
      cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
      cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
      cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
      cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
    }
    /**
     * 如果有插件能补充该能力，则抹平该差异
     * @example
     * compatible(GLCapabilityType.depthTexture,{
     *    UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
     * })
     * 满足条件时， gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL
     * */

  }, {
    key: "compatibleInterface",
    value: function compatibleInterface(capabilityType, flatItem) {
      var rhi = this.rhi;
      var gl = rhi.gl;
      var ext = null;
      /** 如果有插件能补充该能力，则抹平该差异 */

      if (ext = rhi.requireExtension(capabilityType)) {
        for (var _glKey in flatItem) {
          var _extensionKey = flatItem[_glKey];
          var extensionVal = ext[_extensionKey];

          if (extensionVal instanceof Function) {
            gl[_glKey] = extensionVal.bind(ext);
          } else {
            gl[_glKey] = extensionVal;
          }
        }
      }
    }
    /** 抹平接口差异 */

  }, {
    key: "compatibleAllInterface",
    value: function compatibleAllInterface() {
      // 需要兼容的能力
      var depthTexture = o3Core.GLCapabilityType.depthTexture,
          vertexArrayObject = o3Core.GLCapabilityType.vertexArrayObject,
          instancedArrays = o3Core.GLCapabilityType.instancedArrays,
          drawBuffers = o3Core.GLCapabilityType.drawBuffers,
          textureFilterAnisotropic = o3Core.GLCapabilityType.textureFilterAnisotropic,
          textureHalfFloat = o3Core.GLCapabilityType.textureHalfFloat,
          colorBufferHalfFloat = o3Core.GLCapabilityType.colorBufferHalfFloat,
          WEBGL_colorBufferFloat = o3Core.GLCapabilityType.WEBGL_colorBufferFloat;
      var isWebGL2 = this.rhi.isWebGL2; //  以下能力 WebGL2.0 必有，不需要插件

      if (!isWebGL2) {
        this.compatibleInterface(depthTexture, {
          UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
        });
        this.compatibleInterface(vertexArrayObject, {
          createVertexArray: "createVertexArrayOES",
          deleteVertexArray: "deleteVertexArrayOES",
          isVertexArray: "isVertexArrayOES",
          bindVertexArray: "bindVertexArrayOES"
        });
        this.compatibleInterface(instancedArrays, {
          drawArraysInstanced: "drawArraysInstancedANGLE",
          drawElementsInstanced: "drawElementsInstancedANGLE",
          vertexAttribDivisor: "vertexAttribDivisorANGLE"
        });
        this.compatibleInterface(drawBuffers, {
          MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
        });
        var items = {};

        if (this.canIUse(o3Core.GLCapabilityType.drawBuffers)) {
          for (var i = 0; i < this.rhi.requireExtension(drawBuffers).MAX_DRAW_BUFFERS_WEBGL; i++) {
            i != 0 && (items["COLOR_ATTACHMENT".concat(i)] = "COLOR_ATTACHMENT".concat(i, "_WEBGL"));
            items["DRAW_BUFFER0".concat(i)] = "DRAW_BUFFER".concat(i, "_WEBGL");
          }

          this.compatibleInterface(drawBuffers, _objectSpread2({
            drawBuffers: "drawBuffersWEBGL"
          }, items));
        }

        this.compatibleInterface(textureHalfFloat, {
          HAFL_FLOAT: "HALF_FLOAT_OES"
        });
        this.compatibleInterface(colorBufferHalfFloat, {
          RGBA16F: "RBGA16F_EXT"
        });
        this.compatibleInterface(WEBGL_colorBufferFloat, {
          RGBA32F: "RBGA32F_EXT"
        });
      } // 以下能力依赖插件，不依赖 WebGL 环境


      this.compatibleInterface(textureFilterAnisotropic, {
        TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
      });
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get() {
      return this.canIUse(o3Core.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    }
  }]);

  return GLCapability;
}();

/**
 * GLContext 扩展管理
 * @private
 */
var GLExtensions = /*#__PURE__*/function () {
  function GLExtensions(rhi) {
    _classCallCheck(this, GLExtensions);

    this.rhi = void 0;
    this._requireResult = void 0;
    this.rhi = rhi;
    this._requireResult = {};
  }
  /**
   * 请求扩展
   * @param {String} ext 扩展名
   * @returns {Object|null} 请求结果，返回插件对象或null
   * @private
   */


  _createClass(GLExtensions, [{
    key: "requireExtension",
    value: function requireExtension(ext) {
      if (this._requireResult[ext] !== undefined) {
        return this._requireResult[ext];
      }

      this._requireResult[ext] = this.rhi.gl.getExtension(ext);
      return this._requireResult[ext];
    }
  }]);

  return GLExtensions;
}();

/**
 * GL 资源对象，通过 GLAssetsCache 管理
 * */
var GLAsset = /*#__PURE__*/function () {
  /** @member {AssetObject} -  引擎 js 部分的资源对象 */

  /**
   * @param {WebGLRenderer} rhi - GPU 硬件抽象层的 WebGL
   * @param {AssetObject} asset - 引擎 js 部分的资源对象
   * */
  function GLAsset(rhi, asset) {
    _classCallCheck(this, GLAsset);

    this._rhi = void 0;
    this.asset = void 0;
    this.activeFrame = void 0;
    this.cacheID = void 0;
    this._rhi = rhi;
    this.asset = asset;
  }

  _createClass(GLAsset, [{
    key: "rhi",
    get: function get() {
      return this._rhi;
    }
    /**
     * 释放 GL 资源
     * @param {boolean} force - 强制释放
     */

  }]);

  return GLAsset;
}();

/**
 * Primtive 相关的 GL 资源管理，主要是 WebGLBuffer 对象
 * @private
 */
var GLPrimitive = /*#__PURE__*/function (_GLAsset) {
  _inherits(GLPrimitive, _GLAsset);

  var _super = _createSuper(GLPrimitive);

  function GLPrimitive(rhi, primitive) {
    var _this;

    _classCallCheck(this, GLPrimitive);

    _this = _super.call(this, rhi, primitive);
    _this._primitive = void 0;
    _this.attribLocArray = void 0;
    _this.canUseInstancedArrays = void 0;
    _this._primitive = primitive;
    _this.canUseInstancedArrays = _this.rhi.canIUse(o3Core.GLCapabilityType.instancedArrays);
    return _this;
  }
  /**
   * 绑定 Buffer 和 attribute
   */


  _createClass(GLPrimitive, [{
    key: "bindBufferAndAttrib",
    value: function bindBufferAndAttrib(tech) {
      var gl = this.rhi.gl;
      var primitive = this._primitive;
      var vertexBufferBindings = primitive.vertexBufferBindings;
      this.attribLocArray = [];
      var techAttributes = tech.attributes;
      var attributes = primitive.attributes;
      var vbo;
      var lastBoundVbo;

      for (var name in techAttributes) {
        var loc = techAttributes[name].location;
        if (loc === -1) continue;
        var semantic = techAttributes[name].semantic;
        var element = attributes[semantic];

        if (element) {
          var _vertexBufferBindings = vertexBufferBindings[element.vertexBufferIndex],
              buffer = _vertexBufferBindings.buffer,
              stride = _vertexBufferBindings.stride;
          vbo = buffer._nativeBuffer; // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.

          if (lastBoundVbo !== vbo) {
            lastBoundVbo = vbo;
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          }

          gl.enableVertexAttribArray(loc);
          var _element$_glElementIn = element._glElementInfo,
              size = _element$_glElementIn.size,
              type = _element$_glElementIn.type;
          gl.vertexAttribPointer(loc, size, type, element.normalized, stride, element.offset);

          if (this.canUseInstancedArrays) {
            gl.vertexAttribDivisor(loc, element.instanceDivisor);
          }

          this.attribLocArray.push(loc);
        } else {
          o3Core.Logger.warn("vertex attribute not found: " + name);
        }
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    /**
     * 执行绘制操作。
     */

  }, {
    key: "draw",
    value: function draw(tech) {
      var gl = this.rhi.gl;
      var primitive = this._primitive; // 绑定 Buffer 和 attribute

      this.bindBufferAndAttrib(tech); // draw

      var primitiveTopology = primitive.primitiveTopology,
          indexBufferBinding = primitive.indexBufferBinding,
          drawOffset = primitive.drawOffset,
          drawCount = primitive.drawCount,
          instanceCount = primitive.instanceCount,
          _glIndexType = primitive._glIndexType;

      if (!instanceCount) {
        if (indexBufferBinding) {
          var _nativeBuffer = indexBufferBinding.buffer._nativeBuffer;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
          gl.drawElements(primitiveTopology, drawCount, _glIndexType, drawOffset);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        } else {
          gl.drawArrays(primitiveTopology, drawOffset, drawCount);
        }
      } else {
        if (this.canUseInstancedArrays) {
          if (indexBufferBinding) {
            var _nativeBuffer2 = indexBufferBinding.buffer._nativeBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
            gl.drawElementsInstanced(primitiveTopology, drawCount, _glIndexType, drawOffset, instanceCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          } else {
            gl.drawArraysInstanced(primitiveTopology, drawOffset, drawCount, instanceCount);
          }
        } else {
          o3Core.Logger.error("ANGLE_instanced_arrays extension is not supported");
        }
      }
      /** unbind */


      this.disableAttrib();
    }
  }, {
    key: "disableAttrib",
    value: function disableAttrib() {
      var gl = this.rhi.gl;

      for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
        gl.disableVertexAttribArray(this.attribLocArray[i]);
      }
    }
    /**
     * 释放 GL 资源
     */

  }, {
    key: "finalize",
    value: function finalize() {}
  }]);

  return GLPrimitive;
}(GLAsset);

/**
 * 管理渲染状态，主要功能：设置默认渲染状态，cache当前渲染状态，管理渲染状态stack（供恢复用）
 * @class
 * @private
 */
var GLRenderStates = /*#__PURE__*/function () {
  /**
   * @param {WebGLRenderingContext} gl
   */
  function GLRenderStates(gl) {
    _classCallCheck(this, GLRenderStates);

    this._gl = void 0;
    this._stateStack = [];
    this._parameters = {};
    this._gl = gl;
    this._stateStack = []; // stat block stack

    this._parameters = {}; // current gl state parameters
    //-- 初始化，设置所有渲染状态为默认值 ---------------

    /** cache */

    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS); //-- enable/disable

    this._parameters[gl.BLEND] = false;
    gl.disable(gl.BLEND);
    this._parameters[gl.CULL_FACE] = true;
    gl.enable(gl.CULL_FACE);
    this._parameters[gl.DEPTH_TEST] = true;
    gl.enable(gl.DEPTH_TEST);
    this._parameters[gl.DITHER] = false;
    gl.disable(gl.DITHER);
    this._parameters[gl.POLYGON_OFFSET_FILL] = false;
    gl.disable(gl.POLYGON_OFFSET_FILL);
    this._parameters[gl.SAMPLE_ALPHA_TO_COVERAGE] = false;
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    this._parameters[gl.SAMPLE_COVERAGE] = false;
    gl.disable(gl.SAMPLE_COVERAGE);
    this._parameters[gl.SCISSOR_TEST] = false;
    gl.disable(gl.SCISSOR_TEST);
    this._parameters[gl.STENCIL_TEST] = false;
    gl.disable(gl.STENCIL_TEST); //-- colorMask

    this._parameters[gl.COLOR_WRITEMASK] = [true, true, true, true];
    gl.colorMask(true, true, true, true); //-- depthMask

    this._parameters[gl.DEPTH_WRITEMASK] = true;
    gl.depthMask(true); //-- blendFunc

    this._parameters[gl.BLEND_SRC_RGB] = gl.ONE;
    this._parameters[gl.BLEND_SRC_ALPHA] = gl.ONE;
    this._parameters[gl.BLEND_DST_RGB] = gl.ZERO;
    this._parameters[gl.BLEND_DST_ALPHA] = gl.ZERO;
    gl.blendFunc(gl.ONE, gl.ZERO);
    this._parameters[gl.BLEND_EQUATION_RGB] = gl.FUNC_ADD;
    this._parameters[gl.BLEND_EQUATION_ALPHA] = gl.FUNC_ADD; //-- cullFace

    this._parameters[gl.CULL_FACE_MODE] = gl.BACK;
    gl.cullFace(gl.BACK); //-- frontFace

    this._parameters[gl.FRONT_FACE] = gl.CCW;
    gl.frontFace(gl.CCW); //-- depthFunc

    this._parameters[gl.DEPTH_FUNC] = gl.LESS;
    gl.depthFunc(gl.LESS); //-- depthRange

    this._parameters[gl.DEPTH_RANGE] = [0, 1];
    gl.depthRange(0, 1); //-- polygonOffset

    this._parameters[gl.POLYGON_OFFSET_FACTOR] = 0;
    this._parameters[gl.POLYGON_OFFSET_UNITS] = 0;
    gl.polygonOffset(0, 0); //-- scissor

    this._parameters[gl.SCISSOR_BOX] = [0, 0, gl.canvas.width, gl.canvas.height]; //-- stencilFunc

    this._parameters[gl.STENCIL_FUNC] = gl.ALWAYS;
    this._parameters[gl.STENCIL_VALUE_MASK] = 0xff;
    this._parameters[gl.STENCIL_REF] = 0;
    gl.stencilFunc(gl.ALWAYS, 0, 0xff); // -- stencilMask

    this._parameters[gl.STENCIL_WRITEMASK] = 0xff;
    gl.stencilMask(0xff); //-- stencilOp

    this._parameters[gl.STENCIL_FAIL] = gl.KEEP;
    this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] = gl.KEEP;
    this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = gl.KEEP;
  }
  /**
   * 取得渲染状态参数：any gl.getParameter(pname);
   * @param {GLenum} pname
   */


  _createClass(GLRenderStates, [{
    key: "getParameter",
    value: function getParameter(pname) {
      return this._parameters[pname];
    }
    /**
     * 新建一个State Block（渲染单个对象时的一组渲染状态），并放入状态栈
     */

  }, {
    key: "pushStateBlock",
    value: function pushStateBlock(_name) {
      var stateBlock = {
        name: _name,
        states: []
      };

      this._stateStack.push(stateBlock);
    }
    /**
     * 取出栈顶的State Block，并用来恢复当前的渲染状态
     */

  }, {
    key: "popStateBlock",
    value: function popStateBlock() {
      var stateBlock = this._stateStack.pop(); //-- 恢复渲染状态


      var _iterator = _createForOfIteratorHelper(stateBlock.states),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var state = _step.value;
          var stateFunc = state.func;
          var stateArgs = state.args;
          var parameters = state.parameters;
          stateFunc.apply(this._gl, stateArgs);

          for (var param in parameters) {
            this._parameters[param] = parameters[param];
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * 取得当前状态栈的顶部对象
     * @return {Object}
     * @private
     */

  }, {
    key: "_getStateStackTop",
    value: function _getStateStackTop() {
      var count = this._stateStack.length;

      if (count > 0) {
        return this._stateStack[count - 1];
      } else {
        return null;
      }
    }
    /**
     * 将一个渲染状态放入栈顶的State Block
     * @param {Function} func
     * @param {Array} args
     * @private
     */

  }, {
    key: "_pushState",
    value: function _pushState(_func, _args, _param) {
      var stateBlock = this._getStateStackTop();

      if (stateBlock) {
        stateBlock.states.push({
          func: _func,
          args: _args,
          parameters: _param
        });
      }
    }
    /**
     * 设置渲染状态：void gl.enable(cap);
     * @param {GLenum} cap
     */

  }, {
    key: "enable",
    value: function enable(cap) {
      var currentState = this._parameters[cap];
      if (currentState === true) return;
      this._parameters[cap] = true;

      this._gl.enable(cap);

      var pushParam = {};
      pushParam[cap] = false;

      this._pushState(this._gl.disable, [cap], pushParam);
    }
    /**
     * 设置渲染状态：void gl.disable(cap);
     * @param {GLenum} cap
     */

  }, {
    key: "disable",
    value: function disable(cap) {
      var currentState = this._parameters[cap];
      if (currentState === false) return;
      this._parameters[cap] = false;

      this._gl.disable(cap);

      var pushParam = {};
      pushParam[cap] = true;

      this._pushState(this._gl.enable, [cap], pushParam);
    }
    /**
     * 设置渲染状态：void gl.blendFunc(sfactor, dfactor);
     * @param {GLenum} sfactor
     * @param {GLenum} dfactor
     */

  }, {
    key: "blendFunc",
    value: function blendFunc(sfactor, dfactor) {
      var gl = this._gl;
      var param = this._parameters;
      if (param[gl.BLEND_SRC_RGB] === sfactor && param[gl.BLEND_SRC_ALPHA] === sfactor && param[gl.BLEND_DST_RGB] === dfactor && param[gl.BLEND_DST_ALPHA] === dfactor) return;
      var pushArgs = [param[gl.BLEND_SRC_RGB], param[gl.BLEND_DST_RGB], param[gl.BLEND_SRC_ALPHA], param[gl.BLEND_DST_ALPHA]];
      var pushParam = {};
      pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];
      pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];
      pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];
      pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];

      this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);

      param[gl.BLEND_SRC_RGB] = sfactor;
      param[gl.BLEND_SRC_ALPHA] = sfactor;
      param[gl.BLEND_DST_RGB] = dfactor;
      param[gl.BLEND_DST_ALPHA] = dfactor;
      gl.blendFunc(sfactor, dfactor);
    }
    /**
     * 设置渲染状态：void gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
     * @param {GLenum} srcRGB
     * @param {GLenum} dstRGB
     * @param {GLenum} srcAlpha
     * @param {GLenum} dstAlpha
     */

  }, {
    key: "blendFuncSeparate",
    value: function blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
      var gl = this._gl;
      var param = this._parameters;
      if (param[gl.BLEND_SRC_RGB] === srcRGB && param[gl.BLEND_SRC_ALPHA] === srcAlpha && param[gl.BLEND_DST_RGB] === dstRGB && param[gl.BLEND_DST_ALPHA] === dstAlpha) return;
      var pushArgs = [param[gl.BLEND_SRC_RGB], param[gl.BLEND_DST_RGB], param[gl.BLEND_SRC_ALPHA], param[gl.BLEND_DST_ALPHA]];
      var pushParam = {};
      pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];
      pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];
      pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];
      pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];

      this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);

      param[gl.BLEND_SRC_RGB] = srcRGB;
      param[gl.BLEND_SRC_ALPHA] = srcAlpha;
      param[gl.BLEND_DST_RGB] = dstRGB;
      param[gl.BLEND_DST_ALPHA] = dstAlpha;
      gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }
    /**
     * void gl.blendEquationSeparate(modeRGB, modeAlpha);
     * @param {GLenum} modeRGB
     * @param {GLenum} modeAlpha
     */

  }, {
    key: "blendEquationSeparate",
    value: function blendEquationSeparate(modeRGB, modeAlpha) {
      var gl = this._gl;
      var param = this._parameters;
      if (param[gl.BLEND_EQUATION_RGB] === modeRGB && param[gl.BLEND_EQUATION_ALPHA] === modeAlpha) return;
      var pushArgs = [param[gl.BLEND_EQUATION_RGB], param[gl.BLEND_EQUATION_ALPHA]];
      var pushParam = {};
      pushParam[gl.BLEND_EQUATION_RGB] = param[gl.BLEND_EQUATION_RGB];
      pushParam[gl.BLEND_EQUATION_ALPHA] = param[gl.BLEND_EQUATION_ALPHA];

      this._pushState(gl.blendEquationSeparate, pushArgs, pushParam);

      param[gl.BLEND_EQUATION_RGB] = modeRGB;
      param[gl.BLEND_EQUATION_ALPHA] = modeAlpha;
      gl.blendEquationSeparate(modeRGB, modeAlpha);
    }
    /**
     * 控制颜色通道释放写入Frame Buffer
     * @param {boolean} red 红色通道是否写入
     * @param {boolean} green 绿色通道是否写入
     * @param {boolean} blue 蓝色通道是否写入
     * @param {boolean} alpha 透明通道是否写入
     */

  }, {
    key: "colorMask",
    value: function colorMask(red, green, blue, alpha) {
      var gl = this._gl;
      var pushParam = {};
      pushParam[gl.COLOR_WRITEMASK] = this._parameters[gl.COLOR_WRITEMASK];

      this._pushState(gl.colorMask, this._parameters[gl.COLOR_WRITEMASK], pushParam);

      this._parameters[gl.COLOR_WRITEMASK] = [red, green, blue, alpha];
      gl.colorMask(red, green, blue, alpha);
    }
    /**
     * 是否写入深度缓冲
     * @param {boolean} flag
     */

  }, {
    key: "depthMask",
    value: function depthMask(flag) {
      var gl = this._gl;
      if (this._parameters[gl.DEPTH_WRITEMASK] === flag) return;
      var pushParam = {};
      pushParam[gl.DEPTH_WRITEMASK] = this._parameters[gl.DEPTH_WRITEMASK];

      this._pushState(gl.depthMask, [this._parameters[gl.DEPTH_WRITEMASK]], pushParam);

      this._parameters[gl.DEPTH_WRITEMASK] = flag;
      gl.depthMask(flag);
    }
    /**
     * 设置渲染状态：void gl.cullFace(mode);
     * @param {GLenum} mode
     */

  }, {
    key: "cullFace",
    value: function cullFace(mode) {
      var gl = this._gl;
      if (this._parameters[gl.CULL_FACE_MODE] === mode) return;
      var pushParam = {};
      pushParam[gl.CULL_FACE_MODE] = this._parameters[gl.CULL_FACE_MODE];

      this._pushState(gl.cullFace, [this._parameters[gl.CULL_FACE_MODE]], pushParam);

      this._parameters[gl.CULL_FACE_MODE] = mode;
      gl.cullFace(mode);
    }
    /**
     * 设置渲染状态：void gl.frontFace(mode);
     * @param {GLenum} mode
     */

  }, {
    key: "frontFace",
    value: function frontFace(mode) {
      var gl = this._gl;
      if (this._parameters[gl.FRONT_FACE] === mode) return;
      var pushParam = {};
      pushParam[gl.FRONT_FACE] = this._parameters[gl.FRONT_FACE];

      this._pushState(gl.frontFace, [this._parameters[gl.FRONT_FACE]], pushParam);

      this._parameters[gl.FRONT_FACE] = mode;
      gl.frontFace(mode);
    }
    /**
     * 设置渲染状态：void gl.depthFunc(func);
     * @param {GLenum} func
     */

  }, {
    key: "depthFunc",
    value: function depthFunc(func) {
      var gl = this._gl;
      if (this._parameters[gl.DEPTH_FUNC] === func) return;
      var pushParam = {};
      pushParam[gl.DEPTH_FUNC] = this._parameters[gl.DEPTH_FUNC];

      this._pushState(gl.depthFunc, [this._parameters[gl.DEPTH_FUNC]], pushParam);

      this._parameters[gl.DEPTH_FUNC] = func;
      gl.depthFunc(func);
    }
    /**
     * 设置渲染状态：void gl.depthRange(zNear, zFar);
     * @param {GLclampf} zNear
     * @param {GLclampf} zFar
     */

  }, {
    key: "depthRange",
    value: function depthRange(zNear, zFar) {
      var gl = this._gl;
      var currentValue = this._parameters[gl.DEPTH_RANGE];
      if (currentValue[0] === zNear && currentValue[1] === zFar) return;
      var pushParam = {};
      pushParam[gl.DEPTH_RANGE] = currentValue;

      this._pushState(gl.depthRange, [this._parameters[gl.DEPTH_RANGE]], pushParam);

      this._parameters[gl.DEPTH_RANGE] = [zNear, zFar];
      gl.depthRange(zNear, zFar);
    }
    /**
     * void gl.polygonOffset(factor, units);
     * @param {GLfloat} factor
     * @param {GLfloat} units
     */

  }, {
    key: "polygonOffset",
    value: function polygonOffset(factor, units) {
      var gl = this._gl;
      if (this._parameters[gl.POLYGON_OFFSET_FACTOR] === factor && this._parameters[gl.POLYGON_OFFSET_UNITS] === units) return;
      var pushParam = {};
      pushParam[gl.POLYGON_OFFSET_FACTOR] = this._parameters[gl.POLYGON_OFFSET_FACTOR];
      pushParam[gl.POLYGON_OFFSET_UNITS] = this._parameters[gl.POLYGON_OFFSET_UNITS];

      this._pushState(gl.polygonOffset, [this._parameters[gl.POLYGON_OFFSET_FACTOR], this._parameters[gl.POLYGON_OFFSET_UNITS]], pushParam);

      this._parameters[gl.POLYGON_OFFSET_FACTOR] = factor;
      this._parameters[gl.POLYGON_OFFSET_UNITS] = units;
      gl.polygonOffset(factor, units);
    }
    /**
     * 设置渲染状态：void gl.scissor(x, y, width, height);
     * @param {GLint} x
     * @param {GLint} y
     * @param {GLsizei} width
     * @param {GLsizei} height
     */

  }, {
    key: "scissor",
    value: function scissor(x, y, width, height) {
      var gl = this._gl;
      var box = this._parameters[gl.SCISSOR_BOX];
      if (box[0] === x && box[1] === y && box[2] === width && box[3] === height) return;
      var pushParam = {};
      pushParam[gl.SCISSOR_BOX] = box;

      this._pushState(gl.scissor, box, pushParam);

      this._parameters[gl.SCISSOR_BOX] = [x, y, width, height];
      gl.scissor(x, y, width, height);
    }
    /**
     * 设置渲染状态：void gl.stencilFunc(func, ref, mask);
     * @param {GLenum} func
     * @param {GLint} ref
     * @param {GLint} mask
     */

  }, {
    key: "stencilFunc",
    value: function stencilFunc(func, ref, mask) {
      var gl = this._gl;
      if (this._parameters[gl.STENCIL_FUNC] === func && this._parameters[gl.STENCIL_REF] === ref && this._parameters[gl.STENCIL_VALUE_MASK] === mask) return;
      var pushArgs = [this._parameters[gl.STENCIL_FUNC], this._parameters[gl.STENCIL_REF], this._parameters[gl.STENCIL_VALUE_MASK]];
      var pushParam = {};
      pushParam[gl.STENCIL_FUNC] = pushArgs[0];
      pushParam[gl.STENCIL_REF] = pushArgs[1];
      pushParam[gl.STENCIL_VALUE_MASK] = pushArgs[2];

      this._pushState(gl.stencilFunc, pushArgs, pushParam);

      this._parameters[gl.STENCIL_FUNC] = func;
      this._parameters[gl.STENCIL_REF] = ref;
      this._parameters[gl.STENCIL_VALUE_MASK] = mask;
      gl.stencilFunc(func, ref, mask);
    }
    /**
     * 设置渲染状态：void gl.stencilOp(fail, zfail, zpass);
     * @param {GLenum} fail
     * @param {GLenum} zfail
     * @param {GLenum} zpass
     */

  }, {
    key: "stencilOp",
    value: function stencilOp(fail, zfail, zpass) {
      var gl = this._gl;
      if (this._parameters[gl.STENCIL_FAIL] === fail && this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] === zfail && this._parameters[gl.STENCIL_PASS_DEPTH_PASS] === zpass) return;
      var pushArgs = [this._parameters[gl.STENCIL_FAIL], this._parameters[gl.STENCIL_PASS_DEPTH_FAIL], this._parameters[gl.STENCIL_PASS_DEPTH_PASS]];
      var pushParam = {};
      pushParam[gl.STENCIL_FAIL] = pushArgs[0];
      pushParam[gl.STENCIL_PASS_DEPTH_FAIL] = pushArgs[1];
      pushParam[gl.STENCIL_PASS_DEPTH_PASS] = pushArgs[2];

      this._pushState(gl.stencilOp, pushArgs, pushParam);

      this._parameters[gl.STENCIL_FAIL] = fail;
      this._parameters[gl.STENCIL_BACK_PASS_DEPTH_FAIL] = zfail;
      this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = zpass;
      gl.stencilOp(fail, zfail, zpass);
    }
  }, {
    key: "stencilMask",
    value: function stencilMask(mask) {
      var gl = this._gl;
      if (this._parameters[gl.STENCIL_WRITEMASK] === mask) return;
      var pushParam = {};
      pushParam[gl.STENCIL_WRITEMASK] = this._parameters[gl.STENCIL_WRITEMASK];

      this._pushState(gl.stencilMask, [this._parameters[gl.STENCIL_WRITEMASK]], pushParam);

      this._parameters[gl.STENCIL_WRITEMASK] = mask;
      gl.stencilMask(mask);
    }
  }]);

  return GLRenderStates;
}();

/**
 * GL 层的 RenderTarget 资源管理和渲染调用处理
 * @class
 * @private
 */
var GLRenderTarget = /*#__PURE__*/function (_GLAsset) {
  _inherits(GLRenderTarget, _GLAsset);

  var _super = _createSuper(GLRenderTarget);

  function GLRenderTarget(rhi, renderTarget) {
    var _this;

    _classCallCheck(this, GLRenderTarget);

    _this = _super.call(this, rhi, renderTarget);
    _this.renderTarget = void 0;
    _this.renderTarget = renderTarget;
    return _this;
  }
  /**
   * 激活 RenderTarget 对象，后续的内容将会被渲染到当前激活 RenderTarget 对象上
   * @private
   */


  _createClass(GLRenderTarget, [{
    key: "activeRenderTarget",
    value: function activeRenderTarget() {
      var gl = this.rhi.gl;
      var _this$renderTarget = this.renderTarget,
          width = _this$renderTarget.width,
          height = _this$renderTarget.height;

      this.renderTarget._activeRenderTarget();

      gl.viewport(0.0, 0.0, width, height);
    }
    /**
     * 设置渲染到立方体纹理的面
     * @param {number} faceIndex - gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex
     * */

  }, {
    key: "setRenderTargetFace",
    value: function setRenderTargetFace(faceIndex) {
      this.renderTarget._setRenderTargetFace(faceIndex);
    }
    /** blit FBO */

  }, {
    key: "blitRenderTarget",
    value: function blitRenderTarget() {
      if (this.renderTarget._MSAAFrameBuffer) {
        this.renderTarget._blitRenderTarget();

        return;
      }
    }
    /**
     * 释放 GL 资源
     * @private
     */

  }, {
    key: "finalize",
    value: function finalize() {}
  }]);

  return GLRenderTarget;
}(GLAsset);

/**
 * 管理HUD控件Batch绘制时，需要处理的几何体数据
 * @private
 */

var GLSprite = /*#__PURE__*/function () {
  function GLSprite(gl) {
    _classCallCheck(this, GLSprite);

    this.gl = void 0;
    this._vbo = void 0;
    this._maxBatchCount = void 0;
    this._vertBuffer = void 0;
    this._vertCursor = void 0;
    this._drawSpriteCount = void 0;
    this._vertAttributes = void 0;
    this.gl = gl; //-- vertex attributes

    this._initVertexAttributes(gl); //-- 创建VBO


    this._vbo = gl.createBuffer();
    this._maxBatchCount = 0;
    this._vertBuffer = null; // 在setWidgetCount()中创建

    this._vertCursor = 0; // 当前使用的顶点的index

    this._drawSpriteCount = 0; // 当前这一帧画了多少个Widget
  }
  /**
   * 设置需要绘制的控件的个数
   * @param {NUMBER} count 控件的个数
   */


  _createClass(GLSprite, [{
    key: "setMaxBatchCount",
    value: function setMaxBatchCount(count) {
      // 每个控件需要2个三角形，即6个顶点来绘制
      var requireSize = count * 6 * 9;

      if (this._vertBuffer && this._vertBuffer.length >= requireSize) {
        return;
      }

      this._maxBatchCount = count;
      this._vertBuffer = new Float32Array(requireSize);
    }
    /**
     * 开始绘制控件，清空内部状态
     */

  }, {
    key: "beginDraw",
    value: function beginDraw(count) {
      this._vertCursor = 0;
      this._drawSpriteCount = 0; // 动态扩张

      if (count > this._maxBatchCount) {
        this.setMaxBatchCount(count);
      }
    }
    /**
     * 将一个2D Sprite绘制所需的矩形，Batch到内部的Vertex Buffer之中
     * @param {HUDWidget} screenRect 需要绘制的控件
     */

  }, {
    key: "drawSprite",
    value: function drawSprite(positionQuad, uvRect, tintColor) {
      this._drawSpriteCount++;

      if (this._drawSpriteCount > this._maxBatchCount) {
        o3Core.Logger.warn("Sprite: sprite count overflow");
        return;
      }

      var color = tintColor;
      var u = uvRect.u;
      var v = uvRect.v;
      var p = uvRect.u + uvRect.width;
      var q = uvRect.v + uvRect.height;

      this._pushVertex(positionQuad.leftTop, new o3Math.Vector2(u, v), color);

      this._pushVertex(positionQuad.leftBottom, new o3Math.Vector2(u, q), color);

      this._pushVertex(positionQuad.rightBottom, new o3Math.Vector2(p, q), color);

      this._pushVertex(positionQuad.rightBottom, new o3Math.Vector2(p, q), color);

      this._pushVertex(positionQuad.rightTop, new o3Math.Vector2(p, v), color);

      this._pushVertex(positionQuad.leftTop, new o3Math.Vector2(u, v), color);
    }
    /**
     * 执行真正的绘制
     */

  }, {
    key: "endDraw",
    value: function endDraw() {
      var vertCount = this._vertCursor / 9;
      if (vertCount <= 0) return;
      var gl = this.gl;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
      gl.bufferData(gl.ARRAY_BUFFER, this._vertBuffer, gl.DYNAMIC_DRAW);

      for (var i = 0, len = this._vertAttributes.length; i < len; i++) {
        var attrib = this._vertAttributes[i];
        gl.vertexAttribPointer(attrib.lastShaderLoc, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        gl.enableVertexAttribArray(attrib.lastShaderLoc);
      } // end of for


      gl.drawArrays(gl.TRIANGLES, 0, vertCount);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null); // disable attributes

      for (var _i = 0, _len = this._vertAttributes.length; _i < _len; _i++) {
        gl.disableVertexAttribArray(this._vertAttributes[_i].lastShaderLoc);
      }
    }
    /**
     * 初始化内部的顶点属性，包括pos, uv, color
     * @param {WebGLRenderingContext} gl GL Context对象
     */

  }, {
    key: "_initVertexAttributes",
    value: function _initVertexAttributes(gl) {
      var vertexStride = (3 + 2 + 4) * 4;
      var posAtt = {};
      posAtt.name = "a_pos";
      posAtt.size = 3;
      posAtt.offset = 0;
      posAtt.lastShaderLoc = 0;
      var uvAtt = {};
      uvAtt.name = "a_uv";
      uvAtt.size = 2;
      uvAtt.offset = 3 * 4;
      uvAtt.lastShaderLoc = 1;
      var colorAtt = {};
      colorAtt.name = "a_color";
      colorAtt.size = 4;
      colorAtt.offset = 5 * 4;
      colorAtt.lastShaderLoc = 2;
      this._vertAttributes = [posAtt, uvAtt, colorAtt];

      var _iterator = _createForOfIteratorHelper(this._vertAttributes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var att = _step.value;
          att.type = gl.FLOAT;
          att.normalized = false;
          att.stride = vertexStride;
        } // end of for

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * 向当前的顶点缓冲中添加一个顶点
     * @param {Vector3} pos 位置坐标
     * @param {Vector2} uv 贴图坐标
     * @param {Vector4} color 颜色RGBA
     */

  }, {
    key: "_pushVertex",
    value: function _pushVertex(pos, uv, color) {
      var vb = this._vertBuffer;
      var id = this._vertCursor; //-- pos

      vb[id] = pos.x;
      vb[id + 1] = pos.y;
      vb[id + 2] = pos.z; //-- uv

      vb[id + 3] = uv.x;
      vb[id + 4] = uv.y; //-- color

      vb[id + 5] = color.x;
      vb[id + 6] = color.y;
      vb[id + 7] = color.z;
      vb[id + 8] = color.w; //--

      this._vertCursor += 9;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      if (this._vbo) {
        this.gl.deleteBuffer(this._vbo);
        this._vbo = null;
      }
    }
  }]);

  return GLSprite;
}();

var SpriteVertShader = "\nprecision highp float;\n\nuniform mat4 matProjection;\nuniform mat4 matView;\n\nattribute vec3 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  gl_Position = matProjection * matView * vec4(a_pos,1.0);\n  v_uv = a_uv;\n  v_color = a_color;\n}\n";
var SpriteFragmentShader = "\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D s_diffuse;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  // \u53EA\u4F7F\u7528\u8D34\u56FE\u7684Alpha\u505AMask\uFF0C\u8FD9\u6837Tint Color\u4F9D\u7136\u53EF\u4EE5\u63A7\u5236\u63A7\u4EF6Fade Out\n  vec4 baseColor = texture2D(s_diffuse, v_uv);\n  gl_FragColor = baseColor * v_color;\n}\n";
var SpriteTechnique = {
  name: "spriteTech3D",
  vertexShader: SpriteVertShader,
  fragmentShader: SpriteFragmentShader,
  attribLocSet: {
    a_pos: 0,
    a_uv: 1,
    a_color: 2
  },
  attributes: {
    a_pos: {
      name: "a_pos",
      semantic: "POSITION",
      type: o3Core.DataType.FLOAT_VEC3
    },
    a_uv: {
      name: "a_uv",
      semantic: "TEXCOORD_0",
      type: o3Core.DataType.FLOAT_VEC2
    },
    a_color: {
      name: "a_color",
      semantic: "COLOR",
      type: o3Core.DataType.FLOAT_VEC3
    }
  },
  uniforms: {
    matProjection: {
      name: "matProjection",
      semantic: o3Core.UniformSemantic.PROJECTION,
      type: o3Core.DataType.FLOAT_MAT4
    },
    matView: {
      name: "matView",
      semantic: o3Core.UniformSemantic.VIEW,
      type: o3Core.DataType.FLOAT_MAT4
    },
    s_diffuse: {
      name: "s_diffuse",
      type: o3Core.DataType.SAMPLER_2D
    }
  },
  states: {
    disable: [o3Core.RenderState.CULL_FACE],
    enable: [o3Core.RenderState.BLEND],
    functions: {
      blendFunc: [o3Core.BlendFunc.SRC_ALPHA, o3Core.BlendFunc.ONE_MINUS_SRC_ALPHA],
      depthMask: [false] //[gl.FALSE]

    }
  }
};
function createSpriteMaterial() {
  var values = {};
  return {
    values: values,
    setValue: function setValue(key, val) {
      values[key] = val;
    },
    getValue: function getValue(key) {
      return values[key];
    }
  };
}

var programList = [];

function addLineNum(str) {
  var lines = str.split("\n");
  var limitLength = (lines.length + 1).toString().length + 6;
  var prefix;
  return lines.map(function (line, index) {
    prefix = "0:".concat(index + 1);
    if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;

    for (var i = 0; i < limitLength - prefix.length; i++) {
      prefix += " ";
    }

    return prefix + line;
  }).join("\n");
}
/**
 * GL的Shader+Program的包装，用于对象的绘制. 对应glTF中的一个program对象
 * @class
 * @private
 */


var GLShaderProgram = /*#__PURE__*/function () {
  _createClass(GLShaderProgram, null, [{
    key: "requireProgram",

    /**
     * 从缓存中读取program,如果没有则新建
     * @param {RenderTechnique} tech
     * @param {WebGLRenderingContext} gl
     * @return {GLShaderProgram}
     * */
    value: function requireProgram(tech, gl) {
      var program = null;
      programList.some(function (p) {
        if (p._gl === gl && p._vertexShaderSource === tech.vertexShader && p._fragmentShaderSource === tech.fragmentShader) {
          program = p;
          return true;
        }
      });

      if (!program) {
        program = new GLShaderProgram(gl);
        var sucess = program.createFromSource(tech.vertexShader, tech.fragmentShader, tech.attribLocSet);
        if (!sucess) return null;
        programList.push(program);
      }

      return program;
    }
    /**
     * 从缓存中释放program
     * @param {GLShaderProgram} program
     * */

  }, {
    key: "releaseProgram",
    value: function releaseProgram(program) {
      var index = programList.indexOf(program);

      if (index !== -1) {
        programList.splice(index, 1);
      }
    }
  }]);

  function GLShaderProgram(gl) {
    _classCallCheck(this, GLShaderProgram);

    this._gl = void 0;
    this._vertexShader = void 0;
    this._fragmentShader = void 0;
    this._vertexShaderSource = void 0;
    this._fragmentShaderSource = void 0;
    this._program = void 0;
    this._attributeCache = void 0;
    this._uniformCache = void 0;
    this._gl = gl; // {WebGLShader}

    this._vertexShader = null; // {WebGLShader}

    this._fragmentShader = null; // shader source

    this._vertexShaderSource = null;
    this._fragmentShaderSource = null; // {WebGLProgram}

    this._program = null; // location cache

    this._attributeCache = {};
    this._uniformCache = {};
  }
  /**
   * WebGLProgram对象
   * @member {WebGLProgram}
   * @readonly
   */


  _createClass(GLShaderProgram, [{
    key: "createFromSource",

    /**
     * 使用源代码编译、链接Shader Program
     * @param {string} vertexSource 顶点 Shader 代码
     * @param {string} fragmentSource 片元 Shader 代码
     */
    value: function createFromSource(vertexSource, fragmentSource, attribLocSet) {
      var gl = this._gl; // 编译两个Shader

      var vertexShader = this._compileShader(gl.VERTEX_SHADER, vertexSource);

      if (!vertexShader) {
        return false;
      }

      var fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);

      if (!fragmentShader) {
        return false;
      } // 链接Program


      var program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      if (attribLocSet) {
        for (var attribName in attribLocSet) {
          gl.bindAttribLocation(program, attribLocSet[attribName], attribName);
        }
      }

      gl.linkProgram(program);
      gl.validateProgram(program);

      if (gl.isContextLost()) {
        o3Core.Logger.error("Contex lost while linking program.");
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        return null;
      } // debug开启才进行消耗性能的能力检测
      // if (Logger.isEnabled) {


      if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
        o3Core.Logger.error("Could not link WebGL program. \n" + gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return false; // }
      } // 更新内部变量


      this._vertexShader = vertexShader;
      this._fragmentShader = fragmentShader;
      this._vertexShaderSource = vertexSource;
      this._fragmentShaderSource = fragmentSource;
      this._program = program;
      return true;
    }
    /**
     * 编译Shader
     * @param {GLenum} shaderType
     * @param {string} shaderSource
     * @private
     */

  }, {
    key: "_compileShader",
    value: function _compileShader(shaderType, shaderSource) {
      var gl = this._gl;
      var shader = gl.createShader(shaderType);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);

      if (gl.isContextLost()) {
        o3Core.Logger.error("Contex lost while compiling shader.");
        gl.deleteShader(shader);
        return null;
      } // debug开启才进行消耗性能的能力检测


      if (o3Core.Logger.isEnabled) {
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
          o3Core.Logger.error("Could not compile WebGL shader.\n".concat(addLineNum(shaderSource), "\n").concat(gl.getShaderInfoLog(shader))); // Logger.error( gl.getShaderInfoLog( shader ) );

          gl.deleteShader(shader);
          return null;
        }
      }

      return shader;
    }
    /**
     * getAttribLocation读取速度比较慢，增加缓存机制
     * */

  }, {
    key: "getAttribLocation",
    value: function getAttribLocation(glProgram, name) {
      if (this._attributeCache.hasOwnProperty(name)) {
        return this._attributeCache[name];
      } else {
        return this._attributeCache[name] = this._gl.getAttribLocation(glProgram, name);
      }
    }
    /**
     * getUniformLocation读取速度比较慢，增加缓存机制
     * */

  }, {
    key: "getUniformLocation",
    value: function getUniformLocation(glProgram, name) {
      if (this._uniformCache.hasOwnProperty(name)) {
        return this._uniformCache[name];
      } else {
        return this._uniformCache[name] = this._gl.getUniformLocation(glProgram, name);
      }
    }
    /**
     * 释放GL资源对象
     */

  }, {
    key: "finalize",
    value: function finalize() {
      var gl = this._gl;

      if (this._vertexShader) {
        gl.deleteShader(this._vertexShader);
      }

      if (this._fragmentShader) {
        gl.deleteShader(this._fragmentShader);
      }

      if (this._program) {
        gl.deleteProgram(this._program);
      }

      this._vertexShader = null;
      this._fragmentShader = null;
      this._vertexShaderSource = null;
      this._fragmentShaderSource = null;
      this._program = null;
      this._attributeCache = {};
      this._uniformCache = {};
      GLShaderProgram.releaseProgram(this);
    }
  }, {
    key: "program",
    get: function get() {
      return this._program;
    }
  }]);

  return GLShaderProgram;
}();

/**
 * GL 层的 Technique 资源管理和渲染调用处理
 * @private
 */
var GLTechnique = /*#__PURE__*/function (_GLAsset) {
  _inherits(GLTechnique, _GLAsset);

  var _super = _createSuper(GLTechnique);

  function GLTechnique(rhi, tech) {
    var _this;

    _classCallCheck(this, GLTechnique);

    _this = _super.call(this, rhi, tech);
    _this.valid = void 0;
    _this._tech = void 0;
    _this._activeTextureCount = void 0;
    _this._program = void 0;
    _this._attributes = void 0;
    _this._uniforms = void 0;
    _this._tempSamplerArray = void 0;
    _this._tech = tech;
    _this._activeTextureCount = 0;
    var gl = rhi.gl; //-- 编译shader 或者从缓存中捞program

    _this._program = GLShaderProgram.requireProgram(tech, gl);

    if (_this._program) {
      _this.valid = true;
      var glProgram = _this._program.program; // 记录Attribute的shader location

      _this._attributes = {};
      var attributes = tech.attributes;

      for (var name in attributes) {
        _this._attributes[name] = {
          name: name,
          semantic: attributes[name].semantic,
          location: _this._program.getAttribLocation(glProgram, name)
        };
      } // 记录Unifrom的shader location


      _this._uniforms = {};
      var uniforms = tech.uniforms;

      for (var _name in uniforms) {
        var loc = _this._program.getUniformLocation(glProgram, _name);

        if (loc !== null) {
          _this._uniforms[_name] = {
            name: _name,
            location: loc
          };
        }
      } // end of for

    } else {
      _this.valid = false;
    }

    return _this;
  }
  /**
   * 释放 GL 资源
   */


  _createClass(GLTechnique, [{
    key: "finalize",
    value: function finalize(forceDispose) {
      if (this._program && forceDispose) {
        this._program.finalize();

        this._program = null;
      }
    }
    /**
     * Shader Program 对象
     * @member {GLShaderProgram}
     */

  }, {
    key: "begin",

    /**
     * 开始渲染时调用，绑定内部 GL Program，并设定 Unifrom
     * @param {Material} mtl
     */
    value: function begin(mtl) {
      var gl = this.rhi.gl;
      var glProgram = this._program.program; //-- 重置内部状态变量

      this._activeTextureCount = 0; //-- bind program

      gl.useProgram(glProgram); //-- upload mtl uniforms

      var uniforms = this._uniforms;
      var assetUniforms = this._tech.uniforms;

      for (var name in assetUniforms) {
        if (uniforms.hasOwnProperty(name)) {
          var value = mtl.getValue(name);
          value != null && this._uploadUniformValue(assetUniforms[name], uniforms[name].location, value);
        }
      } //-- change render states


      var stateManager = this.rhi.renderStates;

      if (this._tech.states) {
        stateManager.pushStateBlock(this._tech.name);

        this._applyStates(stateManager);
      }
    }
    /**
     * 结束渲染，回复状态
     */

  }, {
    key: "end",
    value: function end() {
      // 恢复渲染状态
      if (this._tech.states) {
        var stateManager = this.rhi.renderStates;
        stateManager.popStateBlock();
      }
    }
    /**
     * 将状态设置到GL/RenderStateManager
     * @param {GLRenderStates} stateManager
     */

  }, {
    key: "_applyStates",
    value: function _applyStates(stateManager) {
      var states = this._tech.states; //-- enable

      var enable = states.enable;

      if (enable) {
        for (var i = 0, len = enable.length; i < len; i++) {
          stateManager.enable(enable[i]);
        }
      }

      var disable = states.disable;

      if (disable) {
        for (var _i = 0, _len = disable.length; _i < _len; _i++) {
          stateManager.disable(disable[_i]);
        }
      } //-- functions


      var functions = states.functions;

      if (functions) {
        for (var name in functions) {
          var args = Array.isArray(functions[name]) ? functions[name] : [functions[name]];
          var func = stateManager[name];
          func.apply(stateManager, args);
        }
      }
    }
    /**
     * 将自己的value设置到shader的uniform值之上
     * @param uniform
     * @param location
     * @param value
     * @private
     */

  }, {
    key: "_uploadUniformValue",
    value: function _uploadUniformValue(uniform, location, value) {
      var gl = this.rhi.gl; // 设置shader uniform值

      switch (uniform.type) {
        case o3Core.DataType.FLOAT:
          if (value.length) gl.uniform1fv(location, value);else gl.uniform1f(location, value);
          break;

        case o3Core.DataType.FLOAT_ARRAY:
          gl.uniform1fv(location, value);
          break;

        case o3Core.DataType.INT:
          if (value.length) gl.uniform1iv(location, value);else gl.uniform1i(location, value);
          break;

        case o3Core.DataType.INT_ARRAY:
          gl.uniform1iv(location, value);
          break;

        case o3Core.DataType.FLOAT_VEC2:
          gl.uniform2f(location, value.x, value.y);
          break;

        case o3Core.DataType.FLOAT_VEC2_ARRAY:
          gl.uniform2fv(location, value);
          break;

        case o3Core.DataType.FLOAT_VEC3:
          gl.uniform3f(location, value.x, value.y, value.z);
          break;

        case o3Core.DataType.FLOAT_VEC3_ARRAY:
          gl.uniform3fv(location, value);
          break;

        case o3Core.DataType.FLOAT_VEC4:
          gl.uniform4f(location, value.x, value.y, value.z, value.w);
          break;

        case o3Core.DataType.FLOAT_VEC4_ARRAY:
          gl.uniform4fv(location, value);
          break;

        case o3Core.DataType.INT_VEC2:
          gl.uniform2i(location, value.x, value.y);
          break;

        case o3Core.DataType.INT_VEC2_ARRAY:
          gl.uniform2iv(location, value);
          break;

        case o3Core.DataType.INT_VEC3:
          gl.uniform3i(location, value.x, value.y, value.z);
          break;

        case o3Core.DataType.INT_VEC3_ARRAY:
          gl.uniform3iv(location, value);
          break;

        case o3Core.DataType.INT_VEC4:
          gl.uniform4i(location, value.x, value.y, value.z, value.w);
          break;

        case o3Core.DataType.INT_VEC4_ARRAY:
          gl.uniform4iv(location, value);
          break;

        case o3Core.DataType.FLOAT_MAT2:
          gl.uniformMatrix2fv(location, false, value.elements);
          break;

        case o3Core.DataType.FLOAT_MAT2_ARRAY:
          gl.uniformMatrix2fv(location, false, value);
          break;

        case o3Core.DataType.FLOAT_MAT3:
          gl.uniformMatrix3fv(location, false, value.elements);
          break;

        case o3Core.DataType.FLOAT_MAT3_ARRAY:
          gl.uniformMatrix3fv(location, false, value);
          break;

        case o3Core.DataType.FLOAT_MAT4:
          gl.uniformMatrix4fv(location, false, value.elements);
          break;

        case o3Core.DataType.FLOAT_MAT4_ARRAY:
          gl.uniformMatrix4fv(location, false, value);
          break;

        case o3Core.DataType.SAMPLER_2D:
          {
            this._uploadTexture(value, location);

            break;
          }

        case o3Core.DataType.SAMPLER_2D_ARRAY:
          {
            this._uploadTextures(value, location);

            break;
          }

        case o3Core.DataType.SAMPLER_CUBE:
          {
            this._uploadTexture(value, location);

            break;
          }

        case o3Core.DataType.SAMPLER_CUBE_ARRAY:
          {
            this._uploadTextures(value, location);

            break;
          }

        default:
          o3Core.Logger.warn("UNKNOWN uniform type: " + uniform.type);
          break;
      } // end of switch

    }
    /**
     * 将一个内存中的 Texture2D 对象绑定到 GL
     * @param {Texture} texture
     */

  }, {
    key: "_uploadTexture",
    value: function _uploadTexture(texture, location) {
      if (texture) {
        var gl = this.rhi.gl;
        var index = this._activeTextureCount++;
        gl.activeTexture(gl.TEXTURE0 + index);
        gl.bindTexture(texture._target, texture._glTexture);
        gl.uniform1i(location, index);
      } // end of if

    }
    /**
     * 将一堆内存中的 Texture2D 对象绑定到 GL
     */

  }, {
    key: "_uploadTextures",
    value: function _uploadTextures(textures, location) {
      if (!this._tempSamplerArray || this._tempSamplerArray.length !== textures.length) {
        this._tempSamplerArray = new Int32Array(textures.length);
      }

      var gl = this.rhi.gl;

      for (var i = 0, length = textures.length; i < length; i++) {
        var texture = textures[i];

        if (texture) {
          var index = this._activeTextureCount++;
          gl.activeTexture(gl.TEXTURE0 + index);
          gl.bindTexture(texture._target, texture._glTexture);
          this._tempSamplerArray[i] = index;
        } else {
          this._tempSamplerArray[i] = -1;
        }
      }

      gl.uniform1iv(location, this._tempSamplerArray);
    }
  }, {
    key: "program",
    get: function get() {
      return this._program;
    }
    /**
     * 顶点属性数组
     */

  }, {
    key: "attributes",
    get: function get() {
      return this._attributes;
    }
    /**
     * Unifrom 参数集合
     */

  }, {
    key: "uniforms",
    get: function get() {
      return this._uniforms;
    }
  }]);

  return GLTechnique;
}(GLAsset);

/**
 * GL 层的 Technique 资源管理和渲染调用处理
 * @private
 */

var GLSpriteBatcher = /*#__PURE__*/function () {
  function GLSpriteBatcher(rhi) {
    _classCallCheck(this, GLSpriteBatcher);

    this._gl = void 0;
    this._batchedQueue = void 0;
    this._targetTexture = void 0;
    this._glSprite = void 0;
    this._glTech = void 0;
    this._material = void 0;
    this._camera = void 0;
    this._gl = rhi.gl;
    this._batchedQueue = [];
    this._targetTexture = null;
    this._glSprite = new GLSprite(rhi.gl); //-- 初始化GLTechnique

    this._glTech = new GLTechnique(rhi, SpriteTechnique);
    this._material = createSpriteMaterial();
    this._camera = null;
  }
  /**
   * 将缓存的Sprite也绘制出来
   */


  _createClass(GLSpriteBatcher, [{
    key: "flush",
    value: function flush() {
      if (this._batchedQueue.length === 0) {
        return;
      }

      if (!this._targetTexture) {
        o3Core.Logger.error("No texture!");
        return;
      }

      this._material.setValue("s_diffuse", this._targetTexture);

      this._material.setValue("matView", this._camera.viewMatrix);

      this._material.setValue("matProjection", this._camera.projectionMatrix);

      this._glTech.begin(this._material); // 绘制


      this._glSprite.beginDraw(this._batchedQueue.length);

      for (var i = 0, len = this._batchedQueue.length; i < len; i++) {
        var positionQuad = this._batchedQueue[i].positionQuad;
        var uvRect = this._batchedQueue[i].uvRect;
        var tintColor = this._batchedQueue[i].tintColor;

        this._glSprite.drawSprite(positionQuad, uvRect, tintColor);
      }

      this._glSprite.endDraw();

      this._glTech.end();

      this._batchedQueue = [];
      this._targetTexture = null;
      this._camera = null;
    }
    /**
     * 检查一个Sprite绘制的时候，能否和上一个Sprite合并绘制
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */

  }, {
    key: "canBatch",
    value: function canBatch(texture, renderMode, camera) {
      if (this._targetTexture === null) {
        return true;
      }

      return texture === this._targetTexture && camera === this._camera;
    }
    /**
     * 把一个 Sprite 绘制需要的信息传进来，完成Batch逻辑
     * @param {Object} positionQuad  Sprite四个顶点的位置
     * @param {Object} uvRect        Sprite在texture上的纹理坐标
     * @param {vec4}   tintColor     颜色
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */

  }, {
    key: "drawSprite",
    value: function drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {
      if (!this.canBatch(texture, renderMode, camera)) {
        this.flush();
      }

      this._targetTexture = texture;
      this._camera = camera;

      this._batchedQueue.push({
        positionQuad: positionQuad,
        uvRect: uvRect,
        tintColor: tintColor
      });
    }
    /**
     * 释放资源
     */

  }, {
    key: "finalize",
    value: function finalize() {
      this._glSprite.finalize();

      this._glTech.finalize();
    }
  }]);

  return GLSpriteBatcher;
}();

/**
 * 基于 VAO 的 GLPrimitive
 * */
var GLVAOPrimitive = /*#__PURE__*/function (_GLPrimitive) {
  _inherits(GLVAOPrimitive, _GLPrimitive);

  var _super = _createSuper(GLVAOPrimitive);

  function GLVAOPrimitive(rhi, primitive) {
    var _this;

    _classCallCheck(this, GLVAOPrimitive);

    _this = _super.call(this, rhi, primitive);
    _this.vao = void 0;
    _this.vao = new Map();
    return _this;
  }
  /** 注册 VAO */


  _createClass(GLVAOPrimitive, [{
    key: "registerVAO",
    value: function registerVAO(tech) {
      var gl = this.rhi.gl;
      var vao = gl.createVertexArray();
      /** register VAO */

      gl.bindVertexArray(vao);
      var indexBufferBinding = this._primitive.indexBufferBinding;

      if (indexBufferBinding) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferBinding.buffer._nativeBuffer);
      }

      this.bindBufferAndAttrib(tech);
      /** unbind */

      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      this.disableAttrib();
      this.vao.set(tech.cacheID, vao);
    }
    /**
     * 使用 VAO 执行绘制操作
     * @param {GLTechnique} tech
     */

  }, {
    key: "draw",
    value: function draw(tech) {
      var gl = this.rhi.gl;
      var primitive = this._primitive;
      /** render */

      if (!this.vao.has(tech.cacheID)) {
        this.registerVAO(tech);
      }

      var vao = this.vao.get(tech.cacheID);
      gl.bindVertexArray(vao); // draw

      var primitiveTopology = primitive.primitiveTopology,
          indexBufferBinding = primitive.indexBufferBinding,
          drawOffset = primitive.drawOffset,
          drawCount = primitive.drawCount,
          instanceCount = primitive.instanceCount,
          _glIndexType = primitive._glIndexType;

      if (!instanceCount) {
        if (indexBufferBinding) {
          gl.drawElements(primitiveTopology, drawCount, _glIndexType, drawOffset);
        } else {
          gl.drawArrays(primitiveTopology, drawOffset, drawCount);
        }
      } else {
        if (this.canUseInstancedArrays) {
          if (indexBufferBinding) {
            gl.drawElementsInstanced(primitiveTopology, drawCount, _glIndexType, drawOffset, instanceCount);
          } else {
            gl.drawArraysInstanced(primitiveTopology, drawOffset, drawCount, instanceCount);
          }
        } else {
          o3Core.Logger.error("ANGLE_instanced_arrays extension is not supported");
        }
      }

      gl.bindVertexArray(null);
    }
    /**
     * 释放 GL 资源
     */

  }, {
    key: "finalize",
    value: function finalize() {
      _get(_getPrototypeOf(GLVAOPrimitive.prototype), "finalize", this).call(this);

      var gl = this.rhi.gl; // 释放 vao

      this.vao.forEach(function (vao) {
        gl.deleteVertexArray(vao);
      });
      this.vao = null;
    }
  }]);

  return GLVAOPrimitive;
}(GLPrimitive);

/**
 * WebGLRenderer的参数选项。
 */

(function (WebGLMode) {
  WebGLMode[WebGLMode["Auto"] = 0] = "Auto";
  WebGLMode[WebGLMode["WebGL2"] = 1] = "WebGL2";
  WebGLMode[WebGLMode["WebGL1"] = 2] = "WebGL1";
})(exports.WebGLMode || (exports.WebGLMode = {}));

/**
 * WebGL渲染器实现，包含了WebGL1.0/和WebGL2.0。
 */
var WebGLRenderer = /*#__PURE__*/function () {
  _createClass(WebGLRenderer, [{
    key: "isWebGL2",

    /** 当前 RHI 是否为 WebGL 2.0 */
    get: function get() {
      return this._isWebGL2;
    }
  }]);

  function WebGLRenderer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WebGLRenderer);

    this._options = void 0;
    this._gl = void 0;
    this._renderStates = void 0;
    this._assetsCache = void 0;
    this._extensions = void 0;
    this._frameCount = void 0;
    this._spriteBatcher = void 0;
    this._capability = void 0;
    this._isWebGL2 = void 0;
    this._options = options;
  }

  _createClass(WebGLRenderer, [{
    key: "init",
    value: function init(canvas) {
      var option = this._options;
      var webCanvas = canvas._webCanvas;
      var webGLMode = option.webGLMode || exports.WebGLMode.Auto;
      var gl;

      if (webGLMode == exports.WebGLMode.Auto || webGLMode == exports.WebGLMode.WebGL2) {
        gl = webCanvas.getContext("webgl2", option);

        if (!gl && webCanvas instanceof HTMLCanvasElement) {
          gl = webCanvas.getContext("experimental-webgl2", option);
        }

        this._isWebGL2 = true;
      }

      if (!gl) {
        if (webGLMode == exports.WebGLMode.Auto || webGLMode == exports.WebGLMode.WebGL1) {
          gl = webCanvas.getContext("webgl", option);

          if (!gl && webCanvas instanceof HTMLCanvasElement) {
            gl = webCanvas.getContext("experimental-webgl", option);
          }

          this._isWebGL2 = false;
        }
      }

      if (!gl) {
        throw new Error("Get GL Context FAILED.");
      }

      this._gl = gl;
      this._renderStates = new GLRenderStates(gl);
      this._assetsCache = new GLAssetsCache(this, option);
      this._extensions = new GLExtensions(this);
      this._capability = new GLCapability(this);
      this._frameCount = 0;
      this._options = null;
    }
    /**
     * GL Context 对象
     * @member {WebGLRenderingContext}
     * @readonly
     */

  }, {
    key: "requireExtension",

    /**
     * 请求扩展
     * @param {String} ext 扩展名
     * @returns {Object|null} 请求结果，返回插件对象或null
     */
    value: function requireExtension(ext) {
      return this._extensions.requireExtension(ext);
    }
    /**
     * 查询能否使用某些 GL 能力
     * */

  }, {
    key: "canIUse",
    value: function canIUse(capabilityType) {
      return this.capability.canIUse(capabilityType);
    }
    /**
     * 查询能否使用某种压缩纹理格式
     * */

  }, {
    key: "canIUseCompressedTextureInternalFormat",
    value: function canIUseCompressedTextureInternalFormat(type) {
      return this.capability.canIUseCompressedTextureInternalFormat(type);
    }
    /** 是否能使用更多骨骼关节 */

  }, {
    key: "viewport",

    /**
     * 设置视口区域
     * @param {number} x 用来设定视口的左下角水平坐标
     * @param {number} y 用来设定视口的左下角垂直坐标
     * @param {number} width 用来设定视口的宽度
     * @param {number} height 用来设定视口的高度
     */
    value: function viewport(x, y, width, height) {
      // 开启裁剪
      // gl.enable(gl.SCISSOR_TEST);
      // gl.scissor(x, transformY, width, height);
      var gl = this._gl;
      gl.viewport(x, gl.drawingBufferHeight - y - height, width, height);
    }
  }, {
    key: "colorMask",
    value: function colorMask(r, g, b, a) {
      this._gl.colorMask(r, g, b, a);
    }
    /**
     * 在一帧的渲染开始时，处理内部状态
     */

  }, {
    key: "beginFrame",
    value: function beginFrame() {
      this._frameCount++;
    }
    /**
     * 清空渲染缓冲
     * @param {ClearMode} clearMode
     * @param {*} clearParam
     */

  }, {
    key: "clearRenderTarget",
    value: function clearRenderTarget(clearMode, clearParam) {
      var gl = this._gl;

      switch (clearMode) {
        case o3Core.ClearMode.SOLID_COLOR:
          // solid color
          gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          break;

        case o3Core.ClearMode.DEPTH_ONLY:
          // depth only
          gl.clear(gl.DEPTH_BUFFER_BIT);
          break;

        case o3Core.ClearMode.COLOR_ONLY:
          gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
          gl.clear(gl.COLOR_BUFFER_BIT);
          break;

        case o3Core.ClearMode.STENCIL_ONLY:
          gl.clear(gl.STENCIL_BUFFER_BIT);
          break;

        case o3Core.ClearMode.ALL_CLEAR:
          gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
          break;

        case o3Core.ClearMode.DONT_CLEAR:
          // dont clear
          break;
      }
    }
    /**
     * 使用指定的材质绘制一个 Primitive
     * @param {Primitive} primitive
     * @param {Material} mtl
     */

  }, {
    key: "drawPrimitive",
    value: function drawPrimitive(primitive, mtl) {
      // todo: VAO 不支持 morph 动画
      var glPrimitive = this._assetsCache.requireObject(primitive, this.canIUse(o3Core.GLCapabilityType.vertexArrayObject) && !primitive.targets.length ? GLVAOPrimitive : GLPrimitive);

      var glTech = this._assetsCache.requireObject(mtl.technique, GLTechnique);

      if (!glTech.valid) return;

      if (glPrimitive && glTech) {
        glTech.begin(mtl);
        glPrimitive.draw(glTech);
        glTech.end();
      } else {
        o3Core.Logger.error("draw primitive failed.");
      }
    }
    /**
     * 把一个 Sprite 绘制需要的信息传进来
     * @param {Object} positionQuad  Sprite四个顶点的位置
     * @param {Object} uvRect        Sprite在texture上的纹理坐标
     * @param {vec4}   tintColor     颜色
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */

  }, {
    key: "drawSprite",
    value: function drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {
      // _spriteBatcher只有在需要的时候才会创建
      if (!this._spriteBatcher) {
        this._spriteBatcher = new GLSpriteBatcher(this);
      }

      this._spriteBatcher.drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera);
    }
    /**
     * 给 SpriteRenderPass 在最后调用，确保所有 Sprite 绘制
     */

  }, {
    key: "flushSprite",
    value: function flushSprite() {
      if (this._spriteBatcher) {
        this._spriteBatcher.flush();
      }
    }
    /**
     * 激活指定的RenderTarget
     * @param {RenderTarget} renderTarget  需要被激活的RenderTarget对象，如果未设置，则渲染到屏幕帧
     */

  }, {
    key: "activeRenderTarget",
    value: function activeRenderTarget(renderTarget, camera) {
      if (renderTarget) {
        var glRenderTarget = this._assetsCache.requireObject(renderTarget, GLRenderTarget);

        glRenderTarget.activeRenderTarget();
      } else {
        var gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        var viewport = camera.viewport;
        var width = gl.drawingBufferWidth;
        var height = gl.drawingBufferHeight;
        this.viewport(viewport.x * width, viewport.y * height, viewport.z * width, viewport.w * height);
      }
    }
    /** blit FBO */

  }, {
    key: "blitRenderTarget",
    value: function blitRenderTarget(renderTarget) {
      if (renderTarget) {
        var glRenderTarget = this._assetsCache.requireObject(renderTarget, GLRenderTarget);

        glRenderTarget.blitRenderTarget();
      }
    }
    /**
     * 设置渲染到立方体纹理的面
     * @param {RenderTarget} renderTarget  需要设置的 RenderTarget 对象
     * @param {number} faceIndex - gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex
     * */

  }, {
    key: "setRenderTargetFace",
    value: function setRenderTargetFace(renderTarget, faceIndex) {
      if (renderTarget) {
        var glRenderTarget = this._assetsCache.requireObject(renderTarget, GLRenderTarget);

        glRenderTarget.setRenderTargetFace(faceIndex);
      }
    }
    /**
     * 在一帧结束时，处理内部状态，释放 texture 缓存
     */

  }, {
    key: "endFrame",
    value: function endFrame() {
      var CHECK_FREQ = 8;

      if (this._frameCount % CHECK_FREQ === 0) {
        this._assetsCache.compact();
      }
    }
    /**
     * 释放资源
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._assetsCache.finalize();
    }
  }, {
    key: "gl",
    get: function get() {
      return this._gl;
    }
    /**
     * GL 资源对象缓冲池
     */

  }, {
    key: "assetsCache",
    get: function get() {
      return this._assetsCache;
    }
    /**
     * GL 状态管理器
     */

  }, {
    key: "renderStates",
    get: function get() {
      return this._renderStates;
    }
    /**
     * GL 能力管理
     * */

  }, {
    key: "capability",
    get: function get() {
      return this._capability;
    }
    /**
     * 当前帧的计数
     */

  }, {
    key: "frameCount",
    get: function get() {
      return this._frameCount;
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get() {
      return this.capability.canIUseMoreJoints;
    }
  }]);

  return WebGLRenderer;
}();

/**
 * Web端使用的画布,可以支持HTMLCanvasElement和OffscreenCanvas。
 */

var WebCanvas = /*#__PURE__*/function () {
  _createClass(WebCanvas, [{
    key: "resizeByClientSize",

    /**
     * 根据 canvas 的 clientWidth 和 clientHeight 重置画布渲染尺寸。
     * @param pixelRatio 像素比例，若不传初次设置为设备像素比。
     */
    value: function resizeByClientSize() {
      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.devicePixelRatio;
      var webCanvas = this._webCanvas;

      if (webCanvas instanceof HTMLCanvasElement) {
        var width = webCanvas.clientWidth;
        var height = webCanvas.clientHeight;
        this.width = width * pixelRatio;
        this.height = height * pixelRatio;
      }
    }
    /**
     * 创建Web画布。
     * @param webCanvas 画布。
     */

  }, {
    key: "width",

    /**
     * @inheritdoc
     */
    get: function get() {
      return this._width;
    },
    set: function set(value) {
      if (this._width !== value) {
        this._webCanvas.width = value;
        this._width = value;
      }
    }
    /**
     * @inheritdoc
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    },
    set: function set(value) {
      if (this._height !== value) {
        this._webCanvas.height = value;
        this._height = value;
      }
    }
    /**
     * 画布的缩放比例,值为显示宽高/渲染分辨率宽高。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "scale",
    get: function get() {
      var webCanvas = this._webCanvas;

      if (webCanvas instanceof HTMLCanvasElement) {
        this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
      }

      return this._scale;
    },
    set: function set(value) {
      var webCanvas = this._webCanvas;

      if (webCanvas instanceof HTMLCanvasElement) {
        webCanvas.style.transformOrigin = "left top";
        webCanvas.style.transform = "scale(".concat(value.x, ", ").concat(value.y, ")");
      }
    }
  }]);

  function WebCanvas(webCanvas) {
    _classCallCheck(this, WebCanvas);

    this._webCanvas = void 0;
    this._width = void 0;
    this._height = void 0;
    this._scale = new o3Math.Vector2();
    var width = webCanvas.width;
    var height = webCanvas.height;
    this._webCanvas = webCanvas;
    this._width = width;
    this._height = height;
  }
  /**
   * 设置缩放
   * @param x - 沿 X 轴的缩放。
   * @param y - 沿 Y 轴的缩放。
   */


  _createClass(WebCanvas, [{
    key: "setScale",
    value: function setScale(x, y) {
      this._scale.setValue(x, y);

      this.scale = this._scale;
    }
  }]);

  return WebCanvas;
}();

/**
 * WebGL 平台引擎，渲染器包含 WebGL1.0 和 WebGL2.0。
 */

var WebGLEngine = /*#__PURE__*/function (_Engine) {
  _inherits(WebGLEngine, _Engine);

  var _super = _createSuper(WebGLEngine);

  /**
   * 创建适用于 WebGL 平台的引擎。
   * @param canvas - Web 画布
   * @param webGLRendererOptions - WebGL渲染器参数
   */
  function WebGLEngine(canvas, webGLRendererOptions) {
    _classCallCheck(this, WebGLEngine);

    var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
    var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
    return _super.call(this, webCanvas, hardwareRenderer);
  }
  /**
   * Web 画布。
   */


  _createClass(WebGLEngine, [{
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
  }]);

  return WebGLEngine;
}(o3Core.Engine);

exports.GLRenderTarget = GLRenderTarget;
exports.GLShaderProgram = GLShaderProgram;
exports.GLTechnique = GLTechnique;
exports.WebCanvas = WebCanvas;
exports.WebGLEngine = WebGLEngine;
exports.WebGLRenderer = WebGLRenderer;
//# sourceMappingURL=main.js.map
