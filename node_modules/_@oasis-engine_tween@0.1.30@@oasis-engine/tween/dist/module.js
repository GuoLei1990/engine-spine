import { Quaternion, Vector4, Vector3, Vector2, DataType } from 'oasis-engine';

class Tween {
  constructor() {
    this._nextId = 0;
    this.tweeners = {};
  }
  getId() {
    return this._nextId++;
  }
  add(tweener) {
    if (!tweener.id) {
      tweener.id = this.getId();
    }
    this.tweeners[tweener.id] = tweener;
  }
  update(deltaTime) {
    for (const tweenerId in this.tweeners) {
      const tweener = this.tweeners[tweenerId];
      tweener.update(deltaTime);
      if (tweener._played && tweener._paused && !tweener.preserved) {
        delete this.tweeners[tweenerId];
      }
    }
  }
}

const LOOP_TYPE = {
  Restart: 0,
  Yoyo: 1
};

var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
function A(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
}
function B(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
}
function C(aA1) {
  return 3 * aA1;
}
function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
function getSlope(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
function LinearEasing(x) {
  return x;
}
function bezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }
  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return function BezierEasing(x) {
    if (x === 0 || x === 1) {
      return x;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
}

function linear(t, b, c, d) {
  return c * t / d + b;
}
function easeInQuad(t, b, c, d) {
  return c * (t /= d) * t + b;
}
function easeOutQuad(t, b, c, d) {
  return -c * (t /= d) * (t - 2) + b;
}
function easeInOutQuad(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t + b;
  } else {
    return -c / 2 * (--t * (t - 2) - 1) + b;
  }
}
function easeInCubic(t, b, c, d) {
  return c * (t /= d) * t * t + b;
}
function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
function easeInOutCubic(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t + b;
  } else {
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }
}
function easeInQuart(t, b, c, d) {
  return c * (t /= d) * t * t * t + b;
}
function easeOutQuart(t, b, c, d) {
  return -c * ((t = t / d - 1) * t * t * t - 1) + b;
}
function easeInOutQuart(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t * t + b;
  } else {
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }
}
function easeInQuint(t, b, c, d) {
  return c * (t /= d) * t * t * t * t + b;
}
function easeOutQuint(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
}
function easeInOutQuint(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t * t * t + b;
  } else {
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }
}
function easeInSine(t, b, c, d) {
  return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
}
function easeOutSine(t, b, c, d) {
  return c * Math.sin(t / d * (Math.PI / 2)) + b;
}
function easeInOutSine(t, b, c, d) {
  return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
}
function easeInExpo(t, b, c, d) {
  let _ref;
  return (_ref = t === 0) !== null ? _ref : {
    b: c * Math.pow(2, 10 * (t / d - 1)) + b
  };
}
function easeOutExpo(t, b, c, d) {
  let _ref;
  return (_ref = t === d) !== null ? _ref : b + {
    c: c * (-Math.pow(2, -10 * t / d) + 1) + b
  };
}
function easeInOutExpo(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
  } else {
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }
}
function easeInCirc(t, b, c, d) {
  return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
}
function easeOutCirc(t, b, c, d) {
  return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
}
function easeInOutCirc(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
  } else {
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }
}
function easeInElastic(t, b, c, d) {
  let a, p, s;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) ; else if ((t /= d) === 1) ;
  if (!p) {
    p = d * 0.3;
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
}
function easeOutElastic(t, b, c, d) {
  let a, p, s;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) ; else if ((t /= d) === 1) ;
  if (!p) {
    p = d * 0.3;
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
}
function easeInOutElastic(t, b, c, d) {
  let a, p, s;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) ; else if ((t /= d / 2) === 2) ;
  if (!p) {
    p = d * (0.3 * 1.5);
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  if (t < 1) {
    return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  } else {
    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
  }
}
function easeInBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }
  return c * (t /= d) * t * ((s + 1) * t - s) + b;
}
function easeOutBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }
  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
}
function easeInOutBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }
  if ((t /= d / 2) < 1) {
    return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
  } else {
    return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
  }
}
function easeInBounce(t, b, c, d) {
  let v;
  v = easeOutBounce(d - t, 0, c, d);
  return c - v + b;
}
function easeOutBounce(t, b, c, d) {
  if ((t /= d) < 1 / 2.75) {
    return c * (7.5625 * t * t) + b;
  } else if (t < 2 / 2.75) {
    return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
  } else if (t < 2.5 / 2.75) {
    return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
  } else {
    return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
  }
}
function easeInOutBounce(t, b, c, d) {
  let v;
  if (t < d / 2) {
    v = easeInBounce(t * 2, 0, c, d);
    return v * 0.5 + b;
  } else {
    v = easeOutBounce(t * 2 - d, 0, c, d);
    return v * 0.5 + c * 0.5 + b;
  }
}
function bezierEasing(x1, y1, x2, y2) {
  const easing = bezier(x1, y1, x2, y2);
  return (t, b, c, d) => {
    return c * easing(t / d) + b;
  };
}

var Easing = /*#__PURE__*/Object.freeze({
  __proto__: null,
  linear: linear,
  easeInQuad: easeInQuad,
  easeOutQuad: easeOutQuad,
  easeInOutQuad: easeInOutQuad,
  easeInCubic: easeInCubic,
  easeOutCubic: easeOutCubic,
  easeInOutCubic: easeInOutCubic,
  easeInQuart: easeInQuart,
  easeOutQuart: easeOutQuart,
  easeInOutQuart: easeInOutQuart,
  easeInQuint: easeInQuint,
  easeOutQuint: easeOutQuint,
  easeInOutQuint: easeInOutQuint,
  easeInSine: easeInSine,
  easeOutSine: easeOutSine,
  easeInOutSine: easeInOutSine,
  easeInExpo: easeInExpo,
  easeOutExpo: easeOutExpo,
  easeInOutExpo: easeInOutExpo,
  easeInCirc: easeInCirc,
  easeOutCirc: easeOutCirc,
  easeInOutCirc: easeInOutCirc,
  easeInElastic: easeInElastic,
  easeOutElastic: easeOutElastic,
  easeInOutElastic: easeInOutElastic,
  easeInBack: easeInBack,
  easeOutBack: easeOutBack,
  easeInOutBack: easeInOutBack,
  easeInBounce: easeInBounce,
  easeOutBounce: easeOutBounce,
  easeInOutBounce: easeInOutBounce,
  bezierEasing: bezierEasing
});

const noop = () => {
};
class TweenerBase {
  constructor(getter, setter, endValue, interval, options = {}, target) {
    this.options = {
      id: "",
      loops: {
        count: 0,
        type: LOOP_TYPE.Yoyo
      },
      easing: linear,
      delay: 0,
      plugin: noop,
      pluginOptions: {},
      onComplete: noop,
      onTick: noop,
      ...options
    };
    this._time = 0;
    this._remainLoops = this.options.loops.count || 0;
    this._paused = true;
    this._played = false;
    this.rewind = false;
    this.preserved = false;
    this.elapsedTime = 0;
    this.startValue = getter();
    this.endValue = endValue;
    this.getter = getter;
    this.setter = setter;
    this.interval = interval;
  }
  duration() {
  }
  update(deltaTime) {
  }
  setLoops(count, type = LOOP_TYPE.Yoyo) {
    this.options.loops = {count, type};
    this._remainLoops = count;
    return this;
  }
  set(key, value) {
    this.options = {...this.options, ...{[key]: value}};
    return this;
  }
  stop() {
    this.options.onComplete(this);
    this._paused = true;
    return this;
  }
  pause() {
    if (this._paused)
      return false;
    this._paused = true;
    return this;
  }
  start(tweenManager) {
    if (tweenManager) {
      tweenManager.add(this);
    }
    if (!this._paused)
      return false;
    this.elapsedTime = 0;
    this._paused = false;
    this._played = true;
    return this;
  }
}

class Tweener extends TweenerBase {
  constructor(getter, setter, endValue, interval, options = {}, target = null) {
    super(getter, setter, endValue, interval, options, target);
  }
  duration() {
    let duration = 0;
    if (this.options.loops.count === -1) {
      duration = -1;
    } else {
      duration = this.options.delay + this.options.loops.count * this.interval;
    }
    return duration;
  }
  update(deltaTime) {
    this._time += deltaTime;
    if (!this._paused) {
      if (this.options.delay > this._time) {
        return true;
      }
      this.elapsedTime += deltaTime;
      this.elapsedTime = this.elapsedTime > this.interval ? this.interval : this.elapsedTime;
      this.options.plugin(this);
      this.options.onTick(this);
      if (this.elapsedTime === this.interval) {
        if (this._remainLoops > 0 || this._remainLoops <= -1) {
          switch (this.options.loops.type) {
            case LOOP_TYPE.Yoyo:
              this.rewind = !this.rewind;
              this.elapsedTime = 0;
              if (!this.rewind) {
                this._remainLoops--;
              }
              break;
            case LOOP_TYPE.Restart:
              this.elapsedTime = 0;
              this._remainLoops--;
              break;
          }
        } else {
          this.stop();
        }
      }
      return true;
    }
  }
}

const QuaternionPlugin = (tweener) => {
  const {easing} = tweener.options;
  const result = new Quaternion();
  const percent = easing(tweener.elapsedTime, 0, 1, tweener.interval);
  Quaternion.slerp(tweener.startValue, tweener.endValue, percent, result);
  tweener.setter(result);
};

const FloatPlugin = (tweener) => {
  const easing = tweener.options.easing;
  const result = easing(tweener.elapsedTime, tweener.startValue, tweener.endValue - tweener.startValue, tweener.interval);
  tweener.setter(result);
};

const handleVecComp = (tweener, comp, result) => {
  const easing = tweener.options.easing;
  let startValue = tweener.startValue[comp];
  let offsetValue = tweener.endValue[comp] - tweener.startValue[comp];
  if (tweener.rewind) {
    startValue = tweener.endValue[comp];
    offsetValue = tweener.startValue[comp] - tweener.endValue[comp];
  }
  result[comp] = easing(tweener.elapsedTime, startValue, offsetValue, tweener.interval);
};
const VectorPluginGenerator = (count) => {
  return (tweener) => {
    let result;
    switch (count) {
      case 2:
        result = new Vector2();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        break;
      case 3:
        result = new Vector3();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        handleVecComp(tweener, "z", result);
        break;
      default:
        result = new Vector4();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        handleVecComp(tweener, "z", result);
        handleVecComp(tweener, "w", result);
        break;
    }
    tweener.setter(result);
  };
};

const Vector2Plugin = VectorPluginGenerator(2);

const Vector3Plugin = VectorPluginGenerator(3);

const Vector4Plugin = VectorPluginGenerator(4);

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  QuaternionPlugin: QuaternionPlugin,
  FloatPlugin: FloatPlugin,
  Vector2Plugin: Vector2Plugin,
  Vector3Plugin: Vector3Plugin,
  Vector4Plugin: Vector4Plugin
});

const doTransformRotate = (obj, endValue, interval, options = {}) => {
  options.plugin = options.plugin || QuaternionPlugin;
  return new Tweener(() => obj.rotation.clone(), (value) => obj.rotation = value, endValue, interval, options, obj);
};
const doTransformTranslate = (obj, endValue, interval, options = {}) => {
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(() => obj.position.clone(), (value) => obj.position = value, endValue, interval, options, obj);
};
const doTransformScale = (obj, endValue, interval, options = {}) => {
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(() => obj.scale.clone(), (value) => obj.scale = value, endValue, interval, options, obj);
};
const doMaterialValue = (mtl, endValue, property = "", interval, options = {}) => {
  options.plugin = options.plugin || FloatPlugin;
  return new Tweener(() => mtl.getValue(property), (value) => mtl.setValue(property, value), endValue, interval, options, mtl);
};
const doMaterialColor = (mtl, endValue, property = "", interval, options = {}) => {
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(() => mtl.getValue(property), (value) => {
    mtl.setValue(property, [value[0] / 255, value[1] / 255, value[2] / 255]);
  }, endValue, interval, options, mtl);
};
const doTransformByDataType = (startValue, setter, endValue, interval, options = {}) => {
  if (options.dataType === DataType.FLOAT_VEC2) {
    options.plugin = options.plugin || Vector2Plugin;
    return new Tweener(() => startValue.clone(), setter, endValue, interval, options);
  } else if (options.dataType === DataType.FLOAT_VEC3) {
    options.plugin = options.plugin || Vector3Plugin;
    return new Tweener(() => startValue.clone(), setter, endValue, interval, options);
  } else if (options.dataType === DataType.FLOAT_VEC4) {
    options.plugin = options.plugin || Vector3Plugin;
    return new Tweener(() => startValue.clone(), setter, endValue, interval, options);
  } else {
    options.plugin = options.plugin || FloatPlugin;
    return new Tweener(() => startValue, setter, endValue, interval, options);
  }
};
const doTransform = {
  Rotate: doTransformRotate,
  Translate: doTransformTranslate,
  Scale: doTransformScale,
  DataType: doTransformByDataType
};
const doMaterial = {
  Float: doMaterialValue,
  Color: doMaterialColor
};

export { Easing, LOOP_TYPE, Tween, index as TweenPlugins, Tweener, doMaterial, doTransform };
//# sourceMappingURL=module.js.map
