{"version":3,"file":"module.js","sources":["../src/enums/IntersectInfo.ts","../src/util.ts","../src/MathUtil.ts","../src/Vector3.ts","../src/BoudingSphere.ts","../src/BoundingBox.ts","../src/Matrix3x3.ts","../src/Quaternion.ts","../src/Matrix.ts","../src/OBB.ts","../src/Ray.ts","../src/RaycastHit.ts","../src/Spherical.ts","../src/Vector2.ts","../src/Vector4.ts"],"sourcesContent":["/**\n * 相交信息\n * */\nexport enum IntersectInfo {\n  /** 分离 */\n  EXCLUDE,\n  /** 交叉 */\n  INTERSECT,\n  /** 包含 */\n  INCLUDE\n}\n","import { Matrix } from \"./Matrix\";\nimport { Vector3 } from \"./Vector3\";\nimport { Vector4 } from \"./Vector4\";\n\n/**\n * 一个点到一个平面的距离\n * @param {Vector4} plane - 平面方程\n * @param {Vector3} pt - 点的位置矢量\n * @private\n */\nexport function pointDistanceToPlane(plane: Vector4, pt: Vector3) {\n  return plane.x * pt.x + plane.y * pt.y + plane.z * pt.z + plane.w;\n}\n\n/**\n * 从列主序矩阵获取最大轴向的 scale\n * @param {Matrix} modelMatrix - Local to World矩阵\n * */\nexport function getMaxScaleByModelMatrix(modelMatrix: Matrix): number {\n  let m = modelMatrix.elements;\n  let scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];\n  let scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];\n  let scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];\n  return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n}\n","/**\n * 数学工具类。\n */\nexport class MathUtil {\n  /** 单精度浮点零容差。 */\n  static readonly zeroTolerance: number = 1e-6;\n  /** 弧度转角度的转换因子。 */\n  static readonly radToDegreeFactor: number = 180 / Math.PI;\n  /** 角度转弧度的转换因子。 */\n  static readonly degreeToRadFactor: number = Math.PI / 180;\n\n  /**\n   * 求指定范围内的值。\n   * @param v\n   * @param min\n   * @param max\n   * @returns 范围内的值\n   */\n  static clamp(v: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, v));\n  }\n\n  /**\n   * 比较两个数是否相等(大小在零容差之内就算相等)。\n   * @param a\n   * @param b\n   * @returns 两个数是否相等\n   */\n  static equals(a: number, b: number): boolean {\n    return Math.abs(a - b) <= MathUtil.zeroTolerance;\n  }\n\n  /**\n   * 判断一个数是否是 2 的幂。\n   * @param v\n   * @returns 传入的数是否是 2 的幂\n   */\n  static isPowerOf2(v: number): boolean {\n    return (v & (v - 1)) === 0;\n  }\n\n  /**\n   * 弧度转角度。\n   * @param r\n   * @returns 角度\n   */\n  static radianToDegree(r: number): number {\n    return r * MathUtil.radToDegreeFactor;\n  }\n\n  /**\n   * 角度转弧度。\n   * @param d\n   * @returns 弧度\n   */\n  static degreeToRadian(d: number): number {\n    return d * MathUtil.degreeToRadFactor;\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix } from \"./Matrix\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector4 } from \"./Vector4\";\n\n/**\n * 三维向量。\n */\nexport class Vector3 implements IClone {\n  /** @internal 零向量。*/\n  static readonly _zero = new Vector3(0.0, 0.0, 0.0);\n  /** @internal 一向量。*/\n  static readonly _one = new Vector3(1.0, 1.0, 1.0);\n  /** @internal */\n  static readonly _tempVector3 = new Vector3();\n\n  /**\n   * 将两个向量相加。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 向量相加结果\n   */\n  static add(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n  }\n\n  /**\n   * 将两个向量相减。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个三维向量的相减结果\n   */\n  static subtract(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n    out.z = left.z - right.z;\n  }\n\n  /**\n   * 将两个向量相乘。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个三维向量的相乘结果\n   */\n  static multiply(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n    out.z = left.z * right.z;\n  }\n\n  /**\n   * 将两个三维向量相除。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个三维向量的相除结果\n   */\n  static divide(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n    out.z = left.z / right.z;\n  }\n\n  /**\n   * 计算两个三维向量的点积。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @returns 两个向量的点积\n   */\n  static dot(left: Vector3, right: Vector3): number {\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n  }\n\n  /**\n   * 计算两个三维向量的叉乘。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个三维向量的叉乘结果\n   */\n  static cross(left: Vector3, right: Vector3, out: Vector3): void {\n    const ax = left.x;\n    const ay = left.y;\n    const az = left.z;\n    const bx = right.x;\n    const by = right.y;\n    const bz = right.z;\n\n    out.x = ay * bz - az * by;\n    out.y = az * bx - ax * bz;\n    out.z = ax * by - ay * bx;\n  }\n\n  /**\n   * 计算两个三维向量的距离。\n   * @param a - 向量\n   * @param b - 向量\n   * @returns 两个向量的距离\n   */\n  static distance(a: Vector3, b: Vector3): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n\n  /**\n   * 计算两个三维向量的距离的平方。\n   * @param a - 向量\n   * @param b - 向量\n   * @returns 两个向量的距离的平方\n   */\n  static distanceSquared(a: Vector3, b: Vector3): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return x * x + y * y + z * z;\n  }\n\n  /**\n   * 判断两个三维向量的值是否相等。\n   * @param left - 向量\n   * @param right - 向量\n   * @returns 两个向量是否相等，是返回 true，否则返回 false\n   */\n  static equals(left: Vector3, right: Vector3): boolean {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);\n  }\n\n  /**\n   * 插值三维向量。\n   * @param start - 向量\n   * @param end - 向量\n   * @param t - 插值比例\n   * @param out - 插值结果\n   */\n  static lerp(start: Vector3, end: Vector3, t: number, out: Vector3): void {\n    const { x, y, z } = start;\n    out.x = x + (end.x - x) * t;\n    out.y = y + (end.y - y) * t;\n    out.z = z + (end.z - z) * t;\n  }\n\n  /**\n   * 分别取两个三维向量 x、y 的最大值计算新的三维向量。\n   * @param left - 向量\n   * @param right - 向量\n   * @param out - 结果向量\n   */\n  static max(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n    out.z = Math.max(left.z, right.z);\n  }\n\n  /**\n   * 分别取两个三维向量 x、y 的最小值计算新的三维向量。\n   * @param left - 向量\n   * @param right - 向量\n   * @param out - 结果向量\n   */\n  static min(left: Vector3, right: Vector3, out: Vector3): void {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n    out.z = Math.min(left.z, right.z);\n  }\n\n  /**\n   * 将向量 a 反转的结果输出到 out。\n   * @param a - 向量\n   * @param out - 向量反转的结果\n   */\n  static negate(a: Vector3, out: Vector3): void {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n  }\n\n  /**\n   * 将向量 a 归一化的结果输出到 out。\n   * @param a - 向量\n   * @param out - 向量归一化的结果\n   */\n  static normalize(a: Vector3, out: Vector3): void {\n    const { x, y, z } = a;\n    let len: number = Math.sqrt(x * x + y * y + z * z);\n    if (len > 0) {\n      // TODO\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n    }\n  }\n\n  /**\n   * 将向量 a 缩放的结果输出到 out。\n   * @param a - 向量\n   * @param s - 缩放因子\n   * @param out - 向量缩放的结果\n   */\n  static scale(a: Vector3, s: number, out: Vector3): void {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n  }\n\n  /**\n   * 通过4x4矩阵将一个三维向量进行法线转换到另一个三维向量。\n   * @remarks\n   * 法线变换假设 w 分量为零，这导致矩阵的第四行和第四列并不使用。\n   * 最终得出的结果是一个没有位置变换的向量，但是其他变换属性均被应用。\n   * 通常这对法线向量来说比较友好，因为法线向量纯粹代表方向。\n   * @param v - 向量\n   * @param m - 转换矩阵\n   * @param out - 通过矩阵转换后的向量\n   */\n  static transformNormal(v: Vector3, m: Matrix, out: Vector3): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8];\n    out.y = x * e[1] + y * e[5] + z * e[9];\n    out.z = x * e[2] + y * e[6] + z * e[10];\n  }\n\n  /**\n   * 通过4x4矩阵将一个三维向量转换到另一个三维向量。\n   * @param v - 向量\n   * @param m - 转换矩阵\n   * @param out - 通过矩阵转换后的向量\n   */\n  static transformToVec3(v: Vector3, m: Matrix, out: Vector3): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n\n    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];\n  }\n\n  /**\n   * 通过4x4矩阵将一个三维向量转换到一个四维向量。\n   * @param v - 向量\n   * @param m - 转换矩阵\n   * @param out - 通过矩阵转换后的向量\n   */\n  static transformToVec4(v: Vector3, m: Matrix, out: Vector4): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n\n    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];\n    out.w = x * e[3] + y * e[7] + z * e[11] + e[15];\n  }\n\n  /**\n   * 通过4x4矩阵将一个三维向量转换到另一个三维向量。\n   *\n   * @remarks\n   * 坐标变换价值 w 分量为一，从变换得到的四维向量的每个分量都除以 w 分量。\n   * 这导致变换结果的 w 分量为一,向量变为齐次向量。\n   * 齐次向量在坐标变换中使用，w 分量可以安全的忽略。\n   *\n   * @param v - 向量\n   * @param m - 转换矩阵\n   * @param out - 通过矩阵转换后的向量，此向量为齐次\n   */\n  static transformCoordinate(v: Vector3, m: Matrix, out: Vector3): void {\n    const { x, y, z } = v;\n    const e = m.elements;\n    let w = x * e[3] + y * e[7] + z * e[11] + e[15];\n    w = 1.0 / w;\n\n    out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;\n    out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;\n    out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;\n  }\n\n  /**\n   * 通过四元数将一个三维向量转换到另一个三维向量。\n   * @param v - 向量\n   * @param q - 四元数\n   * @param out - 通过矩阵转换后的向量\n   */\n  static transformByQuat(v: Vector3, q: Quaternion, out: Vector3): void {\n    const { x, y, z } = v;\n    const qx = q.x;\n    const qy = q.y;\n    const qz = q.z;\n    const qw = q.w;\n\n    // calculate quat * vec\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out.x = ix * qw - iw * qx - iy * qz + iz * qy;\n    out.y = iy * qw - iw * qy - iz * qx + ix * qz;\n    out.z = iz * qw - iw * qz - ix * qy + iy * qx;\n  }\n\n  /** 向量的 X 分量。*/\n  x: number;\n  /** 向量的 Y 分量。*/\n  y: number;\n  /** 向量的 Z 分量。*/\n  z: number;\n\n  /**\n   * 创建一个 Vector3 实例。\n   * @param x - 向量的 X 分量，默认值 0\n   * @param y - 向量的 Y 分量，默认值 0\n   * @param z - 向量的 Z 分量，默认值 0\n   */\n  constructor(x: number = 0, y: number = 0, z: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  /**\n   * 设置 x, y, z 的值，并返回当前向量。\n   * @param x - 向量的 X 分量\n   * @param y - 向量的 Y 分量\n   * @param z - 向量的 Z 分量\n   * @returns 当前向量\n   */\n  setValue(x: number, y: number, z: number): Vector3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  /**\n   * 通过数组设置值，并返回当前向量。\n   * @param array - 数组\n   * @param offset - 数组偏移\n   * @returns 当前向量\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Vector3 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n\n  /**\n   * 将当前向量加上给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  add(right: Vector3): Vector3 {\n    this.x += right.x;\n    this.y += right.y;\n    this.z += right.z;\n    return this;\n  }\n\n  /**\n   * 将当前向量减去给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  subtract(right: Vector3): Vector3 {\n    this.x -= right.x;\n    this.y -= right.y;\n    this.z -= right.z;\n    return this;\n  }\n\n  /**\n   * 将当前向量乘以给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  multiply(right: Vector3): Vector3 {\n    this.x *= right.x;\n    this.y *= right.y;\n    this.z *= right.z;\n    return this;\n  }\n\n  /**\n   * 将当前向量除以给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  divide(right: Vector3): Vector3 {\n    this.x /= right.x;\n    this.y /= right.y;\n    this.z /= right.z;\n    return this;\n  }\n\n  /**\n   * 计算一个三维向量的标量长度。\n   * @returns 当前向量的标量长度\n   */\n  length(): number {\n    const { x, y, z } = this;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n\n  /**\n   * 计算一个三维向量的标量长度的平方。\n   * @returns 当前向量的标量长度的平方\n   */\n  lengthSquared(): number {\n    const { x, y, z } = this;\n    return x * x + y * y + z * z;\n  }\n\n  /**\n   * 向量反转。\n   * @returns 当前向量\n   */\n  negate(): Vector3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  /**\n   * 向量归一化。\n   * @returns 当前向量\n   */\n  normalize(): Vector3 {\n    Vector3.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * 向量缩放。\n   * @param s - 缩放因子\n   * @returns 当前向量\n   */\n  scale(s: number): Vector3 {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    return this;\n  }\n\n  /**\n   * 拷贝到数组。\n   * @param out - 数组。\n   * @param outOffset - 数组偏移。\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n  }\n\n  /**\n   * 克隆并返回一个新的三维向量对象。\n   * @returns 新的三维向量对象\n   */\n  clone(): Vector3 {\n    return new Vector3(this.x, this.y, this.z);\n  }\n\n  /**\n   * 将当前向量值拷贝给 out 向量。\n   * @param out - 目标向量\n   */\n  cloneTo(out: Vector3): Vector3 {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    return out;\n  }\n\n  /**\n   * 通过4x4矩阵将当前向量转换。\n   * @remarks\n   * 法线变换假设 w 分量为零，这导致矩阵的第四行和第四列并不使用。\n   * 最终得出的结果是一个没有位置变换的向量，但是其他变换属性均被应用。\n   * 通常这对法线向量来说比较友好，因为法线向量纯粹代表方向。\n   * @param m - 转换矩阵\n   * @returns 当前向量\n   */\n  transformNormal(m: Matrix): Vector3 {\n    Vector3.transformNormal(this, m, this);\n    return this;\n  }\n\n  /**\n   * 通过4x4矩阵将当前向量转换。\n   * @param m - 转换矩阵\n   * @returns 当前向量\n   */\n  transformToVec3(m: Matrix): Vector3 {\n    Vector3.transformToVec3(this, m, this);\n    return this;\n  }\n\n  /**\n   * 通过4x4矩阵将当前向量转换。\n   * @remarks\n   * 坐标变换价值 w 分量为一，从变换得到的四维向量的每个分量都除以 w 分量。\n   * 这导致变换结果的 w 分量为一,向量变为齐次向量。\n   * 齐次向量在坐标变换中使用，w 分量可以安全的忽略。\n\n   * @param m - 转换矩阵\n   * @returns 当前向量\n   */\n  transformCoordinate(m: Matrix): Vector3 {\n    Vector3.transformCoordinate(this, m, this);\n    return this;\n  }\n\n  /**\n   * 通过四元数将当前向量转换。\n   * @param q - 四元数\n   * @param out - 通过矩阵转换后的向量\n   */\n  transformByQuat(q: Quaternion): Vector3 {\n    Vector3.transformByQuat(this, q, this);\n    return this;\n  }\n}\n","import { IntersectInfo } from \"./enums/IntersectInfo\";\nimport { Matrix } from \"./Matrix\";\nimport { getMaxScaleByModelMatrix, pointDistanceToPlane } from \"./util\";\nimport { Vector3 } from \"./Vector3\";\nimport { Vector4 } from \"./Vector4\";\n\n/**\n * 包围球\n * */\nexport class BoundingSphere {\n  /** 本地坐标系 */\n  public center: Vector3 = new Vector3();\n  public radius: number = 0;\n  /** 世界坐标系 */\n  public centerWorld: Vector3 = new Vector3();\n  public radiusWorld: number = 0;\n\n  /**\n   * 初始化包围球, 之后可以通过 modelMatrix 缓存计算\n   * @param {Vector3} minLocal - 本地坐标系的最小坐标\n   * @param {Vector3} maxLocal - 本地坐标系的最大坐标\n   * @param {Matrix} modelMatrix - Local to World矩阵\n   * */\n  constructor(minLocal: Vector3, maxLocal: Vector3, modelMatrix: Matrix) {\n    // 先计算local\n    let distance = Vector3.distance(minLocal, maxLocal);\n    this.radius = distance * 0.5;\n\n    Vector3.add(minLocal, maxLocal, this.center);\n    this.center.scale(0.5);\n\n    // 计算world\n    this.updateByModelMatrix(modelMatrix);\n  }\n\n  /**\n   * 通过模型矩阵，和缓存的本地坐标系包围球，获取新的世界坐标系包围球\n   * @param {Matrix} modelMatrix - Local to World矩阵\n   * */\n  updateByModelMatrix(modelMatrix: Matrix) {\n    Vector3.transformCoordinate(this.center, modelMatrix, this.centerWorld);\n    this.radiusWorld = this.radius * getMaxScaleByModelMatrix(modelMatrix);\n  }\n\n  /**\n   * 获取与视锥体的 具体相交状态\n   * @param { Vector4[] } frustumPlanes - Oasis 视锥体的6个平面方程\n   * @return {IntersectInfo} 返回相交状态\n   * */\n  intersectsFrustum(frustumPlanes: Vector4[]): IntersectInfo {\n    for (let i = 0; i < 6; i++) {\n      const distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);\n      if (distance < -this.radiusWorld) {\n        return IntersectInfo.EXCLUDE;\n      }\n      if (distance < this.radiusWorld) {\n        return IntersectInfo.INTERSECT;\n      }\n    }\n\n    return IntersectInfo.INCLUDE;\n  }\n\n  /**\n   * 是否在视锥体内部（包含或者交叉）\n   * @param { Vector4[] } frustumPlanes - Oasis 视锥体的6个平面方程\n   * @return {boolean}\n   * */\n  isInFrustum(frustumPlanes: Vector4[]): boolean {\n    for (let i = 0; i < 6; i++) {\n      const distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);\n      if (distance < -this.radiusWorld) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { IntersectInfo } from \"./enums/IntersectInfo\";\nimport { pointDistanceToPlane } from \"./util\";\nimport { Vector3 } from \"./Vector3\";\nimport { Vector4 } from \"./Vector4\";\n\n/**\n * 轴对齐的包围盒(Axis Aligned Bound Box)\n * */\nexport class BoundingBox implements IClone {\n  public min: Vector3 = new Vector3();\n  public max: Vector3 = new Vector3();\n\n  /**\n   * AABB 的 min/max 基于世界坐标系，且不能通过 modelMatrix 缓存计算\n   * @param {Vector3} minWorld - 世界坐标系的最小坐标\n   * @param {Vector3} maxWorld - 世界坐标系的最大坐标\n   * */\n  constructor(minWorld: Vector3, maxWorld: Vector3) {\n    this.update(minWorld, maxWorld);\n  }\n\n  /**\n   * 更新 AABB\n   * @param {Vector3} minWorld - 世界坐标系的最小坐标\n   * @param {Vector3} maxWorld - 世界坐标系的最大坐标\n   * */\n  update(minWorld: Vector3, maxWorld: Vector3) {\n    minWorld.cloneTo(this.min);\n    maxWorld.cloneTo(this.max);\n  }\n\n  /**\n   * 使用中心点和 Size 的方式来计算 AABB 包围盒\n   * @param {Vector3} center - 包围盒的中心点\n   * @param {Vector3} size - 包围盒的3个轴向的大小\n   */\n  setFromCenterAndSize(center: Vector3, size: Vector3) {\n    let halfSize = new Vector3();\n    Vector3.scale(size, 0.5, halfSize);\n\n    Vector3.subtract(center, halfSize, this.min);\n    Vector3.add(center, halfSize, this.max);\n  }\n\n  /**\n   * 获取与视锥体的 具体相交状态\n   * @param { Vector4[] } frustumPlanes - Oasis 视锥体的6个平面方程\n   * @return {IntersectInfo} 返回相交状态\n   * */\n  intersectsFrustum(frustumPlanes: Vector4[]): IntersectInfo {\n    const { min, max } = this;\n    const p1: Vector3 = new Vector3();\n    const p2: Vector3 = new Vector3();\n\n    for (let i = 0; i < 6; i++) {\n      const plane: Vector4 = frustumPlanes[i];\n      p1.x = plane.x > 0 ? min.x : max.x;\n      p2.x = plane.x > 0 ? max.x : min.x;\n      p1.y = plane.y > 0 ? min.y : max.y;\n      p2.y = plane.y > 0 ? max.y : min.y;\n      p1.z = plane.z > 0 ? min.z : max.z;\n      p2.z = plane.z > 0 ? max.z : min.z;\n\n      const d1 = pointDistanceToPlane(plane, p1);\n      const d2 = pointDistanceToPlane(plane, p2);\n\n      // 视锥体外\n      if (d1 < 0 && d2 < 0) {\n        return IntersectInfo.EXCLUDE;\n      }\n      // 相交视锥体\n      if (d1 < 0 || d2 < 0) {\n        return IntersectInfo.INTERSECT;\n      }\n    }\n\n    return IntersectInfo.INCLUDE;\n  }\n\n  /**\n   * 是否在视锥体内部（包含或者交叉）\n   * @param { Vector4[] } frustumPlanes -  Oasis 视锥体的6个平面方程\n   * @return {boolean}\n   * */\n  isInFrustum(frustumPlanes: Vector4[]): boolean {\n    const min = this.min;\n    const max = this.max;\n    const p: Vector3 = new Vector3();\n\n    for (let i = 0; i < 6; i++) {\n      const plane: Vector4 = frustumPlanes[i];\n      p.x = plane.x > 0 ? max.x : min.x;\n      p.y = plane.y > 0 ? max.y : min.y;\n      p.z = plane.z > 0 ? max.z : min.z;\n\n      if (pointDistanceToPlane(plane, p) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * 克隆并返回一个新的包围盒对象。\n   * @returns 新的包围盒对象\n   */\n  clone(): BoundingBox {\n    return new BoundingBox(this.min, this.max);\n  }\n\n  /**\n   * 将当包围盒值拷贝给 out 包围盒。\n   * @param out - 目标包围盒\n   */\n  cloneTo(out: BoundingBox): void {\n    this.min.cloneTo(out.min);\n    this.max.cloneTo(out.max);\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix } from \"./Matrix\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector2 } from \"./Vector2\";\n\n/**\n * 3x3矩阵，我们采用列矩阵的模式存储\n */\nexport class Matrix3x3 implements IClone {\n  /**\n   * 将两个矩阵相加。\n   * @param left - 左矩阵\n   * @param right - 右矩阵\n   * @param out - 矩阵相加的结果\n   */\n  static add(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    oe[0] = le[0] + re[0];\n    oe[1] = le[1] + re[1];\n    oe[2] = le[2] + re[2];\n\n    oe[3] = le[3] + re[3];\n    oe[4] = le[4] + re[4];\n    oe[5] = le[5] + re[5];\n\n    oe[6] = le[6] + re[6];\n    oe[7] = le[7] + re[7];\n    oe[8] = le[8] + re[8];\n  }\n\n  /**\n   * 将两个矩阵相减。\n   * @param left - 左矩阵\n   * @param right - 右矩阵\n   * @param out - 矩阵相减的结果\n   */\n  static subtract(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    oe[0] = le[0] - re[0];\n    oe[1] = le[1] - re[1];\n    oe[2] = le[2] - re[2];\n\n    oe[3] = le[3] - re[3];\n    oe[4] = le[4] - re[4];\n    oe[5] = le[5] - re[5];\n\n    oe[6] = le[6] - re[6];\n    oe[7] = le[7] - re[7];\n    oe[8] = le[8] - re[8];\n  }\n\n  /**\n   * 将两个矩阵相乘。\n   * @param left - 左矩阵\n   * @param right - 右矩阵\n   * @param out - 矩阵相乘的结果\n   */\n  static multiply(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    const l11 = le[0],\n      l12 = le[1],\n      l13 = le[2];\n    const l21 = le[3],\n      l22 = le[4],\n      l23 = le[5];\n    const l31 = le[6],\n      l32 = le[7],\n      l33 = le[8];\n\n    const r11 = re[0],\n      r12 = re[1],\n      r13 = re[2];\n    const r21 = re[3],\n      r22 = re[4],\n      r23 = re[5];\n    const r31 = re[6],\n      r32 = re[7],\n      r33 = re[8];\n\n    oe[0] = l11 * r11 + l21 * r12 + l31 * r13;\n    oe[1] = l12 * r11 + l22 * r12 + l32 * r13;\n    oe[2] = l13 * r11 + l23 * r12 + l33 * r13;\n\n    oe[3] = l11 * r21 + l21 * r22 + l31 * r23;\n    oe[4] = l12 * r21 + l22 * r22 + l32 * r23;\n    oe[5] = l13 * r21 + l23 * r22 + l33 * r23;\n\n    oe[6] = l11 * r31 + l21 * r32 + l31 * r33;\n    oe[7] = l12 * r31 + l22 * r32 + l32 * r33;\n    oe[8] = l13 * r31 + l23 * r32 + l33 * r33;\n  }\n\n  /**\n   * 判断两个矩阵的值是否相等。\n   * @param left - 左矩阵\n   * @param right - 右矩阵\n   * @returns 两个矩阵是否相等，是返回 true，否则返回 false\n   */\n  static equals(left: Matrix3x3, right: Matrix3x3): boolean {\n    const le = left.elements;\n    const re = right.elements;\n\n    return (\n      MathUtil.equals(le[0], re[0]) &&\n      MathUtil.equals(le[1], re[1]) &&\n      MathUtil.equals(le[2], re[2]) &&\n      MathUtil.equals(le[3], re[3]) &&\n      MathUtil.equals(le[4], re[4]) &&\n      MathUtil.equals(le[5], re[5]) &&\n      MathUtil.equals(le[6], re[6]) &&\n      MathUtil.equals(le[7], re[7]) &&\n      MathUtil.equals(le[8], re[8])\n    );\n  }\n\n  /**\n   * 从四元数转换为一个3x3矩阵。\n   * @param q - 四元数\n   * @param out - 转换后的3x3矩阵\n   */\n  static rotationQuaternion(q: Quaternion, out: Matrix3x3): void {\n    const oe = out.elements;\n    const { x, y, z, w } = q;\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n\n    oe[0] = 1 - yy - zz;\n    oe[3] = yx - wz;\n    oe[6] = zx + wy;\n\n    oe[1] = yx + wz;\n    oe[4] = 1 - xx - zz;\n    oe[7] = zy - wx;\n\n    oe[2] = zx - wy;\n    oe[5] = zy + wx;\n    oe[8] = 1 - xx - yy;\n  }\n\n  /**\n   * 通过指定缩放生成3x3矩阵。\n   * @param s - 缩放向量\n   * @param out - 指定缩放后矩阵\n   */\n  static scaling(s: Vector2, out: Matrix3x3): void {\n    const oe = out.elements;\n\n    oe[0] = s.x;\n    oe[1] = 0;\n    oe[2] = 0;\n\n    oe[3] = 0;\n    oe[4] = s.y;\n    oe[5] = 0;\n\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 1;\n  }\n\n  /**\n   * 通过指定平移生成3x3矩阵。\n   * @param trans - 平移向量\n   * @param out - 指定平移后矩阵\n   */\n  static translation(trans: Vector2, out: Matrix3x3): void {\n    const oe = out.elements;\n\n    oe[0] = 1;\n    oe[1] = 0;\n    oe[2] = 0;\n\n    oe[3] = 0;\n    oe[4] = 1;\n    oe[5] = 0;\n\n    oe[6] = trans.x;\n    oe[7] = trans.y;\n    oe[8] = 1;\n  }\n\n  /**\n   * 计算矩阵 a 的逆矩阵，并将结果输出到 out。\n   * @param a - 矩阵\n   * @param out - 逆矩阵\n   */\n  static invert(a: Matrix3x3, out: Matrix3x3): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2];\n    const a21 = ae[3],\n      a22 = ae[4],\n      a23 = ae[5];\n    const a31 = ae[6],\n      a32 = ae[7],\n      a33 = ae[8];\n\n    const b12 = a33 * a22 - a23 * a32;\n    const b22 = -a33 * a21 + a23 * a31;\n    const b32 = a32 * a21 - a22 * a31;\n\n    let det = a11 * b12 + a12 * b22 + a13 * b32;\n    if (!det) {\n      return;\n    }\n    det = 1.0 / det;\n\n    oe[0] = b12 * det;\n    oe[1] = (-a33 * a12 + a13 * a32) * det;\n    oe[2] = (a23 * a12 - a13 * a22) * det;\n\n    oe[3] = b22 * det;\n    oe[4] = (a33 * a11 - a13 * a31) * det;\n    oe[5] = (-a23 * a11 + a13 * a21) * det;\n\n    oe[6] = b32 * det;\n    oe[7] = (-a32 * a11 + a12 * a31) * det;\n    oe[8] = (a22 * a11 - a12 * a21) * det;\n  }\n\n  /**\n   * 从4x4矩阵中计算出3x3法线矩阵。\n   * @remarks 计算过程为求逆矩阵的转置矩阵。\n   * @param mat4 - 4x4矩阵\n   * @param out - 3x3法线矩阵\n   */\n  static normalMatrix(mat4: Matrix, out: Matrix3x3): void {\n    const ae = mat4.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2],\n      a14 = ae[3];\n    const a21 = ae[4],\n      a22 = ae[5],\n      a23 = ae[6],\n      a24 = ae[7];\n    const a31 = ae[8],\n      a32 = ae[9],\n      a33 = ae[10],\n      a34 = ae[11];\n    const a41 = ae[12],\n      a42 = ae[13],\n      a43 = ae[14],\n      a44 = ae[15];\n\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n      return null;\n    }\n    det = 1.0 / det;\n\n    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;\n    oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;\n    oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;\n\n    oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;\n    oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;\n    oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;\n\n    oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;\n    oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;\n    oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;\n  }\n\n  /**\n   * 将矩阵 a 按给定角度旋转，并将结果输出到 out。\n   * @param a - 矩阵\n   * @param r - 给定的旋转角度(单位：弧度)\n   * @param out - 旋转后的矩阵\n   */\n  static rotate(a: Matrix3x3, r: number, out: Matrix3x3): void {\n    const ae = a.elements;\n    const oe = out.elements;\n    const s = Math.sin(r);\n    const c = Math.cos(r);\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2];\n    const a21 = ae[3],\n      a22 = ae[4],\n      a23 = ae[5];\n    const a31 = ae[6],\n      a32 = ae[7],\n      a33 = ae[8];\n\n    oe[0] = c * a11 + s * a21;\n    oe[1] = c * a12 + s * a22;\n    oe[2] = c * a13 + s * a23;\n\n    oe[3] = c * a21 - s * a11;\n    oe[4] = c * a22 - s * a12;\n    oe[5] = c * a23 - s * a13;\n\n    oe[6] = a31;\n    oe[7] = a32;\n    oe[8] = a33;\n  }\n\n  /**\n   * 将矩阵 a 按给定向量 v 缩放，并将结果输出到 out。\n   * @param m - 矩阵\n   * @param s - 缩放向量\n   * @param out - 缩放后的矩阵\n   */\n  static scale(m: Matrix3x3, s: Vector2, out: Matrix3x3): void {\n    const { x, y } = s;\n    const ae = m.elements;\n    const oe = out.elements;\n\n    oe[0] = x * ae[0];\n    oe[1] = x * ae[1];\n    oe[2] = x * ae[2];\n\n    oe[3] = y * ae[3];\n    oe[4] = y * ae[4];\n    oe[5] = y * ae[5];\n\n    oe[6] = ae[6];\n    oe[7] = ae[7];\n    oe[8] = ae[8];\n  }\n\n  /**\n   * 将矩阵 a 按给定向量 v 转换，并将结果输出到 out。\n   * @param m - 矩阵\n   * @param trans - 转换向量\n   * @param out - 转换后的结果\n   */\n  static translate(m: Matrix3x3, trans: Vector2, out: Matrix3x3): void {\n    const { x, y } = trans;\n    const ae = m.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2];\n    const a21 = ae[3],\n      a22 = ae[4],\n      a23 = ae[5];\n    const a31 = ae[6],\n      a32 = ae[7],\n      a33 = ae[8];\n\n    oe[0] = a11;\n    oe[1] = a12;\n    oe[2] = a13;\n\n    oe[3] = a21;\n    oe[4] = a22;\n    oe[5] = a23;\n\n    oe[6] = x * a11 + y * a21 + a31;\n    oe[7] = x * a12 + y * a22 + a32;\n    oe[8] = x * a13 + y * a23 + a33;\n  }\n\n  /**\n   * 计算矩阵 a 的转置矩阵，并将结果输出到 out。\n   * @param a - 矩阵\n   * @param out - 转置矩阵\n   */\n  static transpose(a: Matrix3x3, out: Matrix3x3): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    if (out === a) {\n      const a12 = ae[1];\n      const a13 = ae[2];\n      const a23 = ae[5];\n      oe[1] = ae[3];\n      oe[2] = ae[6];\n      oe[3] = a12;\n      oe[5] = ae[7];\n      oe[6] = a13;\n      oe[7] = a23;\n    } else {\n      oe[0] = ae[0];\n      oe[1] = ae[3];\n      oe[2] = ae[6];\n\n      oe[3] = ae[1];\n      oe[4] = ae[4];\n      oe[5] = ae[7];\n\n      oe[6] = ae[2];\n      oe[7] = ae[5];\n      oe[8] = ae[8];\n    }\n  }\n\n  /**\n   * 矩阵元素数组，采用列矩阵的模式存储。\n   * @remarks\n   * elements[0] 表示第 1 列第 1 行 m11\n   * elements[1] 表示第 1 列第 2 行 m12\n   * elements[2] 表示第 1 列第 3 行 m13\n   * elements[3] 表示第 2 列第 1 行 m21\n   * 依次类推\n   */\n  elements: Float32Array = new Float32Array(9);\n\n  /**\n   * 创建3x3矩阵实例，默认创建单位矩阵，采用列矩阵的模式存储。\n   * @param m11 - 默认值1 column 1, row 1\n   * @param m12 - 默认值0 column 1, row 2\n   * @param m13 - 默认值0 column 1, row 3\n   * @param m21 - 默认值0 column 2, row 1\n   * @param m22 - 默认值1 column 2, row 2\n   * @param m23 - 默认值0 column 2, row 3\n   * @param m31 - 默认值0 column 3, row 1\n   * @param m32 - 默认值0 column 3, row 2\n   * @param m33 - 默认值1 column 3, row 3\n   */\n  constructor(\n    m11: number = 1,\n    m12: number = 0,\n    m13: number = 0,\n    m21: number = 0,\n    m22: number = 1,\n    m23: number = 0,\n    m31: number = 0,\n    m32: number = 0,\n    m33: number = 1\n  ) {\n    const e: Float32Array = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n\n    e[3] = m21;\n    e[4] = m22;\n    e[5] = m23;\n\n    e[6] = m31;\n    e[7] = m32;\n    e[8] = m33;\n  }\n\n  /**\n   * 给矩阵设置值，并返回当前值。\n   * @param m11\n   * @param m12\n   * @param m13\n   * @param m21\n   * @param m22\n   * @param m23\n   * @param m31\n   * @param m32\n   * @param m33\n   * @returns 当前矩阵\n   */\n  setValue(\n    m11: number,\n    m12: number,\n    m13: number,\n    m21: number,\n    m22: number,\n    m23: number,\n    m31: number,\n    m32: number,\n    m33: number\n  ): Matrix3x3 {\n    const e: Float32Array = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n\n    e[3] = m21;\n    e[4] = m22;\n    e[5] = m23;\n\n    e[6] = m31;\n    e[7] = m32;\n    e[8] = m33;\n\n    return this;\n  }\n\n  /**\n   * 通过数组设置值，并返回当前矩阵。\n   * @param array - 数组\n   * @param offset - 数组偏移\n   * @returns 当前矩阵\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Matrix3x3 {\n    const srce = this.elements;\n    for (let i = 0; i < 12; i++) {\n      srce[i] = array[i + offset];\n    }\n    return this;\n  }\n\n  /**\n   * 从4x4矩阵转换为一个3x3矩阵，upper-left 原则，即忽略第4行第4列。\n   * @param a - 4x4矩阵\n   * @returns 当前矩阵\n   */\n  setValueByMatrix(a: Matrix): Matrix3x3 {\n    const ae = a.elements;\n    const e = this.elements;\n\n    e[0] = ae[0];\n    e[1] = ae[1];\n    e[2] = ae[2];\n\n    e[3] = ae[4];\n    e[4] = ae[5];\n    e[5] = ae[6];\n\n    e[6] = ae[8];\n    e[7] = ae[9];\n    e[8] = ae[10];\n\n    return this;\n  }\n\n  /**\n   * 拷贝到数组。\n   * @param out - 数组。\n   * @param outOffset - 数组偏移。\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    const e = this.elements;\n\n    out[outOffset] = e[0];\n    out[outOffset + 1] = e[1];\n    out[outOffset + 2] = e[2];\n    out[outOffset + 3] = e[3];\n    out[outOffset + 4] = e[4];\n    out[outOffset + 5] = e[5];\n    out[outOffset + 6] = e[6];\n    out[outOffset + 7] = e[7];\n    out[outOffset + 8] = e[8];\n  }\n\n  /**\n   * 创建一个新的矩阵，并用当前矩阵值初始化。\n   * @returns 一个新的矩阵，并且拷贝当前矩阵的值\n   */\n  clone(): Matrix3x3 {\n    const e = this.elements;\n    let ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);\n    return ret;\n  }\n\n  /**\n   * 将当前矩阵值拷贝给 out 矩阵。\n   * @param out - 目标矩阵\n   */\n  cloneTo(out: Matrix3x3): Matrix3x3 {\n    const e = this.elements;\n    const oe = out.elements;\n\n    oe[0] = e[0];\n    oe[1] = e[1];\n    oe[2] = e[2];\n\n    oe[3] = e[3];\n    oe[4] = e[4];\n    oe[5] = e[5];\n\n    oe[6] = e[6];\n    oe[7] = e[7];\n    oe[8] = e[8];\n\n    return out;\n  }\n\n  /**\n   * 将当前矩阵加上给定的向量 right，并返回当前矩阵。\n   * @param right - 给定的向量，右操作数\n   * @returns 当前矩阵\n   */\n  add(right: Matrix3x3): Matrix3x3 {\n    Matrix3x3.add(this, right, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵减去给定的向量 right，并返回当前矩阵。\n   * @param right - 给定的向量，右操作数\n   * @returns 当前矩阵\n   */\n  subtract(right: Matrix3x3): Matrix3x3 {\n    Matrix3x3.subtract(this, right, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵乘以给定的向量 right，并返回当前矩阵。\n   * @param right - 给定的向量，右操作数\n   * @returns 当前矩阵\n   */\n  multiply(right: Matrix3x3): Matrix3x3 {\n    Matrix3x3.multiply(this, right, this);\n    return this;\n  }\n\n  /**\n   * 计算3x3矩阵的行列式。\n   * @returns 当前矩阵的行列式\n   */\n  determinant(): number {\n    const e = this.elements;\n\n    const a11 = e[0],\n      a12 = e[1],\n      a13 = e[2];\n    const a21 = e[3],\n      a22 = e[4],\n      a23 = e[5];\n    const a31 = e[6],\n      a32 = e[7],\n      a33 = e[8];\n\n    const b12 = a33 * a22 - a23 * a32;\n    const b22 = -a33 * a21 + a23 * a31;\n    const b32 = a32 * a21 - a22 * a31;\n\n    return a11 * b12 + a12 * b22 + a13 * b32;\n  }\n\n  /**\n   * 将矩阵设置为单位矩阵，并返回。\n   * @returns 当前矩阵\n   */\n  identity(): Matrix3x3 {\n    const e = this.elements;\n\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n\n    e[3] = 0;\n    e[4] = 1;\n    e[5] = 0;\n\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 1;\n\n    return this;\n  }\n\n  /**\n   * 计算当前矩阵的逆矩阵，并返回。\n   * @returns 当前矩阵\n   */\n  invert(): Matrix3x3 {\n    Matrix3x3.invert(this, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵按给定角度旋转，并返回。\n   * @param r - 给定的旋转角度(单位：弧度)\n   * @returns 当前矩阵\n   */\n  rotate(r: number): Matrix3x3 {\n    Matrix3x3.rotate(this, r, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵按给定向量 v 缩放，并返回。\n   * @param s - 缩放向量\n   * @returns 当前矩阵\n   */\n  scale(s: Vector2): Matrix3x3 {\n    Matrix3x3.scale(this, s, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵按给定向量 v 转换，并返回。\n   * @param trans - 转换向量\n   * @returns 当前矩阵\n   */\n  translate(trans: Vector2): Matrix3x3 {\n    Matrix3x3.translate(this, trans, this);\n    return this;\n  }\n\n  /**\n   * 计算当前矩阵的转置矩阵，并返回。\n   * @returns 当前矩阵\n   */\n  transpose(): Matrix3x3 {\n    Matrix3x3.transpose(this, this);\n    return this;\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix3x3 } from \"./Matrix3x3\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * 四元数。\n */\nexport class Quaternion implements IClone {\n  /** @internal */\n  static readonly _tempVector3 = new Vector3();\n\n  /**\n   * 将两个四元数相加。\n   * @param left - 左四元数\n   * @param right - 右四元数\n   * @param out - 四元数相加结果\n   */\n  static add(left: Quaternion, right: Quaternion, out: Quaternion): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n    out.w = left.w + right.w;\n  }\n\n  /**\n   * 将两个四元数相乘。\n   * @param left - 左四元数\n   * @param right - 右四元数\n   * @param out - 四元数相乘结果\n   */\n  static multiply(left: Quaternion, right: Quaternion, out: Quaternion): void {\n    const ax = left.x,\n      ay = left.y,\n      az = left.z,\n      aw = left.w;\n    const bx = right.x,\n      by = right.y,\n      bz = right.z,\n      bw = right.w;\n\n    out.x = ax * bw + aw * bx + ay * bz - az * by;\n    out.y = ay * bw + aw * by + az * bx - ax * bz;\n    out.z = az * bw + aw * bz + ax * by - ay * bx;\n    out.w = aw * bw - ax * bx - ay * by - az * bz;\n  }\n\n  /**\n   * 计算共轭四元数。\n   * @param a - 输入四元数\n   * @param out - 输出的共轭四元数\n   */\n  static conjugate(a: Quaternion, out: Quaternion): void {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n    out.w = a.w;\n  }\n\n  /**\n   * 计算两个四元数的点积。\n   * @param left - 左四元数\n   * @param right - 右四元数\n   * @returns 两个四元数的点积\n   */\n  static dot(left: Quaternion, right: Quaternion): number {\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n  }\n\n  /**\n   * 判断两个四元数是否相等。\n   * @param left - 四元数\n   * @param right - 四元数\n   * @returns 两个四元数是否相等，是返回 true，否则返回 false\n   */\n  static equals(left: Quaternion, right: Quaternion): boolean {\n    return (\n      MathUtil.equals(left.x, right.x) &&\n      MathUtil.equals(left.y, right.y) &&\n      MathUtil.equals(left.z, right.z) &&\n      MathUtil.equals(left.w, right.w)\n    );\n  }\n\n  /**\n   * 通过旋转的欧拉角设置四元数。\n   * @param axis - 旋转轴向量\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 生成的四元数\n   */\n  static rotationAxisAngle(axis: Vector3, rad: number, out: Quaternion): void {\n    const normalAxis = Quaternion._tempVector3;\n    Vector3.normalize(axis, normalAxis);\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    out.x = normalAxis.x * s;\n    out.y = normalAxis.y * s;\n    out.z = normalAxis.z * s;\n    out.w = Math.cos(rad);\n  }\n\n  /**\n   * 根据 x,y,z 轴的旋转欧拉角(弧度)生成四元数，欧拉角顺序 pitch yaw roll。\n   * @param x - 绕X轴旋转的弧度 pitch\n   * @param y - 绕Y轴旋转的弧度 yaw\n   * @param z - 绕Z轴旋转的弧度 roll\n   * @param out - 生成的四元数\n   */\n  static rotationEuler(x: number, y: number, z: number, out: Quaternion): void {\n    Quaternion.rotationYawPitchRoll(y, x, z, out);\n  }\n\n  /**\n   * 根据 yaw、pitch、roll 生成四元数\n   * @param yaw - 偏航角(单位弧度)\n   * @param pitch - 俯仰角(单位弧度)\n   * @param roll - 翻滚角(单位弧度)\n   * @param out - 生成的四元数\n   */\n  static rotationYawPitchRoll(yaw: number, pitch: number, roll: number, out: Quaternion): void {\n    const halfRoll = roll * 0.5;\n    const halfPitch = pitch * 0.5;\n    const halfYaw = yaw * 0.5;\n\n    const sinRoll = Math.sin(halfRoll);\n    const cosRoll = Math.cos(halfRoll);\n    const sinPitch = Math.sin(halfPitch);\n    const cosPitch = Math.cos(halfPitch);\n    const sinYaw = Math.sin(halfYaw);\n    const cosYaw = Math.cos(halfYaw);\n\n    const cosYawPitch = cosYaw * cosPitch;\n    const sinYawPitch = sinYaw * sinPitch;\n\n    out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n    out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n    out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;\n    out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;\n  }\n\n  /**\n   * 通过矩阵得出对应的四元数。\n   * @param m - 3x3矩阵\n   * @param out - 生成的四元数\n   */\n  static rotationMatrix3x3(m: Matrix3x3, out: Quaternion): void {\n    const me = m.elements;\n    const m11 = me[0],\n      m12 = me[1],\n      m13 = me[2];\n    const m21 = me[3],\n      m22 = me[4],\n      m23 = me[5];\n    const m31 = me[6],\n      m32 = me[7],\n      m33 = me[8];\n    const scale = m11 + m22 + m33;\n    let sqrt, half;\n\n    if (scale > 0) {\n      sqrt = Math.sqrt(scale + 1.0);\n      out.w = sqrt * 0.5;\n      sqrt = 0.5 / sqrt;\n\n      out.x = (m23 - m32) * sqrt;\n      out.y = (m31 - m13) * sqrt;\n      out.z = (m12 - m21) * sqrt;\n    } else if (m11 >= m22 && m11 >= m33) {\n      sqrt = Math.sqrt(1.0 + m11 - m22 - m33);\n      half = 0.5 / sqrt;\n\n      out.x = 0.5 * sqrt;\n      out.y = (m12 + m21) * half;\n      out.z = (m13 + m31) * half;\n      out.w = (m23 - m32) * half;\n    } else if (m22 > m33) {\n      sqrt = Math.sqrt(1.0 + m22 - m11 - m33);\n      half = 0.5 / sqrt;\n\n      out.x = (m21 + m12) * half;\n      out.y = 0.5 * sqrt;\n      out.z = (m32 + m23) * half;\n      out.w = (m31 - m13) * half;\n    } else {\n      sqrt = Math.sqrt(1.0 + m33 - m11 - m22);\n      half = 0.5 / sqrt;\n\n      out.x = (m13 + m31) * half;\n      out.y = (m23 + m32) * half;\n      out.z = 0.5 * sqrt;\n      out.w = (m12 - m21) * half;\n    }\n  }\n\n  /**\n   * 计算四元数的逆。\n   * @param a - 四元数的逆\n   * @param out - 四元数的逆\n   */\n  static invert(a: Quaternion, out: Quaternion): void {\n    const { x, y, z, w } = a;\n    const dot = x * x + y * y + z * z + w * w;\n    if (dot > MathUtil.zeroTolerance) {\n      const invDot = 1.0 / dot;\n      out.x = -x * invDot;\n      out.y = -y * invDot;\n      out.z = -z * invDot;\n      out.w = w * invDot;\n    }\n  }\n\n  /**\n   * 插值四元数。\n   * @param start - 左四元数\n   * @param end - 右四元数\n   * @param t - 插值比例 范围 0～1\n   * @param out - 插值结果\n   */\n  static lerp(start: Quaternion, end: Quaternion, t: number, out: Quaternion): void {\n    const inv = 1.0 - t;\n    if (Quaternion.dot(start, end) >= 0) {\n      out.x = start.x * inv + end.x * t;\n      out.y = start.y * inv + end.y * t;\n      out.z = start.z * inv + end.z * t;\n      out.w = start.w * inv + end.w * t;\n    } else {\n      out.x = start.x * inv - end.x * t;\n      out.y = start.y * inv - end.y * t;\n      out.z = start.z * inv - end.z * t;\n      out.w = start.w * inv - end.w * t;\n    }\n\n    out.normalize();\n  }\n\n  /**\n   * 球面插值四元数。\n   * @param start - 左四元数\n   * @param end - 右四元数\n   * @param t - 插值比例\n   * @param out - 插值结果\n   */\n  static slerp(start: Quaternion, end: Quaternion, t: number, out: Quaternion): void {\n    //CM: todo: 参照stride实现\n    const ax = start.x;\n    const ay = start.y;\n    const az = start.z;\n    const aw = start.w;\n    let bx = end.x;\n    let by = end.y;\n    let bz = end.z;\n    let bw = end.w;\n\n    let scale0, scale1;\n    // calc cosine\n    let cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > MathUtil.zeroTolerance) {\n      // standard case (slerp)\n      const omega = Math.acos(cosom);\n      const sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    }\n    // calculate final values\n    out.x = scale0 * ax + scale1 * bx;\n    out.y = scale0 * ay + scale1 * by;\n    out.z = scale0 * az + scale1 * bz;\n    out.w = scale0 * aw + scale1 * bw;\n  }\n\n  /**\n   * 将一个四元数归一化。\n   * @param a - 四元数\n   * @param out - 四元数归一化的结果\n   */\n  static normalize(a: Quaternion, out: Quaternion): void {\n    const { x, y, z, w } = a;\n    let len: number = Math.sqrt(x * x + y * y + z * z + w * w);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n      out.w = w * len;\n    }\n  }\n\n  /**\n   * 绕 X 轴旋生成转四元数。\n   * @param a - 四元数\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 旋转后的四元数\n   */\n  static rotationX(rad: number, out: Quaternion): void {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    out.x = s;\n    out.y = 0;\n    out.z = 0;\n    out.w = c;\n  }\n\n  /**\n   * 绕 Y 轴旋转生成四元数。\n   * @param a - 四元数\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 旋转后的四元数\n   */\n  static rotationY(rad: number, out: Quaternion): void {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    out.x = 0;\n    out.y = s;\n    out.z = 0;\n    out.w = c;\n  }\n\n  /**\n   * 绕 Z 轴旋转生成四元数。\n   * @param a - 四元数\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 旋转后的四元数\n   */\n  static rotationZ(rad: number, out: Quaternion): void {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n\n    out.x = 0;\n    out.y = 0;\n    out.z = s;\n    out.w = c;\n  }\n\n  /**\n   * 四元数 q 绕 X 轴旋转。\n   * @param q - 四元数\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 旋转后的四元数\n   */\n  static rotateX(q: Quaternion, rad: number, out: Quaternion): void {\n    const { x, y, z, w } = q;\n    rad *= 0.5;\n    const bx = Math.sin(rad);\n    const bw = Math.cos(rad);\n\n    out.x = x * bw + w * bx;\n    out.y = y * bw + z * bx;\n    out.z = z * bw - y * bx;\n    out.w = w * bw - x * bx;\n  }\n\n  /**\n   * 四元数 q 绕 Y 轴旋转。\n   * @param q - 四元数\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 旋转后的四元数\n   */\n  static rotateY(q: Quaternion, rad: number, out: Quaternion): void {\n    const { x, y, z, w } = q;\n    rad *= 0.5;\n    const by = Math.sin(rad);\n    const bw = Math.cos(rad);\n\n    out.x = x * bw - z * by;\n    out.y = y * bw + w * by;\n    out.z = z * bw + x * by;\n    out.w = w * bw - y * by;\n  }\n\n  /**\n   * 四元数 q 绕 Z 轴旋转。\n   * @param q - 四元数\n   * @param rad - 旋转角度(单位：弧度)\n   * @param out - 旋转后的四元数\n   */\n  static rotateZ(q: Quaternion, rad: number, out: Quaternion): void {\n    const { x, y, z, w } = q;\n    rad *= 0.5;\n    const bz = Math.sin(rad);\n    const bw = Math.cos(rad);\n\n    out.x = x * bw + y * bz;\n    out.y = y * bw - x * bz;\n    out.z = z * bw + w * bz;\n    out.w = w * bw - z * bz;\n  }\n\n  /**\n   * 将一个四元数缩放。\n   * @param a - 四元数\n   * @param s - 缩放因子\n   * @param out - 四元数缩放的结果\n   */\n  static scale(a: Quaternion, s: number, out: Quaternion): void {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n    out.w = a.w * s;\n  }\n\n  /** 四元数的 X 分量 */\n  x: number;\n  /** 四元数的 Y 分量 */\n  y: number;\n  /** 四元数的 Z 分量 */\n  z: number;\n  /** 四元数的 W 分量 */\n  w: number;\n\n  /**\n   * 创建四元数实例。\n   * @param x - 四元数的 X 分量，默认值 0\n   * @param y - 四元数的 Y 分量，默认值 0\n   * @param z - 四元数的 Z 分量，默认值 0\n   * @param w - 四元数的 W 分量，默认值 1\n   */\n  constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  /**\n   * 设置 x, y, z, w 的值。\n   * @param x - 四元数的 X 分量\n   * @param y - 四元数的 Y 分量\n   * @param z - 四元数的 Z 分量\n   * @param w - 四元数的 W 分量\n   * @returns 当前四元数\n   */\n  setValue(x: number, y: number, z: number, w: number): Quaternion {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n\n    return this;\n  }\n\n  /**\n   * 通过数组设置值，并返回当前四元数。\n   * @param array - 数组\n   * @param offset - 数组偏移\n   * @returns 当前四元数\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Quaternion {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n\n  /**\n   * 共轭四元数\n   * @returns 当前四元数\n   */\n  conjugate(): Quaternion {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n\n    return this;\n  }\n\n  /**\n   * 获取四元数的旋转轴和旋转角度(单位：弧度)。\n   * @param out - 四元数的旋转轴\n   * @returns 当前四元数的旋转角度(单位：弧度)\n   */\n  getAxisAngle(out: Vector3): number {\n    const { x, y, z } = this;\n    const length = x * x + y * y + z * z;\n\n    if (length < MathUtil.zeroTolerance) {\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n\n      return 0;\n    } else {\n      const inv = 1.0 / length;\n      out.x = this.x * inv;\n      out.y = this.y * inv;\n      out.z = this.z * inv;\n\n      return Math.acos(this.w) * 2.0;\n    }\n  }\n\n  /**\n   * 将四元数设置为单位四元数。\n   */\n  identity(): Quaternion {\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 1;\n    return this;\n  }\n\n  /**\n   * 计算一个四元数的标量长度。\n   * @returns 当前四元数的标量长度\n   */\n  length(): number {\n    const { x, y, z, w } = this;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n\n  /**\n   * 计算一个四元数的标量长度的平方。\n   * @returns 当前四元数的标量长度的平方\n   */\n  lengthSquared(): number {\n    const { x, y, z, w } = this;\n    return x * x + y * y + z * z + w * w;\n  }\n\n  /**\n   * 四元数归一化。\n   * @returns 当前四元数\n   */\n  normalize(): Quaternion {\n    Quaternion.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * 获取四元数的欧拉角(弧度)。\n   * @param out - 四元数的欧拉角(弧度)\n   * @returns 欧拉角 x->pitch y->yaw z->roll\n   */\n  toEuler(out: Vector3): Vector3 {\n    this.toYawPitchRoll(out);\n    const t = out.x;\n    out.x = out.y;\n    out.y = t;\n    return out;\n  }\n\n  /**\n   * 获取四元数的欧拉角(弧度)。\n   * @param out - 四元数的欧拉角(弧度)\n   * @returns 欧拉角 x->yaw y->pitch z->roll\n   */\n  toYawPitchRoll(out: Vector3): Vector3 {\n    const { x, y, z, w } = this;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const xy = x * y;\n    const zw = z * w;\n    const zx = z * x;\n    const yw = y * w;\n    const yz = y * z;\n    const xw = x * w;\n\n    out.y = Math.asin(2.0 * (xw - yz));\n    if (Math.cos(out.y) > MathUtil.zeroTolerance) {\n      out.z = Math.atan2(2.0 * (xy + zw), 1.0 - 2.0 * (zz + xx));\n      out.x = Math.atan2(2.0 * (zx + yw), 1.0 - 2.0 * (yy + xx));\n    } else {\n      out.z = Math.atan2(-2.0 * (xy - zw), 1.0 - 2.0 * (yy + zz));\n      out.x = 0.0;\n    }\n\n    return out;\n  }\n\n  /**\n   * 拷贝到数组。\n   * @param out - 数组。\n   * @param outOffset - 数组偏移。\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n    out[outOffset + 3] = this.w;\n  }\n\n  /**\n   * 创建一个新的四元数，并用当前四元数初始化。\n   * @returns 一个新的四元数，并且拷贝当前四元数的值\n   */\n  clone(): Quaternion {\n    return new Quaternion(this.x, this.y, this.z, this.w);\n  }\n\n  /**\n   * 将当前四元数值拷贝给 out 四元数。\n   * @param out - 目标四元数\n   */\n  cloneTo(out: Quaternion): Quaternion {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    out.w = this.w;\n    return out;\n  }\n\n  /**\n   * 绕 X 轴旋转。\n   * @param rad - 旋转角度(单位：弧度)\n   * @returns 当前四元数\n   */\n  rotateX(rad: number): Quaternion {\n    Quaternion.rotateX(this, rad, this);\n    return this;\n  }\n\n  /**\n   * 绕 Y 轴旋转。\n   * @param rad - 旋转角度(单位：弧度)\n   * @returns 当前四元数\n   */\n  rotateY(rad: number): Quaternion {\n    Quaternion.rotateY(this, rad, this);\n    return this;\n  }\n\n  /**\n   * 绕 Z 轴旋转。\n   * @param rad - 旋转角度(单位：弧度)\n   * @returns 当前四元数\n   */\n  rotateZ(rad: number): Quaternion {\n    Quaternion.rotateZ(this, rad, this);\n    return this;\n  }\n\n  /**\n   * 通过旋转的欧拉角设置当前四元数。\n   * @param axis - 旋转轴向量\n   * @param rad - 旋转角度(单位：弧度)\n   * @returns 当前四元数\n   */\n  rotationAxisAngle(axis: Vector3, rad: number): Quaternion {\n    Quaternion.rotationAxisAngle(axis, rad, this);\n    return this;\n  }\n\n  /**\n   * 与四元数相乘。\n   * @param quat - 右四元数\n   * @returns 当前四元数\n   */\n  multiply(quat: Quaternion): Quaternion {\n    Quaternion.multiply(this, quat, this);\n    return this;\n  }\n\n  /**\n   * 计算四元数的逆。\n   * @returns 当前四元数\n   */\n  invert(): Quaternion {\n    Quaternion.invert(this, this);\n    return this;\n  }\n\n  /**\n   * 计算与四元数的点积。\n   * @param quat - 右四元数\n   * @returns 点击结果\n   */\n  dot(quat: Quaternion): number {\n    return Quaternion.dot(this, quat);\n  }\n\n  /**\n   * 插值四元数。\n   * @param quat - 右四元数\n   * @param t - 插值比例 范围 0～1\n   * @returns - 插值结果\n   */\n  lerp(quat: Quaternion, t: number): Quaternion {\n    Quaternion.lerp(this, quat, t, this);\n    return this;\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix3x3 } from \"./Matrix3x3\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector3 } from \"./Vector3\";\n\n/**\n * 4x4矩阵。\n */\nexport class Matrix implements IClone {\n  /** @internal */\n  private static readonly _tempVec30: Vector3 = new Vector3();\n  /** @internal */\n  private static readonly _tempVec31: Vector3 = new Vector3();\n  /** @internal */\n  private static readonly _tempVec32: Vector3 = new Vector3();\n  /** @internal */\n  private static readonly _tempMat30: Matrix3x3 = new Matrix3x3();\n  /** @internal */\n  private static readonly _tempMat40: Matrix = new Matrix();\n\n  /** @internal 单位矩阵。*/\n  static readonly _identity: Matrix = new Matrix(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  );\n\n  /**\n   * 将两个矩阵相乘。\n   * @param left - 左矩阵\n   * @param right - 右矩阵\n   * @param out - 矩阵相乘的结果\n   */\n  static multiply(left: Matrix, right: Matrix, out: Matrix): void {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n\n    const l11 = le[0],\n      l12 = le[1],\n      l13 = le[2],\n      l14 = le[3];\n    const l21 = le[4],\n      l22 = le[5],\n      l23 = le[6],\n      l24 = le[7];\n    const l31 = le[8],\n      l32 = le[9],\n      l33 = le[10],\n      l34 = le[11];\n    const l41 = le[12],\n      l42 = le[13],\n      l43 = le[14],\n      l44 = le[15];\n\n    const r11 = re[0],\n      r12 = re[1],\n      r13 = re[2],\n      r14 = re[3];\n    const r21 = re[4],\n      r22 = re[5],\n      r23 = re[6],\n      r24 = re[7];\n    const r31 = re[8],\n      r32 = re[9],\n      r33 = re[10],\n      r34 = re[11];\n    const r41 = re[12],\n      r42 = re[13],\n      r43 = re[14],\n      r44 = re[15];\n\n    oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;\n    oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;\n    oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;\n    oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;\n\n    oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;\n    oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;\n    oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;\n    oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;\n\n    oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;\n    oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;\n    oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;\n    oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;\n\n    oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;\n    oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;\n    oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;\n    oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;\n  }\n\n  /**\n   * 判断两个矩阵的值是否相等。\n   * @param left - 左矩阵\n   * @param right - 右矩阵\n   * @returns 两个矩阵是否相等，是返回 true，否则返回 false\n   */\n  static equals(left: Matrix, right: Matrix): boolean {\n    const le = left.elements;\n    const re = right.elements;\n\n    return (\n      MathUtil.equals(le[0], re[0]) &&\n      MathUtil.equals(le[1], re[1]) &&\n      MathUtil.equals(le[2], re[2]) &&\n      MathUtil.equals(le[3], re[3]) &&\n      MathUtil.equals(le[4], re[4]) &&\n      MathUtil.equals(le[5], re[5]) &&\n      MathUtil.equals(le[6], re[6]) &&\n      MathUtil.equals(le[7], re[7]) &&\n      MathUtil.equals(le[8], re[8]) &&\n      MathUtil.equals(le[9], re[9]) &&\n      MathUtil.equals(le[10], re[10]) &&\n      MathUtil.equals(le[11], re[11]) &&\n      MathUtil.equals(le[12], re[12]) &&\n      MathUtil.equals(le[13], re[13]) &&\n      MathUtil.equals(le[14], re[14]) &&\n      MathUtil.equals(le[15], re[15])\n    );\n  }\n\n  /**\n   * 通过四元数生成旋转矩阵。\n   * @param q - 四元数\n   * @param out - 转换后的4x4矩阵\n   */\n  static rotationQuaternion(q: Quaternion, out: Matrix): void {\n    const oe = out.elements;\n    const { x, y, z, w } = q;\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    oe[0] = 1 - yy - zz;\n    oe[1] = yx + wz;\n    oe[2] = zx - wy;\n    oe[3] = 0;\n\n    oe[4] = yx - wz;\n    oe[5] = 1 - xx - zz;\n    oe[6] = zy + wx;\n    oe[7] = 0;\n\n    oe[8] = zx + wy;\n    oe[9] = zy - wx;\n    oe[10] = 1 - xx - yy;\n    oe[11] = 0;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n\n  /**\n   * 通过绕任意轴旋转生成4x4矩阵。\n   * * @param axis - 旋转轴\n   * @param r - 旋转角度\n   * @param out - 指定旋转后矩阵\n   */\n  static rotationAxisAngle(axis: Vector3, r: number, out: Matrix): void {\n    //CM：stride实现\n    const oe = out.elements;\n    let { x, y, z } = axis;\n    let len = Math.sqrt(x * x + y * y + z * z);\n    let s, c, t;\n\n    if (Math.abs(len) < MathUtil.zeroTolerance) {\n      return;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(r);\n    c = Math.cos(r);\n    t = 1 - c;\n\n    // Perform rotation-specific matrix multiplication\n    oe[0] = x * x * t + c;\n    oe[1] = y * x * t + z * s;\n    oe[2] = z * x * t - y * s;\n    oe[3] = 0;\n\n    oe[4] = x * y * t - z * s;\n    oe[5] = y * y * t + c;\n    oe[6] = z * y * t + x * s;\n    oe[7] = 0;\n\n    oe[8] = x * z * t + y * s;\n    oe[9] = y * z * t - x * s;\n    oe[10] = z * z * t + c;\n    oe[11] = 0;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n\n  /**\n   * 通过指定的旋转四元数,转换向量生成4x4矩阵。\n   * @param q - 旋转四元数\n   * @param trans - 转换向量\n   * @param out - 生成的4x4矩阵\n   */\n  static rotationTranslation(q: Quaternion, trans: Vector3, out: Matrix): void {\n    Matrix.rotationQuaternion(q, out);\n\n    const oe = out.elements;\n    oe[12] = trans.x;\n    oe[13] = trans.y;\n    oe[14] = trans.z;\n  }\n\n  /**\n   * 创建仿射矩阵。\n   * @param scale - 缩放向量\n   * @param rotation - 旋转四元数\n   * @param trans - 转换向量\n   * @param out - 生成的4x4矩阵\n   */\n  static affineTransformation(scale: Vector3, rotation: Quaternion, trans: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    const { x, y, z, w } = rotation;\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = scale.x;\n    let sy = scale.y;\n    let sz = scale.z;\n\n    oe[0] = (1 - (yy + zz)) * sx;\n    oe[1] = (xy + wz) * sx;\n    oe[2] = (xz - wy) * sx;\n    oe[3] = 0;\n\n    oe[4] = (xy - wz) * sy;\n    oe[5] = (1 - (xx + zz)) * sy;\n    oe[6] = (yz + wx) * sy;\n    oe[7] = 0;\n\n    oe[8] = (xz + wy) * sz;\n    oe[9] = (yz - wx) * sz;\n    oe[10] = (1 - (xx + yy)) * sz;\n    oe[11] = 0;\n\n    oe[12] = trans.x;\n    oe[13] = trans.y;\n    oe[14] = trans.z;\n    oe[15] = 1;\n  }\n\n  /**\n   * 通过指定缩放生成4x4矩阵。\n   * @param s - 缩放向量\n   * @param out - 指定缩放后矩阵\n   */\n  static scaling(s: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    oe[0] = s.x;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = s.y;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = s.z;\n    oe[11] = 0;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n\n  /**\n   * 通过指定平移生成4x4矩阵。\n   * @param trans - 平移向量\n   * @param out - 指定平移后矩阵\n   */\n  static translation(trans: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    oe[0] = 1;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = 1;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = 1;\n    oe[11] = 0;\n\n    oe[12] = trans.x;\n    oe[13] = trans.y;\n    oe[14] = trans.z;\n    oe[15] = 1;\n  }\n\n  /**\n   * 计算矩阵 a 的逆矩阵，并将结果输出到 out。\n   * @param a - 矩阵\n   * @param out - 逆矩阵\n   */\n  static invert(a: Matrix, out: Matrix): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    const a11 = ae[0],\n      a12 = ae[1],\n      a13 = ae[2],\n      a14 = ae[3];\n    const a21 = ae[4],\n      a22 = ae[5],\n      a23 = ae[6],\n      a24 = ae[7];\n    const a31 = ae[8],\n      a32 = ae[9],\n      a33 = ae[10],\n      a34 = ae[11];\n    const a41 = ae[12],\n      a42 = ae[13],\n      a43 = ae[14],\n      a44 = ae[15];\n\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n      return null;\n    }\n    det = 1.0 / det;\n\n    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;\n    oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;\n    oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;\n    oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;\n\n    oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;\n    oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;\n    oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;\n    oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;\n\n    oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;\n    oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;\n    oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;\n    oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;\n\n    oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;\n    oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;\n    oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;\n    oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;\n  }\n\n  /**\n   * 计算观察矩阵，基于右手坐标系。\n   * @param eye - 观察者视点位置\n   * @param target - 视点目标\n   * @param up - 向上向量\n   * @param out - 观察矩阵\n   */\n  static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix): void {\n    const oe = out.elements;\n    const xAxis: Vector3 = Matrix._tempVec30;\n    const yAxis: Vector3 = Matrix._tempVec31;\n    const zAxis: Vector3 = Matrix._tempVec32;\n\n    Vector3.subtract(eye, target, zAxis);\n    zAxis.normalize();\n    Vector3.cross(up, zAxis, xAxis);\n    xAxis.normalize();\n    Vector3.cross(zAxis, xAxis, yAxis);\n\n    oe[0] = xAxis.x;\n    oe[1] = yAxis.x;\n    oe[2] = zAxis.x;\n    oe[3] = 0;\n\n    oe[4] = xAxis.y;\n    oe[5] = yAxis.y;\n    oe[6] = zAxis.y;\n    oe[7] = 0;\n\n    oe[8] = xAxis.z;\n    oe[9] = yAxis.z;\n    oe[10] = zAxis.z;\n    oe[11] = 0;\n\n    oe[12] = -Vector3.dot(xAxis, eye);\n    oe[13] = -Vector3.dot(yAxis, eye);\n    oe[14] = -Vector3.dot(zAxis, eye);\n    oe[15] = 1;\n  }\n\n  /**\n   * 计算正交投影矩阵。\n   * @param left - 视锥左边界\n   * @param right - 视锥右边界\n   * @param bottom - 视锥底边界\n   * @param top - 视锥顶边界\n   * @param near - 视锥近边界\n   * @param far - 视锥远边界\n   * @param out - 正交投影矩阵\n   */\n  static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number, out: Matrix): void {\n    const oe = out.elements;\n    const lr = 1 / (left - right);\n    const bt = 1 / (bottom - top);\n    const nf = 1 / (near - far);\n\n    oe[0] = -2 * lr;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = -2 * bt;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = 2 * nf;\n    oe[11] = 0;\n\n    oe[12] = (left + right) * lr;\n    oe[13] = (top + bottom) * bt;\n    oe[14] = (far + near) * nf;\n    oe[15] = 1;\n  }\n\n  /**\n   * 计算透视投影矩阵。\n   * @param fovy - 视角\n   * @param aspect - 视图的宽高比\n   * @param near - 近裁面\n   * @param far - 远裁面\n   * @param out - 透视投影矩阵\n   */\n  static perspective(fovy: number, aspect: number, near: number, far: number, out: Matrix): void {\n    const oe = out.elements;\n    const f = 1.0 / Math.tan(fovy / 2);\n    const nf = 1 / (near - far);\n\n    oe[0] = f / aspect;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n\n    oe[4] = 0;\n    oe[5] = f;\n    oe[6] = 0;\n    oe[7] = 0;\n\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = (far + near) * nf;\n    oe[11] = -1;\n\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 2 * far * near * nf;\n    oe[15] = 0;\n  }\n\n  /**\n   * 将矩阵 a 按给定角度旋转，并将结果输出到 out。\n   * @param m - 矩阵\n   * @param axis - 旋转轴\n   * @param r - 给定的旋转角度\n   * @param out - 旋转后的矩阵\n   */\n  static rotateAxisAngle(m: Matrix, axis: Vector3, r: number, out: Matrix): void {\n    let { x, y, z } = axis;\n    let len = Math.sqrt(x * x + y * y + z * z);\n\n    if (Math.abs(len) < MathUtil.zeroTolerance) {\n      return;\n    }\n\n    const me = m.elements;\n    const oe = out.elements;\n    let s, c, t;\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(r);\n    c = Math.cos(r);\n    t = 1 - c;\n\n    let a11 = me[0],\n      a12 = me[1],\n      a13 = me[2],\n      a14 = me[3];\n    let a21 = me[4],\n      a22 = me[5],\n      a23 = me[6],\n      a24 = me[7];\n    let a31 = me[8],\n      a32 = me[9],\n      a33 = me[10],\n      a34 = me[11];\n\n    // Construct the elements of the rotation matrix\n    let b11 = x * x * t + c;\n    let b12 = y * x * t + z * s;\n    let b13 = z * x * t - y * s;\n    let b21 = x * y * t - z * s;\n    let b22 = y * y * t + c;\n    let b23 = z * y * t + x * s;\n    let b31 = x * z * t + y * s;\n    let b32 = y * z * t - x * s;\n    let b33 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    oe[0] = a11 * b11 + a21 * b12 + a31 * b13;\n    oe[1] = a12 * b11 + a22 * b12 + a32 * b13;\n    oe[2] = a13 * b11 + a23 * b12 + a33 * b13;\n    oe[3] = a14 * b11 + a24 * b12 + a34 * b13;\n\n    oe[4] = a11 * b21 + a21 * b22 + a31 * b23;\n    oe[5] = a12 * b21 + a22 * b22 + a32 * b23;\n    oe[6] = a13 * b21 + a23 * b22 + a33 * b23;\n    oe[7] = a14 * b21 + a24 * b22 + a34 * b23;\n\n    oe[8] = a11 * b31 + a21 * b32 + a31 * b33;\n    oe[9] = a12 * b31 + a22 * b32 + a32 * b33;\n    oe[10] = a13 * b31 + a23 * b32 + a33 * b33;\n    oe[11] = a14 * b31 + a24 * b32 + a34 * b33;\n\n    if (m !== out) {\n      // If the source and destination differ, copy the unchanged last row\n      oe[12] = me[12];\n      oe[13] = me[13];\n      oe[14] = me[14];\n      oe[15] = me[15];\n    }\n  }\n\n  /**\n   * 将矩阵 a 按给定向量 v 缩放，并将结果输出到 out。\n   * @param m - 矩阵\n   * @param s - 缩放向量\n   * @param out - 缩放后的矩阵\n   */\n  static scale(m: Matrix, s: Vector3, out: Matrix): void {\n    const me = m.elements;\n    const oe = out.elements;\n    const { x, y, z } = s;\n\n    oe[0] = me[0] * x;\n    oe[1] = me[1] * x;\n    oe[2] = me[2] * x;\n    oe[3] = me[3] * x;\n\n    oe[4] = me[4] * y;\n    oe[5] = me[5] * y;\n    oe[6] = me[6] * y;\n    oe[7] = me[7] * y;\n\n    oe[8] = me[8] * z;\n    oe[9] = me[9] * z;\n    oe[10] = me[10] * z;\n    oe[11] = me[11] * z;\n\n    oe[12] = me[12];\n    oe[13] = me[13];\n    oe[14] = me[14];\n    oe[15] = me[15];\n  }\n\n  /**\n   * 将矩阵 a 按给定向量 v 转换，并将结果输出到 out。\n   * @param m - 矩阵\n   * @param v - 转换向量\n   * @param out - 转换后的结果\n   */\n  static translate(m: Matrix, v: Vector3, out: Matrix): void {\n    const me = m.elements;\n    const oe = out.elements;\n    const { x, y, z } = v;\n\n    if (m === out) {\n      oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];\n      oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];\n      oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];\n      oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];\n    } else {\n      const a11 = me[0],\n        a12 = me[1],\n        a13 = me[2],\n        a14 = me[3];\n      const a21 = me[4],\n        a22 = me[5],\n        a23 = me[6],\n        a24 = me[7];\n      const a31 = me[8],\n        a32 = me[9],\n        a33 = me[10],\n        a34 = me[11];\n\n      (oe[0] = a11), (oe[1] = a12), (oe[2] = a13), (oe[3] = a14);\n      (oe[4] = a21), (oe[5] = a22), (oe[6] = a23), (oe[7] = a24);\n      (oe[8] = a31), (oe[9] = a32), (oe[10] = a33), (oe[11] = a34);\n\n      oe[12] = a11 * x + a21 * y + a31 * z + me[12];\n      oe[13] = a12 * x + a22 * y + a32 * z + me[13];\n      oe[14] = a13 * x + a23 * y + a33 * z + me[14];\n      oe[15] = a14 * x + a24 * y + a34 * z + me[15];\n    }\n  }\n\n  /**\n   * 计算矩阵 a 的转置矩阵，并将结果输出到 out。\n   * @param a - 矩阵\n   * @param out - 转置矩阵\n   */\n  static transpose(a: Matrix, out: Matrix): void {\n    const ae = a.elements;\n    const oe = out.elements;\n\n    if (out === a) {\n      const a12 = ae[1];\n      const a13 = ae[2];\n      const a14 = ae[3];\n      const a23 = ae[6];\n      const a24 = ae[7];\n      const a34 = ae[11];\n\n      oe[1] = ae[4];\n      oe[2] = ae[8];\n      oe[3] = ae[12];\n\n      oe[4] = a12;\n      oe[6] = ae[9];\n      oe[7] = ae[13];\n\n      oe[8] = a13;\n      oe[9] = a23;\n      oe[11] = ae[14];\n\n      oe[12] = a14;\n      oe[13] = a24;\n      oe[14] = a34;\n    } else {\n      oe[0] = ae[0];\n      oe[1] = ae[4];\n      oe[2] = ae[8];\n      oe[3] = ae[12];\n\n      oe[4] = ae[1];\n      oe[5] = ae[5];\n      oe[6] = ae[9];\n      oe[7] = ae[13];\n\n      oe[8] = ae[2];\n      oe[9] = ae[6];\n      oe[10] = ae[10];\n      oe[11] = ae[14];\n\n      oe[12] = ae[3];\n      oe[13] = ae[7];\n      oe[14] = ae[11];\n      oe[15] = ae[15];\n    }\n  }\n\n  /**\n   * 矩阵元素数组，采用列矩阵的模式存储。\n   * @remarks\n   * elements[0] 表示第 1 列第 1 行 m11\n   * elements[1] 表示第 1 列第 2 行 m12\n   * elements[2] 表示第 1 列第 3 行 m13\n   * elements[3] 表示第 1 列第 4 行 m14\n   * elements[4] 表示第 2 列第 1 行 m21\n   * 依次类推\n   */\n  elements: Float32Array = new Float32Array(16);\n\n  /**\n   * 创建4x4矩阵实例，默认创建单位矩阵，采用列矩阵的模式存储。\n   * @param m11 - 默认值 1，column 1, row 1\n   * @param m12 - 默认值 0，column 1, row 2\n   * @param m13 - 默认值 0，column 1, row 3\n   * @param m14 - 默认值 0，column 1, row 4\n   * @param m21 - 默认值 0，column 2, row 1\n   * @param m22 - 默认值 1，column 2, row 2\n   * @param m23 - 默认值 0，column 2, row 3\n   * @param m24 - 默认值 0，column 2, row 4\n   * @param m31 - 默认值 0，column 3, row 1\n   * @param m32 - 默认值 0，column 3, row 2\n   * @param m33 - 默认值 1，column 3, row 3\n   * @param m34 - 默认值 0，column 3, row 4\n   * @param m41 - 默认值 0，column 4, row 1\n   * @param m42 - 默认值 0，column 4, row 2\n   * @param m43 - 默认值 0，column 4, row 3\n   * @param m44 - 默认值 1，column 4, row 4\n   */\n  constructor(\n    m11: number = 1,\n    m12: number = 0,\n    m13: number = 0,\n    m14: number = 0,\n    m21: number = 0,\n    m22: number = 1,\n    m23: number = 0,\n    m24: number = 0,\n    m31: number = 0,\n    m32: number = 0,\n    m33: number = 1,\n    m34: number = 0,\n    m41: number = 0,\n    m42: number = 0,\n    m43: number = 0,\n    m44: number = 1\n  ) {\n    const e: Float32Array = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m14;\n\n    e[4] = m21;\n    e[5] = m22;\n    e[6] = m23;\n    e[7] = m24;\n\n    e[8] = m31;\n    e[9] = m32;\n    e[10] = m33;\n    e[11] = m34;\n\n    e[12] = m41;\n    e[13] = m42;\n    e[14] = m43;\n    e[15] = m44;\n  }\n\n  /**\n   * 给矩阵设置值，并返回当前值。\n   * @param m11 - column 1, row 1\n   * @param m12 - column 1, row 2\n   * @param m13 - column 1, row 3\n   * @param m14 - column 1, row 4\n   * @param m21 - column 2, row 1\n   * @param m22 - column 2, row 2\n   * @param m23 - column 2, row 3\n   * @param m24 - column 2, row 4\n   * @param m31 - column 3, row 1\n   * @param m32 - column 3, row 2\n   * @param m33 - column 3, row 3\n   * @param m34 - column 3, row 4\n   * @param m41 - column 4, row 1\n   * @param m42 - column 4, row 2\n   * @param m43 - column 4, row 3\n   * @param m44 - column 4, row 4\n   * @returns 当前矩阵\n   */\n  setValue(\n    m11: number,\n    m12: number,\n    m13: number,\n    m14: number,\n    m21: number,\n    m22: number,\n    m23: number,\n    m24: number,\n    m31: number,\n    m32: number,\n    m33: number,\n    m34: number,\n    m41: number,\n    m42: number,\n    m43: number,\n    m44: number\n  ): Matrix {\n    const e = this.elements;\n\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m14;\n\n    e[4] = m21;\n    e[5] = m22;\n    e[6] = m23;\n    e[7] = m24;\n\n    e[8] = m31;\n    e[9] = m32;\n    e[10] = m33;\n    e[11] = m34;\n\n    e[12] = m41;\n    e[13] = m42;\n    e[14] = m43;\n    e[15] = m44;\n\n    return this;\n  }\n\n  /**\n   * 通过数组设置值，并返回当前矩阵。\n   * @param array - 数组\n   * @param offset - 数组偏移\n   * @returns 当前矩阵\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Matrix {\n    const srce = this.elements;\n    for (let i = 0; i < 16; i++) {\n      srce[i] = array[i + offset];\n    }\n    return this;\n  }\n\n  /**\n   * 拷贝到数组。\n   * @param out - 数组。\n   * @param outOffset - 数组偏移。\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    const e = this.elements;\n\n    out[outOffset] = e[0];\n    out[outOffset + 1] = e[1];\n    out[outOffset + 2] = e[2];\n    out[outOffset + 3] = e[3];\n    out[outOffset + 4] = e[4];\n    out[outOffset + 5] = e[5];\n    out[outOffset + 6] = e[6];\n    out[outOffset + 7] = e[7];\n    out[outOffset + 8] = e[8];\n    out[outOffset + 9] = e[9];\n    out[outOffset + 10] = e[10];\n    out[outOffset + 11] = e[11];\n    out[outOffset + 12] = e[12];\n    out[outOffset + 13] = e[13];\n    out[outOffset + 14] = e[14];\n    out[outOffset + 15] = e[15];\n  }\n\n  /**\n   * 创建一个新的矩阵，并用当前矩阵值初始化。\n   * @returns 一个新的矩阵，并且拷贝当前矩阵的值\n   */\n  clone(): Matrix {\n    const e = this.elements;\n    let ret = new Matrix(\n      e[0],\n      e[1],\n      e[2],\n      e[3],\n      e[4],\n      e[5],\n      e[6],\n      e[7],\n      e[8],\n      e[9],\n      e[10],\n      e[11],\n      e[12],\n      e[13],\n      e[14],\n      e[15]\n    );\n    return ret;\n  }\n\n  /**\n   * 将当前矩阵值拷贝给 out 矩阵。\n   * @param out - 目标矩阵\n   */\n  cloneTo(out: Matrix): Matrix {\n    const e = this.elements;\n    const oe = out.elements;\n\n    oe[0] = e[0];\n    oe[1] = e[1];\n    oe[2] = e[2];\n    oe[3] = e[3];\n\n    oe[4] = e[4];\n    oe[5] = e[5];\n    oe[6] = e[6];\n    oe[7] = e[7];\n\n    oe[8] = e[8];\n    oe[9] = e[9];\n    oe[10] = e[10];\n    oe[11] = e[11];\n\n    oe[12] = e[12];\n    oe[13] = e[13];\n    oe[14] = e[14];\n    oe[15] = e[15];\n\n    return out;\n  }\n\n  /**\n   * 将当前矩阵乘以给定的向量 right，并返回当前矩阵。\n   * @param right - 给定的向量，右操作数\n   * @returns 当前矩阵\n   */\n  multiply(right: Matrix): Matrix {\n    Matrix.multiply(this, right, this);\n    return this;\n  }\n\n  /**\n   * 计算4x4矩阵的行列式。\n   * @returns 当前矩阵的行列式\n   */\n  determinant(): number {\n    const e = this.elements;\n\n    const a11 = e[0],\n      a12 = e[1],\n      a13 = e[2],\n      a14 = e[3];\n    const a21 = e[4],\n      a22 = e[5],\n      a23 = e[6],\n      a24 = e[7];\n    const a31 = e[8],\n      a32 = e[9],\n      a33 = e[10],\n      a34 = e[11];\n    const a41 = e[12],\n      a42 = e[13],\n      a43 = e[14],\n      a44 = e[15];\n\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  }\n\n  /**\n   * 将矩阵分解为平移向量、旋转四元数、缩放向量。\n   * @param pos - 平移向量\n   * @param q - 旋转四元数\n   * @param s - 缩放向量\n   * @returns 是否可以分解。\n   */\n  decompose(pos: Vector3, q: Quaternion, s: Vector3): boolean {\n    const rm: Matrix3x3 = Matrix._tempMat30;\n\n    const e = this.elements;\n    const rme = rm.elements;\n\n    const m11 = e[0];\n    const m12 = e[1];\n    const m13 = e[2];\n    const m14 = e[3];\n    const m21 = e[4];\n    const m22 = e[5];\n    const m23 = e[6];\n    const m24 = e[7];\n    const m31 = e[8];\n    const m32 = e[9];\n    const m33 = e[10];\n    const m34 = e[11];\n\n    pos.x = e[12];\n    pos.y = e[13];\n    pos.z = e[14];\n\n    const xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;\n    const ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;\n    const zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;\n\n    const sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n    const sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n    const sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n\n    s.x = sx;\n    s.y = sy;\n    s.z = sz;\n\n    if (\n      Math.abs(sx) < MathUtil.zeroTolerance ||\n      Math.abs(sy) < MathUtil.zeroTolerance ||\n      Math.abs(sz) < MathUtil.zeroTolerance\n    ) {\n      q.identity();\n      return false;\n    } else {\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n\n      rme[0] = m11 * invSX;\n      rme[1] = m12 * invSX;\n      rme[2] = m13 * invSX;\n      rme[3] = m21 * invSY;\n      rme[4] = m22 * invSY;\n      rme[5] = m23 * invSY;\n      rme[6] = m31 * invSZ;\n      rme[7] = m32 * invSZ;\n      rme[8] = m33 * invSZ;\n      Quaternion.rotationMatrix3x3(rm, q);\n      return true;\n    }\n  }\n\n  /**\n   * 从矩阵中返回表示旋转的四元数。\n   * @param a - 转换矩阵\n   * @param out - 表示旋转的四元数\n   * @returns 当前矩阵的旋转四元数\n   */\n  getRotation(out: Quaternion): Quaternion {\n    const e = this.elements;\n    let trace = e[0] + e[5] + e[10];\n\n    if (trace > MathUtil.zeroTolerance) {\n      let S = Math.sqrt(trace + 1.0) * 2;\n      out.w = 0.25 * S;\n      out.x = (e[6] - e[9]) / S;\n      out.y = (e[8] - e[2]) / S;\n      out.z = (e[1] - e[4]) / S;\n    } else if (e[0] > e[5] && e[0] > e[10]) {\n      let S = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;\n      out.w = (e[6] - e[9]) / S;\n      out.x = 0.25 * S;\n      out.y = (e[1] + e[4]) / S;\n      out.z = (e[8] + e[2]) / S;\n    } else if (e[5] > e[10]) {\n      let S = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;\n      out.w = (e[8] - e[2]) / S;\n      out.x = (e[1] + e[4]) / S;\n      out.y = 0.25 * S;\n      out.z = (e[6] + e[9]) / S;\n    } else {\n      let S = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;\n      out.w = (e[1] - e[4]) / S;\n      out.x = (e[8] + e[2]) / S;\n      out.y = (e[6] + e[9]) / S;\n      out.z = 0.25 * S;\n    }\n\n    return out;\n  }\n\n  /**\n   * 从矩阵中返回缩放向量。\n   * @param out - 缩放向量\n   * @returns 当前矩阵的缩放向量\n   */\n  getScaling(out: Vector3): Vector3 {\n    //getScale()\n    const e = this.elements;\n    const m11 = e[0],\n      m12 = e[1],\n      m13 = e[2];\n    const m21 = e[4],\n      m22 = e[5],\n      m23 = e[6];\n    const m31 = e[8],\n      m32 = e[9],\n      m33 = e[10];\n\n    out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n    out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n    out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n\n    return out;\n  }\n\n  /**\n   * 从矩阵中返回转换向量。\n   * @param out - 转换向量\n   * @returns 当前矩阵的转换向量\n   */\n  getTranslation(out: Vector3): Vector3 {\n    const e = this.elements;\n\n    out.x = e[12];\n    out.y = e[13];\n    out.z = e[14];\n\n    return out;\n  }\n\n  /**\n   * 将矩阵设置为单位矩阵。\n   * @returns 当前矩阵\n   */\n  identity(): Matrix {\n    const e = this.elements;\n\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 0;\n\n    e[4] = 0;\n    e[5] = 1;\n    e[6] = 0;\n    e[7] = 0;\n\n    e[8] = 0;\n    e[9] = 0;\n    e[10] = 1;\n    e[11] = 0;\n\n    e[12] = 0;\n    e[13] = 0;\n    e[14] = 0;\n    e[15] = 1;\n\n    return this;\n  }\n\n  /**\n   * 计算当前矩阵的逆矩阵，并返回。\n   * @returns 当前矩阵\n   */\n  invert(): Matrix {\n    Matrix.invert(this, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵按给定角度旋转，并返回。\n   * @param axis - 旋转轴\n   * @param r - 给定的旋转角度\n   * @returns 当前矩阵\n   */\n  rotateAxisAngle(axis: Vector3, r: number): Matrix {\n    Matrix.rotateAxisAngle(this, axis, r, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵按给定向量 v 缩放，并返回。\n   * @param s\n   * @returns 当前矩阵\n   */\n  scale(s: Vector3): Matrix {\n    Matrix.scale(this, s, this);\n    return this;\n  }\n\n  /**\n   * 将当前矩阵按给定向量 v 转换，并返回。\n   * @param v - 转换向量\n   * @returns 当前矩阵\n   */\n  translate(v: Vector3): Matrix {\n    Matrix.translate(this, v, this);\n    return this;\n  }\n\n  /**\n   * 计算当前矩阵的转置矩阵，并返回。\n   * @returns 当前矩阵\n   */\n  transpose(): Matrix {\n    Matrix.transpose(this, this);\n    return this;\n  }\n}\n","import { IntersectInfo } from \"./enums/IntersectInfo\";\nimport { Matrix } from \"./Matrix\";\nimport { pointDistanceToPlane } from \"./util\";\nimport { Vector3 } from \"./Vector3\";\nimport { Vector4 } from \"./Vector4\";\n\n/**\n * 方向包围盒(Oriented Bounding Box)\n * */\nexport class OBB {\n  private static _tempVec3: Vector3 = new Vector3();\n\n  /** 本地坐标系 */\n  public min: Vector3 = new Vector3();\n  public max: Vector3 = new Vector3();\n  public corners: Vector3[] = [];\n  /** 世界坐标系 */\n  public minWorld: Vector3 = new Vector3();\n  public maxWorld: Vector3 = new Vector3();\n  public cornersWorld: Vector3[] = [];\n\n  /**\n   * 初始化 OBB, 之后可以通过 modelMatrix 缓存计算\n   * @param {Vector3} minLocal - 本地坐标系的最小坐标\n   * @param {Vector3} maxLocal - 本地坐标系的最大坐标\n   * @param {Matrix} modelMatrix - Local to World矩阵\n   * */\n  constructor(minLocal: Vector3, maxLocal: Vector3, modelMatrix: Matrix) {\n    minLocal.cloneTo(this.min);\n    maxLocal.cloneTo(this.max);\n\n    this.corners = this.getCornersFromMinMax(minLocal, maxLocal);\n\n    // world\n    this.updateByModelMatrix(modelMatrix);\n  }\n\n  /**\n   * 根据 min/max ,取得八个顶点的位置\n   * @param {Vector3} min - 最小坐标\n   * @param {Vector3} max - 最大坐标\n   */\n  getCornersFromMinMax(min: Vector3, max: Vector3) {\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const corners = [\n      new Vector3(minX, minY, minZ),\n      new Vector3(maxX, maxY, maxZ),\n      new Vector3(maxX, minY, minZ),\n      new Vector3(minX, maxY, minZ),\n      new Vector3(minX, minY, maxZ),\n      new Vector3(maxX, maxY, minZ),\n      new Vector3(minX, maxY, maxZ),\n      new Vector3(maxX, minY, maxZ)\n    ];\n    return corners;\n  }\n\n  /**\n   * 通过模型矩阵，和缓存的本地坐标系 OBB，获取新的世界坐标系 OBB\n   * @param {Matrix} modelMatrix - Local to World矩阵\n   * */\n  updateByModelMatrix(modelMatrix: Matrix) {\n    const min = this.minWorld;\n    const max = this.maxWorld;\n    min.setValue(Infinity, Infinity, Infinity);\n    max.setValue(-Infinity, -Infinity, -Infinity);\n\n    for (let i = 0; i < 8; ++i) {\n      const corner: Vector3 = this.corners[i];\n      const cornerWorld: Vector3 = OBB._tempVec3;\n\n      Vector3.transformCoordinate(corner, modelMatrix, cornerWorld);\n      Vector3.min(min, cornerWorld, min);\n      Vector3.max(max, cornerWorld, max);\n\n      this.cornersWorld[i] = new Vector3();\n      cornerWorld.cloneTo(this.cornersWorld[i]);\n    }\n  }\n\n  /**\n   * 获取与视锥体的 具体相交状态\n   * @param { Vector4[] } frustumPlanes - Oasis 视锥体的6个平面方程\n   * @return {IntersectInfo} 返回相交状态\n   * */\n  intersectsFrustum(frustumPlanes: Vector4[]): IntersectInfo {\n    const cornersWorld = this.cornersWorld;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = frustumPlanes[i];\n      let isInPlane = false;\n      for (let j = 0; j < 8; j++) {\n        if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {\n          isInPlane = true;\n        } else if (isInPlane) {\n          return IntersectInfo.INTERSECT;\n        }\n      }\n      if (!isInPlane) {\n        return IntersectInfo.EXCLUDE;\n      }\n    }\n\n    return IntersectInfo.INCLUDE;\n  }\n\n  /**\n   * 是否在视锥体内部（包含或者交叉）\n   * @param { Vector4[] } frustumPlanes - Oasis 视锥体的6个平面方程\n   * @return {boolean}\n   * */\n  isInFrustum(frustumPlanes: Vector4[]): boolean {\n    const cornersWorld = this.cornersWorld;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = frustumPlanes[i];\n      let isInPlane = false;\n      for (let j = 0; j < 8; j++) {\n        if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {\n          isInPlane = true;\n          break;\n        }\n      }\n      if (!isInPlane) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n","import { Vector3 } from \"./Vector3\";\n\n/**\n * 射线。\n */\nexport class Ray {\n  /** 射线的起点。*/\n  readonly origin: Vector3 = new Vector3();\n  /** 射线的归一化方向。*/\n  readonly direction: Vector3 = new Vector3();\n\n  /**\n   * 创建射线实例。\n   * @param origin - 起点\n   * @param direction - 归一化方向\n   */\n  constructor(origin?: Vector3, direction?: Vector3) {\n    origin && origin.cloneTo(this.origin);\n    direction && direction.cloneTo(this.direction);\n  }\n\n  /**\n   * 检测本射线与平面相交\n   * @param {Vector3} point 平面上的一个点：(p-p0)·n = 0\n   * @param {Vector3} normal 平面的法线\n   */\n  intersectPlane(point: Vector3, normal: Vector3) {\n    const origin = this.origin;\n\n    const denom = Vector3.dot(normal, this.direction);\n    if (Math.abs(denom) > 1e-6) {\n      const p0l0 = new Vector3();\n      Vector3.subtract(point, origin, p0l0);\n\n      const t = Vector3.dot(p0l0, normal) / denom;\n      if (t >= 0) {\n        return t;\n      }\n    } // end of if\n\n    return false;\n  }\n\n  /**\n   * 射线方向上，距离起点指定距离的坐标\n   * @param {number} distance 距离\n   */\n  getPoint(distance: number): Vector3 {\n    // origin + direction * distance;\n    const point = new Vector3();\n    Vector3.scale(this.direction, distance, point);\n    return point.add(this.origin);\n  }\n\n  /**\n   * 检测本射线与球体相交\n   * @param {Vector3} center 球心坐标\n   * @param {number} radius 球的半径\n   */\n  intersectSphere(center: Vector3, radius: number) {\n    // analytic solution\n    const dir = this.direction;\n    const L = new Vector3();\n    Vector3.subtract(this.origin, center, L);\n\n    const a = Vector3.dot(dir, dir);\n    const b = 2 * Vector3.dot(dir, L);\n    const c = Vector3.dot(L, L) - radius * radius;\n\n    const s = this._solveQuadratic(a, b, c);\n    if (s) {\n      return s[0];\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * 检测本射线与轴对齐的Box的相交\n   * @param {Vector3} max Box的最大点\n   * @param {Vector3} min Box的最小点\n   */\n  intersectAABB(max: Vector3, min: Vector3) {\n    const dir = this.direction;\n    const orig = this.origin;\n    const invdir = new Vector3(1 / dir.x, 1 / dir.y, 1 / dir.z);\n\n    const bounds = [min, max];\n    const sign = [dir.x < 0 ? 1 : 0, dir.y < 0 ? 1 : 0, dir.z < 0 ? 1 : 0];\n\n    let tmin = (bounds[sign[0]].x - orig.x) * invdir.x;\n    let tmax = (bounds[1 - sign[0]].x - orig.x) * invdir.x;\n    const tymin = (bounds[sign[1]].y - orig.y) * invdir.y;\n    const tymax = (bounds[1 - sign[1]].y - orig.y) * invdir.y;\n\n    if (tmin > tymax || tymin > tmax) {\n      return false;\n    }\n\n    if (tymin > tmin) {\n      tmin = tymin;\n    }\n    if (tymax < tmax) {\n      tmax = tymax;\n    }\n\n    const tzmin = (bounds[sign[2]].z - orig.z) * invdir.z;\n    const tzmax = (bounds[1 - sign[2]].z - orig.z) * invdir.z;\n\n    if (tmin > tzmax || tzmin > tmax) {\n      return false;\n    }\n\n    if (tzmin > tmin) {\n      tmin = tzmin;\n    }\n    if (tzmax < tmax) {\n      tmax = tzmax;\n    }\n\n    let t = tmin;\n\n    if (t < 0) {\n      t = tmax;\n      if (t < 0) {\n        return false;\n      }\n    }\n\n    return t;\n  }\n\n  /**\n   * solve: ax^2 + bx + c = 0\n   * @returns {null|array} null: no answers; [x0 : float, x1 : float] where x0 <= x1\n   */\n  private _solveQuadratic(a, b, c) {\n    const discr = b * b - 4 * a * c;\n    if (discr < 0) {\n      return false;\n    } else if (discr == 0) {\n      const x = (-0.5 * b) / a;\n      return [x, x];\n    } else {\n      const r = Math.sqrt(discr);\n      const q = b > 0 ? -0.5 * (b + r) : -0.5 * (b - r);\n      const x0 = q / a;\n      const x1 = c / q;\n      if (x0 <= x1) {\n        return [x0, x1];\n      } else {\n        return [x1, x0];\n      }\n    } // end of else\n  }\n}\n","import { Vector3 } from \"./Vector3\";\n\n/**\n * Raycast检测的结果记录\n */\nexport class RaycastHit {\n  public distance: number;\n  public collider: any;\n  public point: Vector3;\n  /**\n   * 构造函数\n   */\n  constructor() {\n    /**\n     * 碰撞点离射线起点的距离\n     * @member {float}\n     */\n    this.distance = Number.MAX_VALUE;\n\n    /**\n     * 与射线相交的碰撞体\n     * @member {ACollider}∏\n     */\n    this.collider = null;\n\n    /**\n     * 碰撞体与射线的相交点\n     * @member {vec3}\n     */\n    this.point = null;\n  }\n}\n","import { MathUtil } from \"./MathUtil\";\nimport { Vector3 } from \"./Vector3\";\n\n// 防止万向锁\nconst ESP = MathUtil.zeroTolerance;\n\n// 球面坐标\nexport class Spherical {\n  public radius;\n  public phi;\n  public theta;\n\n  constructor(radius?, phi?, theta?) {\n    this.radius = radius !== undefined ? radius : 1.0;\n    this.phi = phi !== undefined ? phi : 0;\n    this.theta = theta !== undefined ? theta : 0;\n  }\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n\n    return this;\n  }\n\n  makeSafe() {\n    this.phi = MathUtil.clamp(this.phi, ESP, Math.PI - ESP);\n    return this;\n  }\n\n  setFromVec3(v3: Vector3) {\n    this.radius = v3.length();\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(v3.x, v3.z);\n      this.phi = Math.acos(MathUtil.clamp(v3.y / this.radius, -1, 1));\n    }\n\n    return this;\n  }\n\n  setToVec3(v3: Vector3) {\n    const sinPhiRadius = Math.sin(this.phi) * this.radius;\n\n    v3.x = sinPhiRadius * Math.sin(this.theta);\n    v3.y = Math.cos(this.phi) * this.radius;\n    v3.z = sinPhiRadius * Math.cos(this.theta);\n\n    return this;\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\n\n/**\n * 二维向量。\n */\nexport class Vector2 implements IClone {\n  /** @internal 零向量。*/\n  static readonly _zero = new Vector2(0.0, 0.0);\n  /** @internal 一向量。*/\n  static readonly _one = new Vector2(1.0, 1.0);\n\n  /**\n   * 将两个向量相加并输出结果至 out。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 向量相加结果\n   */\n  static add(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n  }\n\n  /**\n   * 将两个向量相减并输出结果至 out。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个二维向量的相减结果\n   */\n  static subtract(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n  }\n\n  /**\n   * 将两个向量相乘并输出结果至 out。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个二维向量的相乘结果\n   */\n  static multiply(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n  }\n\n  /**\n   * 将两个二维向量相除并输出结果至 out。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个二维向量的相除结果\n   */\n  static divide(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n  }\n\n  /**\n   * 计算两个二维向量的点积。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @returns 两个向量的点积\n   */\n  static dot(left: Vector2, right: Vector2): number {\n    return left.x * right.x + left.y * right.y;\n  }\n\n  /**\n   * 计算两个二维向量的距离。\n   * @param left - 向量\n   * @param right - 向量\n   * @returns 两个向量的距离\n   */\n  static distance(left: Vector2, right: Vector2): number {\n    const x = right.x - left.x;\n    const y = right.y - left.y;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * 计算两个二维向量的距离的平方。\n   * @param left - 向量\n   * @param right - 向量\n   * @returns 两个向量的距离的平方\n   */\n  static distanceSquared(left: Vector2, right: Vector2): number {\n    const x = right.x - left.x;\n    const y = right.y - left.y;\n    return x * x + y * y;\n  }\n\n  /**\n   * 判断两个二维向量的值是否相等。\n   * @param left - 向量\n   * @param right - 向量\n   * @returns 两个向量是否相等，是返回 true，否则返回 false\n   */\n  static equals(left: Vector2, right: Vector2): boolean {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);\n  }\n\n  /**\n   * 插值二维向量。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param t - 插值比例\n   * @param out - 插值结果\n   */\n  static lerp(left: Vector2, right: Vector2, t: number, out: Vector2): void {\n    const { x, y } = left;\n    out.x = x + (right.x - x) * t;\n    out.y = y + (right.y - y) * t;\n  }\n\n  /**\n   * 分别取两个二维向量 x、y 的最大值计算新的二维向量。\n   * @param left - 向量\n   * @param right - 向量\n   * @param out - 结果向量\n   */\n  static max(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n  }\n\n  /**\n   * 分别取两个二维向量 x、y 的最小值计算新的二维向量。\n   * @param left - 向量\n   * @param right - 向量\n   * @param out - 结果向量\n   */\n  static min(left: Vector2, right: Vector2, out: Vector2): void {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n  }\n\n  /**\n   * 将向量 left 反转的结果输出到 out。\n   * @param left - 向量\n   * @param out - 向量反转的结果\n   */\n  static negate(left: Vector2, out: Vector2): void {\n    out.x = -left.x;\n    out.y = -left.y;\n  }\n\n  /**\n   * 将向量 left 归一化的结果输出到 out。\n   * @param left - 向量\n   * @param out - 向量归一化的结果\n   */\n  static normalize(left: Vector2, out: Vector2): void {\n    const { x, y } = left;\n    let len: number = Math.sqrt(x * x + y * y);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n    }\n  }\n\n  /**\n   * 将向量 left 缩放的结果输出到 out。\n   * @param left - 向量\n   * @param scale - 缩放因子\n   * @param out - 向量缩放的结果\n   */\n  static scale(left: Vector2, s: number, out: Vector2): void {\n    out.x = left.x * s;\n    out.y = left.y * s;\n  }\n\n  /** 向量的 X 分量。 */\n  x: number;\n  /** 向量的 Y 分量。 */\n  y: number;\n\n  /**\n   * 创建一个 Vector2 实例。\n   * @param x - 向量的 X 分量，默认值 0\n   * @param y - 向量的 Y 分量，默认值 0\n   */\n  constructor(x: number = 0, y: number = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * 设置 x, y 的值，并返回当前向量。\n   * @param x - 向量的 X 分量\n   * @param y - 向量的 Y 分量\n   * @returns 当前向量\n   */\n  setValue(x: number, y: number): Vector2 {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * 通过数组设置值，并返回当前向量。\n   * @param array - 数组\n   * @param offset - 数组偏移\n   * @returns 当前向量\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Vector2 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n\n  /**\n   * 将当前向量加上给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  add(right: Vector2): Vector2 {\n    this.x += right.x;\n    this.y += right.y;\n    return this;\n  }\n\n  /**\n   * 将当前向量减去给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  subtract(right: Vector2): Vector2 {\n    this.x -= right.x;\n    this.y -= right.y;\n    return this;\n  }\n\n  /**\n   * 将当前向量乘以给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  multiply(right: Vector2): Vector2 {\n    this.x *= right.x;\n    this.y *= right.y;\n    return this;\n  }\n\n  /**\n   * 将当前向量除以给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  divide(right: Vector2): Vector2 {\n    this.x /= right.x;\n    this.y /= right.y;\n    return this;\n  }\n\n  /**\n   * 计算一个二维向量的标量长度。\n   * @returns 当前向量的标量长度\n   */\n  length(): number {\n    const { x, y } = this;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * 计算一个二维向量的标量长度的平方。\n   * @returns 当前向量的标量长度的平方\n   */\n  lengthSquared(): number {\n    const { x, y } = this;\n    return x * x + y * y;\n  }\n\n  /**\n   * 向量反转。\n   * @returns 当前向量\n   */\n  negate(): Vector2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  /**\n   * 当前向量归一化，并返回。\n   * @returns 当前向量\n   */\n  normalize(): Vector2 {\n    Vector2.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * 向量缩放。\n   * @param s - 缩放因子\n   * @returns 当前向量\n   */\n  scale(s: number): Vector2 {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  }\n\n  /**\n   * 拷贝到数组。\n   * @param out - 数组。\n   * @param outOffset - 数组偏移。\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n  }\n\n  /**\n   * 克隆并返回一个新的二维向量对象。\n   * @returns 新的二维向量对象\n   */\n  clone(): Vector2 {\n    return new Vector2(this.x, this.y);\n  }\n\n  /**\n   * 将当前向量值拷贝给目标向量。\n   * @param out - 目标向量\n   */\n  cloneTo(out: Vector2): Vector2 {\n    out.x = this.x;\n    out.y = this.y;\n    return out;\n  }\n}\n","import { IClone } from \"@oasis-engine/design\";\nimport { MathUtil } from \"./MathUtil\";\nimport { Matrix } from \"./Matrix\";\nimport { Quaternion } from \"./Quaternion\";\n\n/**\n * 四维向量。\n */\nexport class Vector4 implements IClone {\n  /** @internal 零向量。*/\n  static readonly _zero = new Vector4(0.0, 0.0, 0.0, 0.0);\n  /** @internal 一向量。*/\n  static readonly _one = new Vector4(1.0, 1.0, 1.0, 1.0);\n\n  /**\n   * 将两个向量相加。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 向量相加结果\n   */\n  static add(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n    out.w = left.w + right.w;\n  }\n\n  /**\n   * 将两个向量相减。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个四维向量的相减结果\n   */\n  static subtract(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n    out.z = left.z - right.z;\n    out.w = left.w - right.w;\n  }\n\n  /**\n   * 将两个向量相乘。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个四维向量的相乘结果\n   */\n  static multiply(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n    out.z = left.z * right.z;\n    out.w = left.w * right.w;\n  }\n\n  /**\n   * 将两个四维向量相除。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @param out - 两个四维向量的相除结果\n   */\n  static divide(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n    out.z = left.z / right.z;\n    out.w = left.w / right.w;\n  }\n\n  /**\n   * 计算两个四维向量的点积。\n   * @param left - 左向量\n   * @param right - 右向量\n   * @returns 两个向量的点积\n   */\n  static dot(left: Vector4, right: Vector4): number {\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n  }\n\n  /**\n   * 计算两个四维向量的距离。\n   * @param a - 向量\n   * @param b - 向量\n   * @returns 两个向量的距离\n   */\n  static distance(a: Vector4, b: Vector4): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    const w = b.w - a.w;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n\n  /**\n   * 计算两个四维向量的距离的平方。\n   * @param a - 向量\n   * @param b - 向量\n   * @returns 两个向量的距离的平方\n   */\n  static distanceSquared(a: Vector4, b: Vector4): number {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    const w = b.w - a.w;\n    return x * x + y * y + z * z + w * w;\n  }\n\n  /**\n   * 判断两个四维向量的值是否相等。\n   * @param left - 向量\n   * @param right - 向量\n   * @returns 两个向量是否相等，是返回 true，否则返回 false\n   */\n  static equals(left: Vector4, right: Vector4): boolean {\n    return (\n      MathUtil.equals(left.x, right.x) &&\n      MathUtil.equals(left.y, right.y) &&\n      MathUtil.equals(left.z, right.z) &&\n      MathUtil.equals(left.w, right.w)\n    );\n  }\n\n  /**\n   * 插值四维向量。\n   * @param start - 左向量\n   * @param end - 右向量\n   * @param t - 插值比例\n   * @param out - 插值结果\n   */\n  static lerp(start: Vector4, end: Vector4, t: number, out: Vector4): void {\n    const { x, y, z, w } = start;\n    out.x = x + (end.x - x) * t;\n    out.y = y + (end.y - y) * t;\n    out.z = z + (end.z - z) * t;\n    out.w = w + (end.w - w) * t;\n  }\n\n  /**\n   * 分别取两个四维向量 x、y 的最大值计算新的四维向量。\n   * @param left - 向量\n   * @param right - 向量\n   * @param out - 结果向量\n   */\n  static max(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n    out.z = Math.max(left.z, right.z);\n    out.w = Math.max(left.w, right.w);\n  }\n\n  /**\n   * 分别取两个四维向量 x、y 的最小值计算新的四维向量。\n   * @param left - 向量\n   * @param right - 向量\n   * @param out - 结果向量\n   */\n  static min(left: Vector4, right: Vector4, out: Vector4): void {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n    out.z = Math.min(left.z, right.z);\n    out.w = Math.min(left.w, right.w);\n  }\n\n  /**\n   * 将向量 a 反转的结果输出到 out。\n   * @param a - 向量\n   * @param out - 向量反转的结果\n   */\n  static negate(a: Vector4, out: Vector4): void {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n    out.w = -a.w;\n  }\n\n  /**\n   * 将向量 a 归一化的结果输出到 out。\n   * @param a - 向量\n   * @param out - 向量归一化的结果\n   */\n  static normalize(a: Vector4, out: Vector4): void {\n    const { x, y, z, w } = a;\n    let len: number = Math.sqrt(x * x + y * y + z * z + w * w);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n      out.w = w * len;\n    }\n  }\n\n  /**\n   * 将向量 a 缩放的结果输出到 out。\n   * @param a - 向量\n   * @param s - 缩放因子\n   * @param out - 向量缩放的结果\n   */\n  static scale(a: Vector4, s: number, out: Vector4): void {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n    out.w = a.w * s;\n  }\n\n  /**\n   * 通过4x4矩阵将一个四维向量转换到另一个四维向量。\n   * @param v - 向量\n   * @param m - 转换矩阵\n   * @param out - 通过矩阵转换后的向量\n   */\n  static transform(v: Vector4, m: Matrix, out: Vector4): void {\n    const { x, y, z, w } = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];\n    out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];\n  }\n\n  /**\n   * 通过四元数将一个四维向量转换到另一个四维向量。\n   * @param v - 向量\n   * @param m - 转换矩阵\n   * @param out - 通过矩阵转换后的向量\n   */\n  static transformByQuat(v: Vector4, q: Quaternion, out: Vector4): void {\n    const { x, y, z, w } = v;\n    const qx = q.x;\n    const qy = q.y;\n    const qz = q.z;\n    const qw = q.w;\n\n    // calculate quat * vec\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out.x = ix * qw - iw * qx - iy * qz + iz * qy;\n    out.y = iy * qw - iw * qy - iz * qx + ix * qz;\n    out.z = iz * qw - iw * qz - ix * qy + iy * qx;\n    out.w = w;\n  }\n\n  /** 向量的 X 分量。 */\n  x: number;\n  /** 向量的 Y 分量。 */\n  y: number;\n  /** 向量的 Z 分量。 */\n  z: number;\n  /** 向量的 W 分量。 */\n  w: number;\n\n  /**\n   * 创建一个 Vector4 实例。\n   * @param x - 向量的 X 分量，默认值 0\n   * @param y - 向量的 Y 分量，默认值 0\n   * @param z - 向量的 Z 分量，默认值 0\n   * @param w - 向量的 W 分量，默认值 0\n   */\n  constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  /**\n   * 设置 x, y, z, w 的值，并返回当前向量。\n   * @param x - 向量的 X 分量\n   * @param y - 向量的 Y 分量\n   * @param z - 向量的 Z 分量\n   * @param w - 向量的 W 分量\n   * @returns 当前向量\n   */\n  setValue(x: number, y: number, z: number, w: number): Vector4 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n\n  /**\n   * 通过数组设置值，并返回当前向量。\n   * @param array - 数组\n   * @param offset - 数组偏移\n   * @returns 当前向量\n   */\n  setValueByArray(array: ArrayLike<number>, offset: number = 0): Vector4 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n\n  /**\n   * 将当前向量加上给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  add(right: Vector4): Vector4 {\n    this.x += right.x;\n    this.y += right.y;\n    this.z += right.z;\n    this.w += right.w;\n    return this;\n  }\n\n  /**\n   * 将当前向量减去给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  subtract(right: Vector4): Vector4 {\n    this.x -= right.x;\n    this.y -= right.y;\n    this.z -= right.z;\n    this.w -= right.w;\n    return this;\n  }\n\n  /**\n   * 将当前向量乘以给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  multiply(right: Vector4): Vector4 {\n    this.x *= right.x;\n    this.y *= right.y;\n    this.z *= right.z;\n    this.w *= right.w;\n    return this;\n  }\n\n  /**\n   * 将当前向量除以给定的向量 right，并返回当前向量。\n   * @param right - 给定的向量\n   * @returns 当前向量\n   */\n  divide(right: Vector4): Vector4 {\n    this.x /= right.x;\n    this.y /= right.y;\n    this.z /= right.z;\n    this.w /= right.w;\n    return this;\n  }\n\n  /**\n   * 计算一个四维向量的标量长度。\n   * @returns 当前向量的标量长度\n   */\n  length(): number {\n    const { x, y, z, w } = this;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n\n  /**\n   * 计算一个四维向量的标量长度的平方。\n   * @returns 当前向量的标量长度的平方\n   */\n  lengthSquared(): number {\n    const { x, y, z, w } = this;\n    return x * x + y * y + z * z + w * w;\n  }\n\n  /**\n   * 向量反转。\n   * @returns 当前向量\n   */\n  negate(): Vector4 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n\n  /**\n   * 向量归一化。\n   * @returns 当前向量\n   */\n  normalize(): Vector4 {\n    Vector4.normalize(this, this);\n    return this;\n  }\n\n  /**\n   * 向量缩放。\n   * @param s - 缩放因子\n   * @returns 当前向量\n   */\n  scale(s: number): Vector4 {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    this.w *= s;\n    return this;\n  }\n\n  /**\n   * 拷贝到数组。\n   * @param out - 数组。\n   * @param outOffset - 数组偏移。\n   */\n  toArray(out: number[] | Float32Array | Float64Array, outOffset: number = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n    out[outOffset + 3] = this.w;\n  }\n\n  /**\n   * 创建一个新的四维向量，并用当前向量值初始化。\n   * @returns 一个新的向量，并且拷贝当前向量的值\n   */\n  clone(): Vector4 {\n    let ret = new Vector4(this.x, this.y, this.z, this.w);\n    return ret;\n  }\n\n  /**\n   * 将当前向量值拷贝给 out 向量。\n   * @param out - 目标向量\n   */\n  cloneTo(out: Vector4): Vector4 {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    out.w = this.w;\n    return out;\n  }\n}\n"],"names":["MathUtil2","Vector32","IntersectInfo2","Matrix3x32"],"mappings":"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"}