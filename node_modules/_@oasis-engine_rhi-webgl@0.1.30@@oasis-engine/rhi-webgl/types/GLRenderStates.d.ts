/**
 * 管理渲染状态，主要功能：设置默认渲染状态，cache当前渲染状态，管理渲染状态stack（供恢复用）
 * @class
 * @private
 */
export declare class GLRenderStates {
    private _gl;
    private _stateStack;
    private _parameters;
    /**
     * @param {WebGLRenderingContext} gl
     */
    constructor(gl: WebGLRenderingContext);
    /**
     * 取得渲染状态参数：any gl.getParameter(pname);
     * @param {GLenum} pname
     */
    getParameter(pname: any): any;
    /**
     * 新建一个State Block（渲染单个对象时的一组渲染状态），并放入状态栈
     */
    pushStateBlock(_name: any): void;
    /**
     * 取出栈顶的State Block，并用来恢复当前的渲染状态
     */
    popStateBlock(): void;
    /**
     * 取得当前状态栈的顶部对象
     * @return {Object}
     * @private
     */
    _getStateStackTop(): any;
    /**
     * 将一个渲染状态放入栈顶的State Block
     * @param {Function} func
     * @param {Array} args
     * @private
     */
    _pushState(_func: any, _args: any, _param: any): void;
    /**
     * 设置渲染状态：void gl.enable(cap);
     * @param {GLenum} cap
     */
    enable(cap: any): void;
    /**
     * 设置渲染状态：void gl.disable(cap);
     * @param {GLenum} cap
     */
    disable(cap: any): void;
    /**
     * 设置渲染状态：void gl.blendFunc(sfactor, dfactor);
     * @param {GLenum} sfactor
     * @param {GLenum} dfactor
     */
    blendFunc(sfactor: any, dfactor: any): void;
    /**
     * 设置渲染状态：void gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
     * @param {GLenum} srcRGB
     * @param {GLenum} dstRGB
     * @param {GLenum} srcAlpha
     * @param {GLenum} dstAlpha
     */
    blendFuncSeparate(srcRGB: any, dstRGB: any, srcAlpha: any, dstAlpha: any): void;
    /**
     * void gl.blendEquationSeparate(modeRGB, modeAlpha);
     * @param {GLenum} modeRGB
     * @param {GLenum} modeAlpha
     */
    blendEquationSeparate(modeRGB: any, modeAlpha: any): void;
    /**
     * 控制颜色通道释放写入Frame Buffer
     * @param {boolean} red 红色通道是否写入
     * @param {boolean} green 绿色通道是否写入
     * @param {boolean} blue 蓝色通道是否写入
     * @param {boolean} alpha 透明通道是否写入
     */
    colorMask(red: boolean, green: boolean, blue: boolean, alpha: boolean): void;
    /**
     * 是否写入深度缓冲
     * @param {boolean} flag
     */
    depthMask(flag: any): void;
    /**
     * 设置渲染状态：void gl.cullFace(mode);
     * @param {GLenum} mode
     */
    cullFace(mode: GLenum): void;
    /**
     * 设置渲染状态：void gl.frontFace(mode);
     * @param {GLenum} mode
     */
    frontFace(mode: GLenum): void;
    /**
     * 设置渲染状态：void gl.depthFunc(func);
     * @param {GLenum} func
     */
    depthFunc(func: GLenum): void;
    /**
     * 设置渲染状态：void gl.depthRange(zNear, zFar);
     * @param {GLclampf} zNear
     * @param {GLclampf} zFar
     */
    depthRange(zNear: any, zFar: any): void;
    /**
     * void gl.polygonOffset(factor, units);
     * @param {GLfloat} factor
     * @param {GLfloat} units
     */
    polygonOffset(factor: any, units: any): void;
    /**
     * 设置渲染状态：void gl.scissor(x, y, width, height);
     * @param {GLint} x
     * @param {GLint} y
     * @param {GLsizei} width
     * @param {GLsizei} height
     */
    scissor(x: any, y: any, width: any, height: any): void;
    /**
     * 设置渲染状态：void gl.stencilFunc(func, ref, mask);
     * @param {GLenum} func
     * @param {GLint} ref
     * @param {GLint} mask
     */
    stencilFunc(func: GLenum, ref: GLint, mask: GLint): void;
    /**
     * 设置渲染状态：void gl.stencilOp(fail, zfail, zpass);
     * @param {GLenum} fail
     * @param {GLenum} zfail
     * @param {GLenum} zpass
     */
    stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void;
    stencilMask(mask: GLuint): void;
}
