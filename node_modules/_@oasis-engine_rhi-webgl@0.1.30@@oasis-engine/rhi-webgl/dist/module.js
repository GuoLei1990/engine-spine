import { Logger, DataType, InternalAssetType, GLCapabilityType, GLCompressedTextureInternalFormat, UniformSemantic, RenderState, BlendFunc, ClearMode, Engine } from '@oasis-engine/core';
import { Vector2 } from '@oasis-engine/math';

let programList = [];
function addLineNum(str) {
  const lines = str.split("\n");
  const limitLength = (lines.length + 1).toString().length + 6;
  let prefix;
  return lines.map((line, index) => {
    prefix = `0:${index + 1}`;
    if (prefix.length >= limitLength)
      return prefix.substring(0, limitLength) + line;
    for (let i = 0; i < limitLength - prefix.length; i++)
      prefix += " ";
    return prefix + line;
  }).join("\n");
}
class GLShaderProgram {
  constructor(gl, _engine) {
    this._engine = _engine;
    this._gl = gl;
    this._vertexShader = null;
    this._fragmentShader = null;
    this._vertexShaderSource = null;
    this._fragmentShaderSource = null;
    this._program = null;
    this._attributeCache = {};
    this._uniformCache = {};
  }
  static requireProgram(tech, gl, engine) {
    let program = null;
    programList.some((p) => {
      if (p._gl === gl && p._vertexShaderSource === tech.vertexShader && p._fragmentShaderSource === tech.fragmentShader) {
        program = p;
        return true;
      }
    });
    if (!program) {
      program = new GLShaderProgram(gl, engine);
      const sucess = program.createFromSource(tech.vertexShader, tech.fragmentShader, tech.attribLocSet);
      if (!sucess)
        return null;
      programList.push(program);
    }
    return program;
  }
  static releaseProgram(program) {
    let index = programList.indexOf(program);
    if (index !== -1) {
      programList.splice(index, 1);
    }
  }
  get program() {
    return this._program;
  }
  createFromSource(vertexSource, fragmentSource, attribLocSet) {
    const gl = this._gl;
    const vertexShader = this._compileShader(gl.VERTEX_SHADER, vertexSource);
    if (!vertexShader) {
      return false;
    }
    const fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (!fragmentShader) {
      return false;
    }
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    if (attribLocSet) {
      for (const attribName in attribLocSet) {
        gl.bindAttribLocation(program, attribLocSet[attribName], attribName);
      }
    }
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (gl.isContextLost()) {
      Logger.error("Contex lost while linking program.");
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }
    if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
      const msg = "Could not link WebGL program. \n" + gl.getProgramInfoLog(program);
      console.error(msg);
      this._engine.dispatch("linkProgramError", msg);
      gl.deleteProgram(program);
      return false;
    }
    this._vertexShader = vertexShader;
    this._fragmentShader = fragmentShader;
    this._vertexShaderSource = vertexSource;
    this._fragmentShaderSource = fragmentSource;
    this._program = program;
    return true;
  }
  _compileShader(shaderType, shaderSource) {
    const gl = this._gl;
    const shader = gl.createShader(shaderType);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (gl.isContextLost()) {
      Logger.error("Contex lost while compiling shader.");
      gl.deleteShader(shader);
      return null;
    }
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
      const msg = `Could not compile WebGL shader.
${addLineNum(shaderSource)}
${gl.getShaderInfoLog(shader)}`;
      console.error(msg);
      this._engine.dispatch("compileShaderError", msg);
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  getAttribLocation(glProgram, name) {
    if (this._attributeCache.hasOwnProperty(name)) {
      return this._attributeCache[name];
    } else {
      return this._attributeCache[name] = this._gl.getAttribLocation(glProgram, name);
    }
  }
  getUniformLocation(glProgram, name) {
    if (this._uniformCache.hasOwnProperty(name)) {
      return this._uniformCache[name];
    } else {
      return this._uniformCache[name] = this._gl.getUniformLocation(glProgram, name);
    }
  }
  finalize() {
    const gl = this._gl;
    if (this._vertexShader) {
      gl.deleteShader(this._vertexShader);
    }
    if (this._fragmentShader) {
      gl.deleteShader(this._fragmentShader);
    }
    if (this._program) {
      gl.deleteProgram(this._program);
    }
    this._vertexShader = null;
    this._fragmentShader = null;
    this._vertexShaderSource = null;
    this._fragmentShaderSource = null;
    this._program = null;
    this._attributeCache = {};
    this._uniformCache = {};
    GLShaderProgram.releaseProgram(this);
  }
}

class GLAsset {
  constructor(rhi, asset) {
    this._rhi = rhi;
    this.asset = asset;
  }
  get rhi() {
    return this._rhi;
  }
}

class GLTechnique extends GLAsset {
  constructor(rhi, tech) {
    super(rhi, tech);
    this.cacheID = ++GLTechnique.cacheCounter;
    this._tech = tech;
    this._activeTextureCount = 0;
    const gl = rhi.gl;
    this._program = GLShaderProgram.requireProgram(tech, gl, rhi._engine);
    if (this._program) {
      this.valid = true;
      const glProgram = this._program.program;
      this._attributes = {};
      const attributes = tech.attributes;
      for (const name in attributes) {
        this._attributes[name] = {
          name,
          semantic: attributes[name].semantic,
          location: this._program.getAttribLocation(glProgram, name)
        };
      }
      this._uniforms = {};
      const uniforms = tech.uniforms;
      for (const name in uniforms) {
        const loc = this._program.getUniformLocation(glProgram, name);
        if (loc !== null) {
          this._uniforms[name] = {
            name,
            location: loc
          };
        }
      }
    } else {
      this.valid = false;
    }
  }
  finalize(forceDispose) {
    if (this._program && forceDispose) {
      this._program = null;
    }
  }
  get program() {
    return this._program;
  }
  get attributes() {
    return this._attributes;
  }
  get uniforms() {
    return this._uniforms;
  }
  begin(mtl) {
    const gl = this.rhi.gl;
    const glProgram = this._program.program;
    this._activeTextureCount = 0;
    gl.useProgram(glProgram);
    const uniforms = this._uniforms;
    const assetUniforms = this._tech.uniforms;
    for (const name in assetUniforms) {
      if (uniforms.hasOwnProperty(name)) {
        const value = mtl.getValue(name);
        value != null && this._uploadUniformValue(assetUniforms[name], uniforms[name].location, value);
      }
    }
    const stateManager = this.rhi.renderStates;
    if (this._tech.states) {
      stateManager.pushStateBlock(this._tech.name);
      this._applyStates(stateManager);
    }
  }
  end() {
    if (this._tech.states) {
      const stateManager = this.rhi.renderStates;
      stateManager.popStateBlock();
    }
  }
  _applyStates(stateManager) {
    const states = this._tech.states;
    const enable = states.enable;
    if (enable) {
      for (let i = 0, len = enable.length; i < len; i++) {
        stateManager.enable(enable[i]);
      }
    }
    const disable = states.disable;
    if (disable) {
      for (let i = 0, len = disable.length; i < len; i++) {
        stateManager.disable(disable[i]);
      }
    }
    const functions = states.functions;
    if (functions) {
      for (const name in functions) {
        const args = Array.isArray(functions[name]) ? functions[name] : [functions[name]];
        const func = stateManager[name];
        func.apply(stateManager, args);
      }
    }
  }
  _uploadUniformValue(uniform, location, value) {
    const gl = this.rhi.gl;
    switch (uniform.type) {
      case DataType.FLOAT:
        if (value.length)
          gl.uniform1fv(location, value);
        else
          gl.uniform1f(location, value);
        break;
      case DataType.FLOAT_ARRAY:
        gl.uniform1fv(location, value);
        break;
      case DataType.INT:
        if (value.length)
          gl.uniform1iv(location, value);
        else
          gl.uniform1i(location, value);
        break;
      case DataType.INT_ARRAY:
        gl.uniform1iv(location, value);
        break;
      case DataType.FLOAT_VEC2:
        gl.uniform2f(location, value.x, value.y);
        break;
      case DataType.FLOAT_VEC2_ARRAY:
        gl.uniform2fv(location, value);
        break;
      case DataType.FLOAT_VEC3:
        gl.uniform3f(location, value.x, value.y, value.z);
        break;
      case DataType.FLOAT_VEC3_ARRAY:
        gl.uniform3fv(location, value);
        break;
      case DataType.FLOAT_VEC4:
        gl.uniform4f(location, value.x, value.y, value.z, value.w);
        break;
      case DataType.FLOAT_VEC4_ARRAY:
        gl.uniform4fv(location, value);
        break;
      case DataType.INT_VEC2:
        gl.uniform2i(location, value.x, value.y);
        break;
      case DataType.INT_VEC2_ARRAY:
        gl.uniform2iv(location, value);
        break;
      case DataType.INT_VEC3:
        gl.uniform3i(location, value.x, value.y, value.z);
        break;
      case DataType.INT_VEC3_ARRAY:
        gl.uniform3iv(location, value);
        break;
      case DataType.INT_VEC4:
        gl.uniform4i(location, value.x, value.y, value.z, value.w);
        break;
      case DataType.INT_VEC4_ARRAY:
        gl.uniform4iv(location, value);
        break;
      case DataType.FLOAT_MAT2:
        gl.uniformMatrix2fv(location, false, value.elements);
        break;
      case DataType.FLOAT_MAT2_ARRAY:
        gl.uniformMatrix2fv(location, false, value);
        break;
      case DataType.FLOAT_MAT3:
        gl.uniformMatrix3fv(location, false, value.elements);
        break;
      case DataType.FLOAT_MAT3_ARRAY:
        gl.uniformMatrix3fv(location, false, value);
        break;
      case DataType.FLOAT_MAT4:
        gl.uniformMatrix4fv(location, false, value.elements);
        break;
      case DataType.FLOAT_MAT4_ARRAY:
        gl.uniformMatrix4fv(location, false, value);
        break;
      case DataType.SAMPLER_2D: {
        this._uploadTexture(value, location);
        break;
      }
      case DataType.SAMPLER_2D_ARRAY: {
        this._uploadTextures(value, location);
        break;
      }
      case DataType.SAMPLER_CUBE: {
        this._uploadTexture(value, location);
        break;
      }
      case DataType.SAMPLER_CUBE_ARRAY: {
        this._uploadTextures(value, location);
        break;
      }
      default:
        Logger.warn("UNKNOWN uniform type: " + uniform.type);
        break;
    }
  }
  _uploadTexture(texture, location) {
    if (texture) {
      const gl = this.rhi.gl;
      const index = this._activeTextureCount++;
      gl.activeTexture(gl.TEXTURE0 + index);
      gl.bindTexture(texture._target, texture._glTexture);
      gl.uniform1i(location, index);
    }
  }
  _uploadTextures(textures, location) {
    if (!this._tempSamplerArray || this._tempSamplerArray.length !== textures.length) {
      this._tempSamplerArray = new Int32Array(textures.length);
    }
    const gl = this.rhi.gl;
    for (let i = 0, length = textures.length; i < length; i++) {
      const texture = textures[i];
      if (texture) {
        const index = this._activeTextureCount++;
        gl.activeTexture(gl.TEXTURE0 + index);
        gl.bindTexture(texture._target, texture._glTexture);
        this._tempSamplerArray[i] = index;
      } else {
        this._tempSamplerArray[i] = -1;
      }
    }
    gl.uniform1iv(location, this._tempSamplerArray);
  }
}
GLTechnique.cacheCounter = 0;

class GLTexture extends GLAsset {
  constructor(rhi, config, type) {
    super(rhi, config);
    this._gl = rhi.gl;
    this._glTexture = config._glTexture;
    this._config = config;
    this._type = type;
  }
  get glTexture() {
    return this._glTexture;
  }
  activeBinding(textureIndex) {
    const gl = this._gl;
    gl.activeTexture(gl.TEXTURE0 + textureIndex);
    gl.bindTexture(this._type, this._glTexture);
  }
  finalize() {
  }
}

class WebCanvas {
  constructor(webCanvas) {
    this._scale = new Vector2();
    const width = webCanvas.width;
    const height = webCanvas.height;
    this._webCanvas = webCanvas;
    this._width = width;
    this._height = height;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (this._width !== value) {
      this._webCanvas.width = value;
      this._width = value;
    }
  }
  get height() {
    return this._height;
  }
  set height(value) {
    if (this._height !== value) {
      this._webCanvas.height = value;
      this._height = value;
    }
  }
  get scale() {
    const webCanvas = this._webCanvas;
    if (webCanvas instanceof HTMLCanvasElement) {
      this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
    }
    return this._scale;
  }
  set scale(value) {
    const webCanvas = this._webCanvas;
    if (webCanvas instanceof HTMLCanvasElement) {
      webCanvas.style.transformOrigin = `left top`;
      webCanvas.style.transform = `scale(${value.x}, ${value.y})`;
    }
  }
  resizeByClientSize(pixelRatio = window.devicePixelRatio) {
    const webCanvas = this._webCanvas;
    if (webCanvas instanceof HTMLCanvasElement) {
      const width = webCanvas.clientWidth;
      const height = webCanvas.clientHeight;
      this.width = width * pixelRatio;
      this.height = height * pixelRatio;
    }
  }
  setScale(x, y) {
    this._scale.setValue(x, y);
    this.scale = this._scale;
  }
}

class GLAssetsCache {
  constructor(rhi, props = {}) {
    this._rhi = rhi;
    this._objectSet = {};
    this._checkList = [];
    this._nextID = 1;
    this._enableCollect = props.enableCollect === void 0 ? true : !!props.enableCollect;
  }
  requireObject(asset, ctor) {
    let cachedObject = null;
    if (asset.cacheID) {
      cachedObject = this._objectSet[asset.cacheID];
    }
    if (!cachedObject || asset.needRecreate) {
      const cacheID = this._nextID++;
      const objectSet = this._objectSet;
      cachedObject = new ctor(this._rhi, asset);
      objectSet[cacheID] = cachedObject;
      cachedObject.cacheID = cacheID;
      cachedObject.asset = asset;
      asset.cacheID = cacheID;
      asset.needRecreate = false;
      if (this._enableCollect && asset.type === InternalAssetType.Cache) {
        this._checkList.push(cachedObject);
      }
    }
    cachedObject.activeFrame = this._rhi.frameCount;
    return cachedObject;
  }
  compact() {
    if (!this._enableCollect)
      return;
    const currentFrame = this._rhi.frameCount;
    const checkList = this._checkList;
    const objectSet = this._objectSet;
    for (let i = checkList.length - 1; i >= 0; i--) {
      const cachedObject = checkList[i];
      if (cachedObject.activeFrame < currentFrame) {
        delete objectSet[cachedObject.cacheID];
        checkList.splice(i, 1);
        cachedObject.finalize();
      }
    }
  }
  finalize() {
    for (const name in this._objectSet) {
      const obj = this._objectSet[name];
      obj.finalize(true);
    }
    this._objectSet = {};
    this._checkList = [];
  }
}

class GLCapability {
  get maxDrawBuffers() {
    if (!this._maxDrawBuffers) {
      if (this.canIUse(GLCapabilityType.drawBuffers)) {
        this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
      } else {
        this._maxDrawBuffers = 1;
      }
    }
    return this._maxDrawBuffers;
  }
  get maxAnisoLevel() {
    if (!this._maxAnisoLevel) {
      const ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);
      this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    }
    return this._maxAnisoLevel;
  }
  get maxAntiAliasing() {
    if (!this._maxAntiAliasing) {
      const gl = this._rhi.gl;
      const canMSAA = this.canIUse(GLCapabilityType.multipleSample);
      this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
    }
    return this._maxAntiAliasing;
  }
  get rhi() {
    return this._rhi;
  }
  constructor(rhi) {
    this._rhi = rhi;
    this.capabilityList = new Map();
    this.init();
    this.compatibleAllInterface();
  }
  canIUse(capabilityType) {
    return this.capabilityList.get(capabilityType);
  }
  canIUseCompressedTextureInternalFormat(internalType) {
    const {
      RGBA_ASTC_4X4_KHR,
      RGBA_ASTC_12X12_KHR,
      SRGB8_ALPHA8_ASTC_4X4_KHR,
      SRGB8_ALPHA8_ASTC_12X12_KHR,
      RGB_ETC1_WEBGL,
      R11_EAC,
      SRGB8_ALPHA8_ETC2_EAC,
      RGB_PVRTC_4BPPV1_IMG,
      RGBA_PVRTC_2BPPV1_IMG,
      RGB_S3TC_DXT1_EXT,
      RGBA_S3TC_DXT5_EXT
    } = GLCompressedTextureInternalFormat;
    if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
      return this.canIUse(GLCapabilityType.astc);
    } else if (internalType === RGB_ETC1_WEBGL) {
      return this.canIUse(GLCapabilityType.etc1);
    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
      return this.canIUse(GLCapabilityType.etc);
    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
      return this.canIUse(GLCapabilityType.pvrtc);
    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
      return this.canIUse(GLCapabilityType.s3tc);
    }
    return false;
  }
  get canIUseMoreJoints() {
    return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
  }
  init() {
    const cap = this.capabilityList;
    const {isWebGL2} = this.rhi;
    const requireExtension = this.rhi.requireExtension.bind(this.rhi);
    const {
      standardDerivatives,
      shaderTextureLod,
      elementIndexUint,
      depthTexture,
      vertexArrayObject,
      instancedArrays,
      multipleSample,
      drawBuffers,
      astc,
      astc_webkit,
      etc,
      etc_webkit,
      etc1,
      etc1_webkit,
      pvrtc,
      pvrtc_webkit,
      s3tc,
      s3tc_webkit,
      textureFloat,
      textureHalfFloat,
      textureFloatLinear,
      textureHalfFloatLinear,
      WEBGL_colorBufferFloat,
      colorBufferFloat,
      colorBufferHalfFloat,
      textureFilterAnisotropic
    } = GLCapabilityType;
    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
    cap.set(multipleSample, isWebGL2);
    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
    cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
    cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
  }
  compatibleInterface(capabilityType, flatItem) {
    const rhi = this.rhi;
    const gl = rhi.gl;
    let ext = null;
    if (ext = rhi.requireExtension(capabilityType)) {
      for (let glKey in flatItem) {
        const extensionKey = flatItem[glKey];
        const extensionVal = ext[extensionKey];
        if (extensionVal?.bind) {
          gl[glKey] = extensionVal.bind(ext);
        } else {
          gl[glKey] = extensionVal;
        }
      }
    }
  }
  compatibleAllInterface() {
    const {
      depthTexture,
      vertexArrayObject,
      instancedArrays,
      drawBuffers,
      textureFilterAnisotropic,
      textureHalfFloat,
      colorBufferHalfFloat,
      WEBGL_colorBufferFloat
    } = GLCapabilityType;
    const {isWebGL2} = this.rhi;
    if (!isWebGL2) {
      this.compatibleInterface(depthTexture, {
        UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
      });
      this.compatibleInterface(vertexArrayObject, {
        createVertexArray: "createVertexArrayOES",
        deleteVertexArray: "deleteVertexArrayOES",
        isVertexArray: "isVertexArrayOES",
        bindVertexArray: "bindVertexArrayOES"
      });
      this.compatibleInterface(instancedArrays, {
        drawArraysInstanced: "drawArraysInstancedANGLE",
        drawElementsInstanced: "drawElementsInstancedANGLE",
        vertexAttribDivisor: "vertexAttribDivisorANGLE"
      });
      this.compatibleInterface(drawBuffers, {
        MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
      });
      const items = {};
      if (this.canIUse(GLCapabilityType.drawBuffers)) {
        const maxDrawBuffers = this.maxDrawBuffers;
        for (let i = 0; i < maxDrawBuffers; i++) {
          i != 0 && (items[`COLOR_ATTACHMENT${i}`] = `COLOR_ATTACHMENT${i}_WEBGL`);
          items[`DRAW_BUFFER${i}`] = `DRAW_BUFFER${i}_WEBGL`;
        }
        this.compatibleInterface(drawBuffers, {
          drawBuffers: "drawBuffersWEBGL",
          ...items
        });
      }
      this.compatibleInterface(textureHalfFloat, {
        HAFL_FLOAT: "HALF_FLOAT_OES"
      });
      this.compatibleInterface(colorBufferHalfFloat, {
        RGBA16F: "RBGA16F_EXT"
      });
      this.compatibleInterface(WEBGL_colorBufferFloat, {
        RGBA32F: "RBGA32F_EXT"
      });
    }
    this.compatibleInterface(textureFilterAnisotropic, {
      TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
    });
  }
}

class GLExtensions {
  constructor(rhi) {
    this.rhi = rhi;
    this._requireResult = {};
  }
  requireExtension(ext) {
    if (this._requireResult[ext] !== void 0) {
      return this._requireResult[ext];
    }
    this._requireResult[ext] = this.rhi.gl.getExtension(ext);
    return this._requireResult[ext];
  }
}

class GLPrimitive {
  constructor(rhi, primitive) {
    this.vao = new Map();
    this._primitive = primitive;
    this.canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);
    this.gl = rhi.gl;
  }
  draw(tech, subPrimitive) {
    const gl = this.gl;
    const primitive = this._primitive;
    if (this._useVao) {
      if (!this.vao.has(tech.cacheID)) {
        this.registerVAO(tech);
      }
      const vao = this.vao.get(tech.cacheID);
      gl.bindVertexArray(vao);
    } else {
      this.bindBufferAndAttrib(tech);
    }
    const {indexBufferBinding, instanceCount, _glIndexType} = primitive;
    const {topology, start, count} = subPrimitive;
    if (!instanceCount) {
      if (indexBufferBinding) {
        if (this._useVao) {
          gl.drawElements(topology, count, _glIndexType, start);
        } else {
          const {_nativeBuffer} = indexBufferBinding.buffer;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
          gl.drawElements(topology, count, _glIndexType, start);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      } else {
        gl.drawArrays(topology, start, count);
      }
    } else {
      if (this.canUseInstancedArrays) {
        if (indexBufferBinding) {
          if (this._useVao) {
            gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);
          } else {
            const {_nativeBuffer} = indexBufferBinding.buffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
            gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArraysInstanced(topology, start, count, instanceCount);
        }
      } else {
        Logger.error("ANGLE_instanced_arrays extension is not supported");
      }
    }
    if (this._useVao) {
      gl.bindVertexArray(null);
    } else {
      this.disableAttrib();
    }
  }
  destroy() {
    if (this._useVao) {
      const gl = this.gl;
      this.vao.forEach((vao) => {
        gl.deleteVertexArray(vao);
      });
    }
  }
  bindBufferAndAttrib(tech) {
    const gl = this.gl;
    const primitive = this._primitive;
    const vertexBufferBindings = primitive.vertexBufferBindings;
    this.attribLocArray = [];
    const techAttributes = tech.attributes;
    const attributes = primitive._vertexElementMap;
    let vbo;
    let lastBoundVbo;
    for (const name in techAttributes) {
      const loc = techAttributes[name].location;
      if (loc === -1)
        continue;
      const semantic = techAttributes[name].semantic;
      const element = attributes[semantic];
      if (element) {
        const {buffer, stride} = vertexBufferBindings[element.bindingIndex];
        vbo = buffer._nativeBuffer;
        if (lastBoundVbo !== vbo) {
          lastBoundVbo = vbo;
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        }
        gl.enableVertexAttribArray(loc);
        const {size, type: type2} = element._glElementInfo;
        gl.vertexAttribPointer(loc, size, type2, element.normalized, stride, element.offset);
        if (this.canUseInstancedArrays) {
          gl.vertexAttribDivisor(loc, element.instanceDivisor);
        }
        this.attribLocArray.push(loc);
      } else {
        Logger.warn("vertex attribute not found: " + name);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  disableAttrib() {
    const gl = this.gl;
    for (let i = 0, l = this.attribLocArray.length; i < l; i++) {
      gl.disableVertexAttribArray(this.attribLocArray[i]);
    }
  }
  registerVAO(tech) {
    const gl = this.gl;
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    const {indexBufferBinding} = this._primitive;
    if (indexBufferBinding) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferBinding.buffer._nativeBuffer);
    }
    this.bindBufferAndAttrib(tech);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.disableAttrib();
    this.vao.set(tech.cacheID, vao);
  }
}

class GLRenderStates {
  constructor(gl) {
    this._stateStack = [];
    this._parameters = {};
    this._gl = gl;
    this._stateStack = [];
    this._parameters = {};
    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.BLEND] = false;
    gl.disable(gl.BLEND);
    this._parameters[gl.CULL_FACE] = true;
    gl.enable(gl.CULL_FACE);
    this._parameters[gl.DEPTH_TEST] = true;
    gl.enable(gl.DEPTH_TEST);
    this._parameters[gl.DITHER] = false;
    gl.disable(gl.DITHER);
    this._parameters[gl.POLYGON_OFFSET_FILL] = false;
    gl.disable(gl.POLYGON_OFFSET_FILL);
    this._parameters[gl.SAMPLE_ALPHA_TO_COVERAGE] = false;
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    this._parameters[gl.SAMPLE_COVERAGE] = false;
    gl.disable(gl.SAMPLE_COVERAGE);
    this._parameters[gl.SCISSOR_TEST] = false;
    gl.disable(gl.SCISSOR_TEST);
    this._parameters[gl.STENCIL_TEST] = false;
    gl.disable(gl.STENCIL_TEST);
    this._parameters[gl.COLOR_WRITEMASK] = [true, true, true, true];
    gl.colorMask(true, true, true, true);
    this._parameters[gl.DEPTH_WRITEMASK] = true;
    gl.depthMask(true);
    this._parameters[gl.BLEND_SRC_RGB] = gl.ONE;
    this._parameters[gl.BLEND_SRC_ALPHA] = gl.ONE;
    this._parameters[gl.BLEND_DST_RGB] = gl.ZERO;
    this._parameters[gl.BLEND_DST_ALPHA] = gl.ZERO;
    gl.blendFunc(gl.ONE, gl.ZERO);
    this._parameters[gl.BLEND_EQUATION_RGB] = gl.FUNC_ADD;
    this._parameters[gl.BLEND_EQUATION_ALPHA] = gl.FUNC_ADD;
    this._parameters[gl.CULL_FACE_MODE] = gl.BACK;
    gl.cullFace(gl.BACK);
    this._parameters[gl.FRONT_FACE] = gl.CCW;
    gl.frontFace(gl.CCW);
    this._parameters[gl.DEPTH_FUNC] = gl.LESS;
    gl.depthFunc(gl.LESS);
    this._parameters[gl.DEPTH_RANGE] = [0, 1];
    gl.depthRange(0, 1);
    this._parameters[gl.POLYGON_OFFSET_FACTOR] = 0;
    this._parameters[gl.POLYGON_OFFSET_UNITS] = 0;
    gl.polygonOffset(0, 0);
    this._parameters[gl.SCISSOR_BOX] = [0, 0, gl.canvas.width, gl.canvas.height];
    this._parameters[gl.STENCIL_FUNC] = gl.ALWAYS;
    this._parameters[gl.STENCIL_VALUE_MASK] = 255;
    this._parameters[gl.STENCIL_REF] = 0;
    gl.stencilFunc(gl.ALWAYS, 0, 255);
    this._parameters[gl.STENCIL_WRITEMASK] = 255;
    gl.stencilMask(255);
    this._parameters[gl.STENCIL_FAIL] = gl.KEEP;
    this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] = gl.KEEP;
    this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = gl.KEEP;
  }
  getParameter(pname) {
    return this._parameters[pname];
  }
  pushStateBlock(_name) {
    const stateBlock = {
      name: _name,
      states: []
    };
    this._stateStack.push(stateBlock);
  }
  popStateBlock() {
    const stateBlock = this._stateStack.pop();
    for (const state of stateBlock.states) {
      const stateFunc = state.func;
      const stateArgs = state.args;
      const parameters = state.parameters;
      stateFunc.apply(this._gl, stateArgs);
      for (const param in parameters) {
        this._parameters[param] = parameters[param];
      }
    }
  }
  _getStateStackTop() {
    const count = this._stateStack.length;
    if (count > 0) {
      return this._stateStack[count - 1];
    } else {
      return null;
    }
  }
  _pushState(_func, _args, _param) {
    const stateBlock = this._getStateStackTop();
    if (stateBlock) {
      stateBlock.states.push({
        func: _func,
        args: _args,
        parameters: _param
      });
    }
  }
  enable(cap) {
    const currentState = this._parameters[cap];
    if (currentState === true)
      return;
    this._parameters[cap] = true;
    this._gl.enable(cap);
    const pushParam = {};
    pushParam[cap] = false;
    this._pushState(this._gl.disable, [cap], pushParam);
  }
  disable(cap) {
    const currentState = this._parameters[cap];
    if (currentState === false)
      return;
    this._parameters[cap] = false;
    this._gl.disable(cap);
    const pushParam = {};
    pushParam[cap] = true;
    this._pushState(this._gl.enable, [cap], pushParam);
  }
  blendFunc(sfactor, dfactor) {
    const gl = this._gl;
    const param = this._parameters;
    if (param[gl.BLEND_SRC_RGB] === sfactor && param[gl.BLEND_SRC_ALPHA] === sfactor && param[gl.BLEND_DST_RGB] === dfactor && param[gl.BLEND_DST_ALPHA] === dfactor)
      return;
    const pushArgs = [
      param[gl.BLEND_SRC_RGB],
      param[gl.BLEND_DST_RGB],
      param[gl.BLEND_SRC_ALPHA],
      param[gl.BLEND_DST_ALPHA]
    ];
    const pushParam = {};
    pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];
    pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];
    pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];
    pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];
    this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);
    param[gl.BLEND_SRC_RGB] = sfactor;
    param[gl.BLEND_SRC_ALPHA] = sfactor;
    param[gl.BLEND_DST_RGB] = dfactor;
    param[gl.BLEND_DST_ALPHA] = dfactor;
    gl.blendFunc(sfactor, dfactor);
  }
  blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
    const gl = this._gl;
    const param = this._parameters;
    if (param[gl.BLEND_SRC_RGB] === srcRGB && param[gl.BLEND_SRC_ALPHA] === srcAlpha && param[gl.BLEND_DST_RGB] === dstRGB && param[gl.BLEND_DST_ALPHA] === dstAlpha)
      return;
    const pushArgs = [
      param[gl.BLEND_SRC_RGB],
      param[gl.BLEND_DST_RGB],
      param[gl.BLEND_SRC_ALPHA],
      param[gl.BLEND_DST_ALPHA]
    ];
    const pushParam = {};
    pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];
    pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];
    pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];
    pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];
    this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);
    param[gl.BLEND_SRC_RGB] = srcRGB;
    param[gl.BLEND_SRC_ALPHA] = srcAlpha;
    param[gl.BLEND_DST_RGB] = dstRGB;
    param[gl.BLEND_DST_ALPHA] = dstAlpha;
    gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  blendEquationSeparate(modeRGB, modeAlpha) {
    const gl = this._gl;
    const param = this._parameters;
    if (param[gl.BLEND_EQUATION_RGB] === modeRGB && param[gl.BLEND_EQUATION_ALPHA] === modeAlpha)
      return;
    const pushArgs = [param[gl.BLEND_EQUATION_RGB], param[gl.BLEND_EQUATION_ALPHA]];
    const pushParam = {};
    pushParam[gl.BLEND_EQUATION_RGB] = param[gl.BLEND_EQUATION_RGB];
    pushParam[gl.BLEND_EQUATION_ALPHA] = param[gl.BLEND_EQUATION_ALPHA];
    this._pushState(gl.blendEquationSeparate, pushArgs, pushParam);
    param[gl.BLEND_EQUATION_RGB] = modeRGB;
    param[gl.BLEND_EQUATION_ALPHA] = modeAlpha;
    gl.blendEquationSeparate(modeRGB, modeAlpha);
  }
  colorMask(red, green, blue, alpha) {
    const gl = this._gl;
    const pushParam = {};
    pushParam[gl.COLOR_WRITEMASK] = this._parameters[gl.COLOR_WRITEMASK];
    this._pushState(gl.colorMask, this._parameters[gl.COLOR_WRITEMASK], pushParam);
    this._parameters[gl.COLOR_WRITEMASK] = [red, green, blue, alpha];
    gl.colorMask(red, green, blue, alpha);
  }
  depthMask(flag) {
    const gl = this._gl;
    if (this._parameters[gl.DEPTH_WRITEMASK] === flag)
      return;
    const pushParam = {};
    pushParam[gl.DEPTH_WRITEMASK] = this._parameters[gl.DEPTH_WRITEMASK];
    this._pushState(gl.depthMask, [this._parameters[gl.DEPTH_WRITEMASK]], pushParam);
    this._parameters[gl.DEPTH_WRITEMASK] = flag;
    gl.depthMask(flag);
  }
  cullFace(mode) {
    const gl = this._gl;
    if (this._parameters[gl.CULL_FACE_MODE] === mode)
      return;
    const pushParam = {};
    pushParam[gl.CULL_FACE_MODE] = this._parameters[gl.CULL_FACE_MODE];
    this._pushState(gl.cullFace, [this._parameters[gl.CULL_FACE_MODE]], pushParam);
    this._parameters[gl.CULL_FACE_MODE] = mode;
    gl.cullFace(mode);
  }
  frontFace(mode) {
    const gl = this._gl;
    if (this._parameters[gl.FRONT_FACE] === mode)
      return;
    const pushParam = {};
    pushParam[gl.FRONT_FACE] = this._parameters[gl.FRONT_FACE];
    this._pushState(gl.frontFace, [this._parameters[gl.FRONT_FACE]], pushParam);
    this._parameters[gl.FRONT_FACE] = mode;
    gl.frontFace(mode);
  }
  depthFunc(func) {
    const gl = this._gl;
    if (this._parameters[gl.DEPTH_FUNC] === func)
      return;
    const pushParam = {};
    pushParam[gl.DEPTH_FUNC] = this._parameters[gl.DEPTH_FUNC];
    this._pushState(gl.depthFunc, [this._parameters[gl.DEPTH_FUNC]], pushParam);
    this._parameters[gl.DEPTH_FUNC] = func;
    gl.depthFunc(func);
  }
  depthRange(zNear, zFar) {
    const gl = this._gl;
    const currentValue = this._parameters[gl.DEPTH_RANGE];
    if (currentValue[0] === zNear && currentValue[1] === zFar)
      return;
    const pushParam = {};
    pushParam[gl.DEPTH_RANGE] = currentValue;
    this._pushState(gl.depthRange, [this._parameters[gl.DEPTH_RANGE]], pushParam);
    this._parameters[gl.DEPTH_RANGE] = [zNear, zFar];
    gl.depthRange(zNear, zFar);
  }
  polygonOffset(factor, units) {
    const gl = this._gl;
    if (this._parameters[gl.POLYGON_OFFSET_FACTOR] === factor && this._parameters[gl.POLYGON_OFFSET_UNITS] === units)
      return;
    const pushParam = {};
    pushParam[gl.POLYGON_OFFSET_FACTOR] = this._parameters[gl.POLYGON_OFFSET_FACTOR];
    pushParam[gl.POLYGON_OFFSET_UNITS] = this._parameters[gl.POLYGON_OFFSET_UNITS];
    this._pushState(gl.polygonOffset, [this._parameters[gl.POLYGON_OFFSET_FACTOR], this._parameters[gl.POLYGON_OFFSET_UNITS]], pushParam);
    this._parameters[gl.POLYGON_OFFSET_FACTOR] = factor;
    this._parameters[gl.POLYGON_OFFSET_UNITS] = units;
    gl.polygonOffset(factor, units);
  }
  scissor(x, y, width, height) {
    const gl = this._gl;
    const box = this._parameters[gl.SCISSOR_BOX];
    if (box[0] === x && box[1] === y && box[2] === width && box[3] === height)
      return;
    const pushParam = {};
    pushParam[gl.SCISSOR_BOX] = box;
    this._pushState(gl.scissor, box, pushParam);
    this._parameters[gl.SCISSOR_BOX] = [x, y, width, height];
    gl.scissor(x, y, width, height);
  }
  stencilFunc(func, ref, mask) {
    const gl = this._gl;
    if (this._parameters[gl.STENCIL_FUNC] === func && this._parameters[gl.STENCIL_REF] === ref && this._parameters[gl.STENCIL_VALUE_MASK] === mask)
      return;
    const pushArgs = [
      this._parameters[gl.STENCIL_FUNC],
      this._parameters[gl.STENCIL_REF],
      this._parameters[gl.STENCIL_VALUE_MASK]
    ];
    const pushParam = {};
    pushParam[gl.STENCIL_FUNC] = pushArgs[0];
    pushParam[gl.STENCIL_REF] = pushArgs[1];
    pushParam[gl.STENCIL_VALUE_MASK] = pushArgs[2];
    this._pushState(gl.stencilFunc, pushArgs, pushParam);
    this._parameters[gl.STENCIL_FUNC] = func;
    this._parameters[gl.STENCIL_REF] = ref;
    this._parameters[gl.STENCIL_VALUE_MASK] = mask;
    gl.stencilFunc(func, ref, mask);
  }
  stencilOp(fail, zfail, zpass) {
    const gl = this._gl;
    if (this._parameters[gl.STENCIL_FAIL] === fail && this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] === zfail && this._parameters[gl.STENCIL_PASS_DEPTH_PASS] === zpass)
      return;
    const pushArgs = [
      this._parameters[gl.STENCIL_FAIL],
      this._parameters[gl.STENCIL_PASS_DEPTH_FAIL],
      this._parameters[gl.STENCIL_PASS_DEPTH_PASS]
    ];
    const pushParam = {};
    pushParam[gl.STENCIL_FAIL] = pushArgs[0];
    pushParam[gl.STENCIL_PASS_DEPTH_FAIL] = pushArgs[1];
    pushParam[gl.STENCIL_PASS_DEPTH_PASS] = pushArgs[2];
    this._pushState(gl.stencilOp, pushArgs, pushParam);
    this._parameters[gl.STENCIL_FAIL] = fail;
    this._parameters[gl.STENCIL_BACK_PASS_DEPTH_FAIL] = zfail;
    this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = zpass;
    gl.stencilOp(fail, zfail, zpass);
  }
  stencilMask(mask) {
    const gl = this._gl;
    if (this._parameters[gl.STENCIL_WRITEMASK] === mask)
      return;
    const pushParam = {};
    pushParam[gl.STENCIL_WRITEMASK] = this._parameters[gl.STENCIL_WRITEMASK];
    this._pushState(gl.stencilMask, [this._parameters[gl.STENCIL_WRITEMASK]], pushParam);
    this._parameters[gl.STENCIL_WRITEMASK] = mask;
    gl.stencilMask(mask);
  }
}

class GLSprite {
  constructor(gl) {
    this.gl = gl;
    this._initVertexAttributes(gl);
    this._vbo = gl.createBuffer();
    this._maxBatchCount = 0;
    this._vertBuffer = null;
    this._vertCursor = 0;
    this._drawSpriteCount = 0;
  }
  setMaxBatchCount(count) {
    const requireSize = count * 6 * 9;
    if (this._vertBuffer && this._vertBuffer.length >= requireSize) {
      return;
    }
    this._maxBatchCount = count;
    this._vertBuffer = new Float32Array(requireSize);
  }
  beginDraw(count) {
    this._vertCursor = 0;
    this._drawSpriteCount = 0;
    if (count > this._maxBatchCount) {
      this.setMaxBatchCount(count);
    }
  }
  drawSprite(positionQuad, uvRect, tintColor) {
    this._drawSpriteCount++;
    if (this._drawSpriteCount > this._maxBatchCount) {
      Logger.warn("Sprite: sprite count overflow");
      return;
    }
    const color = tintColor;
    const u = uvRect.u;
    const v = uvRect.v;
    const p = uvRect.u + uvRect.width;
    const q = uvRect.v + uvRect.height;
    this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);
    this._pushVertex(positionQuad.leftBottom, new Vector2(u, q), color);
    this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);
    this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);
    this._pushVertex(positionQuad.rightTop, new Vector2(p, v), color);
    this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);
  }
  endDraw() {
    const vertCount = this._vertCursor / 9;
    if (vertCount <= 0)
      return;
    var gl = this.gl;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
    gl.bufferData(gl.ARRAY_BUFFER, this._vertBuffer, gl.DYNAMIC_DRAW);
    for (let i = 0, len = this._vertAttributes.length; i < len; i++) {
      const attrib = this._vertAttributes[i];
      gl.vertexAttribPointer(attrib.lastShaderLoc, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      gl.enableVertexAttribArray(attrib.lastShaderLoc);
    }
    gl.drawArrays(gl.TRIANGLES, 0, vertCount);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    for (let i = 0, len = this._vertAttributes.length; i < len; i++) {
      gl.disableVertexAttribArray(this._vertAttributes[i].lastShaderLoc);
    }
  }
  _initVertexAttributes(gl) {
    const vertexStride = (3 + 2 + 4) * 4;
    const posAtt = {};
    posAtt.name = "a_pos";
    posAtt.size = 3;
    posAtt.offset = 0;
    posAtt.lastShaderLoc = 0;
    const uvAtt = {};
    uvAtt.name = "a_uv";
    uvAtt.size = 2;
    uvAtt.offset = 3 * 4;
    uvAtt.lastShaderLoc = 1;
    const colorAtt = {};
    colorAtt.name = "a_color";
    colorAtt.size = 4;
    colorAtt.offset = 5 * 4;
    colorAtt.lastShaderLoc = 2;
    this._vertAttributes = [posAtt, uvAtt, colorAtt];
    for (const att of this._vertAttributes) {
      att.type = gl.FLOAT;
      att.normalized = false;
      att.stride = vertexStride;
    }
  }
  _pushVertex(pos, uv, color) {
    const vb = this._vertBuffer;
    const id = this._vertCursor;
    vb[id] = pos.x;
    vb[id + 1] = pos.y;
    vb[id + 2] = pos.z;
    vb[id + 3] = uv.x;
    vb[id + 4] = uv.y;
    vb[id + 5] = color.x;
    vb[id + 6] = color.y;
    vb[id + 7] = color.z;
    vb[id + 8] = color.w;
    this._vertCursor += 9;
  }
  finalize() {
    if (this._vbo) {
      this.gl.deleteBuffer(this._vbo);
      this._vbo = null;
    }
  }
}

const SpriteVertShader = `
precision highp float;

uniform mat4 matProjection;
uniform mat4 matView;

attribute vec3 a_pos;
attribute vec2 a_uv;
attribute vec4 a_color;

varying vec2 v_uv;
varying vec4 v_color;

void main()
{
  gl_Position = matProjection * matView * vec4(a_pos,1.0);
  v_uv = a_uv;
  v_color = a_color;
}
`;
const SpriteFragmentShader = `
precision mediump float;
precision mediump int;

uniform sampler2D s_diffuse;
varying vec2 v_uv;
varying vec4 v_color;

void main()
{
  // \u53EA\u4F7F\u7528\u8D34\u56FE\u7684Alpha\u505AMask\uFF0C\u8FD9\u6837Tint Color\u4F9D\u7136\u53EF\u4EE5\u63A7\u5236\u63A7\u4EF6Fade Out
  vec4 baseColor = texture2D(s_diffuse, v_uv);
  gl_FragColor = baseColor * v_color;
}
`;
const SpriteTechnique = {
  name: "spriteTech3D",
  vertexShader: SpriteVertShader,
  fragmentShader: SpriteFragmentShader,
  attribLocSet: {
    a_pos: 0,
    a_uv: 1,
    a_color: 2
  },
  attributes: {
    a_pos: {
      name: "a_pos",
      semantic: "POSITION",
      type: DataType.FLOAT_VEC3
    },
    a_uv: {
      name: "a_uv",
      semantic: "TEXCOORD_0",
      type: DataType.FLOAT_VEC2
    },
    a_color: {
      name: "a_color",
      semantic: "COLOR",
      type: DataType.FLOAT_VEC3
    }
  },
  uniforms: {
    matProjection: {
      name: "matProjection",
      semantic: UniformSemantic.PROJECTION,
      type: DataType.FLOAT_MAT4
    },
    matView: {
      name: "matView",
      semantic: UniformSemantic.VIEW,
      type: DataType.FLOAT_MAT4
    },
    s_diffuse: {
      name: "s_diffuse",
      type: DataType.SAMPLER_2D
    }
  },
  states: {
    disable: [RenderState.CULL_FACE],
    enable: [RenderState.BLEND],
    functions: {
      blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA],
      depthMask: [false]
    }
  }
};
function createSpriteMaterial() {
  const values = {};
  return {
    values,
    setValue: (key, val) => {
      values[key] = val;
    },
    getValue: (key) => {
      return values[key];
    }
  };
}

class GLSpriteBatcher {
  constructor(rhi) {
    this._gl = rhi.gl;
    this._batchedQueue = [];
    this._targetTexture = null;
    this._glSprite = new GLSprite(rhi.gl);
    this._glTech = new GLTechnique(rhi, SpriteTechnique);
    this._material = createSpriteMaterial();
    this._camera = null;
  }
  flush() {
    if (this._batchedQueue.length === 0) {
      return;
    }
    if (!this._targetTexture) {
      Logger.error("No texture!");
      return;
    }
    this._material.setValue("s_diffuse", this._targetTexture);
    this._material.setValue("matView", this._camera.viewMatrix);
    this._material.setValue("matProjection", this._camera.projectionMatrix);
    this._glTech.begin(this._material);
    this._glSprite.beginDraw(this._batchedQueue.length);
    for (let i = 0, len = this._batchedQueue.length; i < len; i++) {
      const positionQuad = this._batchedQueue[i].positionQuad;
      const uvRect = this._batchedQueue[i].uvRect;
      const tintColor = this._batchedQueue[i].tintColor;
      this._glSprite.drawSprite(positionQuad, uvRect, tintColor);
    }
    this._glSprite.endDraw();
    this._glTech.end();
    this._batchedQueue = [];
    this._targetTexture = null;
    this._camera = null;
  }
  canBatch(texture, renderMode, camera) {
    if (this._targetTexture === null) {
      return true;
    }
    return texture === this._targetTexture && camera === this._camera;
  }
  drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    if (!this.canBatch(texture, renderMode, camera)) {
      this.flush();
    }
    this._targetTexture = texture;
    this._camera = camera;
    this._batchedQueue.push({positionQuad, uvRect, tintColor});
  }
  finalize() {
    this._glSprite.finalize();
    this._glTech.finalize();
  }
}

var WebGLMode;
(function(WebGLMode2) {
  WebGLMode2[WebGLMode2["Auto"] = 0] = "Auto";
  WebGLMode2[WebGLMode2["WebGL2"] = 1] = "WebGL2";
  WebGLMode2[WebGLMode2["WebGL1"] = 2] = "WebGL1";
})(WebGLMode || (WebGLMode = {}));
class WebGLRenderer {
  get isWebGL2() {
    return this._isWebGL2;
  }
  constructor(options = {}) {
    this._options = options;
  }
  init(canvas, engine) {
    const option = this._options;
    this._engine = engine;
    const webCanvas = canvas._webCanvas;
    const webGLMode = option.webGLMode || 0;
    let gl;
    if (webGLMode == 0 || webGLMode == 1) {
      gl = webCanvas.getContext("webgl2", option);
      if (!gl && webCanvas instanceof HTMLCanvasElement) {
        gl = webCanvas.getContext("experimental-webgl2", option);
      }
      this._isWebGL2 = true;
    }
    if (!gl) {
      if (webGLMode == 0 || webGLMode == 2) {
        gl = webCanvas.getContext("webgl", option);
        if (!gl && webCanvas instanceof HTMLCanvasElement) {
          gl = webCanvas.getContext("experimental-webgl", option);
        }
        this._isWebGL2 = false;
      }
    }
    if (!gl) {
      throw new Error("Get GL Context FAILED.");
    }
    this._gl = gl;
    this._renderStates = new GLRenderStates(gl);
    this._assetsCache = new GLAssetsCache(this, option);
    this._extensions = new GLExtensions(this);
    this._capability = new GLCapability(this);
    this._frameCount = 0;
    this._options = null;
  }
  createPlatformPrimitive(primitive) {
    return new GLPrimitive(this, primitive);
  }
  get gl() {
    return this._gl;
  }
  get assetsCache() {
    return this._assetsCache;
  }
  get renderStates() {
    return this._renderStates;
  }
  get capability() {
    return this._capability;
  }
  get frameCount() {
    return this._frameCount;
  }
  requireExtension(ext) {
    return this._extensions.requireExtension(ext);
  }
  canIUse(capabilityType) {
    return this.capability.canIUse(capabilityType);
  }
  canIUseCompressedTextureInternalFormat(type2) {
    return this.capability.canIUseCompressedTextureInternalFormat(type2);
  }
  get canIUseMoreJoints() {
    return this.capability.canIUseMoreJoints;
  }
  viewport(x, y, width, height) {
    const gl = this._gl;
    gl.viewport(x, gl.drawingBufferHeight - y - height, width, height);
  }
  colorMask(r, g, b, a) {
    this._gl.colorMask(r, g, b, a);
  }
  beginFrame() {
    this._frameCount++;
  }
  clearRenderTarget(clearMode, clearParam) {
    const gl = this._gl;
    switch (clearMode) {
      case ClearMode.SOLID_COLOR:
        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        break;
      case ClearMode.DEPTH_ONLY:
        gl.clear(gl.DEPTH_BUFFER_BIT);
        break;
      case ClearMode.COLOR_ONLY:
        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
        gl.clear(gl.COLOR_BUFFER_BIT);
        break;
      case ClearMode.STENCIL_ONLY:
        gl.clear(gl.STENCIL_BUFFER_BIT);
        break;
      case ClearMode.ALL_CLEAR:
        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        break;
      case ClearMode.DONT_CLEAR:
        break;
    }
  }
  drawPrimitive(primitive, group, mtl) {
    let glTech = mtl.technique._glTechnique;
    glTech || (glTech = mtl.technique._glTechnique = new GLTechnique(this, mtl.technique));
    if (!glTech.valid)
      return;
    if (primitive && glTech) {
      glTech.begin(mtl);
      primitive.draw(glTech, group);
      glTech.end();
    } else {
      Logger.error("draw primitive failed.");
    }
  }
  drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    if (!this._spriteBatcher) {
      this._spriteBatcher = new GLSpriteBatcher(this);
    }
    this._spriteBatcher.drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera);
  }
  flushSprite() {
    if (this._spriteBatcher) {
      this._spriteBatcher.flush();
    }
  }
  activeRenderTarget(renderTarget, camera) {
    const gl = this._gl;
    if (renderTarget) {
      renderTarget._activeRenderTarget();
      const {width, height} = renderTarget;
      gl.viewport(0, 0, width, height);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      const viewport = camera.viewport;
      const width = gl.drawingBufferWidth;
      const height = gl.drawingBufferHeight;
      this.viewport(viewport.x * width, viewport.y * height, viewport.z * width, viewport.w * height);
    }
  }
  blitRenderTarget(renderTarget) {
    if (renderTarget) {
      if (renderTarget._MSAAFrameBuffer) {
        renderTarget._blitRenderTarget();
        return;
      }
    }
  }
  setRenderTargetFace(renderTarget, faceIndex) {
    if (renderTarget) {
      renderTarget._setRenderTargetFace(faceIndex);
    }
  }
  endFrame() {
    const CHECK_FREQ = 8;
    if (this._frameCount % CHECK_FREQ === 0) {
      this._assetsCache.compact();
    }
  }
  destroy() {
    this._assetsCache.finalize();
  }
}

class WebGLEngine extends Engine {
  constructor(canvas, webGLRendererOptions) {
    const webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
    const hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
    super(webCanvas, hardwareRenderer);
  }
  get canvas() {
    return this._canvas;
  }
}

export { GLShaderProgram, GLTechnique, GLTexture, WebCanvas, WebGLEngine, WebGLMode, WebGLRenderer };
//# sourceMappingURL=module.js.map
