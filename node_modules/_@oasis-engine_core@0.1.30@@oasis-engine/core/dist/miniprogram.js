'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var miniprogramAdapter = require('@ali/miniprogram-adapter');
var miniprogram = require('@oasis-engine/math/dist/miniprogram');

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * 资源加载的 Promise。
 */

(function (AssetPromiseStatus) {
  AssetPromiseStatus[AssetPromiseStatus["Success"] = 0] = "Success";
  AssetPromiseStatus[AssetPromiseStatus["Pending"] = 1] = "Pending";
  AssetPromiseStatus[AssetPromiseStatus["Failed"] = 2] = "Failed";
})(exports.AssetPromiseStatus || (exports.AssetPromiseStatus = {}));

var AssetPromise = /*#__PURE__*/function (_Promise) {
  _inherits(AssetPromise, _Promise);

  var _super = _createSuper(AssetPromise);

  _createClass(AssetPromise, [{
    key: "onProgress",

    /**
     * 进度回调。
     * @param callback - 进度回调
     * @returns 资源 Promise
     */
    value: function onProgress(callback) {
      this._listeners.add(callback);

      return this;
    }
    /**
     * 取消 Promise 请求。
     * @returns 资源 Promise
     */

  }, {
    key: "cancel",
    value: function cancel() {
      if (this._status !== exports.AssetPromiseStatus.Pending) {
        return this;
      }

      this._reject("Promise Canceled");

      return this;
    }
    /**
     * 创建一个资源加载的 Promise。
     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:
     * a resolve callback used to resolve the promise with a value or the result of another promise,
     * and a reject callback used to reject the promise with a provided reason or error.
     * and a setProgress callback used to set promise progress with a percent.
     */

  }, {
    key: "status",

    /**
     * 当前 promise 状态。
     */
    get: function get() {
      return this._status;
    }
    /**
     * 加载进度。
     */

  }, {
    key: "progress",
    get: function get() {
      return this._progress;
    }
  }], [{
    key: "all",

    /**
     * 通过提供的资源 Promise 集合返回一个新的资源 Promise。
     * 当提供集合中所有的 Promise 完成时会触发新资源 Promise 的 resolved。
     * @param - 资源 Promise 集合
     * @returns 资源 Promise
     */
    value: function all(promises) {
      return new AssetPromise(function (resolve, reject, setProgress) {
        if (!Array.isArray(promises)) {
          return resolve([promises]);
        }

        var completed = 0;
        var total = promises.length;
        var results = new Array(total);
        promises.forEach(function (value, index) {
          Promise.resolve(value).then(function (result) {
            results[index] = result;
            completed += 1;
            setProgress(completed / total);

            if (completed == total) {
              resolve(results);
            }
          })["catch"](function (err) {
            return reject(err);
          });
        });
      });
    }
  }]);

  function AssetPromise(executor) {
    var _this;

    _classCallCheck(this, AssetPromise);

    var newReject;

    var setProgress = function setProgress(progress) {
      if (progress <= _this._progress) {
        return;
      }

      _this._progress = progress;

      var _iterator = _createForOfIteratorHelper(_this._listeners),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          listener(progress);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };

    _this = _super.call(this, function (resolve, reject) {
      newReject = function newReject(reason) {
        // 加入到微任务中，避免直接调用找不到 this 报错
        Promise.resolve().then(function () {
          _this._status = exports.AssetPromiseStatus.Failed;
          reject(reason);
        });
      };

      executor(function (value) {
        // 加入到微任务中，避免直接调用找不到 this 报错
        Promise.resolve().then(function () {
          setProgress(1);
          _this._status = exports.AssetPromiseStatus.Success;
          resolve(value);
        });
      }, newReject, function (progress) {
        // 加入到微任务中，避免直接调用找不到 this 报错
        Promise.resolve().then(function () {
          setProgress(progress);
        });
      });
    });
    _this._status = void 0;
    _this._progress = void 0;
    _this._reject = void 0;
    _this._listeners = void 0;
    _this._reject = newReject;
    _this._listeners = new Set();
    _this._progress = 0;
    _this._status = exports.AssetPromiseStatus.Pending;
    return _this;
  }

  return AssetPromise;
}( /*#__PURE__*/_wrapNativeSuper(Promise));

var Util = {
  isArray: "isArray" in Array ? Array.isArray : function (value) {
    return toString.call(value) === "[object Array]";
  },
  isArrayLike: function isArrayLike(x) {
    return !!x && typeof x.length === "number" && typeof x !== "function";
  },
  clone: function clone(obj) {
    if (_typeof(obj) !== "object" || obj === null) {
      return obj;
    }

    var rst;

    if (Util.isArrayLike(obj)) {
      rst = obj.slice();

      for (var i = 0, l = obj.length; i < l; i++) {
        rst[i] = Util.clone(obj[i]);
      }
    } else {
      rst = {};

      for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
          rst[k] = Util.clone(obj[k]);
        }
      }
    }

    return rst;
  },

  /**
   * 下载Blob对象
   * @param {Blob} blob - 浏览器 blob 对象
   * @param {string} fileName - 下载文件名字
   */
  downloadBlob: function downloadBlob(blob) {
    var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (miniprogramAdapter.navigator && miniprogramAdapter.navigator.msSaveBlob) {
      miniprogramAdapter.navigator.msSaveBlob(blob, fileName);
      return;
    }

    var url = miniprogramAdapter.window.URL.createObjectURL(blob);
    var a = miniprogramAdapter.document.createElement("a");
    miniprogramAdapter.document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function () {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    miniprogramAdapter.window.URL.revokeObjectURL(url);
  }
};
/**
 * 通过交换法快速从数组中移除元素。
 * @param array - 数组
 * @param item - 元素
 */

function removeFromArray(array, item) {
  var index = array.indexOf(item);

  if (index < 0) {
    return false;
  }

  var last = array.length - 1;

  if (index !== last) {
    var end = array[last];
    array[index] = end;
  }

  array.length--;
  return true;
}
function ObjectValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

/**
 * 资源管理员。
 */

var ResourceManager = /*#__PURE__*/function () {
  _createClass(ResourceManager, null, [{
    key: "_addLoader",

    /** loader 集合。*/

    /**
     * @internal
     */
    value: function _addLoader(type, loader, extnames) {
      this._loaders[type] = loader;

      for (var i = 0, len = extnames.length; i < len; i++) {
        this._extTypeMapping[extnames[i]] = type;
      }
    }
  }, {
    key: "_getTypeByUrl",
    value: function _getTypeByUrl(url) {
      var path = url.split("?")[0];
      return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
    }
    /** 加载资产失败后的重试次数。*/

  }]);

  /**
   * 创建资源管理员。
   * @param engine - 当前资源管理所属的 engine
   */
  function ResourceManager(engine) {
    _classCallCheck(this, ResourceManager);

    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = 20000;
    this._assetPool = Object.create(null);
    this._assetUrlPool = Object.create(null);
    this._refObjectPool = Object.create(null);
    this._loadingPromises = {};
  }
  /**
   * 通过路径异步加载资源。
   * @param path - 路径
   * @returns 资源 Promise
   */


  _createClass(ResourceManager, [{
    key: "load",
    value: function load(assetInfo) {
      var _this = this;

      // single item
      if (!Array.isArray(assetInfo)) {
        return this._loadSingleItem(assetInfo);
      } // multi items


      var promises = assetInfo.map(function (item) {
        return _this._loadSingleItem(item);
      });
      return AssetPromise.all(promises);
    }
    /**
     * 取消所有未完成加载的资产。
     */

  }, {
    key: "cancelNotLoaded",
    value: function cancelNotLoaded(url) {
      var _this2 = this;

      if (!url) {
        ObjectValues(this._loadingPromises).forEach(function (promise) {
          promise.cancel();
        });
      } else if (typeof url === "string") {
        var _this$_loadingPromise;

        (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
      } else {
        url.forEach(function (p) {
          var _this2$_loadingPromis;

          (_this2$_loadingPromis = _this2._loadingPromises[p]) === null || _this2$_loadingPromis === void 0 ? void 0 : _this2$_loadingPromis.cancel();
        });
      }
    }
    /**
     * 垃圾回收，会释放受引用计数管理的资源对象。
     * @remarks 释放原则为没有被组件实例引用，包含直接引用和间接引用。
     */

  }, {
    key: "gc",
    value: function gc() {
      var objects = ObjectValues(this._refObjectPool);

      for (var i = 0, len = objects.length; i < len; i++) {
        if (!objects[i].isGCIgnored) {
          objects[i].destroy();
        }
      }
    }
    /**
     * 根据 instanceId 获取资源路径
     * @param instanceId 对象 id
     * @returns 资源路径
     */

  }, {
    key: "getAssetPath",
    value: function getAssetPath(instanceId) {
      return this._assetPool[instanceId];
    }
    /**
     * @internal
     */

  }, {
    key: "_addAsset",
    value: function _addAsset(path, asset) {
      this._assetPool[asset.instanceId] = path;
      this._assetUrlPool[path] = asset;
    }
    /**
     * @internal
     */

  }, {
    key: "_deleteAsset",
    value: function _deleteAsset(asset) {
      var id = asset.instanceId;
      var path = this._assetPool[id];

      if (path) {
        delete this._assetPool[id];
        delete this._assetUrlPool[path];
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_addRefObject",
    value: function _addRefObject(id, asset) {
      this._refObjectPool[id] = asset;
    }
    /**
     * @internal
     */

  }, {
    key: "_deleteRefObject",
    value: function _deleteRefObject(id) {
      delete this._refObjectPool[id];
    }
  }, {
    key: "_assignDefaultOptions",
    value: function _assignDefaultOptions(assetInfo) {
      var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;

      assetInfo.type = (_assetInfo$type = assetInfo.type) !== null && _assetInfo$type !== void 0 ? _assetInfo$type : ResourceManager._getTypeByUrl(assetInfo.url);

      if (assetInfo.type === undefined) {
        throw "asset type should be specified: ".concat(assetInfo.url);
      }

      assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) !== null && _assetInfo$retryCount !== void 0 ? _assetInfo$retryCount : this.retryCount;
      assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) !== null && _assetInfo$timeout !== void 0 ? _assetInfo$timeout : this.timeout;
      assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) !== null && _assetInfo$retryInter !== void 0 ? _assetInfo$retryInter : this.retryInterval;
      assetInfo.url = (_assetInfo$url = assetInfo.url) !== null && _assetInfo$url !== void 0 ? _assetInfo$url : assetInfo.urls.join(",");
      return assetInfo;
    }
  }, {
    key: "_loadSingleItem",
    value: function _loadSingleItem(item) {
      var _this3 = this;

      var info = this._assignDefaultOptions(typeof item === "string" ? {
        url: item
      } : item);

      var url = info.url; // has cache

      if (this._assetUrlPool[url]) {
        return new AssetPromise(function (resolve) {
          resolve(_this3._assetUrlPool[url]);
        });
      } // loading


      if (this._loadingPromises[url]) {
        return this._loadingPromises[info.url];
      }

      var loader = ResourceManager._loaders[info.type];
      var promise = loader.load(info, this);
      this._loadingPromises[url] = promise;
      promise.then(function (res) {
        if (loader.useCache) _this3._addAsset(url, res);
        delete _this3._loadingPromises[url];
      })["catch"](function () {// then 会产生一个新的 promise，若是报错没有 catch 会导致 uncaught error
      });
      return promise;
    }
  }]);

  return ResourceManager;
}();
/**
 * 声明 resourceLoader 的装饰器。
 * @param assetType - 资源类型
 * @param extnames - 扩展名
 */

ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
function resourceLoader(assetType, extnames) {
  var useCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return function (Target) {
    var loader = new Target(useCache);

    ResourceManager._addLoader(assetType, loader, extnames);
  };
}

/** 事件对象* @class */
var Event = /*#__PURE__*/function () {
  _createClass(Event, [{
    key: "propagationStopped",
    get: function get() {
      return this._propagationStopped;
    }
  }, {
    key: "target",
    get: function get() {
      return this._target;
    },
    set: function set(t) {
      this._target = t;
    }
  }, {
    key: "timeStamp",
    get: function get() {
      return this._timeStamp;
    }
  }, {
    key: "currentTarget",
    get: function get() {
      return this._currentTarget;
    },
    set: function set(t) {
      this._currentTarget = t;
    }
  }, {
    key: "bubbles",
    get: function get() {
      return this._bubbles;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }]);

  function Event(type) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var bubbles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    _classCallCheck(this, Event);

    this.data = void 0;
    this._timeStamp = void 0;
    this._target = void 0;
    this._currentTarget = void 0;
    this._bubbles = void 0;
    this._propagationStopped = void 0;
    this._type = void 0;
    this._timeStamp = new Date().getTime();
    this._target = target;
    this.data = data;
    this._currentTarget = null;
    this._bubbles = bubbles;
    this._propagationStopped = false;
    this._type = type;
  }

  _createClass(Event, [{
    key: "stopPropagation",
    value: function stopPropagation() {
      this._propagationStopped = true;
    }
  }]);

  return Event;
}();

/**
 * 克隆模式。
 */
var CloneMode;

(function (CloneMode) {
  CloneMode[CloneMode["Ignore"] = 0] = "Ignore";
  CloneMode[CloneMode["Assignment"] = 1] = "Assignment";
  CloneMode[CloneMode["Shallow"] = 2] = "Shallow";
  CloneMode[CloneMode["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));

/**
 * 属性装饰器，克隆时对字段进行忽略。
 */

function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
/**
 * 属性装饰器，克隆时对字段进行浅克隆。
 * 克隆后会保持自身引用独立，并使用赋值的方式克隆其内部所有字段（如果内部字段是基本类型则会拷贝值，如果内部字段是引用类型则会拷贝其引用地址）。
 *
 * @remarks
 * 适用于 Obect、Array 和 Class 类型。
 */

function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
/**
 * 属性装饰器，克隆时对属性进行深克隆。
 * 克隆后会保持自身引用独立，并且其内部所有深层字段均保持完全独立。
 *
 * @remarks
 * 适用于 Obect、Array 和 Class 类型。
 * 如果在深克隆过程中遇到 Class 则会调用对象的 cloneTo() 实现克隆，需要对象实现 IClone 接口。
 */

function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
/**
 * @internal
 * 克隆管理员。
 */

var CloneManager = /*#__PURE__*/function () {
  function CloneManager() {
    _classCallCheck(this, CloneManager);
  }

  _createClass(CloneManager, null, [{
    key: "registerCloneMode",

    /** @internal */

    /** @internal */

    /**
     * 注释克隆模式。
     * @param target - 克隆目标类型
     * @param propertyKey - 属性名称
     * @param mode - 克隆模式
     */
    value: function registerCloneMode(target, propertyKey, mode) {
      var targetMap = CloneManager._subCloneModeMap.get(target.constructor);

      if (!targetMap) {
        targetMap = Object.create(null);

        CloneManager._subCloneModeMap.set(target.constructor, targetMap);
      }

      targetMap[propertyKey] = mode;
    }
    /**
     * 根据原型链获取 CloneMode。
     */

  }, {
    key: "getCloneModeMode",
    value: function getCloneModeMode(type) {
      var cloneModes = CloneManager._cloneModeMap.get(type);

      if (!cloneModes) {
        cloneModes = Object.create(null);

        CloneManager._cloneModeMap.set(type, cloneModes);

        var obejctType = CloneManager._obejctType;
        var cloneModeMap = CloneManager._subCloneModeMap;

        while (type !== obejctType) {
          var subCloneModes = cloneModeMap.get(type);

          if (subCloneModes) {
            _extends(cloneModes, subCloneModes);
          }

          type = Object.getPrototypeOf(type);
        }
      }

      return cloneModes;
    }
  }]);

  return CloneManager;
}();
CloneManager._subCloneModeMap = new Map();
CloneManager._cloneModeMap = new Map();
CloneManager._obejctType = Object.getPrototypeOf(Object);

var _class, _descriptor, _descriptor2, _class2, _temp;
/**
 * 引擎对象。
 */

var EngineObject = (_class = (_temp = _class2 =
/** 引擎唯一 Id。*/

/** 所属引擎。*/
function EngineObject(engine) {
  _classCallCheck(this, EngineObject);

  _initializerDefineProperty(this, "instanceId", _descriptor, this);

  _initializerDefineProperty(this, "_engine", _descriptor2, this);

  this._engine = engine;
}, _class2._instanceIdCounter = 0, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "instanceId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return ++EngineObject._instanceIdCounter;
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "_engine", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class);

var _class$1, _descriptor$1, _temp$1;
/**
 * 事件派发管理，可作为基类继承
 * @class
 */

var EventDispatcher = (_class$1 = (_temp$1 = /*#__PURE__*/function (_EngineObject) {
  _inherits(EventDispatcher, _EngineObject);

  var _super = _createSuper(EventDispatcher);

  function EventDispatcher() {
    var _this;

    _classCallCheck(this, EventDispatcher);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _initializerDefineProperty(_this, "_evts", _descriptor$1, _assertThisInitialized(_this));

    _this._evtCount = 0;
    return _this;
  }

  _createClass(EventDispatcher, [{
    key: "hasEvent",

    /**
     * 判断是否有事件监听。
     * @param event 事件名
     * @returns 返回是否有对应事件
     */
    value: function hasEvent(event) {
      return this._evts[event] != null;
    }
    /**
     * 返回注册的所有事件名。
     * @returns 所有的事件名
     */

  }, {
    key: "eventNames",
    value: function eventNames() {
      if (this._evtCount === 0) return [];
      return Object.keys(this._evts);
    }
    /**
     * 返回指定事件名的监听函数的数量。
     * @param event 事件名
     * @returns 监听函数的数量
     */

  }, {
    key: "listenerCount",
    value: function listenerCount(event) {
      var listeners = this._evts[event];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    }
    /**
     * 派发指定事件名的事件。
     * @param event 事件名
     * @param data 数据
     * @returns 派发事件是否成功
     */

  }, {
    key: "dispatch",
    value: function dispatch(event, data) {
      if (!this._evts[event]) {
        return false;
      }

      var listeners = this._evts[event];

      if (listeners.fn) {
        if (listeners.once) this.removeEventListener(event, listeners.fn);
        listeners.fn(data);
      } else {
        var l = listeners.length;

        for (var i = 0; i < l; i++) {
          if (listeners[i].once) this.removeEventListener(event, listeners[i].fn);
          listeners[i].fn(data);
        }
      }

      return true;
    }
    /**
     * 添加监听函数。
     * @param event 事件名
     * @param fn 函数
     * @returns this
     */

  }, {
    key: "on",
    value: function on(event, fn) {
      return this.addEventListener(event, fn);
    }
    /**
     * 添加一次性的监听函数。
     * @param event 事件名
     * @param fn 函数
     * @returns this
     */

  }, {
    key: "once",
    value: function once(event, fn) {
      return this.addEventListener(event, fn, true);
    }
    /**
     * @deprecated 使用 on/once 替换
     * 添加指定事件名的监听函数。
     * @param event 事件名
     * @param fn 函数
     * @param once 是否是一次性监听
     * @returns this
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(event, fn, once) {
      var listener = {
        fn: fn,
        once: once
      };
      var events = this._evts;

      if (!events[event]) {
        events[event] = listener;
        this._evtCount++;
      } else if (!events[event].fn) {
        events[event].push(listener);
      } else {
        events[event] = [events[event], listener];
      }

      return this;
    }
  }, {
    key: "off",
    value: function off(event, fn) {
      if (!this._evts[event]) return this;

      if (!fn) {
        this._clearEvent(event);

        return this;
      }

      var listeners = this._evts[event];

      if (listeners.fn && listeners.fn === fn) {
        this._clearEvent(event);
      } else {
        var index = listeners.indexOf(fn);

        if (index > -1) {
          var temp = listeners[listeners.length - 1];
          listeners[index] = temp;
          listeners.length--;

          if (listeners.length === 1) {
            this._evts[event] = listeners[0];
          }
        }
      }

      return this;
    }
    /**
     * @deprecated 使用
     * 移除指定事件名的事件监听。
     * @param event - 事件名
     * @param fn - 函数，若不传则删除所有对应的事件监听
     */

  }, {
    key: "removeEventListener",
    value: function removeEventListener(event, fn) {
      return this.off(event, fn);
    }
    /**
     * 移除所有的事件监听。
     * @param event - 事件名，若不传则删除所有事件
     */

  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners(event) {
      if (event) {
        if (this._evts[event]) this._clearEvent(event);
      } else {
        this._evts = Object.create(null);
        this._evtCount = 0;
      }
    }
    /**
     * @deprecated 使用 dispatch 替换
     * @param - 事件
     */

  }, {
    key: "trigger",
    value: function trigger(e) {
      this.dispatch(e.type, e.data);
    }
  }, {
    key: "_clearEvent",
    value: function _clearEvent(event) {
      if (--this._evtCount === 0) {
        this._evts = Object.create(null);
      } else {
        delete this._evts[event];
      }
    }
  }]);

  return EventDispatcher;
}(EngineObject), _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "_evts", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return Object.create(null);
  }
})), _class$1);

/**
 * console log的简单封装，默认为关闭状态，需要调用Logger.enable()来开启
 * @class
 * @private
 */

/* tslint:disable */
var noop = function noop(message) {};

var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,

  /** 开启Log */
  enable: function enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },

  /** 关闭Log */
  disable: function disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};

/**
 * 计算每帧时间的工具类
 * @class
 */
var Time = /*#__PURE__*/function () {
  /**
   * 初始化内部数据
   * @constructor
   */
  function Time() {
    _classCallCheck(this, Time);

    this._clock = void 0;
    this._timeScale = void 0;
    this._deltaTime = void 0;
    this._startTime = void 0;
    this._lastTickTime = void 0;
    // 优先使用 performance 进行计时
    this._clock = miniprogramAdapter.performance ? miniprogramAdapter.performance : Date;
    this._timeScale = 1.0;
    this._deltaTime = 0.0001;

    var now = this._clock.now();

    this._startTime = now;
    this._lastTickTime = now;
  }

  _createClass(Time, [{
    key: "reset",
    value: function reset() {
      this._lastTickTime = this._clock.now();
    }
    /**
     * 当前时间
     * @readonly
     */

  }, {
    key: "tick",

    /**
     * 每帧调用，更新 Delta Time 等内部数据
     */
    value: function tick() {
      var now = this.nowTime;
      this._deltaTime = (now - this._lastTickTime) * this._timeScale;
      this._lastTickTime = now;
    }
  }, {
    key: "nowTime",
    get: function get() {
      return this._clock.now();
    }
    /**
     * 两次 tick 之间的时间
     * @readonly
     */

  }, {
    key: "deltaTime",
    get: function get() {
      return this._deltaTime;
    }
    /**
     * Delta Time 的缩放值
     */

  }, {
    key: "timeScale",
    get: function get() {
      return this._timeScale;
    },
    set: function set(s) {
      this._timeScale = s;
    }
    /**
     * 未经缩放的 Delta Time 数值
     * @readonly
     */

  }, {
    key: "unscaledDeltaTime",
    get: function get() {
      return this._deltaTime / this._timeScale;
    }
    /**
     * 时钟初始化之后，经历的时间
     */

  }, {
    key: "timeSinceStartup",
    get: function get() {
      return this.nowTime - this._startTime;
    }
  }]);

  return Time;
}();

/**
 * 资源的类型，主要用来处理资源对象关联的GL对象的回收
 */
/**
 * Camera 的清空模式枚举
 * @readonly
 */

(function (InternalAssetType) {
  InternalAssetType[InternalAssetType["Scene"] = 1] = "Scene";
  InternalAssetType[InternalAssetType["Cache"] = 2] = "Cache";
})(exports.InternalAssetType || (exports.InternalAssetType = {}));
/**
 * 材质类型枚举
 * @readonly
 */

(function (ClearMode) {
  ClearMode[ClearMode["DONT_CLEAR"] = 0] = "DONT_CLEAR";
  ClearMode[ClearMode["SOLID_COLOR"] = 1] = "SOLID_COLOR";
  ClearMode[ClearMode["DEPTH_ONLY"] = 2] = "DEPTH_ONLY";
  ClearMode[ClearMode["COLOR_ONLY"] = 3] = "COLOR_ONLY";
  ClearMode[ClearMode["STENCIL_ONLY"] = 4] = "STENCIL_ONLY";
  ClearMode[ClearMode["ALL_CLEAR"] = 5] = "ALL_CLEAR";
})(exports.ClearMode || (exports.ClearMode = {}));
/**
 * 可以开启或者关闭的渲染状态
 * @readonly
 */

(function (MaterialType) {
  MaterialType[MaterialType["OPAQUE"] = 1000] = "OPAQUE";
  MaterialType[MaterialType["TRANSPARENT"] = 2000] = "TRANSPARENT";
})(exports.MaterialType || (exports.MaterialType = {}));
/**
 * 面朝向枚举
 * @readonly
 */

(function (RenderState) {
  RenderState[RenderState["BLEND"] = 3042] = "BLEND";
  RenderState[RenderState["CULL_FACE"] = 2884] = "CULL_FACE";
  RenderState[RenderState["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  RenderState[RenderState["ALPHA_TEST"] = 3008] = "ALPHA_TEST";
  RenderState[RenderState["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  RenderState[RenderState["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  RenderState[RenderState["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
})(exports.RenderState || (exports.RenderState = {}));
/**
 * 面剔除枚举
 * @readonly
 */

(function (FrontFace) {
  FrontFace[FrontFace["CW"] = 2304] = "CW";
  FrontFace[FrontFace["CCW"] = 2305] = "CCW";
})(exports.FrontFace || (exports.FrontFace = {}));
/**
 * 显示面枚举
 * @readonly
 * */

(function (CullFace) {
  CullFace[CullFace["FRONT"] = 1028] = "FRONT";
  CullFace[CullFace["BACK"] = 1029] = "BACK";
  CullFace[CullFace["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(exports.CullFace || (exports.CullFace = {}));
/**
 * 比较函数枚举
 * @readonly
 */

(function (Side) {
  Side[Side["FRONT"] = 0] = "FRONT";
  Side[Side["BACK"] = 1] = "BACK";
  Side[Side["NONE"] = 2] = "NONE";
  Side[Side["DOUBLE"] = 3] = "DOUBLE";
})(exports.Side || (exports.Side = {}));
/**
 * 纹理过滤枚举
 * @readonly
 */

(function (CompFunc) {
  CompFunc[CompFunc["NEVER"] = 512] = "NEVER";
  CompFunc[CompFunc["LESS"] = 513] = "LESS";
  CompFunc[CompFunc["EQUAL"] = 514] = "EQUAL";
  CompFunc[CompFunc["LEQUAL"] = 515] = "LEQUAL";
  CompFunc[CompFunc["GREATER"] = 516] = "GREATER";
  CompFunc[CompFunc["NOTEQUAL"] = 517] = "NOTEQUAL";
  CompFunc[CompFunc["GEQUAL"] = 518] = "GEQUAL";
  CompFunc[CompFunc["ALWAYS"] = 519] = "ALWAYS";
})(exports.CompFunc || (exports.CompFunc = {}));
/**
 * 数据类型枚举
 */

(function (TextureFilter) {
  TextureFilter[TextureFilter["NEAREST"] = 9728] = "NEAREST";
  TextureFilter[TextureFilter["LINEAR"] = 9729] = "LINEAR";
  TextureFilter[TextureFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  TextureFilter[TextureFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  TextureFilter[TextureFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  TextureFilter[TextureFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(exports.TextureFilter || (exports.TextureFilter = {}));
/**
 * glTF 1.0所支持的Uniform Semantic以及Oasis3D的扩展
 * @readonly
 */

(function (DataType) {
  DataType[DataType["FLOAT"] = 5126] = "FLOAT";
  DataType[DataType["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType[DataType["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType[DataType["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType[DataType["INT"] = 5124] = "INT";
  DataType[DataType["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType[DataType["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType[DataType["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType[DataType["BOOL"] = 35670] = "BOOL";
  DataType[DataType["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType[DataType["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType[DataType["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType[DataType["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType[DataType["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType[DataType["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType[DataType["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType[DataType["FLOAT_VEC2_ARRAY"] = 100000] = "FLOAT_VEC2_ARRAY";
  DataType[DataType["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType[DataType["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType[DataType["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType[DataType["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType[DataType["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType[DataType["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType[DataType["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType[DataType["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType[DataType["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType[DataType["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType[DataType["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType[DataType["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType[DataType["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType[DataType["BYTE"] = 5120] = "BYTE";
  DataType[DataType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType[DataType["SHORT"] = 5122] = "SHORT";
  DataType[DataType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType[DataType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(exports.DataType || (exports.DataType = {}));
/**
 * 颜色混合方式枚举
 */

(function (UniformSemantic) {
  UniformSemantic[UniformSemantic["LOCAL"] = 1] = "LOCAL";
  UniformSemantic[UniformSemantic["MODEL"] = 2] = "MODEL";
  UniformSemantic[UniformSemantic["VIEW"] = 3] = "VIEW";
  UniformSemantic[UniformSemantic["PROJECTION"] = 4] = "PROJECTION";
  UniformSemantic[UniformSemantic["MODELVIEW"] = 5] = "MODELVIEW";
  UniformSemantic[UniformSemantic["VIEWPROJECTION"] = 21] = "VIEWPROJECTION";
  UniformSemantic[UniformSemantic["MODELVIEWPROJECTION"] = 6] = "MODELVIEWPROJECTION";
  UniformSemantic[UniformSemantic["MODELINVERSE"] = 7] = "MODELINVERSE";
  UniformSemantic[UniformSemantic["VIEWINVERSE"] = 8] = "VIEWINVERSE";
  UniformSemantic[UniformSemantic["PROJECTIONINVERSE"] = 9] = "PROJECTIONINVERSE";
  UniformSemantic[UniformSemantic["MODELVIEWINVERSE"] = 10] = "MODELVIEWINVERSE";
  UniformSemantic[UniformSemantic["MODELVIEWPROJECTIONINVERSE"] = 11] = "MODELVIEWPROJECTIONINVERSE";
  UniformSemantic[UniformSemantic["MODELINVERSETRANSPOSE"] = 12] = "MODELINVERSETRANSPOSE";
  UniformSemantic[UniformSemantic["MODELVIEWINVERSETRANSPOSE"] = 13] = "MODELVIEWINVERSETRANSPOSE";
  UniformSemantic[UniformSemantic["VIEWPORT"] = 14] = "VIEWPORT";
  UniformSemantic[UniformSemantic["JOINTMATRIX"] = 15] = "JOINTMATRIX";
  UniformSemantic[UniformSemantic["MORPHWEIGHTS"] = 16] = "MORPHWEIGHTS";
  UniformSemantic[UniformSemantic["EYEPOS"] = 17] = "EYEPOS";
  UniformSemantic[UniformSemantic["TIME"] = 18] = "TIME";
  UniformSemantic[UniformSemantic["JOINTTEXTURE"] = 19] = "JOINTTEXTURE";
  UniformSemantic[UniformSemantic["JOINTCOUNT"] = 20] = "JOINTCOUNT";
})(exports.UniformSemantic || (exports.UniformSemantic = {}));
/**
 * RenderPass 的可用 MASK
 * @readonly
 * @private
 */

(function (BlendFunc) {
  BlendFunc[BlendFunc["ZERO"] = 0] = "ZERO";
  BlendFunc[BlendFunc["ONE"] = 1] = "ONE";
  BlendFunc[BlendFunc["SRC_COLOR"] = 768] = "SRC_COLOR";
  BlendFunc[BlendFunc["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  BlendFunc[BlendFunc["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  BlendFunc[BlendFunc["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  BlendFunc[BlendFunc["DST_ALPHA"] = 772] = "DST_ALPHA";
  BlendFunc[BlendFunc["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  BlendFunc[BlendFunc["DST_COLOR"] = 774] = "DST_COLOR";
  BlendFunc[BlendFunc["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  BlendFunc[BlendFunc["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  BlendFunc[BlendFunc["enumANT_COLOR"] = 32769] = "enumANT_COLOR";
  BlendFunc[BlendFunc["ONE_MINUS_enumANT_COLOR"] = 32770] = "ONE_MINUS_enumANT_COLOR";
  BlendFunc[BlendFunc["enumANT_ALPHA"] = 32771] = "enumANT_ALPHA";
  BlendFunc[BlendFunc["ONE_MINUS_enumANT_ALPHA"] = 32772] = "ONE_MINUS_enumANT_ALPHA";
})(exports.BlendFunc || (exports.BlendFunc = {}));
/**
 * 探针渲染速率
 * */

(function (MaskList) {
  MaskList[MaskList["MASK1"] = 1] = "MASK1";
  MaskList[MaskList["MASK2"] = 2] = "MASK2";
  MaskList[MaskList["MASK3"] = 4] = "MASK3";
  MaskList[MaskList["MASK4"] = 8] = "MASK4";
  MaskList[MaskList["MASK5"] = 16] = "MASK5";
  MaskList[MaskList["MASK6"] = 32] = "MASK6";
  MaskList[MaskList["MASK7"] = 64] = "MASK7";
  MaskList[MaskList["MASK8"] = 128] = "MASK8";
  MaskList[MaskList["MASK9"] = 256] = "MASK9";
  MaskList[MaskList["MASK10"] = 512] = "MASK10";
  MaskList[MaskList["MASK11"] = 1024] = "MASK11";
  MaskList[MaskList["MASK12"] = 2048] = "MASK12";
  MaskList[MaskList["MASK13"] = 4096] = "MASK13";
  MaskList[MaskList["MASK14"] = 8192] = "MASK14";
  MaskList[MaskList["MASK15"] = 16384] = "MASK15";
  MaskList[MaskList["MASK16"] = 32768] = "MASK16";
  MaskList[MaskList["MASK17"] = 65536] = "MASK17";
  MaskList[MaskList["MASK18"] = 131072] = "MASK18";
  MaskList[MaskList["MASK19"] = 262144] = "MASK19";
  MaskList[MaskList["MASK20"] = 524288] = "MASK20";
  MaskList[MaskList["EVERYTHING"] = 268435455] = "EVERYTHING";
  MaskList[MaskList["SHADOW"] = 268435456] = "SHADOW";
  MaskList[MaskList["SHADOW_MAP"] = 536870912] = "SHADOW_MAP";
})(exports.MaskList || (exports.MaskList = {}));
/**
 * 包围物类型
 * */

(function (RefreshRate) {
  RefreshRate[RefreshRate["ONCE"] = 1] = "ONCE";
  RefreshRate[RefreshRate["EVERYFRAME"] = 2] = "EVERYFRAME";
})(exports.RefreshRate || (exports.RefreshRate = {}));
/**
 * GL 层能力
 * 有些能力可以靠 extension 来抹平，有些能力必须支持 WebGL 2.0
 * */

(function (BoundingType) {
  BoundingType[BoundingType["AABB"] = 0] = "AABB";
  BoundingType[BoundingType["OBB"] = 1] = "OBB";
  BoundingType[BoundingType["SPHERE"] = 2] = "SPHERE";
})(exports.BoundingType || (exports.BoundingType = {}));
/**
 * OIT 模式
 * */

(function (GLCapabilityType) {
  GLCapabilityType["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType["textureFloat"] = "OES_texture_float";
  GLCapabilityType["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
})(exports.GLCapabilityType || (exports.GLCapabilityType = {}));

(function (OITMode) {
  OITMode[OITMode["WEIGHTED_AVERAGE"] = 0] = "WEIGHTED_AVERAGE";
  OITMode[OITMode["DEPTH_PEEL"] = 1] = "DEPTH_PEEL";
  OITMode[OITMode["DUAL_DEPTH_PEEL"] = 2] = "DUAL_DEPTH_PEEL";
})(exports.OITMode || (exports.OITMode = {}));

/**
 * 高性能无序数组，delete采用交换法提升行,内部数只扩不缩。
 */
var DisorderedArray = /*#__PURE__*/function () {
  function DisorderedArray() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    _classCallCheck(this, DisorderedArray);

    this._elements = void 0;
    this.length = 0;
    this._elements = new Array(count);
  }

  _createClass(DisorderedArray, [{
    key: "add",
    value: function add(element) {
      if (this.length === this._elements.length) this._elements.push(element);else this._elements[this.length] = element;
      this.length++;
    }
  }, {
    key: "delete",
    value: function _delete(element) {
      var index = this._elements.indexOf(element); //CM:可修改为自定义二分查找等算法,目前this._elements>=this.length 浪费性能


      this.deleteByIndex(index);
    }
    /**
     *
     * @param index
     * @returns 被替换过来的项 用于外部重置他的index
     */

  }, {
    key: "deleteByIndex",
    value: function deleteByIndex(index) {
      var elements = this._elements;
      var end = null;
      var lastIndex = this.length - 1;

      if (index !== lastIndex) {
        end = elements[lastIndex];
        elements[index] = end;
      }

      this.length--;
      return end;
    }
  }, {
    key: "garbageCollection",
    value: function garbageCollection() {
      this._elements.length = this.length;
    }
  }]);

  return DisorderedArray;
}();

/**
 * 组件的管理员。
 */
var ComponentsManager = /*#__PURE__*/function () {
  function ComponentsManager() {
    _classCallCheck(this, ComponentsManager);

    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._destoryComponents = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._renderers = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }

  _createClass(ComponentsManager, [{
    key: "addRenderer",
    value: function addRenderer(renderer) {
      renderer._rendererIndex = this._renderers.length;

      this._renderers.add(renderer);
    }
  }, {
    key: "removeRenderer",
    value: function removeRenderer(renderer) {
      var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);

      replaced && (replaced._rendererIndex = renderer._rendererIndex);
      renderer._rendererIndex = -1;
    }
  }, {
    key: "addOnStartScript",
    value: function addOnStartScript(script) {
      script._onStartIndex = this._onStartScripts.length;

      this._onStartScripts.add(script);
    }
  }, {
    key: "removeOnStartScript",
    value: function removeOnStartScript(script) {
      var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);

      replaced && (replaced._onStartIndex = script._onStartIndex);
      script._onStartIndex = -1;
    }
  }, {
    key: "addOnUpdateScript",
    value: function addOnUpdateScript(script) {
      script._onUpdateIndex = this._onUpdateScripts.length;

      this._onUpdateScripts.add(script);
    }
  }, {
    key: "removeOnUpdateScript",
    value: function removeOnUpdateScript(script) {
      var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);

      replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
      script._onUpdateIndex = -1;
    }
  }, {
    key: "addOnLateUpdateScript",
    value: function addOnLateUpdateScript(script) {
      script._onLateUpdateIndex = this._onLateUpdateScripts.length;

      this._onLateUpdateScripts.add(script);
    }
  }, {
    key: "removeOnLateUpdateScript",
    value: function removeOnLateUpdateScript(script) {
      var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);

      replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
      script._onLateUpdateIndex = -1;
    }
  }, {
    key: "addOnUpdateAnimations",
    value: function addOnUpdateAnimations(animation) {
      //@ts-ignore
      animation._onUpdateIndex = this._onUpdateAnimations.length;

      this._onUpdateAnimations.add(animation);
    }
  }, {
    key: "removeOnUpdateAnimations",
    value: function removeOnUpdateAnimations(animation) {
      //@ts-ignore
      var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex); //@ts-ignore


      replaced && (replaced._onUpdateIndex = animation._onUpdateIndex); //@ts-ignore

      animation._onUpdateIndex = -1;
    }
  }, {
    key: "addOnUpdateRenderers",
    value: function addOnUpdateRenderers(renderer) {
      renderer._onUpdateIndex = this._onUpdateRenderers.length;

      this._onUpdateRenderers.add(renderer);
    }
  }, {
    key: "removeOnUpdateRenderers",
    value: function removeOnUpdateRenderers(renderer) {
      var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);

      replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
      renderer._onUpdateIndex = -1;
    }
  }, {
    key: "addDestoryComponent",
    value: function addDestoryComponent(component) {
      this._destoryComponents.push(component);
    }
  }, {
    key: "callScriptOnStart",
    value: function callScriptOnStart() {
      var onStartScripts = this._onStartScripts;

      if (onStartScripts.length > 0) {
        var elements = onStartScripts._elements; // onStartScripts's length maybe add if you add some Script with addComponent() in some Script's onStart()

        for (var i = 0; i < onStartScripts.length; i++) {
          var script = elements[i];
          script._started = true;
          script._onStartIndex = -1;
          script.onStart();
        }

        onStartScripts.length = 0;
      }
    }
  }, {
    key: "callScriptOnUpdate",
    value: function callScriptOnUpdate(deltaTime) {
      var elements = this._onUpdateScripts._elements;

      for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
        var element = elements[i];

        if (element._started) {
          element.onUpdate(deltaTime);
        }
      }
    }
  }, {
    key: "callScriptOnLateUpdate",
    value: function callScriptOnLateUpdate(deltaTime) {
      var elements = this._onLateUpdateScripts._elements;

      for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
        var element = elements[i];

        if (element._started) {
          element.onLateUpdate(deltaTime);
        }
      }
    }
  }, {
    key: "callAnimationUpdate",
    value: function callAnimationUpdate(deltaTime) {
      var elements = this._onUpdateAnimations._elements;

      for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
        //@ts-ignore
        elements[i].update(deltaTime);
      }
    }
  }, {
    key: "callRendererOnUpdate",
    value: function callRendererOnUpdate(deltaTime) {
      var elements = this._onUpdateRenderers._elements;

      for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
        elements[i].update(deltaTime);
      }
    }
  }, {
    key: "callRender",
    value: function callRender(camera) {
      var elements = this._renderers._elements;

      for (var i = this._renderers.length - 1; i >= 0; --i) {
        elements[i]._render(camera);
      }
    }
  }, {
    key: "callComponentDestory",
    value: function callComponentDestory() {
      var destoryComponents = this._destoryComponents;
      var length = destoryComponents.length;

      if (length > 0) {
        for (var i = length - 1; i >= 0; --i) {
          destoryComponents[i].onDestroy();
        }

        destoryComponents.length = 0;
      }
    }
  }, {
    key: "callCameraOnBeginRender",
    value: function callCameraOnBeginRender(camera) {
      var camComps = camera.entity._components;

      for (var i = camComps.length - 1; i >= 0; --i) {
        var camComp = camComps[i];
        camComp.onBeginRender && camComp.onBeginRender(camera);
      }
    }
  }, {
    key: "callCameraOnEndRender",
    value: function callCameraOnEndRender(camera) {
      var camComps = camera.entity._components;

      for (var i = camComps.length - 1; i >= 0; --i) {
        var camComp = camComps[i];
        camComp.onBeginRender && camComp.onEndRender(camera);
      }
    }
  }, {
    key: "getActiveChangedTempList",
    value: function getActiveChangedTempList() {
      return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
    }
  }, {
    key: "putActiveChangedTempList",
    value: function putActiveChangedTempList(componentContainer) {
      componentContainer.length = 0;

      this._componentsContainerPool.push(componentContainer);
    }
  }]);

  return ComponentsManager;
}();

var ComponentCloner = /*#__PURE__*/function () {
  function ComponentCloner() {
    _classCallCheck(this, ComponentCloner);
  }

  _createClass(ComponentCloner, null, [{
    key: "cloneComponent",

    /**
     * 克隆组件。
     * @param source - 克隆源
     * @param target - 克隆目标
     */
    value: function cloneComponent(source, target) {
      var cloneModes = CloneManager.getCloneModeMode(source.constructor);
      var keys = Object.keys(source);

      for (var i = 0, n = keys.length; i < n; i++) {
        var k = keys[i];
        var cloneMode = cloneModes[k];

        switch (cloneMode) {
          case undefined:
          case CloneMode.Assignment:
            target[k] = source[k];
            break;

          case CloneMode.Shallow:
            var sourcePropS = source[k];

            if (sourcePropS instanceof Object) {
              var tarProp = target[k];
              tarProp == null && (tarProp = target[k] = sourcePropS.constructor());

              _extends(tarProp, sourcePropS);
            } else {
              target[k] = sourcePropS; // null or undefine and primitive type.
            }

            break;

          case CloneMode.Deep:
            var sourcePropD = source[k];

            if (sourcePropD instanceof Object) {
              var _tarProp = target[k];
              _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());

              ComponentCloner._cloneComponentProp(sourcePropD, _tarProp);
            } else {
              target[k] = sourcePropD; // null or undefine and primitive type.
            }

            break;
        }
      }
    }
    /**
     * 克隆组件属性。
     * @param source - 克隆源
     * @param target - 克隆目标
     */

  }, {
    key: "_cloneComponentProp",
    value: function _cloneComponentProp(source, target) {
      var type = source.constructor;

      if (type === Object) {
        var keys = Object.keys(source);

        for (var i = 0, n = keys.length; i < n; i++) {
          var k = keys[i];
          var sourceItem = source[k];

          if (sourceItem instanceof Object) {
            var targetItem = target[k];
            targetItem == null && (target[k] = targetItem = sourceItem.constructor());

            ComponentCloner._cloneComponentProp(sourceItem, targetItem);
          } else {
            target[k] = sourceItem; // null or undefine and primitive type.
          }
        }
      } else if (type === Array) {
        var arraySource = source;
        var arrayTarget = target;
        var length = arraySource.length;
        arrayTarget.length = length;

        for (var _i = 0; _i < length; _i++) {
          var _sourceItem = arraySource[_i];

          if (_sourceItem instanceof Object) {
            var _targetItem = arrayTarget[_i];
            _targetItem == null && (arrayTarget[_i] = _targetItem = _sourceItem.constructor());

            ComponentCloner._cloneComponentProp(_sourceItem, _targetItem);
          } else {
            arrayTarget[_i] = _sourceItem; // null or undefine and primitive type.
          }
        }
      } else {
        source.cloneTo(target);
      }
    }
  }]);

  return ComponentCloner;
}();

/**
 * 用于组件依赖注册。
 */
var ComponentsDependencies = /*#__PURE__*/function () {
  _createClass(ComponentsDependencies, null, [{
    key: "register",

    /**
     * @internal
     */

    /**
     * 注册组件依赖关系。
     * @param currentComponent
     * @param dependentComponent
     */
    value: function register(currentComponent, dependentComponent) {
      this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);

      this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
    }
    /**
     * @internal
     */

  }, {
    key: "_addCheck",
    value: function _addCheck(entity, type) {
      // 检查是否有被依赖组件
      var dependencies = ComponentsDependencies._dependenciesMap.get(type);

      if (dependencies) {
        for (var i = 0, len = dependencies.length; i < len; i++) {
          if (!entity.getComponent(dependencies[i])) {
            throw "you should add ".concat(dependencies[i], " before adding ").concat(type);
          }
        }
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_removeCheck",
    value: function _removeCheck(entity, type) {
      var invDenpendencies = ComponentsDependencies._invDependenciesMap.get(type);

      if (invDenpendencies) {
        for (var i = 0, len = invDenpendencies.length; i < len; i++) {
          if (entity.getComponent(invDenpendencies[i])) {
            throw "you should remove ".concat(invDenpendencies[i], " before adding ").concat(type);
          }
        }
      }
    }
  }, {
    key: "_addDependency",
    value: function _addDependency(currentComponent, dependentComponent, map) {
      var components = map.get(currentComponent);

      if (!components) {
        components = [];
        map.set(currentComponent, components);
      }

      if (components.indexOf(dependentComponent) === -1) {
        components.push(dependentComponent);
      }
    }
  }]);

  function ComponentsDependencies() {
    _classCallCheck(this, ComponentsDependencies);
  }

  return ComponentsDependencies;
}();
ComponentsDependencies._dependenciesMap = new Map();
ComponentsDependencies._invDependenciesMap = new Map();
function dependencies() {
  for (var _len = arguments.length, abilityClass = new Array(_len), _key = 0; _key < _len; _key++) {
    abilityClass[_key] = arguments[_key];
  }

  return function (target) {
    abilityClass.forEach(function (ability) {
      return ComponentsDependencies.register(target, ability);
    });
  };
}

/**
 * 层，位运算使用。
 */

(function (Layer) {
  Layer[Layer["Layer0"] = 1] = "Layer0";
  Layer[Layer["Layer1"] = 2] = "Layer1";
  Layer[Layer["Layer2"] = 4] = "Layer2";
  Layer[Layer["Layer3"] = 8] = "Layer3";
  Layer[Layer["Layer4"] = 16] = "Layer4";
  Layer[Layer["Layer5"] = 32] = "Layer5";
  Layer[Layer["Layer6"] = 64] = "Layer6";
  Layer[Layer["Layer7"] = 128] = "Layer7";
  Layer[Layer["Layer8"] = 256] = "Layer8";
  Layer[Layer["Layer9"] = 512] = "Layer9";
  Layer[Layer["Layer10"] = 1024] = "Layer10";
  Layer[Layer["Layer11"] = 2048] = "Layer11";
  Layer[Layer["Layer12"] = 4096] = "Layer12";
  Layer[Layer["Layer13"] = 8192] = "Layer13";
  Layer[Layer["Layer14"] = 16384] = "Layer14";
  Layer[Layer["Layer15"] = 32768] = "Layer15";
  Layer[Layer["Layer16"] = 65536] = "Layer16";
  Layer[Layer["Layer17"] = 131072] = "Layer17";
  Layer[Layer["Layer18"] = 262144] = "Layer18";
  Layer[Layer["Layer19"] = 524288] = "Layer19";
  Layer[Layer["Layer20"] = 1048576] = "Layer20";
  Layer[Layer["Layer21"] = 2097152] = "Layer21";
  Layer[Layer["Layer22"] = 4194304] = "Layer22";
  Layer[Layer["Layer23"] = 8388608] = "Layer23";
  Layer[Layer["Layer24"] = 16777216] = "Layer24";
  Layer[Layer["Layer25"] = 33554432] = "Layer25";
  Layer[Layer["Layer26"] = 67108864] = "Layer26";
  Layer[Layer["Layer27"] = 134217728] = "Layer27";
  Layer[Layer["Layer28"] = 268435456] = "Layer28";
  Layer[Layer["Layer29"] = 536870912] = "Layer29";
  Layer[Layer["Layer30"] = 1073741824] = "Layer30";
  Layer[Layer["Layer31"] = 2147483648] = "Layer31";
  Layer[Layer["Everything"] = 4294967295] = "Everything";
  Layer[Layer["Nothing"] = 0] = "Nothing";
})(exports.Layer || (exports.Layer = {}));

var _class$2, _descriptor$2, _descriptor2$1, _descriptor3, _descriptor4, _temp$2;

/**
 * 组件的基类。
 */
var Component = (_class$2 = (_temp$2 = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Component, _EventDispatcher);

  var _super = _createSuper(Component);

  _createClass(Component, [{
    key: "enabled",

    /** @internal */

    /** @internal */

    /**
     * 是否启用。
     */
    get: function get() {
      return this._enabled;
    },
    set: function set(value) {
      if (value === this._enabled) {
        return;
      }

      this._enabled = value;

      if (value) {
        this._entity.isActiveInHierarchy && this._onEnable();
      } else {
        this._entity.isActiveInHierarchy && this._onDisable();
      }
    }
    /**
     * 是否已经销毁。
     */

  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
    /**
     * 所属节点对象。
     */

  }, {
    key: "entity",
    get: function get() {
      return this._entity;
    }
    /**
     * 所属场景对象。
     */

  }, {
    key: "scene",
    get: function get() {
      return this._entity.scene;
    }
    /**
     * 所属的 Engine 对象。
     */

  }, {
    key: "engine",
    get: function get() {
      return this._entity.engine;
    }
  }]);

  function Component(entity) {
    var _this;

    _classCallCheck(this, Component);

    _this = _super.call(this, entity.engine);

    _initializerDefineProperty(_this, "_entity", _descriptor$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_destroyed", _descriptor2$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_enabled", _descriptor3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_awaked", _descriptor4, _assertThisInitialized(_this));

    _this._renderPriority = 0;
    _this._renderPassFlag = void 0;
    _this._passMasks = void 0;
    _this._cullDistanceSq = 0;
    _this._entity = entity;
    _this._renderPassFlag = exports.MaskList.EVERYTHING; // @deprecated

    _this._passMasks = [exports.MaskList.EVERYTHING]; // @deprecated

    return _this;
  }
  /**
   * 销毁本组件对象
   */


  _createClass(Component, [{
    key: "destroy",
    value: function destroy() {
      if (this._destroyed) return;

      this._entity._removeComponent(this);

      if (this._entity.isActiveInHierarchy) {
        this._enabled && this._onDisable();

        this._onInActive();
      }

      this._destroyed = true;

      this._onDestroy();
    }
    /**
     * @internal
     */

  }, {
    key: "_onAwake",
    value: function _onAwake() {}
    /**
     * @internal
     */

  }, {
    key: "_onEnable",
    value: function _onEnable() {}
    /**
     * @internal
     */

  }, {
    key: "_onDisable",
    value: function _onDisable() {}
    /**
     * @internal
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {}
    /**
     * @internal
     */

  }, {
    key: "_onActive",
    value: function _onActive() {}
    /**
     * @internal
     */

  }, {
    key: "_onInActive",
    value: function _onInActive() {}
    /**
     * @internal
     */

  }, {
    key: "_setActive",
    value: function _setActive(value) {
      if (value) {
        if (!this._awaked) {
          this._awaked = true;

          this._onAwake();
        } // onAwake can do isActive = false,for example write this in Script's onAwake().


        if (this._entity._isActiveInHierarchy) {
          this._onActive();

          this._enabled && this._onEnable();
        }
      } else {
        this._enabled && this._onDisable();

        this._onInActive();
      }
    } //---------------------------------------------Deprecated-----------------------------------------------------------------

  }, {
    key: "setPassMasks",

    /**
     * @deprecated
     * 设置通过的 Pass Mask，
     * @param  {PassMask} masks 各个 mask
     */
    value: function setPassMasks() {
      for (var _len = arguments.length, masks = new Array(_len), _key = 0; _key < _len; _key++) {
        masks[_key] = arguments[_key];
      }

      this._passMasks = masks;
      this._renderPassFlag = masks.reduce(function (a, b) {
        return a | b;
      }, 0);
    }
    /**
     * @deprecated
     * 添加 Mask 到通过列表
     * @param  {PassMask} masks 各个 mask
     */

  }, {
    key: "addPassMasks",
    value: function addPassMasks() {
      for (var _len2 = arguments.length, masks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        masks[_key2] = arguments[_key2];
      }

      for (var _i = 0, _masks = masks; _i < _masks.length; _i++) {
        var mask = _masks[_i];

        var idx = this._passMasks.indexOf(mask);

        if (idx < 0) {
          this._passMasks.push(mask);
        }
      }

      this.setPassMasks.apply(this, _toConsumableArray(this._passMasks));
    }
    /**
     * @deprecated
     * 从当前的通过列表移除 Mask
     * @param  {PassMask} masks 各个 mask
     */

  }, {
    key: "removePassMasks",
    value: function removePassMasks() {
      for (var _len3 = arguments.length, masks = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        masks[_key3] = arguments[_key3];
      }

      for (var _i2 = 0, _masks2 = masks; _i2 < _masks2.length; _i2++) {
        var mask = _masks2[_i2];

        var idx = this._passMasks.indexOf(mask);

        if (idx > -1) {
          this._passMasks.splice(idx, 1);
        }
      }

      this.setPassMasks.apply(this, _toConsumableArray(this._passMasks));
    }
  }, {
    key: "renderPriority",
    // 等于0，代表不进行 distance cull

    /**
     * @deprecated
     * 渲染优先级
     * @member {number}
     */
    get: function get() {
      return this._renderPriority;
    },
    set: function set(val) {
      this._renderPriority = val;
    }
    /**
     * @deprecated
     */

  }, {
    key: "cullDistanceSq",
    get: function get() {
      return this._cullDistanceSq;
    }
    /**
     * @deprecated
     */

  }, {
    key: "cullDistance",
    get: function get() {
      return Math.sqrt(this._cullDistanceSq);
    },
    set: function set(val) {
      this._cullDistanceSq = val * val;
    }
    /**
     * @deprecated
     */

  }, {
    key: "renderPassFlag",
    get: function get() {
      return this._renderPassFlag;
    },
    set: function set(val) {
      this._renderPassFlag = val;
    }
  }]);

  return Component;
}(EventDispatcher), _temp$2), (_descriptor$2 = _applyDecoratedDescriptor(_class$2.prototype, "_entity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$1 = _applyDecoratedDescriptor(_class$2.prototype, "_destroyed", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor3 = _applyDecoratedDescriptor(_class$2.prototype, "_enabled", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class$2.prototype, "_awaked", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class$2);

/**
 * 由于更新标记。
 */

var UpdateFlag = /*#__PURE__*/function () {
  /** 标记。 */
  function UpdateFlag() {
    var _flags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, UpdateFlag);

    this._flags = _flags;
    this.flag = true;
  }
  /**
   * 销毁。
   */


  _createClass(UpdateFlag, [{
    key: "destroy",
    value: function destroy() {
      var flags = this._flags;
      removeFromArray(flags, this);
      this._flags = null;
    }
  }]);

  return UpdateFlag;
}();

var _class$3, _descriptor$3, _descriptor2$2, _descriptor3$1, _descriptor4$1, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _class2$1, _temp$3;
/**
 * 用于实现变换相关功能。
 */

var Transform = (_class$3 = (_temp$3 = _class2$1 = /*#__PURE__*/function (_Component) {
  _inherits(Transform, _Component);

  var _super = _createSuper(Transform);

  function Transform() {
    var _this;

    _classCallCheck(this, Transform);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _initializerDefineProperty(_this, "_position", _descriptor$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_rotation", _descriptor2$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_rotationQuaternion", _descriptor3$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_scale", _descriptor4$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldPosition", _descriptor5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldRotation", _descriptor6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldRotationQuaternion", _descriptor7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_lossyWorldScale", _descriptor8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_localMatrix", _descriptor9, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_worldMatrix", _descriptor10, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_changeFlags", _descriptor11, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isParentDirty", _descriptor12, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_parentTransformCache", _descriptor13, _assertThisInitialized(_this));

    _this._dirtyFlag = Transform._WM_WP_WE_WQ_WS_FLAGS;
    return _this;
  }

  _createClass(Transform, [{
    key: "setPosition",

    /**
     * 通过位置的 X Y Z 设置局部位置。
     * @param x - 位置的 X 坐标
     * @param y - 位置的 Y 坐标
     * @param z - 位置的 Z 坐标
     */
    value: function setPosition(x, y, z) {
      this._position.setValue(x, y, z);

      this.position = this._position;
    }
    /**
     * 通过欧拉角的 X、Y、Z 分量设置局部旋转，单位是角度制，欧拉角的旋转顺序为 Yaw、Pitch、Roll。
     * @param x - 绕 X 轴旋转的角度
     * @param y - 绕 Y 轴旋转的角度
     * @param z - 绕 Z 轴旋转的角度
     */

  }, {
    key: "setRotation",
    value: function setRotation(x, y, z) {
      this._rotation.setValue(x, y, z);

      this.rotation = this._rotation;
    }
    /**
     * 通过四元数的 X、Y、Z、W 分量设置局部旋转。
     * @param x - 四元数的 X 分量
     * @param y - 四元数的 Y 分量
     * @param z - 四元数的 Z 分量
     * @param w - 四元数的 W 分量
     */

  }, {
    key: "setRotationQuaternion",
    value: function setRotationQuaternion(x, y, z, w) {
      this._rotationQuaternion.setValue(x, y, z, w);

      this.rotationQuaternion = this._rotationQuaternion;
    }
    /**
     * 通过沿 X、Y、Z 的缩放值设置局部缩放。
     * @param x - 沿 X 缩放
     * @param y - 沿 Y 缩放
     * @param z - 沿 Z 缩放
     */

  }, {
    key: "setScale",
    value: function setScale(x, y, z) {
      this._scale.setValue(x, y, z);

      this.scale = this._scale;
    }
    /**
     * 通过位置的 X Y Z 设置世界位置。
     * @param x - 位置的 X 坐标
     * @param y - 位置的 Y 坐标
     * @param z - 位置的 Z 坐标
     */

  }, {
    key: "setWorldPosition",
    value: function setWorldPosition(x, y, z) {
      this._worldPosition.setValue(x, y, z);

      this.worldPosition = this._worldPosition;
    }
    /**
     * 通过欧拉角的 X、Y、Z 分量设置世界旋转，单位是角度制，欧拉角的旋转顺序为 Yaw、Pitch、Roll。
     * @param x - 绕 X 轴旋转的角度
     * @param y - 绕 Y 轴旋转的角度
     * @param z - 绕 Z 轴旋转的角度
     */

  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(x, y, z) {
      this._worldRotation.setValue(x, y, z);

      this.worldRotation = this._worldRotation;
    }
    /**
     * 通过四元数的 X、Y、Z、W 分量设置世界旋转。
     * @param x - 四元数的 X 分量
     * @param y - 四元数的 Y 分量
     * @param z - 四元数的 Z 分量
     * @param w - 四元数的 W 分量
     */

  }, {
    key: "setWorldRotationQuaternion",
    value: function setWorldRotationQuaternion(x, y, z, w) {
      this._worldRotationQuaternion.setValue(x, y, z, w);

      this.worldRotationQuaternion = this._worldRotationQuaternion;
    }
    /**
     * 获取世界矩阵的前向量。
     * @param forward - 前向量
     * @returns 前向量
     */

  }, {
    key: "getWorldForward",
    value: function getWorldForward(forward) {
      var e = this.worldMatrix.elements;
      forward.setValue(-e[8], -e[9], -e[10]);
      return forward.normalize();
    }
    /**
     * 获取世界矩阵的右向量。
     * @param right - 右向量
     * @returns 右向量
     */

  }, {
    key: "getWorldRight",
    value: function getWorldRight(right) {
      var e = this.worldMatrix.elements;
      right.setValue(e[0], e[1], e[2]);
      return right.normalize();
    }
    /**
     * 获取世界矩阵的上向量。
     * @param up - 上向量
     * @returns 上向量
     */

  }, {
    key: "getWorldUp",
    value: function getWorldUp(up) {
      var e = this.worldMatrix.elements;
      up.setValue(e[4], e[5], e[6]);
      return up.normalize();
    }
    /**
     * 在指定的方向和距离上位移。
     * @param translation - 位移的方向和距离
     * @param relativeToLocal - 是否相对局部空间
     */

  }, {
    key: "translate",
    value: function translate(translation) {
      var relativeToLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (relativeToLocal) {
        var rotationMat = Transform._tempMat40;
        miniprogram.Matrix.rotationQuaternion(this.rotationQuaternion, rotationMat);
        miniprogram.Vector3.transformCoordinate(translation, rotationMat, Transform._tempVec3);
        this.position = this._position.add(Transform._tempVec3);
      } else {
        this.worldPosition = this._worldPosition.add(translation);
      }
    }
    /**
     * 在指定的方向和距离上位移。
     * @param x - X 轴的位移的方向和距离
     * @param y - Y 轴的位移的方向和距离
     * @param z - Z 轴的位移的方向和距离
     * @param relativeToLocal - 是否相对局部空间
     */

  }, {
    key: "translateXYZ",
    value: function translateXYZ(x, y, z) {
      var relativeToLocal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var translate = Transform._tempVec3;
      translate.setValue(x, y, z);
      this.translate(translate, relativeToLocal);
    }
    /**
     * 根据指定欧拉角旋转。
     * @param rotation - 旋转角度，欧拉角表达，单位是角度制
     * @param relativeToLocal - 是否相对局部空间
     */

  }, {
    key: "rotate",
    value: function rotate(rotation) {
      var relativeToLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.rotateXYZ(rotation.x, rotation.y, rotation.z, relativeToLocal);
    }
    /**
     * 根据指定欧拉角旋转。
     * @param x - X 轴旋转角度,单位是角度制
     * @param y - Y 轴旋转角度,单位是角度制
     * @param z - Z 轴旋转角度,单位是角度制
     * @param relativeToLocal - 是否相对局部空间
     */

  }, {
    key: "rotateXYZ",
    value: function rotateXYZ(x, y, z) {
      var relativeToLocal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var radFactor = miniprogram.MathUtil.degreeToRadFactor;
      var rotQuat = Transform._tempQuat0;
      miniprogram.Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);

      this._rotateByQuat(rotQuat, relativeToLocal);
    }
    /**
     * 根据指定角度围绕指定轴进行旋转。
     * @param axis - 旋转轴
     * @param angle - 旋转角度，单位是角度制
     * @param relativeToLocal - 是否相对局部空间
     */

  }, {
    key: "rotateByAxis",
    value: function rotateByAxis(axis, angle) {
      var relativeToLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var rad = angle * miniprogram.MathUtil.degreeToRadFactor;
      miniprogram.Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);

      this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
    }
    /**
     * 旋转并且保证世界前向量指向目标世界位置。
     * @param worldPosition - 目标世界位置
     * @param worldUp - 世界上向量，默认是 Vector3(0, 1, 0)
     */

  }, {
    key: "lookAt",
    value: function lookAt(worldPosition, worldUp) {
      var _worldUp;

      var position = this.worldPosition;
      var EPSILON = miniprogram.MathUtil.zeroTolerance;

      if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {
        return;
      }

      var rotMat = Transform._tempMat43;
      var worldRotationQuaternion = this._worldRotationQuaternion;
      worldUp = (_worldUp = worldUp) !== null && _worldUp !== void 0 ? _worldUp : Transform._tempVec3.setValue(0, 1, 0);
      miniprogram.Matrix.lookAt(position, worldPosition, worldUp, rotMat);
      rotMat.getRotation(worldRotationQuaternion).invert();
      this.worldRotationQuaternion = worldRotationQuaternion;
    }
    /**
     * 注册世界变换改变标记。
     * @returns 改变标记
     */

  }, {
    key: "registerWorldChangeFlag",
    value: function registerWorldChangeFlag() {
      var flag = new UpdateFlag(this._changeFlags);

      this._changeFlags.push(flag);

      return flag;
    }
    /**
     * @internal
     */

  }, {
    key: "_parentChange",
    value: function _parentChange() {
      this._isParentDirty = true;

      this._updateAllWorldFlag();
    }
    /**
     * 获取 worldMatrix：会触发自身以及所有父节点的worldMatrix更新
     * 获取 worldPosition：会触发自身 position 和自身 worldMatrix 以及所有父节点的 worldMatrix 更新
     * 综上所述：任何一个相关变量更新都会造成其中一条完成链路（worldMatrix）的脏标记为 false
     */

  }, {
    key: "_updateWorldPositionFlag",
    value: function _updateWorldPositionFlag() {
      if (!this._isContainDirtyFlags(Transform._WM_WP_FLAGS)) {
        this._worldAssociatedChange(Transform._WM_WP_FLAGS);

        var nodeChildren = this._entity._children;

        for (var i = 0, n = nodeChildren.length; i < n; i++) {
          var _nodeChildren$i$trans;

          (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
        }
      }
    }
    /**
     * 获取worldMatrix：会触发自身以及所有父节点的worldMatrix更新
     * 获取worldPosition：会触发自身position和自身worldMatrix以及所有父节点的worldMatrix更新
     * 获取worldRotationQuaternion：会触发自身以及所有父节点的worldRotationQuaternion更新
     * 获取worldRotation：会触发自身worldRotation和自身worldRotationQuaternion以及所有父节点的worldRotationQuaternion更新
     * 综上所述：任何一个相关变量更新都会造成其中一条完成链路（worldMatrix或orldRotationQuaternion）的脏标记为false
     */

  }, {
    key: "_updateWorldRotationFlag",
    value: function _updateWorldRotationFlag() {
      if (!this._isContainDirtyFlags(Transform._WM_WE_WQ_FLAGS)) {
        this._worldAssociatedChange(Transform._WM_WE_WQ_FLAGS);

        var nodeChildren = this._entity._children;

        for (var i = 0, n = nodeChildren.length; i < n; i++) {
          var _nodeChildren$i$trans2;

          (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag(); //父节点旋转发生变化，子节点的世界位置和旋转都需要更新
        }
      }
    }
    /**
     * 获取 worldMatrix：会触发自身以及所有父节点的 worldMatrix 更新
     * 获取 worldPosition：会触发自身 position 和自身 worldMatrix 以及所有父节点的 worldMatrix 更新
     * 获取 worldRotationQuaternion：会触发自身以及所有父节点的 worldRotationQuaternion 更新
     * 获取 worldRotation：会触发自身 worldRotation 和自身 worldRotationQuaternion 以及所有父节点的worldRotationQuaternion更新
     * 综上所述：任何一个相关变量更新都会造成其中一条完成链路（worldMatrix 或 worldRotationQuaternion）的脏标记为false
     */

  }, {
    key: "_updateWorldPositionAndRotationFlag",
    value: function _updateWorldPositionAndRotationFlag() {
      if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_FLAGS)) {
        this._worldAssociatedChange(Transform._WM_WP_WE_WQ_FLAGS);

        var nodeChildren = this._entity._children;

        for (var i = 0, n = nodeChildren.length; i < n; i++) {
          var _nodeChildren$i$trans3;

          (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
        }
      }
    }
    /**
     * 获取 worldMatrix：会触发自身以及所有父节点的 worldMatrix 更新
     * 获取 worldPosition：会触发自身 position 和自身 worldMatrix 以及所有父节点的 worldMatrix 更新
     * 获取 worldScale：会触发自身以及所有父节点的 worldMatrix 更新
     * 综上所述：任何一个相关变量更新都会造成其中一条完成链路（worldMatrix）的脏标记为 false。
     */

  }, {
    key: "_updateWorldScaleFlag",
    value: function _updateWorldScaleFlag() {
      if (!this._isContainDirtyFlags(Transform._WM_WS_FLAGS)) {
        this._worldAssociatedChange(Transform._WM_WS_FLAGS);

        var nodeChildren = this._entity._children;

        for (var i = 0, n = nodeChildren.length; i < n; i++) {
          var _nodeChildren$i$trans4;

          (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
        }
      }
    }
    /**
     * 获取 worldMatrix：会触发自身以及所有父节点的 worldMatrix 更新
     * 获取 worldPosition：会触发自身 position 和自身 worldMatrix 以及所有父节点的 worldMatrix 更新
     * 获取 worldScale：会触发自身以及所有父节点的worldMatrix更新
     * 综上所述：任何一个相关变量更新都会造成其中一条完成链路（worldMatrix）的脏标记为 false。
     */

  }, {
    key: "_updateWorldPositionAndScaleFlag",
    value: function _updateWorldPositionAndScaleFlag() {
      if (!this._isContainDirtyFlags(Transform._WM_WP_WS_FLAGS)) {
        this._worldAssociatedChange(Transform._WM_WP_WS_FLAGS);

        var nodeChildren = this._entity._children;

        for (var i = 0, n = nodeChildren.length; i < n; i++) {
          var _nodeChildren$i$trans5;

          (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
        }
      }
    }
    /**
     * 更新所有世界标记，原理同上。
     */

  }, {
    key: "_updateAllWorldFlag",
    value: function _updateAllWorldFlag() {
      if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_WS_FLAGS)) {
        this._worldAssociatedChange(Transform._WM_WP_WE_WQ_WS_FLAGS);

        var nodeChildren = this._entity._children;

        for (var i = 0, n = nodeChildren.length; i < n; i++) {
          var _nodeChildren$i$trans6;

          (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
        }
      }
    }
  }, {
    key: "_getParentTransform",
    value: function _getParentTransform() {
      if (!this._isParentDirty) {
        return this._parentTransformCache;
      }

      var parentCache = null;
      var parent = this._entity.parent;

      while (parent) {
        var transform = parent.transform;

        if (transform) {
          parentCache = transform;
          break;
        } else {
          parent = parent.parent;
        }
      }

      this._parentTransformCache = parentCache;
      this._isParentDirty = false;
      return parentCache;
    }
  }, {
    key: "_getScaleMatrix",
    value: function _getScaleMatrix() {
      var invRotation = Transform._tempQuat0;
      var invRotationMat = Transform._tempMat30;
      var worldRotScaMat = Transform._tempMat31;
      var scaMat = Transform._tempMat32;
      worldRotScaMat.setValueByMatrix(this.worldMatrix);
      miniprogram.Quaternion.invert(this.worldRotationQuaternion, invRotation);
      miniprogram.Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
      miniprogram.Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
      return scaMat;
    }
  }, {
    key: "_isContainDirtyFlags",
    value: function _isContainDirtyFlags(targetDirtyFlags) {
      return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
    }
  }, {
    key: "_isContainDirtyFlag",
    value: function _isContainDirtyFlag(type) {
      return (this._dirtyFlag & type) != 0;
    }
  }, {
    key: "_setDirtyFlagTrue",
    value: function _setDirtyFlagTrue(type) {
      this._dirtyFlag |= type;
    }
  }, {
    key: "_setDirtyFlagFalse",
    value: function _setDirtyFlagFalse(type) {
      this._dirtyFlag &= ~type;
    }
  }, {
    key: "_worldAssociatedChange",
    value: function _worldAssociatedChange(type) {
      this._dirtyFlag |= type;
      var len = this._changeFlags.length;

      for (var i = len - 1; i >= 0; i--) {
        this._changeFlags[i].flag = true;
      }
    }
  }, {
    key: "_rotateByQuat",
    value: function _rotateByQuat(rotateQuat, relativeToLocal) {
      if (relativeToLocal) {
        miniprogram.Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
        this.rotationQuaternion = this._rotationQuaternion;
      } else {
        miniprogram.Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);
        this.worldRotationQuaternion = this._worldRotationQuaternion;
      }
    }
  }, {
    key: "position",

    /**
     * 局部位置。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      if (this._position !== value) {
        value.cloneTo(this._position);
      }

      this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);

      this._updateWorldPositionFlag();
    }
    /**
     * 世界位置。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "worldPosition",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._WORLD_POSITION_FLAG)) {
        if (this._getParentTransform()) {
          this.worldMatrix.getTranslation(this._worldPosition);
        } else {
          this._position.cloneTo(this._worldPosition);
        }

        this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);
      }

      return this._worldPosition;
    },
    set: function set(value) {
      if (this._worldPosition !== value) {
        value.cloneTo(this._worldPosition);
      }

      var parent = this._getParentTransform();

      if (parent) {
        miniprogram.Matrix.invert(parent.worldMatrix, Transform._tempMat41);
        miniprogram.Vector3.transformCoordinate(value, Transform._tempMat41, this._position);
      } else {
        value.cloneTo(this._position);
      }

      this.position = this._position;

      this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);
    }
    /**
     * 局部旋转，欧拉角表达，单位是角度制，欧拉角的旋转顺序为 Yaw、Pitch、Roll。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "rotation",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._LOCAL_EULER_FLAG)) {
        this._rotationQuaternion.toEuler(this._rotation);

        this._rotation.scale(miniprogram.MathUtil.radToDegreeFactor); // 弧度转角度


        this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);
      }

      return this._rotation;
    },
    set: function set(value) {
      if (this._rotation !== value) {
        value.cloneTo(this._rotation);
      }

      this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_QUAT_FLAG);

      this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);

      this._updateWorldRotationFlag();
    }
    /**
     * 世界旋转，欧拉角表达，单位是角度制，欧拉角的旋转顺序为 Yaw、Pitch、Roll。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "worldRotation",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._WORLD_EULER_FLAG)) {
        this.worldRotationQuaternion.toEuler(this._worldRotation);

        this._worldRotation.scale(miniprogram.MathUtil.radToDegreeFactor); // 弧度转角度


        this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);
      }

      return this._worldRotation;
    },
    set: function set(value) {
      if (this._worldRotation !== value) {
        value.cloneTo(this._worldRotation);
      }

      miniprogram.Quaternion.rotationEuler(miniprogram.MathUtil.degreeToRadian(value.x), miniprogram.MathUtil.degreeToRadian(value.y), miniprogram.MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;

      this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);
    }
    /**
     * 局部旋转，四元数表达。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "rotationQuaternion",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._LOCAL_QUAT_FLAG)) {
        miniprogram.Quaternion.rotationEuler(miniprogram.MathUtil.degreeToRadian(this._rotation.x), miniprogram.MathUtil.degreeToRadian(this._rotation.y), miniprogram.MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);

        this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);
      }

      return this._rotationQuaternion;
    },
    set: function set(value) {
      if (this._rotationQuaternion !== value) {
        value.cloneTo(this._rotationQuaternion);
      }

      this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_EULER_FLAG);

      this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);

      this._updateWorldRotationFlag();
    }
    /**
     * 世界旋转，四元数表达。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "worldRotationQuaternion",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._WORLD_QUAT_FLAG)) {
        var parent = this._getParentTransform();

        if (parent != null) {
          miniprogram.Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
        } else {
          this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);
        }

        this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);
      }

      return this._worldRotationQuaternion;
    },
    set: function set(value) {
      if (this._worldRotationQuaternion !== value) {
        value.cloneTo(this._worldRotationQuaternion);
      }

      var parent = this._getParentTransform();

      if (parent) {
        miniprogram.Quaternion.invert(parent.worldRotationQuaternion, Transform._tempQuat0);
        miniprogram.Quaternion.multiply(value, Transform._tempQuat0, this._rotationQuaternion);
      } else {
        value.cloneTo(this._rotationQuaternion);
      }

      this.rotationQuaternion = this._rotationQuaternion;

      this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);
    }
    /**
     * 局部缩放。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "scale",
    get: function get() {
      return this._scale;
    },
    set: function set(value) {
      if (this._scale !== value) {
        value.cloneTo(this._scale);
      }

      this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);

      this._updateWorldScaleFlag();
    }
    /**
     * 世界有损缩放。
     * @remarks 某种条件下获取该值可能不正确（例如：父节点有缩放，子节点有旋转），缩放会倾斜，无法使用 Vector3 正确表示,必须使用 Matrix3x3 矩阵才能正确表示。
     */

  }, {
    key: "lossyWorldScale",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._WORLD_SCALE_FLAG)) {
        if (this._getParentTransform()) {
          var scaleMat = this._getScaleMatrix();

          var e = scaleMat.elements;

          this._lossyWorldScale.setValue(e[0], e[4], e[8]);
        } else {
          this._scale.cloneTo(this._lossyWorldScale);
        }

        this._setDirtyFlagFalse(Transform._WORLD_SCALE_FLAG);
      }

      return this._lossyWorldScale;
    }
    /**
     * 局部矩阵。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "localMatrix",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._LOCAL_MATRIX_FLAG)) {
        miniprogram.Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);

        this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);
      }

      return this._localMatrix;
    },
    set: function set(value) {
      if (this._localMatrix !== value) {
        value.cloneTo(this._localMatrix);
      }

      this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);

      this._setDirtyFlagTrue(Transform._LOCAL_EULER_FLAG);

      this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);

      this._updateAllWorldFlag();
    }
    /**
     * 世界矩阵。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "worldMatrix",
    get: function get() {
      if (this._isContainDirtyFlag(Transform._WORLD_MATRIX_FLAG)) {
        var parent = this._getParentTransform();

        if (parent) {
          miniprogram.Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
        } else {
          this.localMatrix.cloneTo(this._worldMatrix);
        }

        this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);
      }

      return this._worldMatrix;
    },
    set: function set(value) {
      if (this._worldMatrix !== value) {
        value.cloneTo(this._worldMatrix);
      }

      var parent = this._getParentTransform();

      if (parent) {
        miniprogram.Matrix.invert(parent.worldMatrix, Transform._tempMat42);
        miniprogram.Matrix.multiply(value, Transform._tempMat42, this._localMatrix);
      } else {
        value.cloneTo(this._localMatrix);
      }

      this.localMatrix = this._localMatrix;

      this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);
    }
  }]);

  return Transform;
}(Component), _class2$1._tempQuat0 = new miniprogram.Quaternion(), _class2$1._tempVec3 = new miniprogram.Vector3(), _class2$1._tempMat30 = new miniprogram.Matrix3x3(), _class2$1._tempMat31 = new miniprogram.Matrix3x3(), _class2$1._tempMat32 = new miniprogram.Matrix3x3(), _class2$1._tempMat40 = new miniprogram.Matrix(), _class2$1._tempMat41 = new miniprogram.Matrix(), _class2$1._tempMat42 = new miniprogram.Matrix(), _class2$1._tempMat43 = new miniprogram.Matrix(), _class2$1._LOCAL_EULER_FLAG = 0x1, _class2$1._LOCAL_QUAT_FLAG = 0x2, _class2$1._WORLD_POSITION_FLAG = 0x4, _class2$1._WORLD_EULER_FLAG = 0x8, _class2$1._WORLD_QUAT_FLAG = 0x10, _class2$1._WORLD_SCALE_FLAG = 0x20, _class2$1._LOCAL_MATRIX_FLAG = 0x40, _class2$1._WORLD_MATRIX_FLAG = 0x80, _class2$1._WM_WP_FLAGS = 0x84, _class2$1._WM_WE_WQ_FLAGS = 0x98, _class2$1._WM_WP_WE_WQ_FLAGS = 0x9c, _class2$1._WM_WS_FLAGS = 0xa0, _class2$1._WM_WP_WS_FLAGS = 0xa4, _class2$1._WM_WP_WE_WQ_WS_FLAGS = 0xbc, _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class$3.prototype, "_position", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector3();
  }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class$3.prototype, "_rotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector3();
  }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class$3.prototype, "_rotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Quaternion();
  }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class$3.prototype, "_scale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector3(1, 1, 1);
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class$3.prototype, "_worldPosition", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector3();
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class$3.prototype, "_worldRotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector3();
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class$3.prototype, "_worldRotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Quaternion();
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class$3.prototype, "_lossyWorldScale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector3(1, 1, 1);
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class$3.prototype, "_localMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class$3.prototype, "_worldMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class$3.prototype, "_changeFlags", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor12 = _applyDecoratedDescriptor(_class$3.prototype, "_isParentDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return true;
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class$3.prototype, "_parentTransformCache", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return null;
  }
})), _class$3);

/**
 * 实体,可作为组件的容器。
 */
var Entity = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Entity, _EventDispatcher);

  var _super = _createSuper(Entity);

  _createClass(Entity, [{
    key: "isActive",

    /**
     * 是否局部激活。
     */
    get: function get() {
      return this._isActive;
    },
    set: function set(value) {
      if (value !== this._isActive) {
        this._isActive = value;

        if (value) {
          var parent = this._parent;

          if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
            this._processActive();
          }
        } else {
          if (this._isActiveInHierarchy) {
            this._processInActive();
          }
        }
      }
    }
    /**
     * 在层级中是否处于激活状态。
     */

  }, {
    key: "isActiveInHierarchy",
    get: function get() {
      return this._isActiveInHierarchy;
    }
    /**
     * 父实体。
     */

  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    },
    set: function set(entity) {
      if (entity !== this._parent) {
        var oldParent = this._removeFromParent();

        var newParent = this._parent = entity;

        if (newParent) {
          newParent._children.push(this);

          var parentScene = newParent._scene;

          if (this._scene !== parentScene) {
            Entity._traverseSetOwnerScene(this, parentScene);
          }

          if (newParent._isActiveInHierarchy) {
            !this._isActiveInHierarchy && this._isActive && this._processActive();
          } else {
            this._isActiveInHierarchy && this._processInActive();
          }
        } else {
          this._isActiveInHierarchy && this._processInActive();

          if (oldParent) {
            Entity._traverseSetOwnerScene(this, null);
          }
        }

        this._setTransformDirty();
      }
    }
    /**
     * 子实体集合。
     */

  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
    /**
     * 子实体数量。
     */

  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }
    /**
     * 所属的场景对象。
     */

  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
    /**
     * 所属引擎。
     */

  }, {
    key: "engine",
    get: function get() {
      return this._engine;
    }
    /**
     * 创建一个实体。
     * @param engine - 所属 Engine
     * @param name - 名字
     */

  }], [{
    key: "findByName",

    /**
     * 根据名字全局查找实体。
     * @param name - 名字
     * @returns 实体
     */
    value: function findByName(name) {
      var entitys = Entity._entitys;
      var elements = entitys._elements;

      for (var i = entitys.length - 1; i >= 0; i--) {
        var _entity = elements[i];

        if (_entity.name === name) {
          return _entity;
        }
      }

      return null;
    }
    /**
     * 根据路径全局查找实体，使用‘/’符号作为路径分割符。
     * @deprecated use scene find by path instead.
     * @param scene - 查找场景
     * @param path - 路径
     * @returns 实体
     */

  }, {
    key: "findByPath",
    value: function findByPath(scene, path) {
      return scene.findEntityByPath(path);
    }
    /**
     * @internal
     */

  }, {
    key: "_findChildByName",
    value: function _findChildByName(root, name) {
      var children = root._children;

      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];

        if (child.name === name) {
          return child;
        }
      }

      return null;
    }
    /**
     * @internal
     */

  }, {
    key: "_traverseSetOwnerScene",
    value: function _traverseSetOwnerScene(entity, scene) {
      entity._scene = scene;
      var children = entity._children;

      for (var i = entity.childCount - 1; i >= 0; i--) {
        this._traverseSetOwnerScene(children[i], scene);
      }
    }
    /* 名字。*/

  }]);

  function Entity(engine, name) {
    var _this;

    _classCallCheck(this, Entity);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this.layer = exports.Layer.Layer0;
    _this.transform = void 0;
    _this._isActiveInHierarchy = false;
    _this._components = [];
    _this._children = [];
    _this._scene = void 0;
    _this._isRoot = false;
    _this._isActive = true;
    _this._parent = null;
    _this._activeChangedComponents = void 0;
    _this._invModelMatrix = new miniprogram.Matrix();
    _this._inverseWorldMatFlag = void 0;

    Entity._entitys.add(_assertThisInitialized(_this));

    _this.name = name;
    _this.transform = _this.addComponent(Transform);
    _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
    return _this;
  }
  /**
   * 根据组件类型添加组件。
   * @param type - 组件类型
   * @returns	组件实例
   */


  _createClass(Entity, [{
    key: "addComponent",
    value: function addComponent(type) {
      ComponentsDependencies._addCheck(this, type);

      var component = new type(this);

      this._components.push(component);

      if (this._isActiveInHierarchy) {
        component._setActive(true);
      }

      return component;
    }
    /**
     * 根据组件类型获取组件。
     * @param type - 组件类型
     * @returns	组件
     */

  }, {
    key: "getComponent",
    value: function getComponent(type) {
      for (var i = this._components.length - 1; i >= 0; i--) {
        var component = this._components[i];

        if (component instanceof type) {
          return component;
        }
      }
    }
    /**
     * 根据组件类型获取组件集合。
     * @param type - 组件类型
     * @param results - 组件集合
     * @returns	组件集合
     */

  }, {
    key: "getComponents",
    value: function getComponents(type, results) {
      results.length = 0;

      for (var i = this._components.length - 1; i >= 0; i--) {
        var component = this._components[i];

        if (component instanceof type) {
          results.push(component);
        }
      }

      return results;
    }
    /**
     * 根据组件类型获取自身和所有子实体的组件集合。
     * @param type - 组件类型
     * @param results - 组件集合
     * @returns	组件集合
     */

  }, {
    key: "getComponentsIncludeChildren",
    value: function getComponentsIncludeChildren(type, results) {
      results.length = 0;

      this._getComponentsIncludeChildren(type, results);

      return results;
    }
    /**
     * 添加子实体。
     * @param child - 子实体
     */

  }, {
    key: "addChild",
    value: function addChild(child) {
      child.parent = this;
    }
    /**
     * 删除子实体。
     * @param child - 子实体
     */

  }, {
    key: "removeChild",
    value: function removeChild(child) {
      child.parent = null;
    }
    /**
     * 根据索引获取子实体。
     * @param index - 索引
     * @returns 实体
     */

  }, {
    key: "getChild",
    value: function getChild(index) {
      return this._children[index];
    }
    /**
     * 根据名字查找子实体。
     * @param name - 名字
     * @returns 实体
     */

  }, {
    key: "findByName",
    value: function findByName(name) {
      var children = this._children;

      var child = Entity._findChildByName(this, name);

      if (child) return child;

      for (var i = children.length - 1; i >= 0; i--) {
        var _child = children[i];

        var grandson = _child.findByName(name);

        if (grandson) {
          return grandson;
        }
      }

      return null;
    }
    /**
     * 根据路径查找实体，使用‘/’符号作为路径分割符。
     * @param path - 路径
     * @returns 实体
     */

  }, {
    key: "findByPath",
    value: function findByPath(path) {
      var splits = path.split("/");
      var entity = this;

      for (var i = 0, length = splits.length; i < length; ++i) {
        var split = splits[i];

        if (split) {
          entity = Entity._findChildByName(entity, split);

          if (!entity) {
            return null;
          }
        }
      }

      return entity;
    }
    /**
     * 创建子实体。
     * @param name - 名称
     * @returns 子实体
     */

  }, {
    key: "createChild",
    value: function createChild(name) {
      var child = new Entity(this.engine, name);
      child.layer = this.layer;
      child.parent = this;
      return child;
    }
    /**
     * 清空子实体。
     */

  }, {
    key: "clearChildren",
    value: function clearChildren() {
      var children = this._children;

      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        child._parent = null;
        child._isActiveInHierarchy && child._processInActive();

        Entity._traverseSetOwnerScene(child, null); // must after child._processInActive()

      }

      children.length = 0;
    }
    /**
     * 克隆。
     * @returns 克隆的实体
     */

  }, {
    key: "clone",
    value: function clone() {
      var cloneEntity = new Entity(this._engine, this.name);
      cloneEntity._isActive = this._isActive;
      cloneEntity.transform.localMatrix = this.transform.localMatrix;
      var children = this._children;

      for (var i = 0, len = this._children.length; i < len; i++) {
        var child = children[i];
        cloneEntity.addChild(child.clone());
      }

      var components = this._components;

      for (var _i = 0, n = components.length; _i < n; _i++) {
        var sourceComp = components[_i];

        if (!(sourceComp instanceof Transform)) {
          var targetComp = cloneEntity.addComponent(sourceComp.constructor);
          ComponentCloner.cloneComponent(sourceComp, targetComp);
        }
      }

      return cloneEntity;
    }
    /**
     * 销毁。
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var abilityArray = this._components;

      for (var i = abilityArray.length - 1; i >= 0; i--) {
        abilityArray[i].destroy();
      }

      this._components.length = 0;
      var children = this._children;

      for (var _i2 = children.length - 1; _i2 >= 0; _i2--) {
        children[_i2].destroy();
      }

      this._children.length = 0;

      if (this._parent != null) {
        var parentChildren = this._parent._children;
        parentChildren.splice(parentChildren.indexOf(this), 1);
      }

      this._parent = null;

      Entity._entitys["delete"](this);
    }
    /**
     * @internal
     */

  }, {
    key: "_removeComponent",
    value: function _removeComponent(component) {
      ComponentsDependencies._removeCheck(this, component.constructor);

      var components = this._components;
      components.splice(components.indexOf(component), 1);
    }
    /**
     * @internal
     */

  }, {
    key: "_removeFromParent",
    value: function _removeFromParent() {
      var oldParent = this._parent;

      if (oldParent != null) {
        var oldParentChildren = oldParent._children;
        oldParentChildren.splice(oldParentChildren.indexOf(this), 1);
        this._parent = null;
      }

      return oldParent;
    }
    /**
     * @internal
     */

  }, {
    key: "_processActive",
    value: function _processActive() {
      if (this._activeChangedComponents) {
        throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
      }

      this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();

      this._setActiveInHierarchy(this._activeChangedComponents);

      this._setActiveComponents(true);
    }
    /**
     * @internal
     */

  }, {
    key: "_processInActive",
    value: function _processInActive() {
      if (this._activeChangedComponents) {
        throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
      }

      this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();

      this._setInActiveInHierarchy(this._activeChangedComponents);

      this._setActiveComponents(false);
    }
  }, {
    key: "_getComponentsIncludeChildren",
    value: function _getComponentsIncludeChildren(type, results) {
      for (var i = this._components.length - 1; i >= 0; i--) {
        var component = this._components[i];

        if (component instanceof type) {
          results.push(component);
        }
      }

      for (var _i3 = this._children.length - 1; _i3 >= 0; _i3--) {
        this._children[_i3]._getComponentsIncludeChildren(type, results);
      }
    }
  }, {
    key: "_setActiveComponents",
    value: function _setActiveComponents(isActive) {
      var activeChangedComponents = this._activeChangedComponents;

      for (var i = 0, length = activeChangedComponents.length; i < length; ++i) {
        activeChangedComponents[i]._setActive(isActive);
      }

      this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);

      this._activeChangedComponents = null;
    }
  }, {
    key: "_setActiveInHierarchy",
    value: function _setActiveInHierarchy(activeChangedComponents) {
      this._isActiveInHierarchy = true;
      var components = this._components;

      for (var i = components.length - 1; i >= 0; i--) {
        activeChangedComponents.push(components[i]);
      }

      var children = this._children;

      for (var _i4 = children.length - 1; _i4 >= 0; _i4--) {
        var child = children[_i4];
        child.isActive && child._setActiveInHierarchy(activeChangedComponents);
      }
    }
  }, {
    key: "_setInActiveInHierarchy",
    value: function _setInActiveInHierarchy(activeChangedComponents) {
      this._isActiveInHierarchy = false;
      var components = this._components;

      for (var i = components.length - 1; i >= 0; i--) {
        activeChangedComponents.push(components[i]);
      }

      var children = this._children;

      for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
        var child = children[_i5];
        child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
      }
    }
  }, {
    key: "_setTransformDirty",
    value: function _setTransformDirty() {
      if (this.transform) {
        this.transform._parentChange();
      } else {
        for (var i = 0, len = this._children.length; i < len; i++) {
          this._children[i]._setTransformDirty();
        }
      }
    } //--------------------------------------------------------------deprecated----------------------------------------------------------------

  }, {
    key: "getInvModelMatrix",

    /**
     * @deprecated
     */
    value: function getInvModelMatrix() {
      if (this._inverseWorldMatFlag.flag) {
        miniprogram.Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
        this._inverseWorldMatFlag.flag = false;
      }

      return this._invModelMatrix;
    }
  }, {
    key: "position",

    /**
     * @deprecated
     * 请使用 transform.position 代替。
     */
    get: function get() {
      return this.transform.position;
    },
    set: function set(val) {
      this.transform.position = val;
    }
    /**
     * @deprecated
     * 请使用 transform.worldPosition 代替
     */

  }, {
    key: "worldPosition",
    get: function get() {
      return this.transform.worldPosition;
    },
    set: function set(val) {
      this.transform.worldPosition = val;
    }
    /**
     * @deprecated
     * 请使用 transform.rotationQuaternion 代替
     */

  }, {
    key: "rotation",
    get: function get() {
      return this.transform.rotationQuaternion;
    },
    set: function set(val) {
      this.transform.rotationQuaternion = val;
    }
    /**
     * @deprecated
     * 请使用 transform.scale 代替
     */

  }, {
    key: "scale",
    get: function get() {
      return this.transform.scale;
    },
    set: function set(val) {
      this.transform.scale = val;
    }
  }]);

  return Entity;
}(EventDispatcher);
Entity._entitys = new DisorderedArray();

/**
 * 管理一组功能特性对象
 * @class
 */
var FeatureManager = /*#__PURE__*/function () {
  function FeatureManager() {
    _classCallCheck(this, FeatureManager);

    this._features = [];
    this._objects = [];
  }

  _createClass(FeatureManager, [{
    key: "registerFeature",

    /**
     * 注册一个功能特性
     * @param {SceneFeature|EngineFeature} Feature
     */
    value: function registerFeature(IFeature) {
      var featureArray = this._features; // -- 按照 type 查找，避免重复添加

      for (var i = 0, len = featureArray.length; i < len; i++) {
        if (featureArray[i] === IFeature) {
          return;
        }
      } // -- 添加到全局数组


      featureArray.push(IFeature); // -- 添加到现有场景实例中

      var objectArray = this._objects;

      for (var _i = 0, _len = objectArray.length; _i < _len; _i++) {
        objectArray[_i].features.push(new IFeature());
      }
    }
    /**
     * 添加一个具有功能特性的对象
     * @param {Scene|Engine} obj
     */

  }, {
    key: "addObject",
    value: function addObject(obj) {
      obj.features = [];

      for (var i = 0, len = this._features.length; i < len; i++) {
        var _engine;

        obj.features.push(new this._features[i]((_engine = obj.engine) !== null && _engine !== void 0 ? _engine : obj));
      }

      this._objects.push(obj);
    }
    /**
     * 调用功能特性的指定方法
     * @param {Scene|Engine} obj
     * @param {string} method
     * @param {Array} args
     */

  }, {
    key: "callFeatureMethod",
    value: function callFeatureMethod(obj, method, args) {
      var features = obj.features;
      var count = features.length;

      for (var i = 0; i < count; i++) {
        var feature = features[i];

        if (feature[method]) {
          feature[method].apply(feature, args);
        }
      }
    }
    /**
     * 查找特性
     * @param {Scene|Engine} obj
     * @param {SceneFeature|EngineFeature} feature
     */

  }, {
    key: "findFeature",
    value: function findFeature(obj, IFeature) {
      var features = obj.features;
      var count = features.length;

      for (var i = 0; i < count; i++) {
        var feature = features[i];

        if (feature.constructor === IFeature) {
          return feature;
        }
      }

      return undefined;
    }
  }]);

  return FeatureManager;
}();

/**
 * 渲染元素。
 */
var RenderElement = /*#__PURE__*/function () {
  function RenderElement() {
    _classCallCheck(this, RenderElement);

    this.component = void 0;
    this.primitive = void 0;
    this.subPrimitive = void 0;
    this.material = void 0;
  }

  _createClass(RenderElement, [{
    key: "setValue",
    value: function setValue(component, primitive, subPrimitive, material) {
      this.component = component;
      this.primitive = primitive;
      this.subPrimitive = subPrimitive;
      this.material = material;
    }
  }], [{
    key: "getFromPool",

    /**
     * 从池中获取渲染元素。
     * @remark 返回值当帧有效，下一帧会自动回收再利用。
     */
    value: function getFromPool() {
      var index = RenderElement._elementPoolIndex,
          pool = RenderElement._elementPool;
      RenderElement._elementPoolIndex++;

      if (pool.length === index) {
        var element = new RenderElement();
        pool.push(element);
        return element;
      } else {
        return pool[index];
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_restPool",
    value: function _restPool() {
      RenderElement._elementPoolIndex = 0;
    }
    /** 可渲染组件。 */

  }]);

  return RenderElement;
}();
RenderElement._elementPoolIndex = 0;
RenderElement._elementPool = [];

/**
 * 场景。
 */
var Scene = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Scene, _EventDispatcher);

  var _super = _createSuper(Scene);

  _createClass(Scene, [{
    key: "engine",

    /** 场景名字 */

    /**
     * @private
     * @deprecated
     * @todo: migrate to camera
     * 裁剪面，平面方程组。裁剪面以下的片元将被剔除绘制
     * @example
     * scene.clipPlanes = [[0,1,0,0]];
     * */

    /**
     * 当前的所属 Engine。
     */
    get: function get() {
      return this._engine;
    }
    /**
     * 根实体的数量。
     */

  }, {
    key: "rootEntitiesCount",
    get: function get() {
      return this._rootEntities.length;
    }
    /**
     * 根实体集合。
     */

  }, {
    key: "rootEntities",
    get: function get() {
      return this._rootEntities;
    }
    /**
     * 是否已销毁。
     */

  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
    /**
     * 创建场景。
     * @param engine - 引擎
     * @param name - 名称
     */

  }]);

  function Scene(engine, name) {
    var _this;

    _classCallCheck(this, Scene);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this.clipPlanes = [];
    _this._activeCameras = [];
    _this._isActiveInEngine = false;
    _this._destroyed = false;
    _this._rootEntities = [];
    _this.features = [];
    _this.name = name || "";
    Scene.sceneFeatureManager.addObject(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * 创建根实体。
   * @param name - 实体名称
   * @returns 实体
   */


  _createClass(Scene, [{
    key: "createRootEntity",
    value: function createRootEntity(name) {
      var entity = new Entity(this._engine, name);
      this.addRootEntity(entity);
      return entity;
    }
    /**
     * 添加根实体。
     * @param entity - 根实体
     */

  }, {
    key: "addRootEntity",
    value: function addRootEntity(entity) {
      var isRoot = entity._isRoot; //let entity become root

      if (!isRoot) {
        entity._isRoot = true;

        entity._removeFromParent();
      } //add or remove from scene's rootEntities


      var oldScene = entity._scene;

      if (oldScene !== this) {
        if (oldScene && isRoot) {
          oldScene._removeEntity(entity);
        }

        this._rootEntities.push(entity);

        Entity._traverseSetOwnerScene(entity, this);
      } else if (!isRoot) {
        this._rootEntities.push(entity);
      } //process entity active/inActive


      if (this._isActiveInEngine) {
        !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
      } else {
        entity._isActiveInHierarchy && entity._processInActive();
      }
    }
    /**
     * 移除根实体。
     * @param entity - 根实体
     */

  }, {
    key: "removeRootEntity",
    value: function removeRootEntity(entity) {
      if (entity._isRoot && entity._scene == this) {
        this._removeEntity(entity);

        this._isActiveInEngine && entity._processInActive();

        Entity._traverseSetOwnerScene(entity, null);
      }
    }
    /**
     * 通过索引获取根实体。
     * @param index - 索引
     */

  }, {
    key: "getRootEntity",
    value: function getRootEntity() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this._rootEntities[index];
    }
    /**
     * 根据名字全局查找实体。
     * @param name - 实体名称
     * @returns 实体
     */

  }, {
    key: "findEntityByName",
    value: function findEntityByName(name) {
      var children = this._rootEntities;

      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];

        if (child.name === name) {
          return child;
        }
      }

      for (var _i = children.length - 1; _i >= 0; _i--) {
        var _child = children[_i];

        var entity = _child.findByName(name);

        if (entity) {
          return entity;
        }
      }

      return null;
    }
    /**
     * 根据路径全局查找实体，使用‘/’符号作为路径分割符。
     * @param path - 实体路径
     * @returns 实体
     */

  }, {
    key: "findEntityByPath",
    value: function findEntityByPath(path) {
      var splits = path.split("/").filter(Boolean);

      for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
        var findEntity = this.getRootEntity(i);
        if (findEntity.name != splits[0]) continue;

        for (var j = 1, m = splits.length; j < m; ++j) {
          findEntity = Entity._findChildByName(findEntity, splits[j]);
          if (!findEntity) break;
        }

        return findEntity;
      }

      return null;
    }
    /**
     * 销毁场景。
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
      Scene.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);

      for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
        this._rootEntities[i].destroy();
      }

      this._rootEntities.length = 0;
      this._activeCameras.length = 0;
      Scene.sceneFeatureManager._objects = [];
      this._destroyed = true;
    }
    /**
     * 向当前场景注册一个摄像机对象
     * @param {CameraComponent} camera 摄像机对象
     * @private
     */

  }, {
    key: "attachRenderCamera",
    value: function attachRenderCamera(camera) {
      var index = this._activeCameras.indexOf(camera);

      if (index === -1) {
        this._activeCameras.push(camera);
      } else {
        Logger.warn("Camera already attached.");
      }
    }
    /**
     * 从当前场景移除一个摄像机对象
     * @param {CameraComponent} camera 摄像机对象
     * @private
     */

  }, {
    key: "detachRenderCamera",
    value: function detachRenderCamera(camera) {
      var index = this._activeCameras.indexOf(camera);

      if (index !== -1) {
        this._activeCameras.splice(index, 1);
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_processActive",
    value: function _processActive(active) {
      this._isActiveInEngine = active;
      var rootEntities = this._rootEntities;

      for (var i = rootEntities.length - 1; i >= 0; i--) {
        var entity = rootEntities[i];

        if (entity._isActive) {
          active ? entity._processActive() : entity._processInActive();
        }
      }
    }
  }, {
    key: "_removeEntity",
    value: function _removeEntity(entity) {
      var oldRootEntities = this._rootEntities;
      oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);
    } //-----------------------------------------@deprecated-----------------------------------

  }, {
    key: "findFeature",
    value: function findFeature(Feature) {
      return Scene.sceneFeatureManager.findFeature(this, Feature);
    }
  }, {
    key: "raycast",

    /**
     * @deprecated
     * 射线
     * @param ray
     */
    value: function raycast(ray, outPos, tag) {}
  }], [{
    key: "registerFeature",
    value: function registerFeature(Feature) {
      Scene.sceneFeatureManager.registerFeature(Feature);
    }
  }]);

  return Scene;
}(EventDispatcher);
Scene.sceneFeatureManager = new FeatureManager();

/**
 * 场景管理员。
 */
var SceneManager = /*#__PURE__*/function () {
  _createClass(SceneManager, [{
    key: "activeScene",

    /**
     * 当前激活场景。
     */
    get: function get() {
      return this._activeScene;
    },
    set: function set(scene) {
      var oldScene = this._activeScene;

      if (oldScene !== scene) {
        oldScene && oldScene._processActive(false);
        scene && scene._processActive(true);
        this._activeScene = scene;
      }
    }
    /**
     * @internal
     */

  }]);

  function SceneManager(engine) {
    _classCallCheck(this, SceneManager);

    this.engine = engine;
    this._activeScene = void 0;
  }
  /**
   * 加载并激活场景。
   * @param url - 场景路径
   * @param destroyOldScene - 是否销毁旧场景信息
   * @returns 场景请求
   */


  _createClass(SceneManager, [{
    key: "loadScene",
    value: function loadScene(url) {
      var _this = this;

      var destroyOldScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var scenePromise = this.engine.resourceManager.load(url);
      scenePromise.then(function (scene) {
        var oldScene = _this._activeScene;
        _this.activeScene = scene;

        if (oldScene && destroyOldScene) {
          oldScene.destroy();
        }
      });
      return scenePromise;
    }
    /**
     * 合并场景，将源场景合并到目标场景。
     * @remarks 合并后将使用 destScene 的全局信息,lightingMap 信息会进行合并。
     * @param sourceScene - 源场景
     * @param destScene - 目标场景
     */

  }, {
    key: "mergeScenes",
    value: function mergeScenes(sourceScene, destScene) {
      var oldRootEntities = sourceScene.rootEntities;

      for (var i = 0, n = oldRootEntities.length; i < n; i++) {
        destScene.addRootEntity(oldRootEntities[i]);
      }
    }
  }]);

  return SceneManager;
}();

/** todo: delete */

var engineFeatureManager = new FeatureManager();
/**
 * 引擎。
 */

var Engine = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Engine, _EventDispatcher);

  var _super = _createSuper(Engine);

  _createClass(Engine, [{
    key: "canvas",

    /**
     * 渲染画布。
     */
    get: function get() {
      return this._canvas;
    }
    /**
     * 资源管理器。
     */

  }, {
    key: "resourceManager",
    get: function get() {
      return this._resourceManager;
    }
    /**
     * 场景管理器。
     */

  }, {
    key: "sceneManager",
    get: function get() {
      return this._sceneManager;
    }
    /**
     * 计时器。
     */

  }, {
    key: "time",
    get: function get() {
      return this._time;
    }
    /**
     * 是否暂停。
     */

  }, {
    key: "isPaused",
    get: function get() {
      return this._isPaused;
    }
    /**
     * 垂直同步数量,表示执行一帧的垂直消隐数量,0表示关闭垂直同步。
     */

  }, {
    key: "vSyncCount",
    get: function get() {
      return this._vSyncCount;
    },
    set: function set(value) {
      this._vSyncCount = Math.max(0, Math.floor(value));
    }
    /**
     * 目标帧率，vSyncCount = 0（即关闭垂直同步）时生效。
     * 值越大，目标帧率越高，Number.POSITIVE_INFINIT 表示无穷大目标帧率。
     */

  }, {
    key: "targetFrameRate",
    get: function get() {
      return this._targetFrameRate;
    },
    set: function set(value) {
      value = Math.max(0.000001, value);
      this._targetFrameRate = value;
      this._targetFrameInterval = 1000 / value;
    }
    /**
     * @deprecated
     * 图形API渲染器。
     */

  }, {
    key: "renderhardware",
    get: function get() {
      return this._hardwareRenderer;
    }
    /**
     * 创建引擎。
     * @param canvas - 渲染画布
     * @param hardwareRenderer - 渲染器
     */

  }]);

  function Engine(canvas, hardwareRenderer) {
    var _this;

    _classCallCheck(this, Engine);

    _this = _super.call(this, null);
    _this._componentsManager = new ComponentsManager();
    _this._hardwareRenderer = void 0;
    _this._canvas = void 0;
    _this._resourceManager = new ResourceManager(_assertThisInitialized(_this));
    _this._sceneManager = new SceneManager(_assertThisInitialized(_this));
    _this._vSyncCount = 1;
    _this._targetFrameRate = 60;
    _this._time = new Time();
    _this._isPaused = true;
    _this._requestId = void 0;
    _this._timeoutId = void 0;
    _this._loopCounter = 0;
    _this._targetFrameInterval = 1000 / 60;

    _this._animate = function () {
      if (_this._vSyncCount) {
        _this._requestId = miniprogramAdapter.requestAnimationFrame(_this._animate);

        if (_this._loopCounter++ % _this._vSyncCount === 0) {
          _this.update();

          _this._loopCounter = 1;
        }
      } else {
        _this._timeoutId = miniprogramAdapter.window.setTimeout(_this._animate, _this._targetFrameInterval);

        _this.update();
      }
    };

    _this.features = [];
    _this._hardwareRenderer = hardwareRenderer;

    _this._hardwareRenderer.init(canvas, _assertThisInitialized(_this));

    _this._canvas = canvas; // @todo delete

    engineFeatureManager.addObject(_assertThisInitialized(_this));
    _this._sceneManager.activeScene = new Scene(_assertThisInitialized(_this), "DefaultScene");
    return _this;
  }
  /**
   * 创建实体。
   * @param name - 名字
   */


  _createClass(Engine, [{
    key: "createEntity",
    value: function createEntity(name) {
      return new Entity(this, name);
    }
    /**
     * 暂停引擎循环。
     */

  }, {
    key: "pause",
    value: function pause() {
      this._isPaused = true;
      miniprogramAdapter.cancelAnimationFrame(this._requestId);
      clearTimeout(this._timeoutId);
    }
    /**
     * 恢复引擎循环。
     */

  }, {
    key: "resume",
    value: function resume() {
      if (!this._isPaused) return;
      this._isPaused = false;
      this.time.reset();
      miniprogramAdapter.requestAnimationFrame(this._animate);
    }
    /**
     * 引擎手动更新，如果调用 run() 则一般无需调用该函数。
     */

  }, {
    key: "update",
    value: function update() {
      var time = this._time;
      var deltaTime = time.deltaTime;
      time.tick();

      RenderElement._restPool();

      engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);

      this._hardwareRenderer.beginFrame();

      var scene = this._sceneManager._activeScene;
      var componentsManager = this._componentsManager;

      if (scene) {
        componentsManager.callScriptOnStart();
        componentsManager.callScriptOnUpdate(deltaTime);
        componentsManager.callAnimationUpdate(deltaTime);
        componentsManager.callScriptOnLateUpdate(deltaTime);

        this._render(scene);
      }

      this._componentsManager.callComponentDestory();

      this._hardwareRenderer.endFrame();

      engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
    }
    /**
     * 执行引擎循环。
     */

  }, {
    key: "run",
    value: function run() {
      // @todo: delete
      engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
      this.resume();
      this.trigger(new Event("run", this));
    }
    /**
     * 销毁引擎。
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this._sceneManager) {
        // -- event
        this.trigger(new Event("shutdown", this));
        engineFeatureManager.callFeatureMethod(this, "shutdown", [this]); // -- cancel animation

        this.pause();
        this._animate = null;

        this._sceneManager._activeScene.destroy();

        this._sceneManager = null;

        this._resourceManager.gc();

        this._resourceManager = null;
        this._canvas = null;
        this.features = [];
        this._time = null; // todo: delete

        engineFeatureManager._objects = [];
      }
    }
  }, {
    key: "_render",
    value: function _render(scene) {
      var cameras = scene._activeCameras;
      var componentsManager = this._componentsManager;
      var deltaTime = this.time.deltaTime;
      componentsManager.callRendererOnUpdate(deltaTime);

      if (cameras.length > 0) {
        // 针对 priority 进行排序
        //@ts-ignore
        cameras.sort(function (camera1, camera2) {
          return camera1.priority - camera2.priority;
        });

        for (var i = 0, l = cameras.length; i < l; i++) {
          var camera = cameras[i];
          var cameraEntity = camera.entity;

          if (camera.enabled && cameraEntity.isActiveInHierarchy) {
            componentsManager.callCameraOnBeginRender(camera);
            Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [this, camera]); //TODO:移除

            camera.render();
            Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [this, camera]); //TODO:移除

            componentsManager.callCameraOnEndRender(camera);
          }
        }
      } else {
        Logger.debug("NO active camera.");
      }
    } //-----------------------------------------@deprecated-----------------------------------

  }, {
    key: "findFeature",
    value: function findFeature(Feature) {
      return engineFeatureManager.findFeature(this, Feature);
    }
  }], [{
    key: "registerFeature",
    value: function registerFeature(Feature) {
      engineFeatureManager.registerFeature(Feature);
    }
  }]);

  return Engine;
}(EventDispatcher);

/**
 * 系统信息。
 */
var SystemInfo = /*#__PURE__*/function () {
  function SystemInfo() {
    _classCallCheck(this, SystemInfo);
  }

  _createClass(SystemInfo, null, [{
    key: "devicePixelRatio",

    /**
     * 设备的像素比。
     */
    get: function get() {
      return miniprogramAdapter.window.devicePixelRatio;
    }
  }]);

  return SystemInfo;
}();

/**
 * 引擎功能特性插件基类
 * @class
 */
var EngineFeature = /*#__PURE__*/function () {
  function EngineFeature() {
    _classCallCheck(this, EngineFeature);
  }

  _createClass(EngineFeature, [{
    key: "preLoad",

    /**
     * 引擎主循环运行之前的回调，用来预加载资源
     * @param {Engine} engine
     */
    value: function preLoad(engine) {}
    /**
     * 场景 Tick 之前的回调
     * @param {Engine} engine
     * @param {Scene} currentScene
     */

  }, {
    key: "preTick",
    value: function preTick(engine, currentScene) {}
    /**
     * 场景 Tick 完成之后的回调
     * @param {Engine} engine
     */

  }, {
    key: "postTick",
    value: function postTick(engine, currentScene) {}
    /**
     * 引擎关闭的时候调用
     * @param {Engine} engine
     */

  }, {
    key: "shutdown",
    value: function shutdown(engine) {}
  }]);

  return EngineFeature;
}();

/**
 * 使用引用计数管理的资源对象基类
 */

var AssetObject = /*#__PURE__*/function (_EngineObject) {
  _inherits(AssetObject, _EngineObject);

  var _super = _createSuper(AssetObject);

  function AssetObject() {
    var _this;

    _classCallCheck(this, AssetObject);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.type = void 0;
    _this.name = void 0;
    _this.cacheID = void 0;
    _this.needRecreate = void 0;
    return _this;
  }

  return AssetObject;
}(EngineObject);

/**
 * Scene 访问者接口
 */
var SceneVisitor = function SceneVisitor() {
  _classCallCheck(this, SceneVisitor);
};

/**
 * 场景的功能特性插件基类
 * @class
 */
var SceneFeature = /*#__PURE__*/function () {
  function SceneFeature() {
    _classCallCheck(this, SceneFeature);
  }

  _createClass(SceneFeature, [{
    key: "preUpdate",

    /**
     * 场景 Update 之前的回调
     * @param {Scene} scene
     */
    value: function preUpdate(scene) {}
    /**
     * 场景 Update 之后的回调
     * @param {Scene} scene
     */

  }, {
    key: "postUpdate",
    value: function postUpdate(scene) {}
    /**
     * 场景渲染前的回调
     * @param scene
     * @param camera
     */

  }, {
    key: "preRender",
    value: function preRender(scene, camera) {}
    /**
     * 场景渲染后的回调
     * @param scene
     * @param camera
     */

  }, {
    key: "postRender",
    value: function postRender(scene, camera) {}
    /**
     * 场景销毁的时候调用
     * @param {Scene} scene
     */

  }, {
    key: "destroy",
    value: function destroy(scene) {}
  }]);

  return SceneFeature;
}();

var _class$4, _descriptor$4, _descriptor2$3, _descriptor3$2, _descriptor4$2, _descriptor5$1, _descriptor6$1, _temp$4;
/**
 * 脚本类，可进行逻辑编写。
 */

var Script = (_class$4 = (_temp$4 = /*#__PURE__*/function (_Component) {
  _inherits(Script, _Component);

  var _super = _createSuper(Script);

  function Script() {
    var _this;

    _classCallCheck(this, Script);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _initializerDefineProperty(_this, "_started", _descriptor$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onStartIndex", _descriptor2$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onLateUpdateIndex", _descriptor4$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onPreRenderIndex", _descriptor5$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_onPostRenderIndex", _descriptor6$1, _assertThisInitialized(_this));

    return _this;
  }

  _createClass(Script, [{
    key: "onAwake",

    /**
     * 第一次触发可用状态时调用,只调用一次。
     */
    value: function onAwake() {}
    /**
     * 触发为可用状态时调用。
     */

  }, {
    key: "onEnable",
    value: function onEnable() {}
    /**
     * 第一次执行帧级循环前调用，只调用一次。
     */

  }, {
    key: "onStart",
    value: function onStart() {}
    /**
     * 主更新，逐帧调用。
     * @param deltaTime - 帧间隔时间
     */

  }, {
    key: "onUpdate",
    value: function onUpdate(deltaTime) {}
    /**
     * 延迟更新，逐帧调用。
     * @param deltaTime - 帧间隔时间
     */

  }, {
    key: "onLateUpdate",
    value: function onLateUpdate(deltaTime) {}
    /**
     * 相机渲染前调用，逐相机调用。
     * @param camera - 当前渲染相机
     */

  }, {
    key: "onBeginRender",
    value: function onBeginRender(camera) {}
    /**
     * 相机完成渲染后调用，逐相机调用。
     * @param camera - 当前渲染相机
     */

  }, {
    key: "onEndRender",
    value: function onEndRender(camera) {}
    /**
     * 触发为禁用状态时调用。
     */

  }, {
    key: "onDisable",
    value: function onDisable() {}
    /**
     * 在被销毁帧的最后调用。
     */

  }, {
    key: "onDestroy",
    value: function onDestroy() {}
    /**
     * @internal
     * @inheritDoc
     * @override
     */

  }, {
    key: "_onAwake",
    value: function _onAwake() {
      this.onAwake();
    }
    /**
     * @internal
     * @inheritDoc
     * @override
     */

  }, {
    key: "_onEnable",
    value: function _onEnable() {
      var componentsManager = this.engine._componentsManager;
      var prototype = Script.prototype;

      if (!this._started) {
        componentsManager.addOnStartScript(this);
      }

      if (this.onUpdate !== prototype.onUpdate) {
        componentsManager.addOnUpdateScript(this);
      }

      if (this.onLateUpdate !== prototype.onLateUpdate) {
        componentsManager.addOnLateUpdateScript(this);
      }

      this.onEnable();
    }
    /**
     * @internal
     * @inheritDoc
     * @override
     */

  }, {
    key: "_onDisable",
    value: function _onDisable() {
      var componentsManager = this.engine._componentsManager; // use "xxIndex" is more safe
      // when call onDisable it maybe it still not in script queue,for example write "entity.isActive = false" in onWake().

      if (this._onStartIndex !== -1) {
        componentsManager.removeOnStartScript(this);
      }

      if (this._onUpdateIndex !== -1) {
        componentsManager.removeOnUpdateScript(this);
      }

      if (this._onLateUpdateIndex !== -1) {
        componentsManager.removeOnLateUpdateScript(this);
      }

      this.onDisable();
    }
    /**
     * @internal
     * @inheritDoc
     * @override
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {
      this.engine._componentsManager.addDestoryComponent(this);
    }
  }]);

  return Script;
}(Component), _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class$4.prototype, "_started", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class$4.prototype, "_onStartIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor3$2 = _applyDecoratedDescriptor(_class$4.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor4$2 = _applyDecoratedDescriptor(_class$4.prototype, "_onLateUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class$4.prototype, "_onPreRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class$4.prototype, "_onPostRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
})), _class$4);

var _class$5, _descriptor$5, _descriptor2$4, _descriptor3$3, _descriptor4$3, _descriptor5$2, _temp$5;

/**
 * 可渲染的组件。
 */
var RenderableComponent = (_class$5 = (_temp$5 = /*#__PURE__*/function (_Component) {
  _inherits(RenderableComponent, _Component);

  var _super = _createSuper(RenderableComponent);

  _createClass(RenderableComponent, [{
    key: "bounds",

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * 包围体。
     */
    get: function get() {
      var changeFlag = this._transformChangeFlag;

      if (changeFlag.flag) {
        this._updateBounds(this._bounds);

        changeFlag.flag = false;
      }

      return this._bounds;
    }
    /**
     * @internal
     */

  }]);

  function RenderableComponent(entity) {
    var _this;

    _classCallCheck(this, RenderableComponent);

    _this = _super.call(this, entity);

    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_rendererIndex", _descriptor2$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_overrideUpdate", _descriptor3$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_transformChangeFlag", _descriptor4$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_bounds", _descriptor5$2, _assertThisInitialized(_this));

    var prototype = RenderableComponent.prototype;
    _this._overrideUpdate = _this.update !== prototype.update;
    _this._transformChangeFlag = _this.entity.transform.registerWorldChangeFlag();
    return _this;
  }
  /**
   * @inheritdoc
   */


  _createClass(RenderableComponent, [{
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf(RenderableComponent.prototype), "destroy", this).call(this);

      var flag = this._transformChangeFlag;

      if (flag) {
        flag.destroy();
        this._transformChangeFlag = null;
      }
    }
  }, {
    key: "update",
    value: function update(deltaTime) {}
  }, {
    key: "_updateBounds",
    value: function _updateBounds(worldBounds) {}
  }, {
    key: "_onEnable",
    value: function _onEnable() {
      var componentsManager = this.engine._componentsManager;

      if (this._overrideUpdate) {
        componentsManager.addOnUpdateRenderers(this);
      }

      componentsManager.addRenderer(this);
    }
  }, {
    key: "_onDisable",
    value: function _onDisable() {
      var componentsManager = this.engine._componentsManager;

      if (this._overrideUpdate) {
        componentsManager.removeOnUpdateRenderers(this);
      }

      componentsManager.removeRenderer(this);
    }
  }, {
    key: "_render",
    value: function _render(camera) {
      var culled = false; // distance cull

      if (this.cullDistanceSq > 0) {
        var distanceSq = miniprogram.Vector3.distanceSquared(camera._entity.transform.worldPosition, this.entity.transform.worldPosition);
        culled = this.cullDistanceSq < distanceSq;
      }

      if (!culled) {
        this.render(camera);
      }
    }
  }]);

  return RenderableComponent;
}(Component), _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class$5.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor2$4 = _applyDecoratedDescriptor(_class$5.prototype, "_rendererIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor3$3 = _applyDecoratedDescriptor(_class$5.prototype, "_overrideUpdate", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class$5.prototype, "_transformChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$2 = _applyDecoratedDescriptor(_class$5.prototype, "_bounds", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.BoundingBox(new miniprogram.Vector3(), new miniprogram.Vector3());
  }
})), _class$5);

/** @todo: monorepo circle dependence */

var passNum = 0;
/**
 * RednerPass 对象
 */

var RenderPass = /*#__PURE__*/function () {
  /**
   * RenderPass 构造函数
   * @param name 这个 Pass 的名称
   * @param priority 优先级，小于0在默认Pass之前，大于0在默认Pass之后
   * @param renderTarget 指定的 Render Target
   * @param replaceMaterial 替换模型的默认材质
   * @param mask 与 Component.renderPassFlag 进行 bit and 操作，对这个 Pass 需要渲染的对象进行筛选
   * @param clearParam 清除renderTarget的背景颜色
   */
  function RenderPass() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "RENDER_PASS".concat(passNum++);
    var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var renderTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var replaceMaterial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var clearParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new miniprogram.Vector4(0, 0, 0, 0);

    _classCallCheck(this, RenderPass);

    this.name = void 0;
    this.enabled = void 0;
    this.priority = void 0;
    this.renderTarget = void 0;
    this.replaceMaterial = void 0;
    this.mask = void 0;
    this.renderOverride = void 0;
    this.clearMode = void 0;
    this._clearParam = void 0;
    this.name = name;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || exports.MaskList.EVERYTHING;
    this.renderOverride = false; ///< 若 renderOverride 设为了 true，则需要实现 render(camera) 方法

    /**
     * 画布清除模式，默认为 ClearMode.SOLID_COLOR
     * @member {number}
     */

    this.clearMode = exports.ClearMode.SOLID_COLOR;
    this._clearParam = clearParam; // PASS use render target's clearParam
  }
  /**
   * 画布清除参数，默认使用 RenderTarget 的 clearColor
   * @type {*}
   */


  _createClass(RenderPass, [{
    key: "render",

    /**
     * 用于自定义的渲染过程，若 renderOverride 设为了 true 将被执行到
     * @param {Camera} camera 相机
     * @param {RenderQueue} opaqueQueue 不透明物体渲染队列
     * @param {RenderQueue} transparentQueue 透明物体渲染队列
     */
    value: function render(camera, opaqueQueue, transparentQueue) {}
    /**
     * Pass 渲染前调用
     * @param {Camera} camera 相机
     * @param {RenderQueue} opaqueQueue 不透明物体渲染队列
     * @param {RenderQueue} transparentQueue 透明物体渲染队列
     */

  }, {
    key: "preRender",
    value: function preRender(camera, opaqueQueue, transparentQueue) {}
    /**
     * Pass 渲染后调用
     * @param {Camera} camera 相机
     * @param {RenderQueue} opaqueQueue 不透明物体渲染队列
     * @param {RenderQueue} transparentQueue 透明物体渲染队列
     */

  }, {
    key: "postRender",
    value: function postRender(camera, opaqueQueue, transparentQueue) {}
  }, {
    key: "clearParam",
    get: function get() {
      return this._clearParam;
    },
    set: function set(v) {
      this._clearParam = v;
    }
  }]);

  return RenderPass;
}();

/**
 * 渲染上下文。
 */

var RenderContext = /*#__PURE__*/function () {
  function RenderContext() {
    _classCallCheck(this, RenderContext);

    this.camera = void 0;
    this.viewMatrix = void 0;
    this.projectionMatrix = void 0;
    this.viewProjectMatrix = new miniprogram.Matrix();
    this.inverseViewMatrix = void 0;
    this.inverseProjectionMatrix = void 0;
    this.viewport = void 0;
    this.cameraPosition = void 0;
  }

  _createClass(RenderContext, null, [{
    key: "_getRenderContext",
    value: function _getRenderContext(camera) {
      var context = RenderContext._renderContext;
      context.camera = camera;
      context.viewport = camera.viewport;
      context.cameraPosition = camera.entity.transform.worldPosition;
      context.inverseViewMatrix = camera.inverseViewMatrix;
      context.inverseProjectionMatrix = camera.inverseProjectionMatrix;
      context.viewMatrix = camera.viewMatrix;
      context.projectionMatrix = camera.projectionMatrix;
      miniprogram.Matrix.multiply(context.projectionMatrix, context.viewMatrix, context.viewProjectMatrix);
      return this._renderContext;
    }
  }]);

  return RenderContext;
}();
RenderContext._renderContext = new RenderContext();

/**
 * 渲染队列管理。
 * @private
 */
var RenderQueue = /*#__PURE__*/function () {
  function RenderQueue() {
    _classCallCheck(this, RenderQueue);

    this._items = [];
  }
  /**
   * 需要渲染的对象数组
   * @member {Object}
   * @readonly
   */


  _createClass(RenderQueue, [{
    key: "clear",

    /**
     * 情况内部数据
     */
    value: function clear() {
      this._items = [];
    }
    /**
     * 把一个 Primitive 对象添加进来
     */

  }, {
    key: "pushPrimitive",
    value: function pushPrimitive(element) {
      this._items.push(element);
    }
    /**
     * 对于透明对象，按照离摄像机由远及近的顺序渲染，有助于减少视觉错误
     * @param {Vector3} eyePos
     */

  }, {
    key: "sortByDistance",
    value: function sortByDistance(eyePos) {
      var items = this._items;

      if (items.length > 1) {
        this._items = items.sort(function (item1, item2) {
          if (item1.component.renderPriority === item2.component.renderPriority) {
            var pos1 = item1.component.entity.transform.worldPosition;
            var pos2 = item2.component.entity.transform.worldPosition;
            var dis = miniprogram.Vector3.distanceSquared(pos2, eyePos) - miniprogram.Vector3.distanceSquared(pos1, eyePos);
            return dis;
          } else {
            return item1.component.renderPriority - item2.component.renderPriority;
          }
        });
      } // end of if

    }
    /**
     * 对于不透明对象，按照 Technique 排序，可以减少渲染状态切换，提升效率
     */

  }, {
    key: "sortByTechnique",
    value: function sortByTechnique() {
      var items = this._items;

      if (items.length > 1) {
        this._items = items.sort(function (item1, item2) {
          if (item1.component.renderPriority === item2.component.renderPriority) {
            var tech1 = item1.material.technique;
            var tech2 = item2.material.technique;

            if (tech1 && tech2) {
              return tech1.name.localeCompare(tech2.name);
            } else {
              return 0;
            }
          } else {
            return item1.component.renderPriority - item2.component.renderPriority;
          }
        });
      } // end of if

    }
    /**
     * 把一个 Sprite 绘制需要的信息传进来
     * @param {Component} component
     * @param {object} positionQuad  Sprite四个顶点的位置
     * @param {object} uvRect        Sprite在texture上的纹理坐标
     * @param {vec4}   tintColor     颜色
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */

  }, {
    key: "pushSprite",
    value: function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
      var element = {
        // @ts-ignore
        component: component,
        positionQuad: positionQuad,
        uvRect: uvRect,
        tintColor: tintColor,
        texture: texture,
        renderMode: renderMode,
        camera: camera
      };

      this._items.push(element);
    }
    /**
     * 执行渲染操作
     * @param {Camera} camera 当前的摄像机
     * @param {Material} replaceMaterial 替换模型自身的材质
     * @param {number} mask 渲染过滤使用的mask
     */

  }, {
    key: "render",
    value: function render(camera, replaceMaterial, mask) {
      var rhi = camera.scene.engine._hardwareRenderer;
      var items = this._items; // 如果没有items不需要渲染

      if (items.length === 0) {
        return;
      }

      this.updateMaxJointsNum(this._items, replaceMaterial);

      var context = RenderContext._getRenderContext(camera);

      var cullingMask = camera.cullingMask;

      for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var component = item.component; //-- filter by camera culling mask

        if (!(cullingMask & component._entity.layer)) continue;
        var renderPassFlag = component.renderPassFlag; //-- filter by mask

        if (!(renderPassFlag & mask)) continue; //-- draw

        if (this._isPrimitive(item)) {
          var _material$preRender, _material$postRender;

          var element = item; //-- 如果有缓存的Sprite尚未绘制，则先绘制缓存的Sprite

          rhi.flushSprite();
          var material = replaceMaterial ? replaceMaterial : element.material;
          (_material$preRender = material.preRender) === null || _material$preRender === void 0 ? void 0 : _material$preRender.call(material, element.component, element.primitive);
          material.prepareDrawing(context, element.component, element.primitive, element.material);
          rhi.drawPrimitive(element.primitive, element.subPrimitive, material);
          (_material$postRender = material.postRender) === null || _material$postRender === void 0 ? void 0 : _material$postRender.call(material, element.component, element.primitive);
        } else {
          var spirteElement = item;
          rhi.drawSprite(spirteElement.positionQuad, spirteElement.uvRect, spirteElement.tintColor, spirteElement.texture, spirteElement.renderMode, spirteElement.camera);
        }
      } // end of for


      rhi.flushSprite();
    }
    /**
     * 更新当前 renderQueue 中各个材质的最大骨骼节点数
     * @param items
     * @param {Material} replaceMaterial
     */

  }, {
    key: "updateMaxJointsNum",
    value: function updateMaxJointsNum(items, replaceMaterial) {
      for (var i = 0, len = items.length; i < len; i++) {
        var _items$i = items[i],
            component = _items$i.component,
            material = _items$i.material;
        var materialControl = replaceMaterial ? replaceMaterial : material; // 仅当 component 为 SkinnedMeshRenderer 时需要计算

        if (component.jointNodes) {
          materialControl.maxJointsNum = Math.max(materialControl.maxJointsNum, component.jointNodes.length);
        }
      }
    }
    /**
     * 判断是否是sprite
     * @private
     */

  }, {
    key: "_isPrimitive",
    value: function _isPrimitive(item) {
      return !!item.primitive;
    }
  }, {
    key: "items",
    get: function get() {
      return this._items;
    }
  }]);

  return RenderQueue;
}();

/**
 * Sprite 的 RenderPass，在后处理后绘制，不受后处理影响
 * @private
 */

var SeparateSpritePass = /*#__PURE__*/function (_RenderPass) {
  _inherits(SeparateSpritePass, _RenderPass);

  var _super = _createSuper(SeparateSpritePass);

  function SeparateSpritePass() {
    var _this;

    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "SeparateSprite";
    var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    _classCallCheck(this, SeparateSpritePass);

    _this = _super.call(this, name, priority);
    _this._spriteItems = void 0;
    _this.clearMode = exports.ClearMode.DONT_CLEAR;
    _this.renderOverride = true;
    _this._spriteItems = [];
    return _this;
  }
  /**
   * 给 RenderPipeline 调用，判断是否需要绘制 Sprite
   */


  _createClass(SeparateSpritePass, [{
    key: "preRender",
    value: function preRender() {
      this.enabled = this.isUsed;
    }
  }, {
    key: "render",
    value: function render(camera) {
      var rhi = camera.renderHardware;

      this._sortByDistance(camera.eyePos);

      var items = this._spriteItems;

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        rhi.drawSprite(item.positionQuad, item.uvRect, item.tintColor, item.texture, item.renderMode, item.camera);
      }

      items.length = 0;
    }
  }, {
    key: "postRender",
    value: function postRender(camera) {
      if (this.enabled) {
        // 确保所有缓冲的 Sprites 都绘制到画布中
        camera.renderHardware.flushSprite();
      }
    }
    /**
     * 对于透明对象，按照离摄像机由远及近的顺序渲染，有助于减少视觉错误
     * @param {vec3} eyePos
     */

  }, {
    key: "_sortByDistance",
    value: function _sortByDistance(eyePos) {
      if (this._spriteItems.length > 1) {
        this._spriteItems = this._spriteItems.sort(function (item1, item2) {
          if (item1.component.renderPriority === item2.component.renderPriority) {
            var pos1 = item1.component.node.worldPosition;
            var pos2 = item2.component.node.worldPosition;
            var dis = miniprogram.Vector3.distanceSquared(pos2, eyePos) - miniprogram.Vector3.distanceSquared(pos1, eyePos);
            return dis;
          } else {
            return item1.component.renderPriority - item2.component.renderPriority;
          }
        });
      } // end of if

    }
    /**
     * 把一个 Sprite 绘制需要的信息传进来
     * @param {Component} component
     * @param {Object} positionQuad  Sprite四个顶点的位置
     * @param {Object} uvRect        Sprite在texture上的纹理坐标
     * @param {vec4}   tintColor     颜色
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */

  }, {
    key: "pushSprite",
    value: function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
      this._spriteItems.push({
        component: component,
        positionQuad: positionQuad,
        uvRect: uvRect,
        tintColor: tintColor,
        texture: texture,
        renderMode: renderMode,
        camera: camera
      });
    }
  }, {
    key: "isUsed",
    get: function get() {
      return this._spriteItems.length > 0;
    }
  }]);

  return SeparateSpritePass;
}(RenderPass);

/** @todo: monorepo circle dependence */

/**
 * 使用指定的CameraComponent对象，渲染当前场景中的所有可见对象
 * @class
 */
var BasicRenderPipeline = /*#__PURE__*/function (_SceneVisitor) {
  _inherits(BasicRenderPipeline, _SceneVisitor);

  var _super = _createSuper(BasicRenderPipeline);

  /**
   * 构造函数
   * @param {Camera} camera 摄像机对象
   */
  function BasicRenderPipeline(camera) {
    var _this;

    _classCallCheck(this, BasicRenderPipeline);

    _this = _super.call(this);
    _this._camera = void 0;
    _this._opaqueQueue = void 0;
    _this._transparentQueue = void 0;
    _this._defaultPass = void 0;
    _this._renderPassArray = void 0;
    _this._canvasDepthPass = void 0;
    _this._separateSpritePass = void 0;
    _this._camera = camera;
    _this._opaqueQueue = new RenderQueue(); // 不透明对象的渲染队列

    _this._transparentQueue = new RenderQueue(); // 透明对象的渲染队列

    _this._renderPassArray = [];
    _this._defaultPass = new RenderPass("default", 0, null, null, 0);

    _this.addRenderPass(_this._defaultPass);

    return _this;
  }
  /**
   * 默认的 RenderPass
   */


  _createClass(BasicRenderPipeline, [{
    key: "addRenderPass",

    /**
     * 添加一个 Render Pass
     * @param {string|RenderPass} nameOrPass 这个 Pass 的名称或者 RenderPass 对象，当为名称时需提供以下参数
     * @param {number} priority 优先级，小于0在默认Pass之前，大于0在默认Pass之后
     * @param {RenderTarget} renderTarget 指定的 Render Target
     * @param {Material} replaceMaterial 替换模型的默认材质
     * @param {MaskList} mask 与 Component.renderPassFlag 进行 bit and 操作，对这个 Pass 需要渲染的对象进行筛选
     * @param clearParam 清除renderTarget的背景颜色
     */
    value: function addRenderPass(nameOrPass) {
      var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var renderTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var replaceMaterial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var clearParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new miniprogram.Vector4(0, 0, 0, 0);

      if (typeof nameOrPass === "string") {
        var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask, clearParam);

        this._renderPassArray.push(renderPass);
      } else if (nameOrPass instanceof RenderPass) {
        this._renderPassArray.push(nameOrPass);
      }

      this._renderPassArray.sort(function (p1, p2) {
        return p1.priority - p2.priority;
      });
    }
    /**
     * 通过名称或 RenderPass 对象移除 RenderPass
     * @param {string | RenderPass} nameOrPass RenderPass 名称
     */

  }, {
    key: "removeRenderPass",
    value: function removeRenderPass(nameOrPass) {
      var pass;
      if (typeof nameOrPass === "string") pass = this.getRenderPass(nameOrPass);else if (nameOrPass instanceof RenderPass) pass = nameOrPass;

      if (pass) {
        var idx = this._renderPassArray.indexOf(pass);

        this._renderPassArray.splice(idx, 1);
      }
    }
    /**
     * 通过名称获取 RenderPass
     * @param {string} name RenderPass 名称
     */

  }, {
    key: "getRenderPass",
    value: function getRenderPass(name) {
      for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
        var pass = this._renderPassArray[i];
        if (pass.name === name) return pass;
      }

      return null;
    }
    /**
     * 不透明对象的渲染队列
     * @member {RenderQueue}
     * @readonly
     */

  }, {
    key: "destroy",

    /**
     * 释放内部资源
     */
    value: function destroy() {}
    /**
     * 执行场景渲染
     */

  }, {
    key: "render",
    value: function render() {
      var camera = this._camera;
      var opaqueQueue = this._opaqueQueue;
      var transparentQueue = this._transparentQueue; //-- 清空内部状态

      opaqueQueue.clear();
      transparentQueue.clear();

      camera.engine._componentsManager.callRender(camera); //-- 执行渲染队列


      opaqueQueue.sortByTechnique();
      transparentQueue.sortByDistance(camera.entity.transform.worldPosition); //-- 为sprite提供canvas上的深度信息

      if (this._canvasDepthPass) this._canvasDepthPass.enabled = false;

      if (this._separateSpritePass && this._separateSpritePass.isUsed) {
        // 如果默认的rendertarget不是canvas的话，就需要在canvas上再绘制一遍确保有深度信息
        if (this._defaultPass.renderTarget) {
          if (!this._canvasDepthPass) {
            this._canvasDepthPass = new RenderPass("CanvasDepthRenderPass", 0, null, null, 0);
            this._canvasDepthPass.clearMode = exports.ClearMode.DONT_CLEAR;
            this.addRenderPass(this._canvasDepthPass);
          }

          this._canvasDepthPass.enabled = true;
        }
      }

      for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
        this._drawRenderPass(this._renderPassArray[i], camera);
      }
    }
  }, {
    key: "_drawRenderPass",
    value: function _drawRenderPass(pass, camera) {
      pass.preRender(camera, this.opaqueQueue, this.transparentQueue);
      var rhi = camera.scene.engine._hardwareRenderer;
      var renderTarget = camera.renderTarget || pass.renderTarget;
      rhi.activeRenderTarget(renderTarget, camera); // keep require rendertarget in case of GC

      if (pass.enabled) {
        rhi.clearRenderTarget(pass.clearMode, pass.clearParam);

        if (pass.renderOverride) {
          pass.render(camera, this.opaqueQueue, this.transparentQueue);
        } else {
          this.opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);
          this.transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
        }
      }

      rhi.blitRenderTarget(renderTarget);
      pass.postRender(camera, this.opaqueQueue, this.transparentQueue);
    }
    /**
     * 将一个 Primitive 对象添加到渲染队列
     * @param {Component} component
     * @param {Primitive} primitive
     * @param {Material} mtl
     */

  }, {
    key: "pushPrimitive",
    value: function pushPrimitive(element) {
      if (element.material.renderType === exports.MaterialType.TRANSPARENT) {
        this._transparentQueue.pushPrimitive(element);
      } else {
        this._opaqueQueue.pushPrimitive(element);
      }
    }
    /**
     * 将一个 Sprite 绘制信息添加到渲染队列
     * @param {Component} component
     * @param {Object} positionQuad  Sprite四个顶点的位置
     * @param {Object} uvRect        Sprite在texture上的纹理坐标
     * @param {vec4}   tintColor     颜色
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */

  }, {
    key: "pushSprite",
    value: function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
      if (component.separateDraw) {
        if (!this._separateSpritePass) {
          this._separateSpritePass = new SeparateSpritePass();
          this.addRenderPass(this._separateSpritePass);
        }

        this._separateSpritePass.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);

        return;
      }

      this._transparentQueue.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);
    }
  }, {
    key: "defaultRenderPass",
    get: function get() {
      return this._defaultPass;
    }
  }, {
    key: "opaqueQueue",
    get: function get() {
      return this._opaqueQueue;
    }
    /**
     * 透明对象的渲染队列
     * @member {RenderQueue}
     * @readonly
     */

  }, {
    key: "transparentQueue",
    get: function get() {
      return this._transparentQueue;
    }
  }]);

  return BasicRenderPipeline;
}(SceneVisitor);

var _dec, _class$6, _class2$2, _descriptor$6, _descriptor2$5, _descriptor3$4, _descriptor4$4, _descriptor5$3, _descriptor6$2, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10$1, _descriptor11$1, _descriptor12$1, _temp$6;

//CM：这个类可能需要搬家
var MathTemp = function MathTemp() {
  _classCallCheck(this, MathTemp);
};
/**
 * 相机的清除标记。
 */


MathTemp.tempMat4 = new miniprogram.Matrix();
MathTemp.tempVec4 = new miniprogram.Vector4();
MathTemp.tempVec3 = new miniprogram.Vector3();
var ClearFlags;
/**
 * Camera 组件，作为渲染三位世界的入口。
 */

(function (ClearFlags) {
  ClearFlags[ClearFlags["DepthSky"] = 0] = "DepthSky";
  ClearFlags[ClearFlags["DepthColor"] = 1] = "DepthColor";
  ClearFlags[ClearFlags["Depth"] = 2] = "Depth";
  ClearFlags[ClearFlags["None"] = 3] = "None";
})(ClearFlags || (ClearFlags = {}));

var Camera = (_dec = dependencies(Transform), _dec(_class$6 = (_class2$2 = (_temp$6 = /*#__PURE__*/function (_Component) {
  _inherits(Camera, _Component);

  var _super = _createSuper(Camera);

  _createClass(Camera, [{
    key: "nearClipPlane",

    /** 渲染优先级，数字越大越先渲染。*/

    /**
     * 渲染遮罩。
     * @remarks 位操作，对应 Entity 的 layer。
     */

    /**
     * 近裁剪平面。
     */
    get: function get() {
      return this._nearClipPlane;
    },
    set: function set(value) {
      this._nearClipPlane = value;

      this._projMatChange();
    }
    /**
     * 远裁剪平面。
     */

  }, {
    key: "farClipPlane",
    get: function get() {
      return this._farClipPlane;
    },
    set: function set(value) {
      this._farClipPlane = value;

      this._projMatChange();
    }
    /**
     * 视场，单位是角度制，透视投影时生效。
     */

  }, {
    key: "fieldOfView",
    get: function get() {
      return this._fieldOfView;
    },
    set: function set(value) {
      this._fieldOfView = value;

      this._projMatChange();
    }
    /**
     * 横纵比，默认由视口的宽高比自动计算，如果手动设置会保持手动值，调用resetAspectRatio()可恢复。
     */

  }, {
    key: "aspectRatio",
    get: function get() {
      var _this$_customAspectRa;

      var canvas = this._entity.engine.canvas;
      return (_this$_customAspectRa = this._customAspectRatio) !== null && _this$_customAspectRa !== void 0 ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
    },
    set: function set(value) {
      this._customAspectRatio = value;

      this._projMatChange();
    }
    /**
     * 视口，归一化表达，左上角为（0，0），右下角为（1，1）。
     * @remarks 修改后需要重新赋值,保证修改生效。
     */

  }, {
    key: "viewport",
    get: function get() {
      return this._viewport;
    },
    set: function set(value) {
      if (value !== this._viewport) {
        value.cloneTo(this._viewport);
      }

      this._projMatChange();
    }
    /**
     * 是否正交，默认是 false。true 会使用正交投影，false 使用透视投影。
     */

  }, {
    key: "isOrthographic",
    get: function get() {
      return this._isOrthographic;
    },
    set: function set(value) {
      this._isOrthographic = value;

      this._projMatChange();
    }
    /**
     * 正交模式下相机的一半尺寸。
     */

  }, {
    key: "orthographicSize",
    get: function get() {
      return this._orthographicSize;
    },
    set: function set(value) {
      this._orthographicSize = value;

      this._projMatChange();
    }
    /**
     * 背景清除标记。
     */

  }, {
    key: "clearFlags",
    get: function get() {
      throw "not implemented";
    }
    /**
     * @todo 天空盒重构
     */
    ,
    set: function set(value) {
      throw "not implemented";
    }
    /**
     * 清除视口的背景颜色，当 clearFlags 为 DepthColor 时生效。
     */

  }, {
    key: "backgroundColor",
    get: function get() {
      return this._backgroundColor;
    },
    set: function set(value) {
      this.setClearMode(this._clearMode, value);
    }
    /**
     * 清除视口的背景天空，当 clearFlags 为 DepthSky 时生效。
     * @todo 渲染管线修改
     */

  }, {
    key: "backgroundSky",
    get: function get() {
      throw new Error("接口未实现");
    }
    /**
     * 视图矩阵。
     */

  }, {
    key: "viewMatrix",
    get: function get() {
      //CM:相机的视图矩阵一般会移除缩放,避免在shader运算出一些奇怪的问题
      if (this._isViewMatrixDirty.flag) {
        this._isViewMatrixDirty.flag = false;
        miniprogram.Matrix.invert(this._transform.worldMatrix, this._viewMatrix);
      }

      return this._viewMatrix;
    }
    /**
     * 投影矩阵,默认由相机的相关参数计算计算，如果手动设置会保持手动值，调用resetProjectionMatrix()可恢复。
     */

  }, {
    key: "projectionMatrix",
    set: function set(value) {
      this._projectionMatrix = value;
      this._isProjMatSetting = true;

      this._projMatChange();
    },
    get: function get() {
      var canvas = this._entity.engine.canvas;

      if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
        return this._projectionMatrix;
      }

      this._isProjectionDirty = false;
      this._lastAspectSize.x = canvas.width;
      this._lastAspectSize.y = canvas.height;
      var aspectRatio = this.aspectRatio;

      if (!this._isOrthographic) {
        miniprogram.Matrix.perspective(miniprogram.MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      } else {
        var width = this._orthographicSize * aspectRatio;
        var height = this._orthographicSize;
        miniprogram.Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      }

      return this._projectionMatrix;
    }
    /**
     * 是否开启HDR。
     * @todo 渲染管线修改
     */

  }, {
    key: "enableHDR",
    get: function get() {
      console.log("not implemention");
      return false;
    },
    set: function set(value) {
      console.log("not implemention");
    }
    /**
     * 渲染目标，设置后会渲染到渲染目标上，如果为空则渲染到主画布。
     */

  }, {
    key: "renderTarget",
    get: function get() {
      return this._renderTarget;
    },
    set: function set(value) {
      this._renderTarget = value;
    }
    /**
     * 创建 Camera 组件。
     * @param entity 实体
     */

  }]);

  function Camera(entity) {
    var _this;

    _classCallCheck(this, Camera);

    _this = _super.call(this, entity);
    _this.priority = 0;
    _this.cullingMask = exports.Layer.Everything;
    _this._isOrthographic = false;
    _this._isProjMatSetting = false;
    _this._clearMode = exports.ClearMode.SOLID_COLOR;
    _this._nearClipPlane = 0.1;
    _this._farClipPlane = 100;
    _this._fieldOfView = 45;
    _this._orthographicSize = 10;
    _this._isProjectionDirty = true;
    _this._isInvProjMatDirty = true;
    _this._customAspectRatio = undefined;
    _this._renderTarget = null;

    _initializerDefineProperty(_this, "_renderPipeline", _descriptor$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_transform", _descriptor2$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isViewMatrixDirty", _descriptor3$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_isInvViewProjDirty", _descriptor4$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_projectionMatrix", _descriptor5$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_viewMatrix", _descriptor6$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_backgroundColor", _descriptor7$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_viewport", _descriptor8$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_inverseProjectionMatrix", _descriptor9$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_inverseViewMatrix", _descriptor10$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_lastAspectSize", _descriptor11$1, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_invViewProjMat", _descriptor12$1, _assertThisInitialized(_this));

    _this._transform = _this.entity.transform;
    _this._isViewMatrixDirty = _this._transform.registerWorldChangeFlag();
    _this._isInvViewProjDirty = _this._transform.registerWorldChangeFlag();
    _this._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this)); // 默认设置

    _this.setClearMode();

    return _this;
  }
  /**
   * 恢复通过 fieldOfView、nearClipPlane 和 farClipPlane 自动计算投影矩阵。
   */


  _createClass(Camera, [{
    key: "resetProjectionMatrix",
    value: function resetProjectionMatrix() {
      this._isProjMatSetting = false;

      this._projMatChange();
    }
    /**
     * 恢复通过视口宽高比自动计算横纵比。
     */

  }, {
    key: "resetAspectRatio",
    value: function resetAspectRatio() {
      this._customAspectRatio = undefined;

      this._projMatChange();
    }
    /**
     * 将一个点从世界空间变换到视口空间。
     * @param point - 世界空间中的点
     * @param out - 视口空间的点，X 和 Y 为视口空间坐标，Z 为视口深度，近裁剪面为 0，远裁剪面为 1，W 为距离相机的世界单位距离
     * @returns 视口空间的点
     */

  }, {
    key: "worldToViewportPoint",
    value: function worldToViewportPoint(point, out) {
      miniprogram.Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);
      MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1.0);
      miniprogram.Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);
      var w = MathTemp.tempVec4.w;
      var nx = MathTemp.tempVec4.x / w;
      var ny = MathTemp.tempVec4.y / w;
      var nz = MathTemp.tempVec4.z / w; // 坐标轴转换

      out.x = (nx + 1.0) * 0.5;
      out.y = (1.0 - ny) * 0.5;
      out.z = nz;
      out.w = w;
      return out;
    }
    /**
     * 将一个点从视口空间变换到世界空间。
     * @param point - X 和 Y 为视口空间坐标，Z 为视口深度，近裁剪面为 0，远裁剪面为 1
     * @param out - 世界空间中的点
     * @returns 世界空间中的点
     */

  }, {
    key: "viewportToWorldPoint",
    value: function viewportToWorldPoint(point, out) {
      var invViewProjMat = this.invViewProjMat;
      return this._innerViewportToWorldPoint(point, invViewProjMat, out);
    }
    /**
     * 通过视口空间点的点获取射线，生成射线的起点在相机的近裁面并穿过点的 X 和 Y 坐标。
     * @param point 视口空间中的点
     * @param out - 射线
     * @returns 射线
     */

  }, {
    key: "viewportPointToRay",
    value: function viewportPointToRay(point, out) {
      var clipPoint = MathTemp.tempVec3; // 使用近裁面的交点作为 origin

      clipPoint.setValue(point.x, point.y, 0);
      var origin = this.viewportToWorldPoint(clipPoint, out.origin); // 使用远裁面的交点作为 origin

      clipPoint.z = 1.0;

      var farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);

      miniprogram.Vector3.subtract(farPoint, origin, out.direction);
      out.direction.normalize();
      return out;
    }
    /**
     * 将一个点的X和Y坐标从屏幕空间变换到视口空间
     * @param point - 屏幕空间点
     * @param out - 视口空间点
     * @returns 射线
     */

  }, {
    key: "screenToViewportPoint",
    value: function screenToViewportPoint(point, out) {
      var canvas = this.engine.canvas;
      var viewport = this.viewport;
      out.x = (point.x / canvas.width - viewport.x) / viewport.z;
      out.y = (point.y / canvas.height - viewport.y) / viewport.w;
      return out;
    }
    /**
     * 将一个点的X和Y坐标从视口空间变换到屏幕空间。
     * @param point - 视口空间的点
     * @param out - 屏幕空间的点
     * @returns 射线
     */

  }, {
    key: "viewportToScreenPoint",
    value: function viewportToScreenPoint(point, out) {
      var canvas = this.engine.canvas;
      var viewport = this.viewport;
      out.x = (viewport.x + point.x * viewport.z) * canvas.width;
      out.y = (viewport.y + point.y * viewport.w) * canvas.height;
      return out;
    }
    /**
     * 将一个点从世界空间变换到屏幕空间。
     * @param point - 世界空间中的点
     * @param out - 屏幕空间的点
     * @returns 屏幕空间的点
     */

  }, {
    key: "worldToScreenPoint",
    value: function worldToScreenPoint(point, out) {
      this.worldToViewportPoint(point, out);
      return this.viewportToScreenPoint(out, out);
    }
    /**
     * 将一个点从屏幕空间变换到世界空间。
     * @param point - 屏幕空间点
     * @param out - 世界空间中的点
     * @returns 世界空间中的点
     */

  }, {
    key: "screenToWorldPoint",
    value: function screenToWorldPoint(point, out) {
      this.screenToViewportPoint(point, out);
      return this.viewportToWorldPoint(out, out);
    }
    /**
     * 手动调用相机的渲染。
     * @param cubeFaces - 立方体的渲染面集合,如果设置了renderTarget并且renderTarget.isCube=true时生效
     */

  }, {
    key: "render",
    value: function render(cubeFaces) {
      this._renderPipeline.render();
    }
    /**
     * @override
     * @inheritdoc
     */

  }, {
    key: "_onActive",
    value: function _onActive() {
      this.entity.scene.attachRenderCamera(this);
    }
    /**
     * @override
     * @inheritdoc
     */

  }, {
    key: "_onInActive",
    value: function _onInActive() {
      this.entity.scene.detachRenderCamera(this);
    }
    /**
     * @override
     * @inheritdoc
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {
      var _this$_renderPipeline;

      (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();

      this._isInvViewProjDirty.destroy();

      this._isViewMatrixDirty.destroy();
    }
  }, {
    key: "_projMatChange",
    value: function _projMatChange() {
      this._isProjectionDirty = true;
      this._isInvProjMatDirty = true;
      this._isInvViewProjDirty.flag = true;
    }
  }, {
    key: "_innerViewportToWorldPoint",
    value: function _innerViewportToWorldPoint(point, invViewProjMat, out) {
      // depth 是归一化的深度，0 是 nearPlane，1 是 farClipPlane
      var depth = point.z * 2 - 1; // 变换到裁剪空间矩阵

      var clipPoint = MathTemp.tempVec4;
      clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);
      miniprogram.Vector4.transform(clipPoint, invViewProjMat, clipPoint);
      var invW = 1.0 / clipPoint.w;
      out.x = clipPoint.x * invW;
      out.y = clipPoint.y * invW;
      out.z = clipPoint.z * invW;
      return out;
    }
    /**
     * @private
     * 视图投影矩阵逆矩阵
     */

  }, {
    key: "setClearMode",

    /**
     * @deprecated
     * @todo 涉及渲染管线修改 rhi.clearRenderTarget 方法
     * @param clearMode
     * @param backgroundColor
     */
    value: function setClearMode() {
      var clearMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.ClearMode.SOLID_COLOR;
      var backgroundColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new miniprogram.Vector4(0.25, 0.25, 0.25, 1);
      this._clearMode = clearMode;
      this._backgroundColor = backgroundColor;
      this._renderPipeline.defaultRenderPass.clearParam = backgroundColor;
      this._renderPipeline.defaultRenderPass.clearMode = clearMode;
    }
  }, {
    key: "invViewProjMat",
    get: function get() {
      if (this._isInvViewProjDirty.flag) {
        this._isInvViewProjDirty.flag = false;
        miniprogram.Matrix.multiply(this.inverseViewMatrix, this.inverseProjectionMatrix, this._invViewProjMat);
      }

      return this._invViewProjMat;
    }
    /**
     * @private
     * 投影矩阵逆矩阵。
     */

  }, {
    key: "inverseProjectionMatrix",
    get: function get() {
      if (this._isInvProjMatDirty) {
        this._isInvProjMatDirty = false;
        miniprogram.Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
      }

      return this._inverseProjectionMatrix;
    } //-------------------------------------------------deprecated---------------------------------------------------

    /**
     * @deprecated
     * 视图矩阵逆矩阵。
     */

  }, {
    key: "inverseViewMatrix",
    get: function get() {
      this._transform.worldMatrix.cloneTo(this._inverseViewMatrix);

      return this._inverseViewMatrix;
    }
  }]);

  return Camera;
}(Component), _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$2.prototype, "_renderPipeline", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$5 = _applyDecoratedDescriptor(_class2$2.prototype, "_transform", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$4 = _applyDecoratedDescriptor(_class2$2.prototype, "_isViewMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$4 = _applyDecoratedDescriptor(_class2$2.prototype, "_isInvViewProjDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$3 = _applyDecoratedDescriptor(_class2$2.prototype, "_projectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
}), _descriptor6$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_viewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_backgroundColor", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector4();
  }
}), _descriptor8$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_viewport", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector4(0, 0, 1, 1);
  }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_inverseProjectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_inverseViewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_lastAspectSize", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Vector2(0, 0);
  }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_invViewProjMat", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return new miniprogram.Matrix();
  }
})), _class2$2)) || _class$6);

var mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
var defaultRetryCount = 4;
var defaultTimeout = 15000;
var defaultInterval = 500;

/**
 * web端 请求
 * @param url 链接
 * @param config 加载配置
 */
function request(url) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new AssetPromise(function (resolve, reject, setProgress) {
    var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;

    var retryCount = (_config$retryCount = config.retryCount) !== null && _config$retryCount !== void 0 ? _config$retryCount : defaultRetryCount;
    var retryInterval = (_config$retryInterval = config.retryInterval) !== null && _config$retryInterval !== void 0 ? _config$retryInterval : defaultInterval;
    config.timeout = (_config$timeout = config.timeout) !== null && _config$timeout !== void 0 ? _config$timeout : defaultTimeout;
    config.type = (_config$type = config.type) !== null && _config$type !== void 0 ? _config$type : getMimeTypeFromUrl(url);
    var realRequest = config.type === "image" ? requestImage : requestRes;
    var lastError;
    var executor = new MultiExecutor(function () {
      return realRequest(url, config).onProgress(setProgress).then(function (res) {
        resolve(res);
        executor.stop();
      })["catch"](function (err) {
        return lastError = err;
      });
    }, retryCount, retryInterval);
    executor.start(function () {
      reject(lastError);
    });
  });
}

function requestImage(url, config) {
  return new AssetPromise(function (resolve, reject) {
    var timeout = config.timeout;
    var img = new miniprogramAdapter.Image();

    var onerror = function onerror() {
      reject(new Error("request ".concat(url, " fail")));
    };

    img.onerror = onerror;
    img.onabort = onerror;
    var timeoutId = setTimeout(function () {
      reject(new Error("request ".concat(url, " timeout")));
    }, timeout);

    img.onload = function (timeoutId) {
      return function () {
        // Call requestAnimationFrame to avoid iOS's bug.
        miniprogramAdapter.requestAnimationFrame(function () {
          //@ts-ignore
          resolve(img);
        });
        clearTimeout(timeoutId);
      };
    }(timeoutId);

    img.crossOrigin = "anonymous";
    img.src = url;
  });
}

function requestRes(url, config) {
  return new AssetPromise(function (resolve, reject, setProgress) {
    var _config$method;

    var xhr = new miniprogramAdapter.XMLHttpRequest();
    xhr.timeout = config.timeout;
    config.method = (_config$method = config.method) !== null && _config$method !== void 0 ? _config$method : "get";

    xhr.onload = function () {
      var _xhr$response;

      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error("request failed from: ".concat(url)));
        return;
      }

      var result = (_xhr$response = xhr.response) !== null && _xhr$response !== void 0 ? _xhr$response : xhr.responseText;
      resolve(result);
    };

    xhr.onerror = function () {
      reject(new Error("request failed from: ".concat(url)));
    };

    xhr.ontimeout = function () {
      reject(new Error("request timeout from: ".concat(url)));
    };

    xhr.onprogress = function (e) {
      setProgress(e.loaded / e.total);
    };

    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include"; //@ts-ignore

    xhr.responseType = config.type;
    var headers = config.headers;

    if (headers) {
      Object.keys(headers).forEach(function (name) {
        xhr.setRequestHeader(name, headers[name]);
      });
    }

    xhr.send(config.body);
  });
}

function getMimeTypeFromUrl(url) {
  var extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}

var MultiExecutor = /*#__PURE__*/function () {
  function MultiExecutor(execFunc, totalCount, interval) {
    _classCallCheck(this, MultiExecutor);

    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.done = void 0;
    this.exec = this.exec.bind(this);
  }

  _createClass(MultiExecutor, [{
    key: "start",
    value: function start(done) {
      this.done = done;
      this.exec();
    }
  }, {
    key: "stop",
    value: function stop() {
      clearTimeout(this._timeoutId);
    }
  }, {
    key: "exec",
    value: function exec() {
      var _this = this;

      if (this._currentCount >= this.totalCount) {
        this.done && this.done();
        return;
      }

      this._currentCount++;
      this.execFunc(this._currentCount).then(function () {
        //@ts-ignore
        _this._timeoutId = setTimeout(_this.exec, _this.interval);
      });
    }
  }]);

  return MultiExecutor;
}();

/**
 * loader 抽象类。
 */
var Loader = function Loader(useCache) {
  _classCallCheck(this, Loader);

  this.useCache = useCache;
  this.request = request;
};

/**
 * 资产类型。
 */

(function (AssetType) {
  AssetType[AssetType["Text"] = 0] = "Text";
  AssetType[AssetType["JSON"] = 1] = "JSON";
  AssetType[AssetType["Buffer"] = 2] = "Buffer";
  AssetType[AssetType["Texture2D"] = 3] = "Texture2D";
  AssetType[AssetType["TextureCube"] = 4] = "TextureCube";
  AssetType[AssetType["Material"] = 5] = "Material";
  AssetType[AssetType["Mesh"] = 6] = "Mesh";
  AssetType[AssetType["AnimationClip"] = 7] = "AnimationClip";
  AssetType[AssetType["Perfab"] = 8] = "Perfab";
  AssetType[AssetType["KTX"] = 9] = "KTX";
  AssetType[AssetType["KTXCube"] = 10] = "KTXCube";
})(exports.AssetType || (exports.AssetType = {}));

/**
 * 资产的基类，具有引用计数能力。
 */
var RefObject = /*#__PURE__*/function (_EngineObject) {
  _inherits(RefObject, _EngineObject);

  var _super = _createSuper(RefObject);

  _createClass(RefObject, [{
    key: "refCount",

    /** 是否忽略垃圾回收的检查,如果为 true 则不受 ResourceManager.gc() 影响。*/

    /**
     * 被有效引用计数。
     */
    get: function get() {
      return this._refCount;
    }
    /**
     * 是否已销毁。
     */

  }, {
    key: "destroyed",
    get: function get() {
      return this._destroyed;
    }
  }]);

  function RefObject(engine) {
    var _this;

    _classCallCheck(this, RefObject);

    _this = _super.call(this, engine);
    _this.isGCIgnored = false;
    _this._refCount = 0;
    _this._refChildren = [];
    _this._refParent = null;
    _this._destroyed = false;

    engine.resourceManager._addRefObject(_this.instanceId, _assertThisInitialized(_this));

    return _this;
  }
  /**
   * 销毁。
   * @param force - 是否强制销毁,如果为 fasle 则 refCount = 0 可释放成功
   * @returns 是否释放成功
   */


  _createClass(RefObject, [{
    key: "destroy",
    value: function destroy() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (this._destroyed) return true;
      if (!force && this._refCount !== 0) return false;
      var resourceManager = this._engine.resourceManager; // resourceManager maybe null,because engine has destroyed.
      // TODO:the right way to fix this is to ensure destroy all when call engine.destroy,thus don't need to add this project.

      if (resourceManager) {
        resourceManager._deleteAsset(this);

        resourceManager._deleteRefObject(this.instanceId);
      }

      if (this._refParent) {
        removeFromArray(this._refParent._refChildren, this);
      }

      this._engine = null;

      this._onDestroy();

      this._destroyed = true;
      return true;
    }
    /**
     * @internal
     * 把当前资源添加到资源管理中。
     */

  }, {
    key: "_addToResourceManager",
    value: function _addToResourceManager(path) {
      this._engine.resourceManager._addAsset(path, this);
    }
    /**
     * @internal
     * 添加资源引用数
     */

  }, {
    key: "_addRefCount",
    value: function _addRefCount(refCount) {
      this._refCount += refCount;
      var refChildren = this._refChildren;

      var _iterator = _createForOfIteratorHelper(refChildren),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;

          item._addRefCount(refCount);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * @internal
     * 添加引用资源。
     */

  }, {
    key: "_addRefChild",
    value: function _addRefChild(obj) {
      this._refChildren.push(obj);

      obj._refParent = this;

      obj._addRefCount(this._refCount);
    }
    /**
     * @internal
     * 移出引用资源。
     */

  }, {
    key: "_removeRefChild",
    value: function _removeRefChild(obj) {
      var refChildren = this._refChildren;

      if (removeFromArray(refChildren, obj)) {
        obj._refParent = null;

        obj._addRefCount(-this._refCount);
      }
    }
    /**
     * 当资源销毁时调用。
     * 子类可重写该函数。
     */

  }]);

  return RefObject;
}(EngineObject);

var _tempVec3 = new miniprogram.Vector3(0, 1, 0);
/**
 * 灯光基类
 */


var Light = /*#__PURE__*/function (_Component) {
  _inherits(Light, _Component);

  var _super = _createSuper(Light);

  _createClass(Light, null, [{
    key: "getUniformDefine",

    /**
     * 生成 Technique 所需的 uniform 定义
     * @example
     * const name = `u_pointLights[0]`;
     * const lgtUniforms = APointLight.getUniformDefine(name)
     * @param {string} uniformName
     */
    value: function getUniformDefine(uniformName) {
      return {};
    }
    /**
     * @param {Entity} entity 节点对象
     */

  }]);

  function Light(entity) {
    var _this;

    _classCallCheck(this, Light);

    _this = _super.call(this, entity);
    _this._viewMat = void 0;
    _this._modelMat = void 0;
    entity.addEventListener("removedFromScene", _this._onDisable.bind(_assertThisInitialized(_this)));
    return _this;
  }
  /** 在对象Enable的时候，挂载到当前的Scene
   * @private
   */


  _createClass(Light, [{
    key: "_onEnable",
    value: function _onEnable() {
      this.scene.findFeature(LightFeature).attachRenderLight(this);
    }
    /** 在对象Disable的时候，从当前的Scene移除
     * @private
     */

  }, {
    key: "_onDisable",
    value: function _onDisable() {
      this.scene.findFeature(LightFeature).detachRenderLight(this);
    }
    /**
     * View 矩阵
     * @member {Matrix}
     * @readonly
     */

  }, {
    key: "viewMatrix",
    get: function get() {
      if (!this._viewMat) this._viewMat = new miniprogram.Matrix();
      miniprogram.Matrix.invert(this.inverseViewMatrix, this._viewMat);
      return this._viewMat;
    }
    /**
     * View 矩阵的逆矩阵
     * @member {Matrix}
     * @readonly
     */

  }, {
    key: "inverseViewMatrix",
    get: function get() {
      if (!this._modelMat) this._modelMat = new miniprogram.Matrix();
      miniprogram.Matrix.rotateAxisAngle(this.entity.transform.worldMatrix, _tempVec3, Math.PI, this._modelMat);
      return this._modelMat;
    }
  }]);

  return Light;
}(Component);

/**
 * 环境光创建类
 */

var AmbientLight = /*#__PURE__*/function (_Light) {
  _inherits(AmbientLight, _Light);

  var _super = _createSuper(AmbientLight);

  _createClass(AmbientLight, null, [{
    key: "getUniformDefine",

    /**
     * 生成 Technique 所需的 uniform 定义
     * @param {string} uniformName
     */
    value: function getUniformDefine(uniformName) {
      var _ref;

      return _ref = {}, _defineProperty(_ref, uniformName + ".color", {
        name: uniformName + ".color",
        type: exports.DataType.FLOAT_VEC3
      }), _defineProperty(_ref, uniformName + ".lightColor", {
        name: uniformName + ".lightColor",
        type: exports.DataType.FLOAT_VEC3
      }), _defineProperty(_ref, uniformName + ".intensity", {
        name: uniformName + ".intensity",
        type: exports.DataType.FLOAT
      }), _ref;
    }
    /**
     * @param {Entity} entity 节点对象
     */

  }]);

  function AmbientLight(entity) {
    var _this;

    _classCallCheck(this, AmbientLight);

    _this = _super.call(this, entity);
    _this._lightColor = void 0;
    _this.color = void 0;
    _this.intensity = void 0;
    _this.color = new miniprogram.Vector3(1, 1, 1);
    _this.intensity = 1.0;
    _this._lightColor = new miniprogram.Vector3();
    return _this;
  }
  /** 获取环境光最终颜色
   * @return {Vector3} 颜色
   * @readonly
   */


  _createClass(AmbientLight, [{
    key: "bindMaterialValues",

    /**
     * 将灯光参数值提交到材质对象
     */
    value: function bindMaterialValues(mtl, uniformName) {
      mtl.setValue(uniformName + ".color", this.color);
      mtl.setValue(uniformName + ".lightColor", this.lightColor);
      mtl.setValue(uniformName + ".intensity", this.intensity);
    }
  }, {
    key: "lightColor",
    get: function get() {
      miniprogram.Vector3.scale(this.color, this.intensity, this._lightColor);
      return this._lightColor;
    }
  }]);

  return AmbientLight;
}(Light);

/**
 * 方向光创建类
 */

var DirectLight = /*#__PURE__*/function (_Light) {
  _inherits(DirectLight, _Light);

  var _super = _createSuper(DirectLight);

  /**
   * @param {Entity} entity 节点对象
   */
  function DirectLight(entity) {
    var _this;

    _classCallCheck(this, DirectLight);

    _this = _super.call(this, entity);
    _this._forward = new miniprogram.Vector3();
    _this._lightColor = void 0;
    _this._reverseDirection = void 0;
    _this.color = void 0;
    _this.intensity = void 0;
    _this.color = new miniprogram.Vector3(1, 1, 1);
    _this.intensity = 1.0;
    _this._lightColor = new miniprogram.Vector3();
    _this._reverseDirection = new miniprogram.Vector3();
    return _this;
  }
  /** 获取方向光方向
   * @return {Vector3} 方向向量
   * @readonly
   */


  _createClass(DirectLight, [{
    key: "bindMaterialValues",

    /**
     * 将灯光参数值提交到材质对象
     */
    value: function bindMaterialValues(mtl, uniformName) {
      mtl.setValue(uniformName + ".color", this.color);
      mtl.setValue(uniformName + ".lightColor", this.lightColor);
      mtl.setValue(uniformName + ".intensity", this.intensity);
      mtl.setValue(uniformName + ".direction", this.direction);
    }
  }, {
    key: "direction",
    get: function get() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
    /** 获取方向光最终颜色
     * @return {Vector3} 颜色
     * @readonly
     */

  }, {
    key: "lightColor",
    get: function get() {
      miniprogram.Vector3.scale(this.color, this.intensity, this._lightColor);
      return this._lightColor;
    }
    /** 方向光方向的反方向
     * @return {Vector3} 方向向量
     * @readonly
     */

  }, {
    key: "reverseDirection",
    get: function get() {
      miniprogram.Vector3.scale(this.direction, -1, this._reverseDirection);
      return this._reverseDirection;
    }
    /**
     * 生成 Technique 所需的 uniform 定义
     * @param {string} uniformName
     */

  }], [{
    key: "getUniformDefine",
    value: function getUniformDefine(uniformName) {
      /**
       *   struct DirectLight {
       *    vec3 color;
       *    float intensity;
       *    vec3 direction;
       *    };
       */
      var uniforms = {};
      uniforms[uniformName + ".color"] = {
        name: uniformName + ".color",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".lightColor"] = {
        name: uniformName + ".lightColor",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".intensity"] = {
        name: uniformName + ".intensity",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".direction"] = {
        name: uniformName + ".direction",
        type: exports.DataType.FLOAT_VEC3
      };
      return uniforms;
    }
  }]);

  return DirectLight;
}(Light);

var cacheMat3 = new miniprogram.Matrix3x3();
/**
 * 环境光源
 */

var EnvironmentMapLight = /*#__PURE__*/function (_Light) {
  _inherits(EnvironmentMapLight, _Light);

  var _super = _createSuper(EnvironmentMapLight);

  _createClass(EnvironmentMapLight, null, [{
    key: "getUniformDefine",

    /**
     * 生成 Technique 所需的 uniform 定义
     * @param {string} uniformName
     */
    value: function getUniformDefine(uniformName) {
      var uniforms = {};
      uniforms["u_env_diffuseSampler"] = {
        name: "u_env_diffuseSampler",
        type: exports.DataType.SAMPLER_CUBE
      };
      uniforms["u_env_specularSampler"] = {
        name: "u_env_specularSampler",
        type: exports.DataType.SAMPLER_CUBE
      };
      uniforms[uniformName + ".diffuse"] = {
        name: uniformName + ".diffuse",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".specular"] = {
        name: uniformName + ".specular",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".mipMapLevel"] = {
        name: uniformName + ".mipMapLevel",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".transformMatrix"] = {
        name: uniformName + ".transformMatrix",
        type: exports.DataType.FLOAT_MAT3
      };
      uniforms[uniformName + ".diffuseIntensity"] = {
        name: uniformName + ".diffuseIntensity",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".specularIntensity"] = {
        name: uniformName + ".specularIntensity",
        type: exports.DataType.FLOAT
      };
      return uniforms;
    }
    /**
     * 环境光源
     * @param {Entity} entity 节点对象
     */

  }]);

  function EnvironmentMapLight(entity) {
    var _this;

    _classCallCheck(this, EnvironmentMapLight);

    _this = _super.call(this, entity);
    _this.diffuseMap = void 0;
    _this.specularMap = void 0;
    _this.diffuse = void 0;
    _this.specular = void 0;
    _this.diffuseIntensity = void 0;
    _this.specularIntensity = void 0;
    _this.diffuse = new miniprogram.Vector3(0.3, 0.3, 0.3);
    _this.specular = new miniprogram.Vector3(0.5, 0.5, 0.5);
    _this.diffuseIntensity = 1;
    _this.specularIntensity = 1;
    return _this;
  }
  /**
   * 是否使用diffuse贴图
   * @private
   * @returns {Boolean}
   */


  _createClass(EnvironmentMapLight, [{
    key: "bindMaterialValues",

    /**
     * 将灯光参数绑定到指定的材质对象上
     */
    value: function bindMaterialValues(mtl, uniformName) {
      mtl.setValue(uniformName + ".diffuseIntensity", this.diffuseIntensity);
      mtl.setValue(uniformName + ".specularIntensity", this.specularIntensity);

      if (this.useDiffuseMap) {
        mtl.setValue("u_env_diffuseSampler", this.diffuseMap);
      } else {
        mtl.setValue(uniformName + ".diffuse", this.diffuse);
      }

      if (this.useSpecularMap) {
        mtl.setValue("u_env_specularSampler", this.specularMap);
        mtl.setValue(uniformName + ".mipMapLevel", this.specularMap.mipmapCount);
      } else {
        mtl.setValue(uniformName + ".specular", this.specular);
      } // 支持旋转


      var transformMatrix = this.entity.transform.worldMatrix;
      cacheMat3.setValueByMatrix(transformMatrix);
      mtl.setValue(uniformName + ".transformMatrix", cacheMat3);
    }
  }, {
    key: "useDiffuseMap",
    get: function get() {
      return !!this.diffuseMap;
    }
    /**
     * 是否使用Specular贴图
     * @private
     * @returns {Boolean}
     */

  }, {
    key: "useSpecularMap",
    get: function get() {
      return !!this.specularMap;
    }
  }]);

  return EnvironmentMapLight;
}(Light);

/**
 * 点光源创建类
 * @extends Light
 */

var PointLight = /*#__PURE__*/function (_Light) {
  _inherits(PointLight, _Light);

  var _super = _createSuper(PointLight);

  function PointLight() {
    var _this;

    _classCallCheck(this, PointLight);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.color = new miniprogram.Vector3(1, 1, 1);
    _this.intensity = 1.0;
    _this.distance = 0;
    _this.decay = 0;
    _this._lightColor = new miniprogram.Vector3();
    return _this;
  }

  _createClass(PointLight, [{
    key: "bindMaterialValues",

    /**
     * 将灯光参数值提交到材质对象
     */
    value: function bindMaterialValues(mtl, uniformName) {
      mtl.setValue(uniformName + ".position", this.position);
      mtl.setValue(uniformName + ".color", this.color);
      mtl.setValue(uniformName + ".lightColor", this.lightColor);
      mtl.setValue(uniformName + ".intensity", this.intensity);
      mtl.setValue(uniformName + ".distance", this.distance);
      mtl.setValue(uniformName + ".decay", this.decay);
    }
  }, {
    key: "position",

    /** 获取点光源位置
     * @return {Vector3} 位置坐标
     * @readonly
     */
    get: function get() {
      return this.entity.worldPosition;
    }
    /** 获取点光源最终颜色
     * @return {Vector3} 光源最终颜色
     * @readonly
     */

  }, {
    key: "lightColor",
    get: function get() {
      miniprogram.Vector3.scale(this.color, this.intensity, this._lightColor);
      return this._lightColor;
    }
    /**
     * 生成 Technique 所需的 uniform 定义
     * @param {string} uniformName
     */

  }], [{
    key: "getUniformDefine",
    value: function getUniformDefine(uniformName) {
      /**
        struct PointLight {
          vec3 position;
          vec3 color;
          float intensity;
          float distance;
          float decay;
        };
       */
      var uniforms = {};
      uniforms[uniformName + ".position"] = {
        name: uniformName + ".position",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".color"] = {
        name: uniformName + ".color",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".lightColor"] = {
        name: uniformName + ".lightColor",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".intensity"] = {
        name: uniformName + ".intensity",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".distance"] = {
        name: uniformName + ".distance",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".decay"] = {
        name: uniformName + ".decay",
        type: exports.DataType.FLOAT
      };
      return uniforms;
    }
  }]);

  return PointLight;
}(Light);

/**
 * 聚光灯创建类
 * @extends Light
 */

var SpotLight = /*#__PURE__*/function (_Light) {
  _inherits(SpotLight, _Light);

  var _super = _createSuper(SpotLight);

  /**
   * @constructor
   * @param {Entity} entity 节点对象
   */
  function SpotLight(entity) {
    var _this;

    _classCallCheck(this, SpotLight);

    _this = _super.call(this, entity);
    _this._forward = new miniprogram.Vector3();
    _this._lightColor = void 0;
    _this._inverseDirection = void 0;
    _this.color = new miniprogram.Vector3(1, 1, 1);
    _this.penumbra = 0;
    _this.distance = 0;
    _this.intensity = 1.0;
    _this.decay = 0;
    _this.angle = Math.PI / 6;
    _this._lightColor = new miniprogram.Vector3();
    _this._inverseDirection = new miniprogram.Vector3();
    return _this;
  }
  /** 获取聚光灯位置
   * @return {Vector3} 位置坐标
   * @readonly
   */


  _createClass(SpotLight, [{
    key: "bindMaterialValues",

    /**
     * 将灯光参数值提交到材质对象
     */
    value: function bindMaterialValues(mtl, uniformName) {
      mtl.setValue(uniformName + ".position", this.position);
      mtl.setValue(uniformName + ".direction", this.direction);
      mtl.setValue(uniformName + ".color", this.color);
      mtl.setValue(uniformName + ".lightColor", this.lightColor);
      mtl.setValue(uniformName + ".intensity", this.intensity);
      mtl.setValue(uniformName + ".distance", this.distance);
      mtl.setValue(uniformName + ".decay", this.decay);
      mtl.setValue(uniformName + ".angle", this.angle);
      mtl.setValue(uniformName + ".penumbra", this.penumbra);
      mtl.setValue(uniformName + ".coneCos", Math.cos(this.angle));
      mtl.setValue(uniformName + ".penumbraCos", Math.cos(this.angle * (1 - this.penumbra)));
    }
  }, {
    key: "position",
    get: function get() {
      return this.entity.worldPosition;
    }
    /** 获取聚光灯方向
     * @return {Vector3} 方向向量
     * @readonly
     */

  }, {
    key: "direction",
    get: function get() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
    /** 获取聚光灯方向的反方向
     * @return {Vector3} 方向向量
     * @readonly
     */

  }, {
    key: "reverseDirection",
    get: function get() {
      miniprogram.Vector3.scale(this.direction, -1, this._inverseDirection);
      return this._inverseDirection;
    }
    /** 最终光照颜色
     * @return {Vector3} 最终光照颜色
     * @readonly
     */

  }, {
    key: "lightColor",
    get: function get() {
      miniprogram.Vector3.scale(this.color, this.intensity, this._lightColor);
      return this._lightColor;
    }
    /**
     * 生成 Technique 所需的 uniform 定义
     * @param {string} uniformName
     */

  }], [{
    key: "getUniformDefine",
    value: function getUniformDefine(uniformName) {
      /**
        struct SpotLight {
          vec3 position;
          vec3 direction;
          vec3 color;
          float intensity;
          float distance;
          float decay;
          float angle;
          float penumbra;
        };
       */
      var uniforms = {};
      uniforms[uniformName + ".position"] = {
        name: uniformName + ".position",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".direction"] = {
        name: uniformName + ".direction",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".color"] = {
        name: uniformName + ".color",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".lightColor"] = {
        name: uniformName + ".lightColor",
        type: exports.DataType.FLOAT_VEC3
      };
      uniforms[uniformName + ".intensity"] = {
        name: uniformName + ".intensity",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".distance"] = {
        name: uniformName + ".distance",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".decay"] = {
        name: uniformName + ".decay",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".angle"] = {
        name: uniformName + ".angle",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".penumbra"] = {
        name: uniformName + ".penumbra",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".coneCos"] = {
        name: uniformName + ".coneCos",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".penumbraCos"] = {
        name: uniformName + ".penumbraCos",
        type: exports.DataType.FLOAT
      };
      return uniforms;
    }
  }]);

  return SpotLight;
}(Light);

/**
 * 判断场景中是否有灯光
 * @returns {boolean}
 * @private
 */

function hasLight() {
  return this.findFeature(LightFeature).visibleLights.length > 0;
}
/**
 * Scene Feature：在场景中添加灯光特性
 * @extends SceneFeature
 * @private
 */

var LightFeature = /*#__PURE__*/function (_SceneFeature) {
  _inherits(LightFeature, _SceneFeature);

  var _super = _createSuper(LightFeature);

  _createClass(LightFeature, [{
    key: "lightSortAmount",

    /**
     * 获取光源种类的相应数量
     * */
    get: function get() {
      var ambientLightCount = 0;
      var directLightCount = 0;
      var pointLightCount = 0;
      var spotLightCount = 0;
      var envMapLightCount = 0;
      var useDiffuseEnv = false;
      var useSpecularEnv = false;
      var lights = this.visibleLights;

      for (var i = 0, len = lights.length; i < len; i++) {
        var light = lights[i];

        if (light instanceof AmbientLight) {
          ambientLightCount++;
        } else if (light instanceof DirectLight) {
          directLightCount++;
        } else if (light instanceof PointLight) {
          pointLightCount++;
        } else if (light instanceof SpotLight) {
          spotLightCount++;
        } else if (light instanceof EnvironmentMapLight) {
          envMapLightCount++;
          useDiffuseEnv = light.useDiffuseMap;
          useSpecularEnv = light.useSpecularMap;
        }
      }

      return {
        ambientLightCount: ambientLightCount,
        directLightCount: directLightCount,
        pointLightCount: pointLightCount,
        spotLightCount: spotLightCount,
        envMapLightCount: envMapLightCount,
        useDiffuseEnv: useDiffuseEnv,
        useSpecularEnv: useSpecularEnv
      };
    }
  }]);

  function LightFeature() {
    var _this;

    _classCallCheck(this, LightFeature);

    _this = _super.call(this);
    _this.visibleLights = void 0;
    _this.visibleLights = [];
    return _this;
  }
  /**
   * 向当前场景注册一个灯光对象
   * @param {Light} light 灯光对象
   * @private
   */


  _createClass(LightFeature, [{
    key: "attachRenderLight",
    value: function attachRenderLight(light) {
      var index = this.visibleLights.indexOf(light);

      if (index == -1) {
        this.visibleLights.push(light);
      } else {
        Logger.warn("Light already attached.");
      }
    }
    /**
     * 从当前场景移除一个灯光对象
     * @param {Light} light 灯光对象
     * @private
     */

  }, {
    key: "detachRenderLight",
    value: function detachRenderLight(light) {
      var index = this.visibleLights.indexOf(light);

      if (index != -1) {
        this.visibleLights.splice(index, 1);
      }
    }
    /**
     * 将灯光数据绑定到指定的材质中（指定 Uniform 的值）
     * @param {Material} mtl 材质对象
     * @private
     */

  }, {
    key: "bindMaterialValues",
    value: function bindMaterialValues(mtl) {
      var directLightCount = 0;
      var pointLightCount = 0;
      var spotLightCount = 0;
      var lights = this.visibleLights;

      for (var i = 0, len = lights.length; i < len; i++) {
        var light = lights[i];

        if (light instanceof AmbientLight) {
          light.bindMaterialValues(mtl, "u_ambientLight");
        } else if (light instanceof DirectLight) {
          light.bindMaterialValues(mtl, "u_directLights[".concat(directLightCount++, "]"));
        } else if (light instanceof PointLight) {
          light.bindMaterialValues(mtl, "u_pointLights[".concat(pointLightCount++, "]"));
        } else if (light instanceof SpotLight) {
          light.bindMaterialValues(mtl, "u_spotLights[".concat(spotLightCount++, "]"));
        } else if (light instanceof EnvironmentMapLight) {
          light.bindMaterialValues(mtl, "u_envMapLight");
        }
      }
    }
    /**
     * 生成 Technique 所需的全部 uniform 定义
     */

  }, {
    key: "getUniformDefine",
    value: function getUniformDefine() {
      var uniforms = {};
      var ambientLightCount = 0;
      var directLightCount = 0;
      var pointLightCount = 0;
      var spotLightCount = 0;
      var envMapLightCount = 0;
      var lights = this.visibleLights;

      for (var i = 0, len = lights.length; i < len; i++) {
        var light = lights[i];

        if (light instanceof AmbientLight && !ambientLightCount++) {
          uniforms = _objectSpread2(_objectSpread2({}, uniforms), AmbientLight.getUniformDefine("u_ambientLight"));
        } else if (light instanceof DirectLight) {
          uniforms = _objectSpread2(_objectSpread2({}, uniforms), DirectLight.getUniformDefine("u_directLights[".concat(directLightCount++, "]")));
        } else if (light instanceof PointLight) {
          uniforms = _objectSpread2(_objectSpread2({}, uniforms), PointLight.getUniformDefine("u_pointLights[".concat(pointLightCount++, "]")));
        } else if (light instanceof SpotLight) {
          uniforms = _objectSpread2(_objectSpread2({}, uniforms), SpotLight.getUniformDefine("u_spotLights[".concat(spotLightCount++, "]")));
        } else if (light instanceof EnvironmentMapLight && !envMapLightCount++) {
          uniforms = _objectSpread2(_objectSpread2({}, uniforms), EnvironmentMapLight.getUniformDefine("u_envMapLight"));
        }
      }

      return uniforms;
    }
  }]);

  return LightFeature;
}(SceneFeature);

var ColliderFeature = /*#__PURE__*/function (_SceneFeature) {
  _inherits(ColliderFeature, _SceneFeature);

  var _super = _createSuper(ColliderFeature);

  function ColliderFeature() {
    var _this;

    _classCallCheck(this, ColliderFeature);

    _this = _super.call(this);
    _this.colliders = void 0;
    _this.colliders = [];
    return _this;
  }
  /**
   * 添加一个 Collider 组件
   * @param {Collider} collider 碰撞体对象
   * @private
   */


  _createClass(ColliderFeature, [{
    key: "attachCollider",
    value: function attachCollider(collider) {
      this.colliders.push(collider);
    }
    /**
     * 移除一个Collider组件
     * @param {Collider} collider 碰撞体对象
     * @private
     */

  }, {
    key: "detachCollider",
    value: function detachCollider(collider) {
      var index = this.colliders.indexOf(collider);

      if (index != -1) {
        this.colliders.splice(index, 1);
      }
    }
  }]);

  return ColliderFeature;
}(SceneFeature);

/**
 * 碰撞体组件的基类, 定义碰撞体的数据
 */

var Collider = /*#__PURE__*/function (_Component) {
  _inherits(Collider, _Component);

  var _super = _createSuper(Collider);

  /**
   * collider flg
   */

  /**
   * @param {Entity} entity
   */
  function Collider(entity) {
    var _this;

    _classCallCheck(this, Collider);

    _this = _super.call(this, entity);
    _this.tag = exports.MaskList.EVERYTHING;
    return _this;
  }
  /** 事件回调：在对象Enable的时候，挂载到当前的Scene
   * @private
   */


  _createClass(Collider, [{
    key: "_onEnable",
    value: function _onEnable() {
      this.scene.findFeature(ColliderFeature).attachCollider(this);
    }
    /** 事件回调：在对象Disable的时候，从当前的Scene移除
     * @private
     */

  }, {
    key: "_onDisable",
    value: function _onDisable() {
      this.scene.findFeature(ColliderFeature).detachCollider(this);
    }
  }]);

  return Collider;
}(Component);

/**
 * 轴对齐的包围盒（AABBox）碰撞体组件
 * @extends Collider
 */

var ABoxCollider = /*#__PURE__*/function (_Collider) {
  _inherits(ABoxCollider, _Collider);

  var _super = _createSuper(ABoxCollider);

  /**
   * 构造函数
   * @param {Entity} entity 对象所在节点
   */
  function ABoxCollider(entity) {
    var _this;

    _classCallCheck(this, ABoxCollider);

    _this = _super.call(this, entity);
    _this.boxMin = void 0;
    _this.boxMax = void 0;
    _this._corners = [];
    _this._cornerFlag = false;
    _this.boxMin = new miniprogram.Vector3(-0.5, -0.5, -0.5);
    _this.boxMax = new miniprogram.Vector3(0.5, 0.5, 0.5);
    return _this;
  }
  /**
   * 使用范围坐标，设置包围盒
   * @param {Vector3} min 最小坐标
   * @param {Vector3} max 最大坐标
   */


  _createClass(ABoxCollider, [{
    key: "setBoxMinMax",
    value: function setBoxMinMax(min, max) {
      this.boxMin = min;
      this.boxMax = max;
      this._cornerFlag = true;
    }
    /**
     * 使用中心点和Size的方式设置包围盒
     * @param {Vector3} center 包围盒的中心点
     * @param {Vector3} size 包围盒的3个轴向的大小
     */

  }, {
    key: "setBoxCenterSize",
    value: function setBoxCenterSize(center, size) {
      var halfSize = ABoxCollider._tempVec3;
      miniprogram.Vector3.scale(size, 0.5, halfSize);
      miniprogram.Vector3.add(center, halfSize, this.boxMax);
      miniprogram.Vector3.subtract(center, halfSize, this.boxMin);
      this._cornerFlag = true;
    }
    /**
     * 取得八个顶点的位置
     */

  }, {
    key: "getCorners",
    value: function getCorners() {
      if (this._cornerFlag) {
        var minX = this.boxMin.x;
        var minY = this.boxMin.y;
        var minZ = this.boxMin.z;
        var w = this.boxMax.x - minX;
        var h = this.boxMax.y - minY;
        var d = this.boxMax.z - minZ;

        if (this._corners.length === 0) {
          for (var i = 0; i < 8; ++i) {
            this._corners.push(new miniprogram.Vector3());
          }
        }

        this._corners[0].setValue(minX + w, minY + h, minZ + d);

        this._corners[1].setValue(minX, minY + h, minZ + d);

        this._corners[2].setValue(minX, minY, minZ + d);

        this._corners[3].setValue(minX + w, minY, minZ + d);

        this._corners[4].setValue(minX + w, minY + h, minZ);

        this._corners[5].setValue(minX, minY + h, minZ);

        this._corners[6].setValue(minX, minY, minZ);

        this._corners[7].setValue(minX + w, minY, minZ);

        this._cornerFlag = false;
      }

      return this._corners;
    }
  }]);

  return ABoxCollider;
}(Collider);
ABoxCollider._tempVec3 = new miniprogram.Vector3();

/**
 * 球型碰撞体组件
 * @extends Collider
 */
var ASphereCollider = /*#__PURE__*/function (_Collider) {
  _inherits(ASphereCollider, _Collider);

  var _super = _createSuper(ASphereCollider);

  /**
   * @constructor
   * @param {Entity} entity
   */
  function ASphereCollider(entity) {
    var _this;

    _classCallCheck(this, ASphereCollider);

    _this = _super.call(this, entity);
    /**
     * 球心的坐标(在Local坐标系)
     * @member {Vector3}
     */

    _this.center = void 0;
    _this.radius = void 0;
    _this.center = new miniprogram.Vector3();
    /**
     * 球体的半径
     * @member {float}
     */

    _this.radius = 1;
    return _this;
  }
  /**
   * 射线检测
   * @param ray - 射线
   * @param hit - 碰撞信息
   */


  _createClass(ASphereCollider, [{
    key: "raycast",
    value: function raycast(ray, hit) {}
    /**
     * 设置球体的属性数据
     * @param {Vector3} center 球心坐标
     * @param {number} radius 球的半径
     */

  }, {
    key: "setSphere",
    value: function setSphere(center, radius) {
      this.center = center;
      this.radius = radius;
    }
  }]);

  return ASphereCollider;
}(Collider);

/**
 * 平面（无限大）碰撞体组件，平面的位置和朝向与SceneObject一致
 * @extends Collider
 */
var PlaneCollider = /*#__PURE__*/function (_Collider) {
  _inherits(PlaneCollider, _Collider);

  var _super = _createSuper(PlaneCollider);

  /**
   * @constructor
   * @param {Entity} entity
   */
  function PlaneCollider(entity) {
    var _this;

    _classCallCheck(this, PlaneCollider);

    _this = _super.call(this, entity);
    /**
     * 平面经过点的坐标(在Local坐标系)
     * @member {Vector3}
     */

    _this.planePoint = void 0;
    _this.normal = void 0;
    _this.planePoint = new miniprogram.Vector3();
    /**
     * 平面法线的方向
     * @member {Vector3}
     */

    _this.normal = new miniprogram.Vector3(0, 1, 0);
    return _this;
  }
  /**
   * 使用Local坐标，设置point
   * @param {Vector3} point 平面上的一个点：(p-p0)·n = 0
   * @param {Vector3} normal 平面的法线
   */


  _createClass(PlaneCollider, [{
    key: "setPlane",
    value: function setPlane(point, normal) {
      this.planePoint = point;
      this.normal = normal;
    }
  }]);

  return PlaneCollider;
}(Collider);

/**
 * 对场景中所有 Collider 进行射线检测，返回离射线起点最近的一个
 * @param {Ray} _ray 使用的射线，对于点击拾取，这个设想可以调用 CameraComponent.screenPointToRay() 方法获得
 * @param {Vector3} _outPos 射线和碰撞体的交点
 * @return {ACollider} 射线检测结果
 */

Scene.prototype.raycast = function (_ray, _outPos) {
  var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.MaskList.EVERYTHING;
  var ray = new miniprogram.Ray(_ray.origin, _ray.direction);
  var cf = this.findFeature(ColliderFeature);
  var colliders = cf.colliders;
  var nearestHit = new miniprogram.RaycastHit();

  for (var i = 0, len = colliders.length; i < len; i++) {
    var collider = colliders[i];

    if (!collider.entity.isActiveInHierarchy) {
      continue;
    }

    if (!(collider.tag & tag)) {
      continue;
    }

    var hit = new miniprogram.RaycastHit();

    if (collider.raycast(ray, hit)) {
      if (hit.distance < nearestHit.distance) {
        nearestHit = hit;
      }
    }
  } // end of for


  if (_outPos && nearestHit.collider) {
    nearestHit.point.cloneTo(_outPos);
  }

  return nearestHit.collider;
};
/**
 * 执行射线检测
 * @param {Ray} ray
 * @param {RaycastHit} hit
 */


ABoxCollider.prototype.raycast = function (ray, hit) {
  var localRay = _getLocalRay(this, ray);

  var intersect = localRay.intersectAABB(this.boxMax, this.boxMin);

  if (intersect) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);

    return true;
  } else {
    return false;
  } // end of else

};

ASphereCollider.prototype.raycast = function (ray, hit) {
  var localRay = _getLocalRay(this, ray);

  var intersect = localRay.intersectSphere(this.center, this.radius);

  if (intersect) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);

    return true;
  } else {
    return false;
  } // end of else

};

PlaneCollider.prototype.raycast = function (ray, hit) {
  var localRay = _getLocalRay(this, ray);

  var intersect = localRay.intersectPlane(this.planePoint, this.normal);

  if (intersect) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);

    return true;
  } else {
    return false;
  } // end of else

};
/**
 * 计算世界坐标系中的碰撞点
 * @param {Ray} ray
 * @param {number} distance
 * @param {RaycastHit} outHit
 * @private
 */


function _updateHitResult(collider, ray, distance, outHit, origin) {
  var hitPos = ray.getPoint(distance);
  miniprogram.Vector3.transformCoordinate(hitPos, collider.entity.transform.worldMatrix, hitPos);
  outHit.distance = miniprogram.Vector3.distance(origin, hitPos);
  outHit.collider = collider;
  outHit.point = hitPos;
}
/**
 * transform ray to local space
 * @param {Ray} ray
 * @private
 */


function _getLocalRay(collider, ray) {
  var worldToLocal = collider.entity.getInvModelMatrix(); // o = worldToLocal * vec4(ray.origin, 1)

  var o = new miniprogram.Vector3();
  miniprogram.Vector3.transformCoordinate(ray.origin, worldToLocal, o); // d = worldToLocal * vec4(ray.direction, 0)

  var d = new miniprogram.Vector3();

  _transformDirection(d, ray.direction, worldToLocal);

  return new miniprogram.Ray(o, d);
} // a: vec3
// m: mat4
// return m * vec3(a, 0)


function _transformDirection(out, a, m) {
  var x = a.x;
  var y = a.y;
  var z = a.z;
  var e = m.elements;
  out.x = x * e[0] + y * e[4] + z * e[8];
  out.y = x * e[1] + y * e[5] + z * e[9];
  out.z = x * e[2] + y * e[6] + z * e[10];
  return out;
}

/**
 * Mesh Asset Object
 */
var Mesh = /*#__PURE__*/function (_EngineObject) {
  _inherits(Mesh, _EngineObject);

  var _super = _createSuper(Mesh);

  /** 名称。*/

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function Mesh(engine, name) {
    var _this;

    _classCallCheck(this, Mesh);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this.primitives = [];
    _this.groups = [];
    _this.weights = void 0;
    _this.bounds = new miniprogram.BoundingBox(new miniprogram.Vector3(), new miniprogram.Vector3());
    _this.name = name;
    return _this;
  }

  _createClass(Mesh, [{
    key: "updatePrimitiveWeightsIndices",
    value: function updatePrimitiveWeightsIndices(weightsIndices) {// this.primitives.forEach((primitive) => {
      //   primitive.updateWeightsIndices(weightsIndices);
      // });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.primitives = null;
    }
  }]);

  return Mesh;
}(EngineObject);

/**
 * mesh skin data, equal glTF skins define
 * @class
 */

var Skin = /*#__PURE__*/function (_AssetObject) {
  _inherits(Skin, _AssetObject);

  var _super = _createSuper(Skin);

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function Skin(name) {
    var _this;

    _classCallCheck(this, Skin);

    _this = _super.call(this, null);
    _this.inverseBindMatrices = void 0;
    _this.joints = void 0;
    _this.skeleton = void 0;
    _this.inverseBindMatrices = []; // inverse bind matrix array, element type: gl-matrix.mat4

    _this.joints = []; // joints name array, element type: string

    _this.skeleton = "none"; // root bone name

    return _this;
  }

  return Skin;
}(AssetObject);

var _class$7, _descriptor$7, _descriptor2$6, _temp$7;

// TODO 硬编码，后续添加到 RenderableComponent 内
function addPrimitivesRefCount(mesh, refCount) {
  var primitives = mesh.primitives;

  for (var i = 0, l = primitives.length; i < l; i++) {
    primitives[i]._addRefCount(refCount);
  }
}
/**
 * 负责渲染一个Mesh对象的组件
 */


var MeshRenderer = (_class$7 = (_temp$7 = /*#__PURE__*/function (_RenderableComponent) {
  _inherits(MeshRenderer, _RenderableComponent);

  var _super = _createSuper(MeshRenderer);

  function MeshRenderer(entity) {
    var _this;

    _classCallCheck(this, MeshRenderer);

    _this = _super.call(this, entity);
    _this._mesh = void 0;

    _initializerDefineProperty(_this, "_instanceMaterials", _descriptor$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_sharedMaterials", _descriptor2$6, _assertThisInitialized(_this));

    _this._mesh = null; // Mesh Asset Object

    return _this;
  }
  /**
   * 当前绑定的 Mesh 对象
   */


  _createClass(MeshRenderer, [{
    key: "setSharedMaterial",

    /**
     * 指定一个Primitive所使用的材质（替代Primitive的默认材质）
     * @param {number} primitiveIndex Primitive 的名称
     * @param {Material} material 材质对象
     */
    value: function setSharedMaterial(primitiveIndex, material) {
      if (this._sharedMaterials[primitiveIndex]) {
        this._sharedMaterials[primitiveIndex]._addRefCount(-1);
      }

      material._addRefCount(1);

      this._sharedMaterials[primitiveIndex] = material;
    }
    /**
     * 指定一个Primitive所使用的材质（替代Primitive的默认材质）
     * @param {number} primitiveIndex Primitive 的名称
     * @param {Material} material 材质对象
     */

  }, {
    key: "setMaterial",
    value: function setMaterial(primitiveIndex, material) {
      if (this._instanceMaterials[primitiveIndex]) {
        this._instanceMaterials[primitiveIndex]._addRefCount(-1);
      }

      material._addRefCount(1);

      this._instanceMaterials[primitiveIndex] = material;
    }
    /**
     * 取得这个组件独有的材质对象
     * @param {number} primitiveIndex 索引值
     * @return {Material}
     */

  }, {
    key: "getInstanceMaterial",
    value: function getInstanceMaterial(primitiveIndex) {
      return this._instanceMaterials[primitiveIndex];
    }
    /**
     * 取得共享的Primitive的材质对象
     * @param {number} primitiveIndex 索引值
     * @return {Material}
     */

  }, {
    key: "getSharedMaterial",
    value: function getSharedMaterial(primitiveIndex) {
      return this._sharedMaterials[primitiveIndex];
    }
    /**
     * 执行渲染
     * @param {CameraComponent} camera
     */

  }, {
    key: "render",
    value: function render(camera) {
      var mesh = this._mesh;

      if (!mesh) {
        return;
      }

      var renderPipeline = camera._renderPipeline;
      var primitives = mesh.primitives,
          groups = mesh.groups; //-- render every primitive

      for (var i = 0, len = primitives.length; i < len; i++) {
        var primitive = primitives[i];
        var material = this._instanceMaterials[i] || this._sharedMaterials[i];

        if (material) {
          var element = RenderElement.getFromPool();
          element.setValue(this, primitive, groups[i], material);
          renderPipeline.pushPrimitive(element);
        } else {
          Logger.error("Primitive has no material: " + primitive.name);
        }
      } // end of for

    }
    /**
     * 释放资源
     */

  }, {
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf(MeshRenderer.prototype), "destroy", this).call(this); //-- release mesh


      this._mesh = null; //-- materials

      this._instanceMaterials = [];
      this._sharedMaterials = []; // 删除引用计数

      for (var i = 0; i < this._instanceMaterials.length; i++) {
        this._instanceMaterials[i]._addRefCount(-1);
      } // 删除引用计数


      for (var _i = 0; _i < this._sharedMaterials.length; _i++) {
        this._sharedMaterials[_i]._addRefCount(-1);
      }

      if (this._mesh) {
        addPrimitivesRefCount(this._mesh, -1);
      }
    }
    /**
     * @override
     */

  }, {
    key: "_updateBounds",
    value: function _updateBounds(worldBounds) {
      var localBounds = this.mesh.bounds;
      var worldMatrix = this._entity.transform.worldMatrix;
      miniprogram.Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min); //TODO:简单模式，有漏洞，待AABB重构

      miniprogram.Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);
    }
  }, {
    key: "mesh",
    get: function get() {
      return this._mesh;
    }
    /**
     * 指定需要渲染的Mesh对象；多个MeshRenderer对象可以引用同一个Mesh对象
     * @param {Mesh} mesh Mesh 对象
     */
    ,
    set: function set(mesh) {
      if (this._mesh) {
        // TODO 硬编码，后续添加到 RenderableComponent 内
        addPrimitivesRefCount(this._mesh, -1);
      } // TODO 硬编码，后续添加到 RenderableComponent 内


      addPrimitivesRefCount(mesh, 1);
      this._mesh = mesh;
      this._sharedMaterials = [];
      this._instanceMaterials = [];
    }
  }]);

  return MeshRenderer;
}(RenderableComponent), _temp$7), (_descriptor$7 = _applyDecoratedDescriptor(_class$7.prototype, "_instanceMaterials", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class$7.prototype, "_sharedMaterials", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
})), _class$7);

/**
 * 纹理的过滤模式。
 */

(function (TextureFilterMode) {
  TextureFilterMode[TextureFilterMode["Point"] = 0] = "Point";
  TextureFilterMode[TextureFilterMode["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode[TextureFilterMode["Trilinear"] = 2] = "Trilinear";
})(exports.TextureFilterMode || (exports.TextureFilterMode = {}));

/**
 * 纹理格式枚举。
 */

(function (TextureFormat) {
  TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat[TextureFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat[TextureFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat[TextureFormat["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat[TextureFormat["Alpha8"] = 5] = "Alpha8";
  TextureFormat[TextureFormat["R32G32B32A32"] = 6] = "R32G32B32A32";
  TextureFormat[TextureFormat["DXT1"] = 7] = "DXT1";
  TextureFormat[TextureFormat["DXT5"] = 8] = "DXT5";
  TextureFormat[TextureFormat["ETC1_RGB"] = 9] = "ETC1_RGB";
  TextureFormat[TextureFormat["ETC2_RGB"] = 10] = "ETC2_RGB";
  TextureFormat[TextureFormat["ETC2_RGBA5"] = 11] = "ETC2_RGBA5";
  TextureFormat[TextureFormat["ETC2_RGBA8"] = 12] = "ETC2_RGBA8";
  TextureFormat[TextureFormat["PVRTC_RGB2"] = 13] = "PVRTC_RGB2";
  TextureFormat[TextureFormat["PVRTC_RGBA2"] = 14] = "PVRTC_RGBA2";
  TextureFormat[TextureFormat["PVRTC_RGB4"] = 15] = "PVRTC_RGB4";
  TextureFormat[TextureFormat["PVRTC_RGBA4"] = 16] = "PVRTC_RGBA4";
  TextureFormat[TextureFormat["ASTC_4x4"] = 17] = "ASTC_4x4";
  TextureFormat[TextureFormat["ASTC_5x5"] = 18] = "ASTC_5x5";
  TextureFormat[TextureFormat["ASTC_6x6"] = 19] = "ASTC_6x6";
  TextureFormat[TextureFormat["ASTC_8x8"] = 20] = "ASTC_8x8";
  TextureFormat[TextureFormat["ASTC_10x10"] = 21] = "ASTC_10x10";
  TextureFormat[TextureFormat["ASTC_12x12"] = 22] = "ASTC_12x12";
})(exports.TextureFormat || (exports.TextureFormat = {}));

/**
 * 纹理的循环模式。
 */

(function (TextureWrapMode) {
  TextureWrapMode[TextureWrapMode["Clamp"] = 0] = "Clamp";
  TextureWrapMode[TextureWrapMode["Repeat"] = 1] = "Repeat";
  TextureWrapMode[TextureWrapMode["Mirror"] = 2] = "Mirror";
})(exports.TextureWrapMode || (exports.TextureWrapMode = {}));

/**
 * @deprecated
 */

(function (GLCompressedTextureInternalFormat) {
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["R11_EAC"] = 37488] = "R11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 37490] = "RG11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
  GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
})(exports.GLCompressedTextureInternalFormat || (exports.GLCompressedTextureInternalFormat = {}));

/**
 * 渲染缓冲颜色格式枚举。
 */

(function (RenderBufferColorFormat) {
  RenderBufferColorFormat[RenderBufferColorFormat["R8G8B8"] = 0] = "R8G8B8";
  RenderBufferColorFormat[RenderBufferColorFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
  RenderBufferColorFormat[RenderBufferColorFormat["R4G4B4A4"] = 2] = "R4G4B4A4";
  RenderBufferColorFormat[RenderBufferColorFormat["R5G5B5A1"] = 3] = "R5G5B5A1";
  RenderBufferColorFormat[RenderBufferColorFormat["R5G6B5"] = 4] = "R5G6B5";
  RenderBufferColorFormat[RenderBufferColorFormat["Alpha8"] = 5] = "Alpha8";
  RenderBufferColorFormat[RenderBufferColorFormat["R16G16B16A16"] = 6] = "R16G16B16A16";
  RenderBufferColorFormat[RenderBufferColorFormat["R32G32B32A32"] = 7] = "R32G32B32A32";
})(exports.RenderBufferColorFormat || (exports.RenderBufferColorFormat = {}));

/**
 * 渲染缓冲深度格式枚举。
 */

(function (RenderBufferDepthFormat) {
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat[RenderBufferDepthFormat["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat[RenderBufferDepthFormat["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(exports.RenderBufferDepthFormat || (exports.RenderBufferDepthFormat = {}));

/**
 * 纹理的基类，包含了纹理相关类的一些公共功能。
 */

var Texture = /*#__PURE__*/function (_RefObject) {
  _inherits(Texture, _RefObject);

  var _super = _createSuper(Texture);

  _createClass(Texture, [{
    key: "generateMipmaps",

    /**
     * 根据第0级数据生成多级纹理。
     */
    value: function generateMipmaps() {
      if (!this._mipmap) return;
      var gl = this._rhi.gl;

      this._bind();

      gl.generateMipmap(this._target);

      this._unbind();
    }
    /**
     * @override
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {
      var gl = this._rhi.gl;
      gl.deleteTexture(this._glTexture);
      this._glTexture = null;
      this._formatDetail = null; // TODO: delete

      this._rhi = null;
    }
    /** @internal */

  }, {
    key: "_bind",
    value: function _bind() {
      var gl = this._rhi.gl;
      gl.bindTexture(this._target, this._glTexture);
    }
    /** @internal */

  }, {
    key: "_unbind",
    value: function _unbind() {
      var gl = this._rhi.gl;
      gl.bindTexture(this._target, null);
    }
    /**
     * @internal
     * 根据指定区域获得像素颜色缓冲。
     * @param face - 如果是立方体纹理，可以选择读取第几个面
     * @param x - 区域起始X坐标
     * @param y - 区域起始Y坐标
     * @param width - 区域宽
     * @param height - 区域高
     * @param out - 颜色数据缓冲
     */

  }, {
    key: "_getPixelBuffer",
    value: function _getPixelBuffer(face, x, y, width, height, out) {
      var gl = this._rhi.gl;
      var _this$_formatDetail = this._formatDetail,
          baseFormat = _this$_formatDetail.baseFormat,
          dataType = _this$_formatDetail.dataType;

      if (!Texture._readFrameBuffer) {
        Texture._readFrameBuffer = gl.createFramebuffer();
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, Texture._readFrameBuffer);

      if (face != null) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
      }

      gl.readPixels(x, y, width, height, baseFormat, dataType, out);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * @internal
     * 预开辟 mipmap 显存
     */

  }, {
    key: "_initMipmap",
    value: function _initMipmap(isCube) {
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;
      var _this$_formatDetail2 = this._formatDetail,
          internalFormat = _this$_formatDetail2.internalFormat,
          baseFormat = _this$_formatDetail2.baseFormat,
          dataType = _this$_formatDetail2.dataType;

      this._bind();

      if (isWebGL2) {
        gl.texStorage2D(this._target, this._mipmapCount, internalFormat, this._width, this._height);
      } else {
        // In WebGL 1, internalformat must be the same as baseFormat
        if (baseFormat !== internalFormat) {
          internalFormat = baseFormat;
        }

        if (!isCube) {
          for (var i = 0; i < this._mipmapCount; i++) {
            var width = Math.max(1, this._width >> i);
            var height = Math.max(1, this._height >> i);
            gl.texImage2D(this._target, i, internalFormat, width, height, 0, baseFormat, dataType, null);
          }
        } else {
          for (var _i = 0; _i < this._mipmapCount; _i++) {
            var size = Math.max(1, this._width >> _i);

            for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
            }
          }
        }
      }

      this._unbind();
    }
    /**
     * @internal
     * 获取相应size的最大mip级别,rounding down
     * http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
     */

  }, {
    key: "_getMaxMiplevel",
    value: function _getMaxMiplevel(size) {
      return Math.floor(Math.log2(size));
    }
    /**
     * @internal
     */

  }, {
    key: "_getMipmapCount",
    value: function _getMipmapCount() {
      return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
    }
    /**
     * @internal
     */

  }, {
    key: "_setWrapMode",
    value: function _setWrapMode(value, pname) {
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;

      if (!isWebGL2 && value !== exports.TextureWrapMode.Clamp && (!Texture._isPowerOf2(this._width) || !Texture._isPowerOf2(this._height))) {
        Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
        value = exports.TextureWrapMode.Clamp;
      }

      switch (value) {
        case exports.TextureWrapMode.Clamp:
          gl.texParameteri(this._target, pname, gl.CLAMP_TO_EDGE);
          break;

        case exports.TextureWrapMode.Repeat:
          gl.texParameteri(this._target, pname, gl.REPEAT);
          break;

        case exports.TextureWrapMode.Mirror:
          gl.texParameteri(this._target, pname, gl.MIRRORED_REPEAT);
          break;
      }
    } // TODO: delete

  }, {
    key: "width",

    /**
     * 纹理宽。
     */
    get: function get() {
      return this._width;
    }
    /**
     * 纹理高。
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * 纹理坐标 U 的循环模式。
     */

  }, {
    key: "wrapModeU",
    get: function get() {
      return this._wrapModeU;
    },
    set: function set(value) {
      if (value === this._wrapModeU) return;
      var gl = this._rhi.gl;
      this._wrapModeU = value;

      this._bind();

      this._setWrapMode(value, gl.TEXTURE_WRAP_S);

      this._unbind();
    }
    /**
     * 纹理坐标 V 的循环模式。
     */

  }, {
    key: "wrapModeV",
    get: function get() {
      return this._wrapModeV;
    },
    set: function set(value) {
      if (value === this._wrapModeV) return;
      var gl = this._rhi.gl;
      this._wrapModeV = value;

      this._bind();

      this._setWrapMode(value, gl.TEXTURE_WRAP_T);

      this._unbind();
    }
    /**
     * 多级纹理的数量。
     */

  }, {
    key: "mipmapCount",
    get: function get() {
      return this._mipmapCount;
    }
    /**
     * 纹理的过滤模式。
     */

  }, {
    key: "filterMode",
    get: function get() {
      return this._filterMode;
    },
    set: function set(value) {
      if (value === this._filterMode) return;
      var gl = this._rhi.gl;
      this._filterMode = value;

      this._bind();

      switch (value) {
        case exports.TextureFilterMode.Point:
          gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
          break;

        case exports.TextureFilterMode.Bilinear:
          gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
          break;

        case exports.TextureFilterMode.Trilinear:
          gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
          break;
      }

      this._unbind();
    }
    /**
     * 各向异性过滤等级。
     */

  }, {
    key: "anisoLevel",
    get: function get() {
      return this._anisoLevel;
    },
    set: function set(value) {
      var max = this._rhi.capability.maxAnisoLevel;

      if (value > max) {
        Logger.warn("anisoLevel:".concat(value, ", exceeds the limit and is automatically downgraded to:").concat(max));
        value = max;
      }

      if (value < 1) {
        Logger.warn("anisoLevel:".concat(value, ", must be greater than 0, and is automatically downgraded to 1"));
        value = 1;
      }

      if (value === this._anisoLevel) return;
      var gl = this._rhi.gl;
      this._anisoLevel = value;

      this._bind();

      gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);

      this._unbind();
    }
  }], [{
    key: "_isPowerOf2",

    /** @internal */

    /** @internal */
    value: function _isPowerOf2(v) {
      return (v & v - 1) === 0;
    }
    /**
     * @internal
     * 根据 TextureFormat 获取具体信息。
     */

  }, {
    key: "_getFormatDetail",
    value: function _getFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.TextureFormat.R8G8B8:
          return {
            internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.R8G8B8A8:
          return {
            internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.R4G4B4A4:
          return {
            internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_4_4_4_4,
            isCompressed: false
          };

        case exports.TextureFormat.R5G5B5A1:
          return {
            internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_5_5_5_1,
            isCompressed: false
          };

        case exports.TextureFormat.R5G6B5:
          return {
            internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_SHORT_5_6_5,
            isCompressed: false
          };

        case exports.TextureFormat.Alpha8:
          return {
            internalFormat: gl.ALPHA,
            baseFormat: gl.ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.TextureFormat.R32G32B32A32:
          return {
            internalFormat: gl.RGBA32F,
            baseFormat: gl.RGBA,
            dataType: gl.FLOAT,
            isCompressed: false
          };

        case exports.TextureFormat.DXT1:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
            isCompressed: true
          };

        case exports.TextureFormat.DXT5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
            isCompressed: true
          };

        case exports.TextureFormat.ETC1_RGB:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
            isCompressed: true
          };

        case exports.TextureFormat.ETC2_RGB:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_ETC2,
            isCompressed: true
          };

        case exports.TextureFormat.ETC2_RGBA5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            isCompressed: true
          };

        case exports.TextureFormat.ETC2_RGBA8:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGB2:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGBA2:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGB4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.PVRTC_RGBA4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_4x4:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_5x5:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_6x6:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_8x8:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_10x10:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
            isCompressed: true
          };

        case exports.TextureFormat.ASTC_12x12:
          return {
            internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
            isCompressed: true
          };

        default:
          throw new Error("this TextureFormat is not supported in Oasis Engine: ".concat(format));
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_getRenderBufferColorFormatDetail",
    value: function _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.RenderBufferColorFormat.R8G8B8:
          return {
            internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R8G8B8A8:
          return {
            internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R4G4B4A4:
          return {
            internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_4_4_4_4,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R5G5B5A1:
          return {
            internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
            baseFormat: gl.RGBA,
            dataType: gl.UNSIGNED_SHORT_5_5_5_1,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R5G6B5:
          return {
            internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
            baseFormat: gl.RGB,
            dataType: gl.UNSIGNED_SHORT_5_6_5,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.Alpha8:
          return {
            internalFormat: gl.ALPHA,
            baseFormat: gl.ALPHA,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R16G16B16A16:
          return {
            internalFormat: gl.RGBA16F,
            baseFormat: gl.RGBA,
            dataType: gl.HALF_FLOAT,
            isCompressed: false
          };

        case exports.RenderBufferColorFormat.R32G32B32A32:
          return {
            internalFormat: gl.RGBA32F,
            baseFormat: gl.RGBA,
            dataType: gl.FLOAT,
            isCompressed: false
          };

        default:
          throw new Error("this RenderBufferColorFormat is not supported in Oasis Engine: ".concat(format));
      }
    }
    /**
     * @internal
     * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D
     */

  }, {
    key: "_getRenderBufferDepthFormatDetail",
    value: function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
      switch (format) {
        case exports.RenderBufferDepthFormat.Depth:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.DepthStencil:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.UNSIGNED_INT_24_8,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Stencil:
          return {
            internalFormat: gl.STENCIL_INDEX8,
            baseFormat: gl.STENCIL_ATTACHMENT,
            dataType: gl.UNSIGNED_BYTE,
            isCompressed: false,
            attachment: gl.STENCIL_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth16:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth24:
          return {
            internalFormat: gl.DEPTH_COMPONENT24,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.UNSIGNED_INT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth32:
          return {
            internalFormat: gl.DEPTH_COMPONENT32F,
            baseFormat: gl.DEPTH_COMPONENT,
            dataType: gl.FLOAT,
            isCompressed: false,
            attachment: gl.DEPTH_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth24Stencil8:
          return {
            internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.UNSIGNED_INT_24_8,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };

        case exports.RenderBufferDepthFormat.Depth32Stencil8:
          return {
            internalFormat: gl.DEPTH32F_STENCIL8,
            baseFormat: gl.DEPTH_STENCIL,
            dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
            isCompressed: false,
            attachment: gl.DEPTH_STENCIL_ATTACHMENT
          };

        default:
          throw new Error("this RenderBufferDepthFormat is not supported in Oasis Engine: ".concat(format));
      }
    }
    /**
     * @internal
     * 检测是否支持相应纹理格式。
     */

  }, {
    key: "_supportTextureFormat",
    value: function _supportTextureFormat(format, rhi) {
      var isSupported = true;

      switch (format) {
        case exports.TextureFormat.R32G32B32A32:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
              isSupported = false;
            }
          }
          break;
      }

      return isSupported;
    }
    /**
     * @internal
     */

  }, {
    key: "_supportRenderBufferColorFormat",
    value: function _supportRenderBufferColorFormat(format, rhi) {
      var isSupported = true;

      switch (format) {
        case exports.RenderBufferColorFormat.R32G32B32A32:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.colorBufferFloat) || !rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
              isSupported = false;
            }
          }
          break;

        case exports.RenderBufferColorFormat.R16G16B16A16:
          {
            if (!rhi.canIUse(exports.GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(exports.GLCapabilityType.textureHalfFloat)) {
              isSupported = false;
            }
          }
          break;
      }

      return isSupported;
    }
    /**
     * @internal
     */

  }, {
    key: "_supportRenderBufferDepthFormat",
    value: function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
      var isWebGL2 = rhi.isWebGL2;
      var isSupported = true;

      if (isTexture && !rhi.canIUse(exports.GLCapabilityType.depthTexture)) {
        return false;
      }

      switch (format) {
        case exports.RenderBufferDepthFormat.Stencil:
          {
            isSupported = false;
          }
          break;

        case exports.RenderBufferDepthFormat.Depth24:
        case exports.RenderBufferDepthFormat.Depth32:
        case exports.RenderBufferDepthFormat.Depth32Stencil8:
          {
            if (!isWebGL2) {
              isSupported = false;
            }
          }
          break;
      }

      return isSupported;
    }
    /** 名称。*/

  }]);

  function Texture(engine) {
    var _this;

    _classCallCheck(this, Texture);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this._glTexture = void 0;
    _this._formatDetail = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._rhi = void 0;
    _this._target = void 0;
    _this._mipmap = void 0;
    _this._mipmapCount = void 0;
    _this._wrapModeU = void 0;
    _this._wrapModeV = void 0;
    _this._filterMode = void 0;
    _this._anisoLevel = 1;
    return _this;
  }

  return Texture;
}(RefObject);
Texture._readFrameBuffer = null;

/**
 * 2D纹理。
 */

var Texture2D = /*#__PURE__*/function (_Texture) {
  _inherits(Texture2D, _Texture);

  var _super = _createSuper(Texture2D);

  _createClass(Texture2D, [{
    key: "format",

    /** 向下兼容 WebGL1.0。 */

    /**
     * 纹理的格式。
     */
    get: function get() {
      return this._format;
    }
    /**
     * 构建一个2D纹理。
     * @param engine - 所属引擎
     * @param width - 宽
     * @param height - 高
     * @param format - 格式，默认值 `TextureFormat.R8G8B8A8`
     * @param mipmap - 是否使用多级纹理
     */

  }]);

  function Texture2D(engine, width, height) {
    var _this;

    var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.TextureFormat.R8G8B8A8;
    var mipmap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    _classCallCheck(this, Texture2D);

    _this = _super.call(this, engine);
    _this._format = void 0;
    _this._compressedMipFilled = 0;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;

    if (!Texture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:".concat(exports.TextureFormat[format]));
    }

    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }

    var formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);

    _this._glTexture = gl.createTexture();
    _this._formatDetail = formatDetail;
    _this._rhi = rhi;
    _this._target = gl.TEXTURE_2D;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
    _this.filterMode = exports.TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = exports.TextureWrapMode.Repeat;
    return _this;
  }
  /**
   * 通过颜色缓冲数据、指定区域和纹理层级设置像素，同样适用于压缩格式。
   * @remarks 如果为WebGL1.0平台且纹理格式为压缩格式，第一次上传必须填满纹理。
   * @param pixelBuffer - 颜色缓冲数据
   * @param mipLevel - 纹理层级
   * @param x - 数据起始X坐标
   * @param y - 数据起始Y坐标
   * @param width - 数据宽度。如果为空的话 width 为 mipLevel 对应的宽度减去 x , mipLevel 对应的宽度为 Math.max(1, this.width >> mipLevel)
   * @param height - 数据高度。如果为空的话 height 为 mipLevel 对应的高度减去 y , mipLevel 对应的高度为 Math.max(1, this.height >> mipLevel)
   */


  _createClass(Texture2D, [{
    key: "setPixelBuffer",
    value: function setPixelBuffer(colorBuffer) {
      var mipLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x = arguments.length > 2 ? arguments[2] : undefined;
      var y = arguments.length > 3 ? arguments[3] : undefined;
      var width = arguments.length > 4 ? arguments[4] : undefined;
      var height = arguments.length > 5 ? arguments[5] : undefined;
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;
      var _this$_formatDetail = this._formatDetail,
          internalFormat = _this$_formatDetail.internalFormat,
          baseFormat = _this$_formatDetail.baseFormat,
          dataType = _this$_formatDetail.dataType,
          isCompressed = _this$_formatDetail.isCompressed;
      var mipWidth = Math.max(1, this._width >> mipLevel);
      var mipHeight = Math.max(1, this._height >> mipLevel);
      x = x || 0;
      y = y || 0;
      width = width || mipWidth - x;
      height = height || mipHeight - y;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

      if (isCompressed) {
        var mipBit = 1 << mipLevel;

        if (isWebGL2 || this._compressedMipFilled & mipBit) {
          gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
        } else {
          gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
          this._compressedMipFilled |= mipBit;
        }
      } else {
        gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
      }

      this._unbind();
    }
    /**
     * 通过图源、指定区域和纹理层级设置像素。
     * @param imageSource - 纹理源
     * @param mipLevel - 多级纹理层级
     * @param flipY - 是否翻转Y轴
     * @param premultiplyAlpha - 是否预乘透明通道
     * @param x - 区域起始X坐标
     * @param y - 区域起始Y坐标
     */

  }, {
    key: "setImageSource",
    value: function setImageSource(imageSource) {
      var mipLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var flipY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var premultiplyAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var x = arguments.length > 4 ? arguments[4] : undefined;
      var y = arguments.length > 5 ? arguments[5] : undefined;
      var gl = this._rhi.gl;
      var _this$_formatDetail2 = this._formatDetail,
          baseFormat = _this$_formatDetail2.baseFormat,
          dataType = _this$_formatDetail2.dataType;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);

      this._unbind();
    }
    /**
     * 根据指定区域获得像素颜色缓冲。
     * @param x - 区域起始X坐标
     * @param y - 区域起始Y坐标
     * @param width - 区域宽
     * @param height - 区域高
     * @param out - 颜色数据缓冲
     */

  }, {
    key: "getPixelBuffer",
    value: function getPixelBuffer(x, y, width, height, out) {
      if (this._formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }

      _get(_getPrototypeOf(Texture2D.prototype), "_getPixelBuffer", this).call(this, null, x, y, width, height, out);
    }
  }]);

  return Texture2D;
}(Texture);

var _class$8, _descriptor$8, _descriptor2$7, _descriptor3$5, _descriptor4$5, _descriptor5$4, _descriptor6$3, _descriptor7$2, _descriptor8$2, _temp$8;

/**
 * 负责渲染一个 Skinned Mesh 的组件
 * @extends MeshRenderer
 */
var SkinnedMeshRenderer = (_class$8 = (_temp$8 = /*#__PURE__*/function (_MeshRenderer) {
  _inherits(SkinnedMeshRenderer, _MeshRenderer);

  var _super = _createSuper(SkinnedMeshRenderer);

  /**
   * constructor
   * @param entity
   * @param props
   */
  function SkinnedMeshRenderer(entity) {
    var _this;

    _classCallCheck(this, SkinnedMeshRenderer);

    _this = _super.call(this, entity);

    _initializerDefineProperty(_this, "matrixPalette", _descriptor$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "jointNodes", _descriptor2$7, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "jointTexture", _descriptor3$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_hasInitJoints", _descriptor4$5, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_mat", _descriptor5$4, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_weights", _descriptor6$3, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "weightsIndices", _descriptor7$2, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_useJointTexture", _descriptor8$2, _assertThisInitialized(_this));

    _this._skin = void 0;
    _this._mat = new miniprogram.Matrix();
    _this._weights = null;
    _this._skin = null;
    return _this;
  }
  /**
   * set morph target weights
   * @param {Number|Vec} weights 权重参数
   */


  _createClass(SkinnedMeshRenderer, [{
    key: "setWeights",
    value: function setWeights(weights) {
      this._weights = weights;

      if (!weights) {
        return;
      }

      var len = weights.length;

      for (var i = 0; i < len; i++) {
        this.weightsIndices[i] = i;
      }

      var weightsIndices = this.weightsIndices; // 冒泡排序，对 weights 进行大小排序，weightsIndices 根据 weights 顺序而调换顺序

      for (var _i = 0; _i < len - 1; _i++) {
        for (var j = _i + 1; j < len; j++) {
          if (weights[j] > weights[_i]) {
            var t = weights[_i];
            weights[_i] = weights[j];
            weights[j] = t;
            t = weightsIndices[_i];
            weightsIndices[_i] = weightsIndices[j];
            weightsIndices[j] = t;
          }
        }
      }

      this.mesh.updatePrimitiveWeightsIndices(weightsIndices);
    }
    /**
     * 当前绑定的 Skin 对象
     */

  }, {
    key: "_initJoints",
    value: function _initJoints() {
      if (!this._skin) return;
      var skin = this._skin; //-- init

      var joints = skin.joints;
      var jointNodes = [];

      for (var i = joints.length - 1; i >= 0; i--) {
        jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
      } // end of for


      this.matrixPalette = new Float32Array(jointNodes.length * 16);
      this.jointNodes = jointNodes;
      /** 是否使用骨骼纹理 */

      var rhi = this.entity.engine._hardwareRenderer;
      if (!rhi) return;
      var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
      var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);

      if (joints.length > maxJoints && rhi.canIUseMoreJoints) {
        this._useJointTexture = true;
      }
    }
  }, {
    key: "findByNodeName",
    value: function findByNodeName(entity, nodeName) {
      if (!entity) return null;
      var n = entity.findByName(nodeName);
      if (n) return n;
      return this.findByNodeName(entity.parent, nodeName);
    }
    /**
     * 在SceneGraph的树形结构中中向上查找
     * @param {SceneNode} entity
     * @param {string} nodeName
     * @private
     */

  }, {
    key: "_findParent",
    value: function _findParent(entity, nodeName) {
      if (entity) {
        var parent = entity.parent;
        if (!parent) return null;
        if (parent.name === nodeName) return parent;
        var brother = parent.findByName(nodeName);
        if (brother) return brother;
        return this._findParent(parent, nodeName);
      }

      return null;
    }
    /**
     * TODO 渲染之前
     * update matrix palette
     * @private
     */

  }, {
    key: "update",
    value: function update() {
      if (!this._hasInitJoints) {
        this._initJoints();

        this._hasInitJoints = true;
      }

      if (this._skin) {
        var joints = this.jointNodes;
        var ibms = this._skin.inverseBindMatrices;
        var matrixPalette = this.matrixPalette;
        var worldToLocal = this.entity.getInvModelMatrix();
        var mat = this._mat;

        for (var i = joints.length - 1; i >= 0; i--) {
          mat.identity();

          if (joints[i]) {
            miniprogram.Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
          } else {
            ibms[i].cloneTo(mat);
          }

          miniprogram.Matrix.multiply(worldToLocal, mat, mat);
          matrixPalette.set(mat.elements, i * 16);
        } // end of for


        if (this._useJointTexture) {
          this.createJointTexture();
        }
      }
    }
    /**
     * 生成骨骼纹理，将 matrixPalette 存储到 u_jointSampler 中
     * 格式：(4 * RGBA) * jointCont
     * */

  }, {
    key: "createJointTexture",
    value: function createJointTexture() {
      if (!this.jointTexture) {
        var engine = this.engine;
        var rhi = engine._hardwareRenderer;
        if (!rhi) return;
        this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, exports.TextureFormat.R32G32B32A32, false);
        this.jointTexture.filterMode = exports.TextureFilterMode.Point;
      }

      this.jointTexture.setPixelBuffer(this.matrixPalette);
    }
  }, {
    key: "skin",
    get: function get() {
      return this._skin;
    }
    /**
     * 绑定 Skin 对象
     */
    ,
    set: function set(skin) {
      this._skin = skin; // this._started = false; // force onStart callback
    }
  }, {
    key: "weights",
    get: function get() {
      return this._weights;
    }
  }]);

  return SkinnedMeshRenderer;
}(MeshRenderer), _temp$8), (_descriptor$8 = _applyDecoratedDescriptor(_class$8.prototype, "matrixPalette", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$7 = _applyDecoratedDescriptor(_class$8.prototype, "jointNodes", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$5 = _applyDecoratedDescriptor(_class$8.prototype, "jointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$5 = _applyDecoratedDescriptor(_class$8.prototype, "_hasInitJoints", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class$8.prototype, "_mat", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$3 = _applyDecoratedDescriptor(_class$8.prototype, "_weights", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$2 = _applyDecoratedDescriptor(_class$8.prototype, "weightsIndices", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [];
  }
}), _descriptor8$2 = _applyDecoratedDescriptor(_class$8.prototype, "_useJointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class$8);

/**
 * 离散 LOD 层级渲染控制：根据对象占用屏幕高度的百分比，切换不同的 Renderer
 */

var LODGroup = /*#__PURE__*/function (_RenderableComponent) {
  _inherits(LODGroup, _RenderableComponent);

  var _super = _createSuper(LODGroup);

  function LODGroup() {
    var _this;

    _classCallCheck(this, LODGroup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this._lods = [];
    return _this;
  }

  _createClass(LODGroup, [{
    key: "addLod",

    /**
     * 添加一个 LOD 层级
     * @param {number} distance 对象距离Camera的距离
     * @param {Component} rendererAbility 当前 LOD 层级激活时的 Renderer 组件对象，可以是 MeshRenderer 或者 SkinnedMeshRenderer 等
     */
    value: function addLod(distance, rendererAbility) {
      // 关闭原因的 Render，由 ALODGroup 接手
      rendererAbility.enabled = false;

      this._lods.push({
        distance: distance,
        rendererAbility: rendererAbility
      });

      this._lods.sort(function (a, b) {
        return b.distance - a.distance;
      });
    }
    /**
     * 计算当前的激活的LOD层级，并调用它的渲染
     */

  }, {
    key: "render",
    value: function render(camera) {
      if (this._lods.length <= 0) return;
      var dist = miniprogram.Vector3.distance(camera.eyePos, this.entity.worldPosition);
      var lods = this._lods;
      var activeLevel = 0;

      for (var i = lods.length - 1; i >= 0; i--) {
        var _lod = lods[i];

        if (dist < _lod.distance) {
          activeLevel = i;
          break;
        }
      } // end of for


      var lod = lods[activeLevel];
      lod.rendererAbility.render(camera);
    }
  }]);

  return LODGroup;
}(RenderableComponent);

/**
 * 材质对象：RenderTechniqe + 实例化参数，对应 glTF 中的 material 对象
 */
var Material = /*#__PURE__*/function (_RefObject) {
  _inherits(Material, _RefObject);

  var _super = _createSuper(Material);

  /**
   * 名称
   * @member {string}
   */

  /**
   * 材质类型：透明 or 不透明
   * @member {MaterialType}
   */

  /**
   * 是否受到全局雾效影响
   * @member {boolean}
   */

  /**
   * 最大骨骼关节数
   * @member {number}
   */

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function Material(engine, name) {
    var _this;

    _classCallCheck(this, Material);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this.renderType = void 0;
    _this.useFog = void 0;
    _this.maxJointsNum = void 0;
    _this._technique = void 0;
    _this._values = void 0;
    _this.name = name;
    _this.renderType = exports.MaterialType.OPAQUE;
    _this.useFog = true;
    _this.maxJointsNum = 0;
    _this._technique = null;
    _this._values = {};
    return _this;
  }
  /** 创建一个本材质对象的深拷贝对象
   * @param {string} name - 复制的材质名字
   * @param {boolean} cloneTexture - 是否复制纹理，默认 false,共用纹理
   * // todo: texture.clone()
   * */


  _createClass(Material, [{
    key: "clone",
    value: function clone() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;
      var newMtl = new this.constructor(name);
      newMtl.renderType = this.renderType;
      newMtl.useFog = this.useFog;

      for (var _name in this._values) {
        if (this._values.hasOwnProperty(_name)) {
          var val = this._values[_name];

          if (val instanceof Texture) {
            newMtl.setValue(_name, val);
          } else {
            newMtl.setValue(_name, Util.clone(val));
          }
        }
      } // end of for


      return newMtl;
    }
    /**
     * 是否透明
     * @member {boolean}
     */

  }, {
    key: "setValue",

    /**
     * 设定材质参数值
     * 当 texture 发生 无 <-> 有 变化时，需要重新编译
     * TODO: 重构成不需要重新编译 technique 的机制
     * @param {string} name 参数名称
     * @param {*} value 参数值
     */
    value: function setValue(name, value) {
      var oriValue = this.getValue(name);
      var oriIsTexture = oriValue instanceof Texture;
      var curIsTexture = value instanceof Texture;

      if (oriIsTexture) {
        this._removeRefChild(oriValue);
      }

      if (curIsTexture) {
        this._addRefChild(value);
      }

      if (this._generateTechnique && oriIsTexture !== curIsTexture) {
        this._technique = null;
      }

      if (value != null) {
        this._values[name] = value;
      } else {
        this.delValue(name);
      }
    }
    /**
     * 删除材质参数值
     * @param {string} name
     * */

  }, {
    key: "delValue",
    value: function delValue(name) {
      delete this._values[name];
    }
    /**
     * 取得某个参数的当前值
     * @param {string} name 参数名称
     * @return {*} 参数的当前值
     */

  }, {
    key: "getValue",
    value: function getValue(name) {
      return this._values[name];
    }
    /**
     * 开始渲染指定对象
     * @param {CameraComponent} camera 当前摄像机
     * @param {Component} component 当前渲染的对象
     * @param {Primitive} primitive 几何对象
     * @param {Material} originalMaterial 物体本来的材质，用于renderPass使用replaceMaterial时的识别
     * @private
     */

  }, {
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive, originalMaterial) {
      var camera = context.camera; // 设置Unifroms

      var uniforms = this._technique.uniforms;

      for (var name in uniforms) {
        var uniform = uniforms[name];

        this._updateValueBySemantic(uniform, context, component);
      }

      var scene = camera.scene;

      if (scene.hasFogFeature) {
        scene.bindFogToMaterial(this);
      }

      this._technique.compile(camera, component, primitive, this);
    }
    /** 编译前钩子，在编译前可以自定义替换tech的shader,customMacros等配置
     * @param {RenderTechnique} tech - technique
     * @example
     *  tech.fragmentShader=tech.fragmentShader.replace(**,**);
     *  tech.fragmentPrecision='highp'
     * */

  }, {
    key: "preCompile",
    value: function preCompile(tech) {}
    /**
     * 编译后钩子
     * */

  }, {
    key: "postCompile",
    value: function postCompile(tech) {}
    /**
     * 材质渲染前钩子
     * @param {Component} component
     * @param {Primitive} primitive
     * */

  }, {
    key: "preRender",
    value: function preRender(component, primitive) {}
    /**
     * 材质渲染后钩子
     * */

  }, {
    key: "postRender",
    value: function postRender(component, primitive) {}
    /**
     * 按照Uniform的Semantic，自动更新部分参数值
     * @param {object} uniform
     * @param {CameraComponent} camera
     * @param {Component} component
     * @private
     */

  }, {
    key: "_updateValueBySemantic",
    value: function _updateValueBySemantic(uniform, context, component) {
      var _component$jointNodes;

      var values = this._values;

      switch (uniform.semantic) {
        // Transforms from the node's coordinate system to its parent's.
        case exports.UniformSemantic.LOCAL:
          {
            values[uniform.name] = component._entity.transform.localMatrix;
            break;
          }
        // Transforms from model to world coordinates

        case exports.UniformSemantic.MODEL:
          values[uniform.name] = component._entity.transform.worldMatrix;
          break;
        // Transforms from world to view coordinates

        case exports.UniformSemantic.VIEW:
          values[uniform.name] = context.viewMatrix;
          break;
        //Transforms from view to clip

        case exports.UniformSemantic.PROJECTION:
          values[uniform.name] = context.projectionMatrix;
          break;
        // Combined MODEL and VIEW.

        case exports.UniformSemantic.MODELVIEW:
          {
            var view = context.viewMatrix;
            var model = component._entity.transform.worldMatrix;
            var modelView = values[uniform.name];
            if (!modelView) modelView = new miniprogram.Matrix();
            miniprogram.Matrix.multiply(view, model, modelView);
            values[uniform.name] = modelView;
            break;
          }
        // Combined VIEW and PROJECTION.

        case exports.UniformSemantic.VIEWPROJECTION:
          {
            var viewProj = context.viewProjectMatrix;
            values[uniform.name] = viewProj;
            break;
          }
        // Combined MODEL, VIEW, and PROJECTION

        case exports.UniformSemantic.MODELVIEWPROJECTION:
          {
            var _viewProj = context.viewProjectMatrix;
            var _model = component._entity.transform.worldMatrix;
            var MVP = values[uniform.name];
            if (!MVP) MVP = new miniprogram.Matrix();
            miniprogram.Matrix.multiply(_viewProj, _model, MVP);
            values[uniform.name] = MVP;
            break;
          }
        // Inverse of MODEL

        case exports.UniformSemantic.MODELINVERSE:
          values[uniform.name] = component.invModelMatrixs;
          break;
        // Inverse of VIEW

        case exports.UniformSemantic.VIEWINVERSE:
          values[uniform.name] = context.inverseViewMatrix;
          break;
        // Inverse of PROJECTION

        case exports.UniformSemantic.PROJECTIONINVERSE:
          values[uniform.name] = context.inverseProjectionMatrix;
          break;
        // Inverse of MODELVIEW

        case exports.UniformSemantic.MODELVIEWINVERSE:
          {
            var _view = context.viewMatrix;
            var _model2 = component._entity.transform.worldMatrix;
            var invMV = values[uniform.name];
            if (!invMV) invMV = new miniprogram.Matrix();
            miniprogram.Matrix.multiply(_view, _model2, invMV);
            miniprogram.Matrix.invert(invMV, invMV);
            values[uniform.name] = invMV;
            break;
          }
        // Inverse of MODELVIEWPROJECTION

        case exports.UniformSemantic.MODELVIEWPROJECTIONINVERSE:
          {
            var _viewProj2 = context.viewProjectMatrix;
            var _model3 = component._entity.transform.worldMatrix;
            var invMVP = values[uniform.name];
            if (!invMVP) invMVP = new miniprogram.Matrix();
            miniprogram.Matrix.multiply(_viewProj2, _model3, invMVP);
            miniprogram.Matrix.invert(invMVP, invMVP);
            values[uniform.name] = invMVP;
            break;
          }
        // The inverse-transpose of MODEL without the translation

        case exports.UniformSemantic.MODELINVERSETRANSPOSE:
          {
            var modelIT = values[uniform.name];
            if (!modelIT) modelIT = new miniprogram.Matrix3x3();
            miniprogram.Matrix3x3.normalMatrix(component._entity.transform.worldMatrix, modelIT);
            values[uniform.name] = modelIT;
            break;
          }
        // The inverse-transpose of MODELVIEW without the translation.

        case exports.UniformSemantic.MODELVIEWINVERSETRANSPOSE:
          {
            var modelViewIT = values[uniform.name];
            if (!modelViewIT) modelViewIT = new miniprogram.Matrix();
            miniprogram.Matrix.multiply(context.viewMatrix, component._entity.transform.worldMatrix, modelViewIT);
            miniprogram.Matrix.invert(modelViewIT, modelViewIT);
            miniprogram.Matrix.transpose(modelViewIT, modelViewIT);
            values[uniform.name] = modelViewIT;
            break;
          }
        // The viewport's x, y, width, and height properties stored in the x, y, z, and w components, respectively.

        case exports.UniformSemantic.VIEWPORT:
          values[uniform.name] = context.viewport;
          break;
        // Transforms mesh coordinates for a particular joint for skinning and animation.

        case exports.UniformSemantic.JOINTMATRIX:
          values[uniform.name] = component.matrixPalette;
          break;

        case exports.UniformSemantic.JOINTTEXTURE:
          values[uniform.name] = component.jointTexture;
          break;

        case exports.UniformSemantic.JOINTCOUNT:
          values[uniform.name] = (_component$jointNodes = component.jointNodes) === null || _component$jointNodes === void 0 ? void 0 : _component$jointNodes.length;
          break;

        case exports.UniformSemantic.MORPHWEIGHTS:
          values[uniform.name] = component.weights;
          break;
        // Camera 的世界坐标位置

        case exports.UniformSemantic.EYEPOS:
          values[uniform.name] = context.cameraPosition;
          break;
        // 页面启动之后的总时长，单位：秒

        case exports.UniformSemantic.TIME:
          values[uniform.name] = component.engine.time.timeSinceStartup * 0.001;
          break;
      } // end of switch

    }
    /**
     * @override
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {
      // TODO: 待材质重构
      if (this._technique) {
        var values = ObjectValues(this._values);

        for (var i = 0, len = values.length; i < len; i++) {
          var value = values[i];

          if (value instanceof Texture) {
            value._addRefCount(-1);
          }
        }

        this._technique._finalize();

        this._technique = null;
      }
    }
  }, {
    key: "transparent",
    get: function get() {
      return this.renderType === exports.MaterialType.TRANSPARENT;
    },
    set: function set(val) {
      this.renderType = val ? exports.MaterialType.TRANSPARENT : exports.MaterialType.OPAQUE;
    }
    /**
     * 获取所引用的RenderTechnique对象
     * @member {RenderTechnique}
     */

  }, {
    key: "technique",
    get: function get() {
      return this._technique;
    }
    /**
     * 设置所引用的RenderTechnique对象
     */
    ,
    set: function set(tech) {
      this._technique = tech; //-- 重新加载材质参数

      this._values = {};
    }
  }]);

  return Material;
}(RefObject);

/**
 * 管理多个 Technique, 根据渲染的需要自动切换内部的 Technique 对象
 * @remarks 典型应用：Shadow Mapping 算法中，场景使用一个统一的 replace material 渲染深度贴图
 */

var ComplexMaterial = /*#__PURE__*/function (_Material) {
  _inherits(ComplexMaterial, _Material);

  var _super = _createSuper(ComplexMaterial);

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function ComplexMaterial(engine, name) {
    var _this;

    _classCallCheck(this, ComplexMaterial);

    _this = _super.call(this, engine, name);
    _this._techniquePool = void 0;
    _this._techniquePool = {}; // technique pool: [key]->value

    return _this;
  }
  /**
   * 在绘制之前，准备好内部的 Technique 对象
   */


  _createClass(ComplexMaterial, [{
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive) {
      var camera = context.camera;

      var tech = this._requireTechnique(camera, component, primitive);

      if (tech) {
        this._technique = tech;

        _get(_getPrototypeOf(ComplexMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }
    /**
     * 清空所有Technique。
     */

  }, {
    key: "clearTechniques",
    value: function clearTechniques() {
      this._techniquePool = {};
    }
    /**
     * 根据当前对象的渲染需求，取得一个可用的 Technique
     */

  }, {
    key: "_requireTechnique",
    value: function _requireTechnique(camera, component, primitive) {
      var key = this._getTechniqueKey(camera, component, primitive);

      var tech = this._techniquePool[key];

      if (!tech) {
        tech = this._generateTechnique(camera, component, primitive);
        this._techniquePool[key] = tech;
      }

      return tech;
    }
    /**
     * 由派生类去实现，针对某个特定的对象，生成一个新的它所需要的 Technique 对象
     */

  }, {
    key: "_generateTechnique",
    value: function _generateTechnique(camera, component, primitive) {}
    /**
     * 按照当前对象是否为 skin、骨骼个数，生成一个 Technique 的索引字符串
     */

  }, {
    key: "_getTechniqueKey",
    value: function _getTechniqueKey(camera, component, primitive) {
      var isSkin = component.skin != null;
      var jontCount = isSkin ? component.skin.joints.length : 0;
      var key = isSkin ? "skin_" : "static_";

      if (isSkin) {
        key += "jont" + jontCount;
      }

      return key;
    }
  }]);

  return ComplexMaterial;
}(Material);

/**
 * 缓冲的用途。
 */

(function (BufferUsage) {
  BufferUsage[BufferUsage["Static"] = 0] = "Static";
  BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
  BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
})(exports.BufferUsage || (exports.BufferUsage = {}));

/**
 * 顶点元素格式。
 */

(function (VertexElementFormat) {
  VertexElementFormat[VertexElementFormat["Float"] = 0] = "Float";
  VertexElementFormat[VertexElementFormat["Vector2"] = 1] = "Vector2";
  VertexElementFormat[VertexElementFormat["Vector3"] = 2] = "Vector3";
  VertexElementFormat[VertexElementFormat["Vector4"] = 3] = "Vector4";
  VertexElementFormat[VertexElementFormat["Byte4"] = 4] = "Byte4";
  VertexElementFormat[VertexElementFormat["UByte4"] = 5] = "UByte4";
  VertexElementFormat[VertexElementFormat["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat[VertexElementFormat["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat[VertexElementFormat["Short2"] = 8] = "Short2";
  VertexElementFormat[VertexElementFormat["UShort2"] = 9] = "UShort2";
  VertexElementFormat[VertexElementFormat["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat[VertexElementFormat["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat[VertexElementFormat["Short4"] = 12] = "Short4";
  VertexElementFormat[VertexElementFormat["UShort4"] = 13] = "UShort4";
  VertexElementFormat[VertexElementFormat["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat[VertexElementFormat["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(exports.VertexElementFormat || (exports.VertexElementFormat = {}));

/**
 * 索引格式。
 */

(function (IndexFormat) {
  IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
  IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
  IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
})(exports.IndexFormat || (exports.IndexFormat = {}));

var BufferUtil = /*#__PURE__*/function () {
  function BufferUtil() {
    _classCallCheck(this, BufferUtil);
  }

  _createClass(BufferUtil, null, [{
    key: "_getGLBufferUsage",

    /**
     * @internal
     */
    value: function _getGLBufferUsage(gl, bufferUsage) {
      switch (bufferUsage) {
        case exports.BufferUsage.Static:
          return gl.STATIC_DRAW;

        case exports.BufferUsage.Dynamic:
          return gl.DYNAMIC_DRAW;

        case exports.BufferUsage.Stream:
          return gl.STREAM_DRAW;
      }
    }
  }, {
    key: "_getGLIndexType",
    value: function _getGLIndexType(indexFormat) {
      switch (indexFormat) {
        case exports.IndexFormat.UInt8:
          return exports.DataType.UNSIGNED_BYTE;

        case exports.IndexFormat.UInt16:
          return exports.DataType.UNSIGNED_SHORT;

        case exports.IndexFormat.UInt32:
          return exports.DataType.UNSIGNED_INT;
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_getElementInfo",
    value: function _getElementInfo(format) {
      var size;
      var type;

      switch (format) {
        case exports.VertexElementFormat.Float:
          size = 1;
          type = exports.DataType.FLOAT;
          break;

        case exports.VertexElementFormat.Vector2:
          size = 2;
          type = exports.DataType.FLOAT;
          break;

        case exports.VertexElementFormat.Vector3:
          size = 3;
          type = exports.DataType.FLOAT;
          break;

        case exports.VertexElementFormat.Vector4:
          size = 4;
          type = exports.DataType.FLOAT;
          break;

        case exports.VertexElementFormat.Byte4:
          size = 4;
          type = exports.DataType.UNSIGNED_BYTE;
          break;

        case exports.VertexElementFormat.Short2:
          size = 2;
          type = exports.DataType.SHORT;
          break;

        case exports.VertexElementFormat.Short4:
          size = 4;
          type = exports.DataType.SHORT;
          break;

        case exports.VertexElementFormat.UShort2:
          size = 2;
          type = exports.DataType.UNSIGNED_SHORT;
          break;

        case exports.VertexElementFormat.UShort4:
          size = 4;
          type = exports.DataType.UNSIGNED_SHORT;
          break;
      }

      return {
        size: size,
        type: type
      };
    }
  }]);

  return BufferUtil;
}();

/**
 * 缓冲绑定标记。
 */

(function (BufferBindFlag) {
  BufferBindFlag[BufferBindFlag["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag[BufferBindFlag["IndexBuffer"] = 1] = "IndexBuffer";
})(exports.BufferBindFlag || (exports.BufferBindFlag = {}));

/**
 * 定义 Buffer 在 SetData 时如何刷新。
 */

(function (SetDataOptions) {
  SetDataOptions[SetDataOptions["None"] = 0] = "None";
  SetDataOptions[SetDataOptions["Discard"] = 1] = "Discard";
})(exports.SetDataOptions || (exports.SetDataOptions = {}));

/**
 * 缓冲。
 */

var Buffer = /*#__PURE__*/function (_RefObject) {
  _inherits(Buffer, _RefObject);

  var _super = _createSuper(Buffer);

  _createClass(Buffer, [{
    key: "engine",

    /**
     * 引擎。
     */
    get: function get() {
      return this._engine;
    }
    /**
     * 缓冲类型。
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * 长度,以字节为单位。
     */

  }, {
    key: "byteLength",
    get: function get() {
      return this._byteLength;
    }
    /**
     * 缓冲用途
     */

  }, {
    key: "bufferUsage",
    get: function get() {
      return this._bufferUsage;
    }
    /**
     * 创建缓冲。
     * @param engine - 引擎
     * @param type - 缓冲类型
     * @param byteLength - 长度，字节为单位
     * @param bufferUsage - 缓冲用途
     */

  }]);

  function Buffer(engine, type, byteLengthOrData) {
    var _this;

    var bufferUsage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.BufferUsage.Static;

    _classCallCheck(this, Buffer);

    _this = _super.call(this, engine);
    _this._glBindTarget = void 0;
    _this._glBufferUsage = void 0;
    _this._nativeBuffer = void 0;
    _this._hardwareRenderer = void 0;
    _this._type = void 0;
    _this._byteLength = void 0;
    _this._bufferUsage = void 0;
    _this._engine = engine;
    _this._type = type;
    _this._bufferUsage = bufferUsage;
    var hardwareRenderer = engine._hardwareRenderer;
    var gl = hardwareRenderer.gl;

    var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);

    var glBindTarget = type === exports.BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    _this._nativeBuffer = gl.createBuffer();
    _this._hardwareRenderer = hardwareRenderer;
    _this._glBufferUsage = glBufferUsage;
    _this._glBindTarget = glBindTarget;

    _this.bind();

    if (typeof byteLengthOrData === "number") {
      _this._byteLength = byteLengthOrData;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    } else {
      _this._byteLength = byteLengthOrData.byteLength;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    }

    gl.bindBuffer(glBindTarget, null);
    return _this;
  }
  /**
   * 绑定。
   */


  _createClass(Buffer, [{
    key: "bind",
    value: function bind() {
      var gl = this._hardwareRenderer.gl;
      gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
    }
    /**
     * 设置缓冲数据。
     * @param data - 数据
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var bufferByteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var dataOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var dataLength = arguments.length > 3 ? arguments[3] : undefined;
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : exports.SetDataOptions.None;
      var gl = this._hardwareRenderer.gl;
      var isWebGL2 = this._hardwareRenderer.isWebGL2;
      var glBindTarget = this._glBindTarget;
      this.bind();

      if (options === exports.SetDataOptions.Discard) {
        gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
      } // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1


      var byteSize = data.BYTES_PER_ELEMENT || 1;
      var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;

      if (dataOffset !== 0 || dataByteLength < data.byteLength) {
        var isArrayBufferView = data.byteOffset !== undefined;

        if (isWebGL2 && isArrayBufferView) {
          gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
        } else {
          var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
          gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
        }
      } else {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data);
      }

      gl.bindBuffer(glBindTarget, null);
    }
    /**
     * 获取缓冲数据。
     * @param data - 缓冲输出数据
     */

  }, {
    key: "getData",
    value: function getData(data) {
      var bufferByteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var dataOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var dataLength = arguments.length > 3 ? arguments[3] : undefined;
      var isWebGL2 = this._hardwareRenderer.isWebGL2;

      if (isWebGL2) {
        var gl = this._hardwareRenderer.gl;
        this.bind();
        gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
      } else {
        throw "Buffer is write-only on WebGL1.0 platforms.";
      }
    }
    /**
     * @override
     * 销毁。
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {
      var gl = this._hardwareRenderer.gl;
      gl.deleteBuffer(this._nativeBuffer);
      this._nativeBuffer = null;
      this._hardwareRenderer = null;
    }
    /**
     * @deprecated
     */

  }, {
    key: "resize",
    value: function resize(dataLength) {
      this.bind();
      var gl = this._hardwareRenderer.gl;
      gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
      this._byteLength = dataLength;
    }
  }]);

  return Buffer;
}(RefObject);

/**
 * 绘制基元拓扑。
 */

(function (PrimitiveTopology) {
  PrimitiveTopology[PrimitiveTopology["Points"] = 0] = "Points";
  PrimitiveTopology[PrimitiveTopology["Lines"] = 1] = "Lines";
  PrimitiveTopology[PrimitiveTopology["LineLoop"] = 2] = "LineLoop";
  PrimitiveTopology[PrimitiveTopology["LineStrip"] = 3] = "LineStrip";
  PrimitiveTopology[PrimitiveTopology["Triangles"] = 4] = "Triangles";
  PrimitiveTopology[PrimitiveTopology["TriangleStrip"] = 5] = "TriangleStrip";
  PrimitiveTopology[PrimitiveTopology["TriangleFan"] = 6] = "TriangleFan";
})(exports.PrimitiveTopology || (exports.PrimitiveTopology = {}));

/**
 * 索引缓冲绑定。
 */
var IndexBufferBinding = /*#__PURE__*/function () {
  _createClass(IndexBufferBinding, [{
    key: "buffer",

    /** @internal */

    /** @internal */

    /**
     * 索引缓冲。
     */
    get: function get() {
      return this._buffer;
    }
    /**
     * 索引格式。
     */

  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
    /**
     * 创建索引缓冲绑定。
     * @param buffer - 索引缓冲
     * @param format - 索引格式
     */

  }]);

  function IndexBufferBinding(buffer, format) {
    _classCallCheck(this, IndexBufferBinding);

    this._buffer = void 0;
    this._format = void 0;
    this._buffer = buffer;
    this._format = format;
  }

  return IndexBufferBinding;
}();

/**
 * 顶点缓冲绑定。
 */
var VertexBufferBinding = /*#__PURE__*/function () {
  _createClass(VertexBufferBinding, [{
    key: "buffer",

    /** @internal */

    /** @internal */

    /**
     * 顶点缓冲。
     */
    get: function get() {
      return this._buffer;
    }
    /**
     * 顶点跨度。
     */

  }, {
    key: "stride",
    get: function get() {
      return this._stride;
    }
    /**
     * 创建顶点缓冲绑定。
     * @param buffer - 顶点缓冲
     * @param stride - 顶点跨度
     */

  }]);

  function VertexBufferBinding(buffer, stride) {
    _classCallCheck(this, VertexBufferBinding);

    this._buffer = void 0;
    this._stride = void 0;
    this._buffer = buffer;
    this._stride = stride;
  }

  return VertexBufferBinding;
}();

/**
 * @private
 */
var Primitive = /*#__PURE__*/function (_RefObject) {
  _inherits(Primitive, _RefObject);

  var _super = _createSuper(Primitive);

  _createClass(Primitive, [{
    key: "vertexBufferBindings",

    /** 名称。*/

    /** 实例数量，0 表示关闭实例渲染。*/

    /**
     * 顶点缓冲绑定信息集合。
     */
    get: function get() {
      return this._vertexBufferBindings;
    }
    /**
     * 顶点元素集合。
     */

  }, {
    key: "vertexElements",
    get: function get() {
      return this._vertexElements;
    }
    /**
     * 索引缓冲绑定信息。
     */

  }, {
    key: "indexBufferBinding",
    get: function get() {
      return this._indexBufferBinding;
    }
  }]);

  function Primitive(engine, name) {
    var _this;

    _classCallCheck(this, Primitive);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this.instanceCount = 0;
    _this._vertexElementMap = {};
    _this._glIndexType = void 0;
    _this._platformPrimitive = void 0;
    _this._vertexBufferBindings = [];
    _this._indexBufferBinding = null;
    _this._vertexElements = [];
    _this.targets = [];
    _this.boundingBox = null;
    _this.boundingSphere = null;
    _this.isInFrustum = true;
    _this.name = name;
    _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * 设置顶点缓冲绑定。
   * @param vertexBuffer - 顶点缓冲
   * @param stride - 顶点缓冲跨度
   * @param firstIndex - 顶点缓冲绑定索引,默认值为 0
   */


  _createClass(Primitive, [{
    key: "setVertexBufferBinding",
    value: function setVertexBufferBinding(bufferOrBinding) {
      var strideOrFirstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var firstIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var binding = bufferOrBinding;
      var isBinding = binding.buffer !== undefined;
      isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
      var bindings = this._vertexBufferBindings;
      bindings.length <= firstIndex && (bindings.length = firstIndex + 1);

      this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : firstIndex, binding);
    }
    /**
     * 设置顶点缓冲绑定信息。
     * @param bufferBindings - 缓冲绑定集合
     * @param firstIndex - 第一个绑定索引
     */

  }, {
    key: "setVertexBufferBindings",
    value: function setVertexBufferBindings(bufferBindings) {
      var firstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bindings = this._vertexBufferBindings;
      var multiBindings = bufferBindings;
      var count = multiBindings.length;
      var needLength = firstIndex + count;
      bindings.length < needLength && (bindings.length = needLength);

      for (var i = 0; i < count; i++) {
        this._setVertexBufferBinding(firstIndex + i, multiBindings[i]);
      }
    }
    /**
     * 设置索引缓冲绑定。
     * @param buffer - 索引缓冲
     * @param format - 索引缓冲格式
     */

  }, {
    key: "setIndexBufferBinding",
    value: function setIndexBufferBinding(bufferOrBinding, format) {
      var binding = bufferOrBinding;
      var isBinding = binding.buffer !== undefined;
      isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
      this._indexBufferBinding = binding;
      this._glIndexType = BufferUtil._getGLIndexType(binding.format);
    }
    /**
     * 设置顶点元素集合。
     * @param elements - 顶点元素集合
     */

  }, {
    key: "setVertexElements",
    value: function setVertexElements(elements) {
      this._clearVertexElements();

      for (var i = 0, n = elements.length; i < n; i++) {
        this._addVertexElement(elements[i]);
      }
    }
    /**
     * 绘制。
     */

  }, {
    key: "draw",
    value: function draw(tech, subPrimitive) {
      this._platformPrimitive.draw(tech, subPrimitive);
    }
    /**
     * @override
     * 销毁。
     */

  }, {
    key: "_onDestroy",
    value: function _onDestroy() {
      this._vertexBufferBindings = null;
      this._indexBufferBinding = null;
      this._vertexElements = null;
      this._vertexElementMap = null;

      this._platformPrimitive.destroy();
    }
  }, {
    key: "_clearVertexElements",
    value: function _clearVertexElements() {
      this._vertexElements.length = 0;
      var vertexElementMap = this._vertexElementMap;

      for (var k in vertexElementMap) {
        delete vertexElementMap[k];
      }
    }
  }, {
    key: "_addVertexElement",
    value: function _addVertexElement(element) {
      this._vertexElementMap[element.semantic] = element;

      this._vertexElements.push(element);
    }
  }, {
    key: "_setVertexBufferBinding",
    value: function _setVertexBufferBinding(index, buffer) {
      var originBufferBinding = this._vertexBufferBindings[index];

      if (originBufferBinding) {
        this._removeRefChild(originBufferBinding._buffer);
      }

      this._addRefChild(buffer._buffer);

      this._vertexBufferBindings[index] = buffer;
    }
  }]);

  return Primitive;
}(RefObject);

/**
 * 顶点元素。
 */

var VertexElement = /*#__PURE__*/function () {
  _createClass(VertexElement, [{
    key: "semantic",

    /**
     * 顶点输入签名。
     */
    get: function get() {
      return this._semantic;
    }
    /**
     * 顶点的偏移，以字节为单位。
     */

  }, {
    key: "offset",
    get: function get() {
      return this._offset;
    }
    /**
     * 顶点元素格式。
     */

  }, {
    key: "format",
    get: function get() {
      return this._format;
    }
    /**
     * 顶点缓冲绑定索引。
     */

  }, {
    key: "bindingIndex",
    get: function get() {
      return this._bindingIndex;
    }
    /**
     * 实例步频，在缓冲中每前进一个顶点绘制的实例数量，非实例元素必须为 0。
     */

  }, {
    key: "instanceStepRate",
    get: function get() {
      return this._instanceStepRate;
    }
    /**
     * 构造顶点元素。
     * @param semantic - 顶点着色器输入签名
     * @param offset - 顶点的偏移，以字节为单位
     * @param format - 顶点元素格式
     * @param bindingIndex - 顶点缓冲绑定索引
     * @param instanceStepRate - 实例步频，在缓冲中每前进一个顶点绘制的实例数量，非实例元素必须为 0
     */

  }]);

  function VertexElement(semantic, offset, format, bindingIndex) {
    var instanceStepRate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    _classCallCheck(this, VertexElement);

    this.normalized = false;
    this._glElementInfo = void 0;
    this._semantic = void 0;
    this._offset = void 0;
    this._format = void 0;
    this._bindingIndex = void 0;
    this._instanceStepRate = void 0;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }
  /**
   * @deprecated
   */


  _createClass(VertexElement, [{
    key: "elementInfo",
    get: function get() {
      return this._glElementInfo;
    }
  }]);

  return VertexElement;
}();

/**
 * 子图元。
 */

var SubPrimitive =
/** 起始绘制偏移。*/

/** 绘制数量。*/

/** 图元拓扑。*/

/**
 * 创建子图元。
 * @param start - 起始绘制偏移
 * @param count - 数量
 * @param topology - 图元拓扑
 */
function SubPrimitive() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var topology = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.PrimitiveTopology.Triangles;

  _classCallCheck(this, SubPrimitive);

  this.start = void 0;
  this.count = void 0;
  this.topology = void 0;
  this.start = start;
  this.count = count;
  this.topology = topology;
};

var common = "#define PI 3.14159265359\n#define LOG2 1.442695\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\n// nosie common\n#include <noise_common>\n";

var common_vert = "attribute vec3 a_position;\n\n#ifdef O3_HAS_UV\n\nattribute vec2 a_uv;\n\n#endif\n\n#ifdef O3_HAS_NORMAL\n\nattribute vec3 a_normal;\n\n#endif\n\n#ifdef O3_HAS_TANGENT\n\nattribute vec4 a_tangent;\n\n#endif\n\n#ifdef O3_HAS_VERTEXCOLOR\n\nattribute vec4 a_color;\n\n#endif\n\n#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\n    attribute vec4 a_joint;\n    attribute vec4 a_weight;\n\n    #ifdef O3_USE_JOINT_TEXTURE\n        uniform sampler2D u_jointSampler;\n        uniform float u_jointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index)\n        {\n            float base = index / u_jointCount;\n            float hf = 0.5 / u_jointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n\n        }\n\n    #elif defined( O3_JOINTS_NUM )\n        uniform mat4 u_jointMatrix[ O3_JOINTS_NUM ];\n    #endif\n#endif\n\nuniform mat4 u_localMat;\nuniform mat4 u_modelMat;\nuniform mat4 u_viewMat;\nuniform mat4 u_projMat;\nuniform mat4 u_MVMat;\nuniform mat4 u_MVPMat;\nuniform mat3 u_normalMat;\nuniform vec3 u_cameraPos;\nuniform float u_time;\n";

var common_frag = "uniform O3_VERTEX_PRECISION mat4 u_localMat;\nuniform O3_VERTEX_PRECISION mat4 u_modelMat;\nuniform O3_VERTEX_PRECISION mat4 u_viewMat;\nuniform O3_VERTEX_PRECISION mat4 u_projMat;\nuniform O3_VERTEX_PRECISION mat4 u_MVMat;\nuniform O3_VERTEX_PRECISION mat4 u_MVPMat;\nuniform O3_VERTEX_PRECISION mat3 u_normalMat;\nuniform O3_VERTEX_PRECISION vec3 u_cameraPos;\nuniform O3_VERTEX_PRECISION float u_time;\n";

var color_share = "#ifdef O3_HAS_VERTEXCOLOR\n\nvarying vec4 v_color;\n\n#endif\n";

var normal_share = "#ifdef O3_HAS_NORMAL\n\n    #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n    varying mat3 v_TBN;\n\n    #else\n\n    varying vec3 v_normal;\n\n    #endif\n\n#endif\n";

var uv_share = "varying vec2 v_uv;\n";

var worldpos_share = "#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\n\nvarying vec3 v_pos;\n\n#endif\n";

var shadow_share = "#ifdef O3_GENERATE_SHADOW_MAP\n\nuniform mat4 u_viewMatFromLight;\nuniform mat4 u_projMatFromLight;\n\n#endif\n\n#ifdef O3_SHADOW_MAP_COUNT\n\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];\nuniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n\n#endif\n";

var fog_share = "#ifdef O3_HAS_FOG\n\nvarying vec3 v_fogDepth;\n\nuniform O3_VERTEX_PRECISION vec3 u_fogColor;\n\n    #ifdef O3_FOG_EXP2\n\n        uniform O3_VERTEX_PRECISION float u_fogDensity;\n\n    #else\n\n        uniform O3_VERTEX_PRECISION float u_fogNear;\n        uniform O3_VERTEX_PRECISION float u_fogFar;\n\n    #endif\n\n#endif\n";

var begin_normal_vert = "    #ifdef O3_HAS_NORMAL\n\n    vec3 normal = vec3( a_normal );\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec4 tangent = vec4( a_tangent );\n\n        #endif\n\n    #endif\n";

var begin_position_vert = "    vec4 position = vec4( a_position , 1.0 );\n";

var morph_target_vert = "#ifdef O3_HAS_MORPH\n\n    uniform float u_morphWeights[ O3_MORPH_NUM ];\n\n    #ifdef O3_MORPH_POSITION\n\n    attribute vec3 a_position0;\n\n    #endif\n\n    #ifdef O3_MORPH_NORMAL\n\n    attribute vec3 a_normal0;\n\n    #endif\n\n    #ifdef O3_MORPH_TANGENT\n\n    attribute vec3 a_tangent0;\n\n    #endif\n\n    #if O3_MORPH_NUM > 1\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position1;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal1;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent1;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 2\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position2;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal2;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent2;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 3\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position3;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal3;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent3;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 4\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position4;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal4;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent4;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 5\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position5;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal5;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent5;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 6\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position6;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal6;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent6;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 7\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position7;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal7;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent7;\n\n        #endif\n\n    #endif\n\n#endif\n";

var position_vert = "    #ifndef O3_GENERATE_SHADOW_MAP\n\n    gl_Position = u_MVPMat * position;\n\n    #endif\n";

var color_vert = "    #ifdef O3_HAS_VERTEXCOLOR\n\n    v_color = a_color;\n\n    #endif\n";

var normal_vert = "    #ifdef O3_HAS_NORMAL\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec3 normalW = normalize( u_normalMat * normal.xyz );\n        vec3 tangentW = normalize( u_normalMat * tangent.xyz );\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\n        v_TBN = mat3( tangentW, bitangentW, normalW );\n\n        #else\n\n        v_normal = normalize( u_normalMat * normal );\n\n        #endif\n\n    #endif\n";

var skinning_vert = "#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\n\n        #ifdef O3_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                a_weight.x * getJointMatrix(u_jointSampler, a_joint.x ) +\n                a_weight.y * getJointMatrix(u_jointSampler, a_joint.y ) +\n                a_weight.z * getJointMatrix(u_jointSampler, a_joint.z ) +\n                a_weight.w * getJointMatrix(u_jointSampler, a_joint.w );\n\n        #elif defined( O3_JOINTS_NUM )\n            mat4 skinMatrix =\n                a_weight.x * u_jointMatrix[ int( a_joint.x ) ] +\n                a_weight.y * u_jointMatrix[ int( a_joint.y ) ] +\n                a_weight.z * u_jointMatrix[ int( a_joint.z ) ] +\n                a_weight.w * u_jointMatrix[ int( a_joint.w ) ];\n        #endif\n\n        position = skinMatrix * position;\n\n        #ifdef O3_HAS_NORMAL\n            normal = vec4( skinMatrix * vec4( normal, 0.0 ) ).xyz;\n            #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n                tangent.xyz = vec4( skinMatrix * vec4( tangent.xyz, 0.0 ) ).xyz;\n            #endif\n\n        #endif\n\n#endif\n";

var uv_vert = "    #ifdef O3_HAS_UV\n\n    v_uv = a_uv;\n\n    #else\n\n    // may need this calculate normal\n    v_uv = vec2( 0., 0. );\n\n    #endif\n";

var worldpos_vert = "    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\n\n    vec4 temp_pos = u_modelMat * position;\n    v_pos = temp_pos.xyz / temp_pos.w;\n\n    #endif\n";

var shadow_vert = "    #ifdef O3_GENERATE_SHADOW_MAP\n\n    gl_Position = u_projMatFromLight * u_viewMatFromLight * u_modelMat * position;\n\n    #endif\n\n    #ifdef O3_SHADOW_MAP_COUNT\n\n    for (int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\n\n        v_PositionFromLight[i] = u_projMatFromLight[i] * u_viewMatFromLight[i] * u_modelMat * vec4( a_position, 1.0 );\n\n    }\n\n    #endif\n";

var morph_vert = "    #ifdef O3_HAS_MORPH\n\n        #if defined( O3_MORPH_POSITION )\n\n        position.xyz += u_morphWeights[ 0 ] * a_position0;\n\n            #if O3_MORPH_NUM > 1\n\n            position.xyz += u_morphWeights[ 1 ] * a_position1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            position.xyz += u_morphWeights[ 2 ] * a_position2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            position.xyz += u_morphWeights[ 3 ] * a_position3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            position.xyz += u_morphWeights[ 4 ] * a_position4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            position.xyz += u_morphWeights[ 5 ] * a_position5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            position.xyz += u_morphWeights[ 6 ] * a_position6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            position.xyz += u_morphWeights[ 7 ] * a_position7;\n\n            #endif\n\n        #endif\n\n        #if defined( O3_HAS_NORMAL ) && defined( O3_MORPH_NORMAL )\n\n        normal.xyz += u_morphWeights[ 0 ] * a_normal0;\n\n            #if O3_MORPH_NUM > 1\n\n            normal.xyz += u_morphWeights[ 1 ] * a_normal1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            normal.xyz += u_morphWeights[ 2 ] * a_normal2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            normal.xyz += u_morphWeights[ 3 ] * a_normal3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            normal.xyz += u_morphWeights[ 4 ] * a_normal4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            normal.xyz += u_morphWeights[ 5 ] * a_normal5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            normal.xyz += u_morphWeights[ 6 ] * a_normal6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            normal.xyz += u_morphWeights[ 7 ] * a_normal7;\n\n            #endif\n\n        #endif\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_MORPH_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        tangent.xyz += u_morphWeights[ 0 ] * a_tangent0;\n\n            #if O3_MORPH_NUM > 1\n\n            tangent.xyz += u_morphWeights[ 1 ] * a_tangent1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            tangent.xyz += u_morphWeights[ 2 ] * a_tangent2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            tangent.xyz += u_morphWeights[ 3 ] * a_tangent3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            tangent.xyz += u_morphWeights[ 4 ] * a_tangent4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            tangent.xyz += u_morphWeights[ 5 ] * a_tangent5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            tangent.xyz += u_morphWeights[ 6 ] * a_tangent6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            tangent.xyz += u_morphWeights[ 7 ] * a_tangent7;\n\n            #endif\n\n        #endif\n\n    #endif\n";

var fog_vert = "    #ifdef O3_HAS_FOG\n\n    v_fogDepth = ( u_MVMat * position ).xyz;\n\n    #endif\n";

var ambient_light_frag = "#ifdef O3_HAS_AMBIENT_LIGHT\n\nstruct AmbientLight {\n    vec3 color;\n    vec3 lightColor;\n    float intensity;\n};\nuniform AmbientLight u_ambientLight;\n\n#endif\n";

var direct_light_frag = "#ifdef O3_DIRECT_LIGHT_COUNT\n\nstruct DirectLight {\n    vec3 color;\n    vec3 lightColor;\n    float intensity;\n    vec3 direction;\n};\nuniform DirectLight u_directLights[ O3_DIRECT_LIGHT_COUNT ];\n\n#endif\n";

var point_light_frag = "#ifdef O3_POINT_LIGHT_COUNT\n\nstruct PointLight {\n    vec3 color;\n    vec3 lightColor;\n    vec3 position;\n    float intensity;\n    float distance;\n    float decay;\n};\nuniform PointLight u_pointLights[ O3_POINT_LIGHT_COUNT ];\n\n#endif\n";

var spot_light_frag = "#ifdef O3_SPOT_LIGHT_COUNT\n\nstruct SpotLight {\n    vec3 color;\n    vec3 lightColor;\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    float distance;\n    float decay;\n    float angle;\n    float penumbra;\n    float coneCos;\n    float penumbraCos;\n};\nuniform SpotLight u_spotLights[ O3_SPOT_LIGHT_COUNT ];\n\n#endif\n";

var mobile_material_frag = "uniform float u_shininess;\n\n#ifdef O3_EMISSION_TEXTURE\n\nuniform sampler2D u_emission;\n\n#else\n\nuniform vec4 u_emission;\n\n#endif\n\n#ifdef O3_AMBIENT_TEXTURE\n\nuniform sampler2D u_ambient;\n\n#else\n\nuniform vec4 u_ambient;\n\n#endif\n\n#ifdef O3_DIFFUSE_TEXTURE\n\nuniform sampler2D u_diffuse;\n\n#else\n\nuniform vec4 u_diffuse;\n\n#endif\n\n#ifdef O3_SPECULAR_TEXTURE\n\nuniform sampler2D u_specular;\n\n#else\n\nuniform vec4 u_specular;\n\n#endif\n";

var fog_frag = "    #ifdef O3_HAS_FOG\n\n    float fogDepth = length( v_fogDepth );\n\n        #ifdef O3_FOG_EXP2\n\n            float fogFactor = whiteCompliment( exp2( - u_fogDensity * u_fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n        #else\n\n            float fogFactor = smoothstep( u_fogNear, u_fogFar, fogDepth );\n\n        #endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, u_fogColor, fogFactor );\n\n    #endif\n";

var begin_mobile_frag = "    #ifdef O3_EMISSION_TEXTURE\n\n    vec4 emission = texture2D(u_emission, v_uv);\n\n    #else\n\n    vec4 emission = u_emission;\n\n    #endif\n\n    vec4 ambient = vec4(0);\n    #ifdef O3_HAS_AMBIENT_LIGHT\n        #ifdef O3_AMBIENT_TEXTURE\n            ambient = texture2D(u_ambient, v_uv) * vec4(u_ambientLight.lightColor, 1.0);\n         #else\n            ambient = u_ambient * vec4(u_ambientLight.lightColor, 1.0);\n         #endif\n    #endif\n\n    #ifdef O3_DIFFUSE_TEXTURE\n\n    vec4 diffuse = texture2D(u_diffuse, v_uv);\n\n    #else\n\n    vec4 diffuse = u_diffuse;\n\n    #endif\n\n    #ifdef O3_SPECULAR_TEXTURE\n\n    vec4 specular = texture2D(u_specular, v_uv);\n\n    #else\n\n    vec4 specular = u_specular;\n\n    #endif\n";

var begin_normal_frag = "    #ifdef O3_HAS_NORMAL\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec3 N = normalize( v_TBN[ 2 ] );\n\n        #else\n\n        vec3 N = normalize( v_normal );\n\n        #endif\n\n    #endif\n";

var begin_viewdir_frag = "    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP )\n\n    vec3 V =  normalize( u_cameraPos - v_pos );\n\n    #endif\n";

var mobile_blinnphong_frag = "    #ifdef O3_HAS_NORMAL\n         N *= float( gl_FrontFacing ) * 2.0 - 1.0;\n    #else\n         vec3 N = vec3(0, 0, 1);\n    #endif\n\n\n    vec3 lightDiffuse = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightSpecular = vec3( 0.0, 0.0, 0.0 );\n\n    #ifdef O3_DIRECT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ) {\n        DirectLight lgt = u_directLights[ i ];\n\n        float d = max(dot(N, -lgt.direction), 0.0)*lgt.intensity;\n        lightDiffuse += lgt.color*d;\n\n        vec3 halfDir = normalize( V - lgt.direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity;\n        lightSpecular += lgt.color * s;\n    }\n\n    #endif\n\n    #ifdef O3_POINT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_POINT_LIGHT_COUNT; i++ ) {\n        PointLight lgt = u_pointLights[ i ];\n        vec3 direction = v_pos - lgt.position;\n        float dist = length( direction );\n        direction /= dist;\n        float decay = pow( max( 0.0, 1.0-dist/lgt.distance ), 2.0 );\n\n        float d =  max( dot( N, -direction ), 0.0 )*lgt.intensity*decay;\n        lightDiffuse += lgt.color*d;\n\n        vec3 halfDir = normalize( V - direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay;\n        lightSpecular += lgt.color * s;\n\n    }\n\n    #endif\n\n    #ifdef O3_SPOT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_SPOT_LIGHT_COUNT; i++) {\n        SpotLight lgt = u_spotLights[ i ];\n        vec3 direction = v_pos - lgt.position;\n        float angle = acos( dot( normalize( direction ), normalize( lgt.direction ) ) );\n        float dist = length( direction );\n        direction /= dist;\n        float decay = pow( max( 0.0, 1.0 - dist / lgt.distance ), 2.0 );\n\n        float hasLight = step( angle, lgt.angle );\n        float hasPenumbra = step( lgt.angle, angle ) * step( angle, lgt.angle * ( 1.0 + lgt.penumbra ) );\n        float penumbra = hasPenumbra * ( 1.0 - ( angle - lgt.angle ) / ( lgt.angle * lgt.penumbra ) );\n        float d = max( dot( N, -direction ), 0.0 ) * lgt.intensity * decay * ( penumbra + hasLight );\n        lightDiffuse += lgt.color * d;\n\n        vec3 halfDir = normalize( V - direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay * ( penumbra + hasLight );\n        lightSpecular += lgt.color * s;\n\n    }\n\n    #endif\n\n    diffuse *= vec4( lightDiffuse, 1.0 );\n    specular *= vec4( lightSpecular, 1.0 );\n";

var mobile_lambert_frag = "    vec3 totalLight = vec3(0.0, 0.0, 0.0);\n    #ifdef O3_DIRECT_LIGHT_COUNT\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ){\n        vec3 lightColor = u_directLights[ i ].color * u_directLights[ i ].intensity;\n        lightColor *= max( dot( N, -u_directLights[ i ].direction ), 0.0 );\n\n        totalLight += lightColor;\n    }\n    #endif\n    diffuse *= vec4( totalLight, 1.0 );\n";

var noise_common = "// Modulo 289 without a division (only multiplications)\nvec4 mod289( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec3 mod289( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec2 mod289( vec2 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nfloat mod289( float x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\n// Modulo 7 without a division\nvec4 mod7( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\nvec3 mod7( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute( vec4 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x);\n\n}\n\nvec3 permute( vec3 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x );\n\n}\n\nfloat permute( float x ) {\n\n  return mod289( ( ( x * 34.0 ) + 1.0 ) * x );\n\n}\n\nvec4 taylorInvSqrt( vec4 r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nfloat taylorInvSqrt( float r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nvec4 fade( vec4 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec3 fade( vec3 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec2 fade( vec2 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kd2 0.0714285714285 // K/2\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n#define jitter1 0.8 // smaller jitter gives less errors in F1 F2\n";

var noise_cellular_2D = "\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec3 oi = vec3( -1.0, 0.0, 1.0);\n\tvec3 of = vec3( -0.5, 0.5, 1.5);\n\tvec3 px = permute( Pi.x + oi );\n\tvec3 p = permute( px.x + Pi.y + oi ); // p11, p12, p13\n\tvec3 ox = fract( p * K ) - Ko;\n\tvec3 oy = mod7( floor( p * K ) ) * K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter * ox;\n\tvec3 dy = Pf.y - of + jitter * oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute( px.y + Pi.y + oi ); // p21, p22, p23\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 0.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute( px.z + Pi.y + oi ); // p31, p32, p33\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 1.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min( d1, d2 );\n\td2 = max( d1, d2 ); // Swap to keep candidates for F2\n\td2 = min( d2, d3 ); // neither F1 nor F2 are now in d3\n\td1 = min( d1a, d2 ); // F1 is now in d1\n\td2 = max( d1a, d2 ); // Swap to keep candidates for F2\n\td1.xy = ( d1.x < d1.y ) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = ( d1.x < d1.z ) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min( d1.yz, d2.yz ); // F2 is now not in d2.yz\n\td1.y = min( d1.y, d1.z ); // nor in  d1.z\n\td1.y = min( d1.y, d2.x ); // F2 is in d1.y, we're done.\n\treturn sqrt( d1.xy );\n\n}\n";

var noise_cellular_2x2 = "\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\n\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 ox = mod7( p ) * K + Kd2;\n\tvec4 oy = mod7( floor( p * K ) ) * K + Kd2;\n\tvec4 dx = Pfx + jitter1 * ox;\n\tvec4 dy = Pfy + jitter1 * oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\n\t// Do it right and find both F1 and F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap if smaller\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx;\n\td.y = min( d.y, d.z );\n\td.y = min( d.y, d.w );\n\treturn sqrt( d.xy );\n\n}\n";

var noise_cellular_2x2x2 = "\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( 0.0, -1.0, 0.0, -1.0 );\n\tvec4 Pfy = Pf.y + vec4( 0.0, 0.0, -1.0, -1.0 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 p1 = permute( p + Pi.z ); // z+0\n\tvec4 p2 = permute( p + Pi.z + vec4( 1.0 ) ); // z+1\n\tvec4 ox1 = fract( p1 * K ) - Ko;\n\tvec4 oy1 = mod7( floor( p1 * K ) ) * K - Ko;\n\tvec4 oz1 = floor( p1 * K2 ) * Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract( p2 * K ) - Ko;\n\tvec4 oy2 = mod7( floor( p2 * K ) ) * K - Ko;\n\tvec4 oz2 = floor( p2 * K2 ) * Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter1 * ox1;\n\tvec4 dy1 = Pfy + jitter1 * oy1;\n\tvec4 dz1 = Pf.z + jitter1 * oz1;\n\tvec4 dx2 = Pfx + jitter1 * ox2;\n\tvec4 dy2 = Pfy + jitter1 * oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter1 * oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min( d1, d2 ); // F1 is now in d\n\td2 = max( d1, d2 ); // Make sure we keep all candidates for F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min( d.yzw, d2.yzw ); // F2 now not in d2.yzw\n\td.y = min( d.y, d.z ); // nor in d.z\n\td.y = min( d.y, d.w ); // nor in d.w\n\td.y = min( d.y, d2.x ); // F2 is now in d.y\n\treturn sqrt( d.xy ); // F1 and F2\n\n}\n";

var noise_cellular_3D = "\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\n\nvec2 cellular( vec3 P ) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P ) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfy = Pf.y + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfz = Pf.z + vec3( 1.0, 0.0, -1.0 );\n\n\tvec3 p = permute( Pi.x + vec3( -1.0, 0.0, 1.0 ) );\n\tvec3 p1 = permute( p + Pi.y - 1.0 );\n\tvec3 p2 = permute( p + Pi.y );\n\tvec3 p3 = permute( p + Pi.y + 1.0 );\n\n\tvec3 p11 = permute( p1 + Pi.z - 1.0 );\n\tvec3 p12 = permute( p1 + Pi.z );\n\tvec3 p13 = permute( p1 + Pi.z + 1.0 );\n\n\tvec3 p21 = permute( p2 + Pi.z - 1.0 );\n\tvec3 p22 = permute( p2 + Pi.z );\n\tvec3 p23 = permute( p2 + Pi.z + 1.0 );\n\n\tvec3 p31 = permute( p3 + Pi.z - 1.0 );\n\tvec3 p32 = permute( p3 + Pi.z );\n\tvec3 p33 = permute( p3 + Pi.z + 1.0 );\n\n\tvec3 ox11 = fract( p11 * K ) - Ko;\n\tvec3 oy11 = mod7( floor( p11 * K ) ) * K - Ko;\n\tvec3 oz11 = floor( p11 * K2 ) * Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract( p12 * K ) - Ko;\n\tvec3 oy12 = mod7( floor( p12 * K ) ) * K - Ko;\n\tvec3 oz12 = floor( p12 * K2 ) * Kz - Kzo;\n\n\tvec3 ox13 = fract( p13 * K ) - Ko;\n\tvec3 oy13 = mod7( floor( p13 * K ) ) * K - Ko;\n\tvec3 oz13 = floor( p13 * K2 ) * Kz - Kzo;\n\n\tvec3 ox21 = fract( p21 * K ) - Ko;\n\tvec3 oy21 = mod7( floor( p21 * K ) ) * K - Ko;\n\tvec3 oz21 = floor( p21 * K2 ) * Kz - Kzo;\n\n\tvec3 ox22 = fract( p22 * K ) - Ko;\n\tvec3 oy22 = mod7( floor( p22 * K ) ) * K - Ko;\n\tvec3 oz22 = floor( p22 * K2 ) * Kz - Kzo;\n\n\tvec3 ox23 = fract( p23 * K ) - Ko;\n\tvec3 oy23 = mod7( floor( p23 * K ) ) * K - Ko;\n\tvec3 oz23 = floor( p23 * K2 ) * Kz - Kzo;\n\n\tvec3 ox31 = fract( p31 * K ) - Ko;\n\tvec3 oy31 = mod7( floor( p31 * K ) ) * K - Ko;\n\tvec3 oz31 = floor( p31 * K2 ) * Kz - Kzo;\n\n\tvec3 ox32 = fract( p32 * K ) - Ko;\n\tvec3 oy32 = mod7( floor( p32 * K ) ) * K - Ko;\n\tvec3 oz32 = floor( p32 * K2 ) * Kz - Kzo;\n\n\tvec3 ox33 = fract( p33 * K ) - Ko;\n\tvec3 oy33 = mod7( floor( p33 * K ) ) * K - Ko;\n\tvec3 oz33 = floor( p33 * K2 ) * Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter * ox11;\n\tvec3 dy11 = Pfy.x + jitter * oy11;\n\tvec3 dz11 = Pfz.x + jitter * oz11;\n\n\tvec3 dx12 = Pfx + jitter * ox12;\n\tvec3 dy12 = Pfy.x + jitter * oy12;\n\tvec3 dz12 = Pfz.y + jitter * oz12;\n\n\tvec3 dx13 = Pfx + jitter * ox13;\n\tvec3 dy13 = Pfy.x + jitter * oy13;\n\tvec3 dz13 = Pfz.z + jitter * oz13;\n\n\tvec3 dx21 = Pfx + jitter * ox21;\n\tvec3 dy21 = Pfy.y + jitter * oy21;\n\tvec3 dz21 = Pfz.x + jitter * oz21;\n\n\tvec3 dx22 = Pfx + jitter * ox22;\n\tvec3 dy22 = Pfy.y + jitter * oy22;\n\tvec3 dz22 = Pfz.y + jitter * oz22;\n\n\tvec3 dx23 = Pfx + jitter * ox23;\n\tvec3 dy23 = Pfy.y + jitter * oy23;\n\tvec3 dz23 = Pfz.z + jitter * oz23;\n\n\tvec3 dx31 = Pfx + jitter * ox31;\n\tvec3 dy31 = Pfy.z + jitter * oy31;\n\tvec3 dz31 = Pfz.x + jitter * oz31;\n\n\tvec3 dx32 = Pfx + jitter * ox32;\n\tvec3 dy32 = Pfy.z + jitter * oy32;\n\tvec3 dz32 = Pfz.y + jitter * oz32;\n\n\tvec3 dx33 = Pfx + jitter * ox33;\n\tvec3 dy33 = Pfy.z + jitter * oy33;\n\tvec3 dz33 = Pfz.z + jitter * oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min( d11, d12 );\n\td12 = max( d11, d12 );\n\td11 = min( d1a, d13 ); // Smallest now not in d12 or d13\n\td13 = max( d1a, d13 );\n\td12 = min( d12, d13 ); // 2nd smallest now not in d13\n\tvec3 d2a = min( d21, d22 );\n\td22 = max( d21, d22 );\n\td21 = min( d2a, d23 ); // Smallest now not in d22 or d23\n\td23 = max( d2a, d23 );\n\td22 = min( d22, d23 ); // 2nd smallest now not in d23\n\tvec3 d3a = min( d31, d32 );\n\td32 = max( d31, d32 );\n\td31 = min( d3a, d33 ); // Smallest now not in d32 or d33\n\td33 = max( d3a, d33 );\n\td32 = min( d32, d33 ); // 2nd smallest now not in d33\n\tvec3 da = min( d11, d21 );\n\td21 = max( d11, d21 );\n\td11 = min( da, d31 ); // Smallest now in d11\n\td31 = max( da, d31 ); // 2nd smallest now not in d31\n\td11.xy = ( d11.x < d11.y ) ? d11.xy : d11.yx;\n\td11.xz = ( d11.x < d11.z ) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min( d12, d21 ); // 2nd smallest now not in d21\n\td12 = min( d12, d22 ); // nor in d22\n\td12 = min( d12, d31 ); // nor in d31\n\td12 = min( d12, d32 ); // nor in d32\n\td11.yz = min( d11.yz, d12.xy ); // nor in d12.yz\n\td11.y = min( d11.y, d12.z ); // Only two more to go\n\td11.y = min( d11.y, d11.z ); // Done! (Phew! )\n\treturn sqrt( d11.xy ); // F1, F2\n\n}\n";

var noise_cellular = "#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";

var noise_perlin_2D = "//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec2 P ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec2 P, vec2 rep ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n";

var noise_perlin_3D = "//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec3 P ) {\n\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec3 P, vec3 rep ) {\n\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n";

var noise_perlin_4D = "//\n// GLSL textureless classic 4D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec4 P ) {\n\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n\n// Classic Perlin noise, periodic version\nfloat perlin( vec4 P, vec4 rep ) {\n\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n";

var noise_perlin = "#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";

var noise_psrd_2D = "// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n//\n// This is (yet) another variation on simplex noise. It's similar to the\n// version presented by Ken Perlin, but the grid is axis-aligned and\n// slightly stretched in the y direction to permit rectangular tiling.\n//\n// The noise can be made to tile seamlessly to any integer period in x and\n// any even integer period in y. Odd periods may be specified for y, but\n// then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and can\n// serve a similar purpose for animation as motion along z in 3-D noise.\n// The rotating gradients in conjunction with the analytic derivatives\n// can make \"flow noise\" effects as presented by Perlin and Neyret.\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The first component of the 3-element return vector is the noise value.\n// The second and third components are the x and y partial derivatives.\n//\n// float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The return value is the noise value.\n// Partial derivatives are not computed, making these functions faster.\n//\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2( vec2 p, float rot ) {\n\n    // For more isotropic gradients, sin/cos can be used instead.\n    float u = permute( permute( p.x ) + p.y ) * 0.0243902439 + rot; // Rotate by shift\n    u = fract( u ) * 6.28318530718; // 2*pi\n    return vec2( cos( u ), sin( u ));\n\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n  // Hack: offset y slightly to hide some rare artifacts\n  pos.y += 0.01;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients\n// and analytical derivative.\n// This function is implemented as a wrapper to \"psrdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 psdnoise(vec2 pos, vec2 per) {\n  return psrdnoise(pos, per, 0.0);\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients,\n// but without the analytical derivative.\n//\nfloat psrnoise(vec2 pos, vec2 per, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"psrnoise\",\n// at the minimal cost of three extra additions.\n//\nfloat psnoise(vec2 pos, vec2 per) {\n  return psrnoise(pos, per, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n// This function is implemented as a wrapper to \"srdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 sdnoise(vec2 pos) {\n  return srdnoise(pos, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients,\n// without the analytical derivative.\n//\nfloat srnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"srnoise\",\n// at the minimal cost of three extra additions.\n// Note: if this kind of noise is all you want, there are faster\n// GLSL implementations of non-tiling simplex noise out there.\n// This one is included mainly for completeness and compatibility\n// with the other functions in the file.\n//\nfloat snoise(vec2 pos) {\n  return srnoise(pos, 0.0);\n}\n";

var noise_simplex_2D = "//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec2 v ) {\n\n    const vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439 ); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor( v + dot( v, C.yy ) );\n    vec2 x0 = v - i + dot( i, C.xx );\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289( i ); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\n        + i.x + vec3( 0.0, i1.x, 1.0 ) );\n\n    vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n    vec3 h = abs( x ) - 0.5;\n    vec3 ox = floor( x + 0.5 );\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot( m, g );\n\n}\n";

var noise_simplex_3D_grad = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20150104 (JcBernack)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v, out vec3 gradient ) {\n\n    const vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4  D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx ) ;\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n            + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n            + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 pdotx = vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) );\n\n    // Determine noise gradient\n    vec4 temp = m2 * m * pdotx;\n    gradient = - 8.0 * ( temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3 );\n    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n    gradient *= 42.0;\n\n    return 42.0 * dot( m4, pdotx );\n\n}\n";

var noise_simplex_3D = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v ) {\n\n    const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx );\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor( p * ns.z * ns.z );  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n                                dot( p2, x2 ), dot( p3, x3 ) ) );\n\n}\n";

var noise_simplex_4D = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec4 grad4( float j, vec4 ip ) {\n\n    const vec4 ones = vec4( 1.0, 1.0, 1.0, -1.0 );\n    vec4 p, s;\n\n    p.xyz = floor( fract( vec3( j ) * ip.xyz ) * 7.0 ) * ip.z - 1.0;\n    p.w = 1.5 - dot( abs( p.xyz ), ones.xyz );\n    s = vec4( lessThan( p, vec4( 0.0 ) ) );\n    p.xyz = p.xyz + ( s.xyz * 2.0 - 1.0 ) * s.www;\n\n    return p;\n\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat simplex(vec4 v) {\n\n    const vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor( v + dot( v, vec4( F4 ) ) );\n    vec4 x0 = v - i + dot( i, C.xxxx );\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289( i );\n    float j0 = permute( permute( permute( permute( i.w ) + i.z ) + i.y ) + i.x );\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4( 1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0 );\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt( dot( p4, p4 ) );\n\n    // Mix contributions from the five corners\n    vec3 m0 = max( 0.6 - vec3( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ) ), 0.0 );\n    vec2 m1 = max( 0.6 - vec2( dot( x3, x3 ), dot( x4, x4 ) ), 0.0 );\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n";

var noise_simplex = "#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";

var perturbation_share = "#ifdef HAS_PERTURBATIONMAP\n  uniform sampler2D u_perturbationSampler;\n  uniform float u_perturbationUOffset;\n  uniform float u_perturbationVOffset;\n#endif\n";

var perturbation_frag = "#ifdef HAS_PERTURBATIONMAP\n  vec2 getScreenUv(){\n    return gl_FragCoord.xy / u_resolution;\n  }\n\n  vec4 screenColor = texture2D(u_perturbationSampler, getScreenUv() + normalize(u_viewMat * vec4(normal, 1.)).xy * vec2(u_perturbationUOffset, u_perturbationVOffset));\n  gl_FragColor = mix(screenColor, gl_FragColor, gl_FragColor.a);\n\n#endif\n";

var refraction_share = "#ifdef HAS_REFRACTIONMAP\n\n    uniform sampler2D u_refractionSampler;\n    uniform mat4 u_PTMMatrix;\n    uniform float u_refractionDepth;\n\n#endif\n";

var refraction_frag = "#ifdef HAS_REFRACTIONMAP\n  vec4 refractionColor = vec4(0.);\n  vec3 refractDir = normalize(refract(-geometry.viewDir, geometry.normal, u_refractionRatio));\n  vec3 newPos = v_pos + refractDir * u_refractionDepth;\n  vec4 projectionPos = u_PTMMatrix * u_projMat * u_viewMat * vec4(newPos, 1.0);\n  vec2 projectionUv = projectionPos.xy / projectionPos.w;\n  refractionColor = texture2D(u_refractionSampler, projectionUv);\n  gl_FragColor = mix(refractionColor, gl_FragColor, gl_FragColor.a);\n\n#endif\n";

var clipPlane_vert_define = "#ifdef O3_CLIPPLANE_NUM\n    uniform vec4 u_clipPlanes[O3_CLIPPLANE_NUM];\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";

var clipPlane_vert = "#ifdef O3_CLIPPLANE_NUM\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\n        v_clipDistances[i] = dot(vec4(v_pos,1.0), u_clipPlanes[i]);\n    }\n#endif\n";

var clipPlane_frag_define = "#ifdef O3_CLIPPLANE_NUM\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";

var clipPlane_frag = "#ifdef O3_CLIPPLANE_NUM\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\n        if(v_clipDistances[i] < 0.0){\n            discard;\n        }\n    }\n#endif\n";

var gamma_frag = "#ifdef GAMMA\n    float gamma = 2.2;\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0 / gamma));\n#endif\n";

var pbr_common_frag_define = "#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n\n#ifndef RECIPROCAL_PI\n    #define RECIPROCAL_PI 0.31830988618\n#endif\n\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";

var pbr_util_frag_define = "vec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    #ifdef MANUAL_SRGB\n\n        #ifdef SRGB_FAST_APPROXIMATION\n\n            vec3 linOut = pow(srgbIn.xyz, vec3(2.2));\n        #else\n\n         vec3 bLess = step(vec3(0.04045), srgbIn.xyz);\n         vec3 linOut = mix(srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055), vec3(2.4)), bLess);\n\n        #endif\n\n    return vec4(linOut, srgbIn.w);;\n\n    #else\n\n    return srgbIn;\n\n    #endif\n}\n\nfloat pow2( const in float x ) {\n    return x * x;\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\n\n// todo: enhance\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n    if( decayExponent > 0.0 ) {\n\n        #if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n        // based upon Frostbite 3 Moving to Physically-based Rendering\n        // page 32, equation 26: E[window1]\n        // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n        // this is intended to be used on spot and point lights who are represented as luminous intensity\n        // but who must be converted to luminous irradiance for surface lighting calculation\n        float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n        float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n        return distanceFalloff * maxDistanceCutoffFactor;\n\n        #else\n\n        return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n        #endif\n\n    }\n\n    return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n}\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n    return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\n\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n\n// 亮度值\nfloat getLuminance(vec3 color)\n{\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n";

var pbr_envmap_light_frag_define = "#ifdef O3_HAS_ENVMAP_LIGHT\n\nstruct EnvMapLight {\n    vec3 diffuse;\n    vec3 specular;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n    mat3 transformMatrix;\n};\n\n\nuniform EnvMapLight u_envMapLight;\n\n#ifdef O3_USE_DIFFUSE_ENV\n    uniform samplerCube u_env_diffuseSampler;\n#endif\n\n#ifdef O3_USE_SPECULAR_ENV\n    uniform samplerCube u_env_specularSampler;\n#endif\n\n#endif\n";

var pbr_base_frag_define = "#ifdef ALPHA_MASK\nuniform float u_alphaCutoff;\n#endif\n\nuniform vec4 u_baseColorFactor;\nuniform vec2 u_metallicRoughnessValue;\nuniform vec3 u_specularFactor;\nuniform float u_glossinessFactor;\n\nuniform float u_envMapIntensity;\nuniform float u_refractionRatio;\n\nuniform vec2 u_resolution;\n\n// todo: delete\nuniform float u_normalScale;\nuniform float u_occlusionStrength;\n\n";

var pbr_texture_frag_define = "#ifdef HAS_BASECOLORMAP\n\nuniform sampler2D u_baseColorSampler;\n\n#endif\n\n#ifdef O3_HAS_NORMALMAP\n\nuniform sampler2D u_normalSampler;\n\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n\nuniform sampler2D u_emissiveSampler;\nuniform vec3 u_emissiveFactor;\n\n#endif\n\n#ifdef HAS_METALMAP\n\nuniform sampler2D u_metallicSampler;\n\n#endif\n\n#ifdef HAS_ROUGHNESSMAP\n\nuniform sampler2D u_roughnessSampler;\n\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\n\nuniform sampler2D u_metallicRoughnessSampler;\n\n#endif\n\n\n#ifdef HAS_SPECULARGLOSSINESSMAP\n\nuniform sampler2D u_specularGlossinessSampler;\n\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\n\nuniform sampler2D u_occlusionSampler;\n\n#endif\n\n#ifdef HAS_OPACITYMAP\n\nuniform sampler2D u_opacitySampler;\n\n#endif\n\n#ifdef HAS_REFLECTIONMAP\n\nuniform samplerCube u_reflectionSampler;\n\n#endif\n";

var pbr_runtime_frag_define = "struct IncidentLight {\n    vec3 color;\n    vec3 direction;\n    bool visible;\n};\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\nstruct PhysicalMaterial {\n    vec3    diffuseColor;\n    float   specularRoughness;\n    vec3    specularColor;\n};\n";

var pbr_normal_frag_define = "vec3 getNormal()\n{\n  #ifdef O3_HAS_NORMALMAP\n    #ifndef O3_HAS_TANGENT\n        #ifdef HAS_DERIVATIVES\n            vec3 pos_dx = dFdx(v_pos);\n            vec3 pos_dy = dFdy(v_pos);\n            vec3 tex_dx = dFdx(vec3(v_uv, 0.0));\n            vec3 tex_dy = dFdy(vec3(v_uv, 0.0));\n            vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n            #ifdef O3_HAS_NORMAL\n                vec3 ng = normalize(v_normal);\n            #else\n                vec3 ng = normalize( cross(pos_dx, pos_dy) );\n            #endif\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            mat3 tbn = mat3(t, b, ng);\n        #else\n            #ifdef O3_HAS_NORMAL\n                vec3 ng = normalize(v_normal);\n            #else\n                vec3 ng = vec3(0.0, 0.0, 1.0);\n            #endif\n            mat3 tbn = mat3(vec3(0.0), vec3(0.0), ng);\n        #endif\n    #else\n        mat3 tbn = v_TBN;\n    #endif\n        vec3 n = texture2D(u_normalSampler, v_uv ).rgb;\n        n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\n  #else\n    #ifdef O3_HAS_NORMAL\n        vec3 n = normalize(v_normal);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v_pos);\n        vec3 pos_dy = dFdy(v_pos);\n        vec3 n = normalize( cross(pos_dx, pos_dy) );\n    #else\n        vec3 n= vec3(0.0,0.0,1.0);\n    #endif\n  #endif\n\n  n *= float( gl_FrontFacing ) * 2.0 - 1.0;\n\n  return n;\n}\n";

var pbr_brdf_cook_torrance_frag_define = "vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n";

var pbr_direct_irradiance_frag_define = "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n    vec3 irradiance = dotNL * directLight.color;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI; // punctual light\n\n    #endif\n\n\n\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n\n\n#ifdef O3_DIRECT_LIGHT_COUNT\n\n    void getDirectionalDirectLightIrradiance( const in DirectLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n        directLight.color = directionalLight.lightColor;\n        directLight.direction = -directionalLight.direction;\n        directLight.visible = true;\n    }\n\n#endif\n\n#ifdef O3_POINT_LIGHT_COUNT\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.lightColor;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n#ifdef O3_SPOT_LIGHT_COUNT\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.lightColor;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n\n#endif\n";

var pbr_ibl_specular_frag_define = "// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n\n} // validated\n\n\n// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\nfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n    //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n    //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n    float maxMIPLevelScalar = float( maxMIPLevel );\n    float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n    // clamp to allowable LOD ranges.\n    return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n}\n\n#ifdef O3_HAS_ENVMAP_LIGHT\n\nvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n    #if !defined(O3_USE_SPECULAR_ENV) && !defined(HAS_REFLECTIONMAP)\n\n        return u_envMapLight.specular * u_envMapLight.specularIntensity * u_envMapIntensity;\n\n    #else\n\n    #ifdef ENVMAPMODE_REFRACT\n\n        vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, u_refractionRatio );\n\n    #else\n\n        vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n    #endif\n//        reflectVec = inverseTransformDirection( reflectVec, u_viewMat );\n\n        reflectVec =  u_envMapLight.transformMatrix * reflectVec;\n\n        float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n        #ifdef HAS_TEX_LOD\n            #ifdef HAS_REFLECTIONMAP\n                 vec4 envMapColor = textureCubeLodEXT( u_reflectionSampler, reflectVec, specularMIPLevel );\n            #else\n                vec4 envMapColor = textureCubeLodEXT( u_env_specularSampler, reflectVec, specularMIPLevel );\n            #endif\n\n        #else\n            #ifdef HAS_REFLECTIONMAP\n                 vec4 envMapColor = textureCube( u_reflectionSampler, reflectVec, specularMIPLevel );\n            #else\n                 vec4 envMapColor = textureCube( u_env_specularSampler, reflectVec, specularMIPLevel );\n            #endif\n        #endif\n\n        envMapColor.rgb = SRGBtoLINEAR( envMapColor * u_envMapLight.specularIntensity * u_envMapIntensity).rgb;\n\n        return envMapColor.rgb;\n\n    #endif\n\n}\n#endif\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n    float dotNL = dotNV;\n\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n}\n";

var pbr_ibl_diffuse_frag_define = "void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#ifdef O3_HAS_AMBIENT_LIGHT\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n    vec3 irradiance = ambientLightColor;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI;\n\n    #endif\n\n    return irradiance;\n\n}\n\n#endif\n";

var pbr_begin_frag = "    vec3 normal = getNormal();\n    vec4 diffuseColor = u_baseColorFactor;\n    vec3 totalEmissiveRadiance = vec3(0.0);\n    float metalnessFactor = u_metallicRoughnessValue.r;\n    float roughnessFactor = u_metallicRoughnessValue.g;\n    vec3 specularFactor = u_specularFactor;\n    float glossinessFactor = u_glossinessFactor;\n\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    PhysicalMaterial material;\n    GeometricContext geometry;\n    IncidentLight directLight;\n\n    #ifdef HAS_BASECOLORMAP\n\n        vec4 baseMapColor = texture2D( u_baseColorSampler, v_uv );\n        baseMapColor = SRGBtoLINEAR( baseMapColor );\n        diffuseColor *= baseMapColor;\n\n    #endif\n\n    #ifdef O3_HAS_VERTEXCOLOR\n\n        diffuseColor.rgb *= v_color.rgb;\n\n        #ifdef O3_HAS_VERTEXALPHA\n\n            diffuseColor.a *= v_color.a;\n\n        #endif\n\n    #endif\n\n    #ifdef ALPHA_MASK\n\n        if( diffuseColor.a < u_alphaCutoff ) {\n            discard;\n        }\n\n    #endif\n\n\n    #if defined(ALPHA_BLEND) && defined(HAS_OPACITYMAP)\n\n        #ifdef GETOPACITYFROMRGB\n            diffuseColor.a *= getLuminance(texture2D( u_opacitySampler, v_uv ).rgb);\n        #else\n            diffuseColor.a *= texture2D( u_opacitySampler, v_uv ).a;\n        #endif\n\n    #endif\n\n    #ifdef UNLIT\n\n        gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n    #else\n\n\n\n        #ifdef HAS_METALROUGHNESSMAP\n\n            vec4 metalRoughMapColor = texture2D( u_metallicRoughnessSampler, v_uv );\n            metalnessFactor *= metalRoughMapColor.b;\n            roughnessFactor *= metalRoughMapColor.g;\n\n        #else\n            #ifdef HAS_METALMAP\n\n            vec4 metalMapColor = texture2D( u_metallicSampler, v_uv );\n            metalnessFactor *= metalMapColor.b;\n\n            #endif\n\n            #ifdef HAS_ROUGHNESSMAP\n\n            vec4 roughMapColor = texture2D( u_roughnessSampler, v_uv );\n            roughnessFactor *= roughMapColor.g;\n\n            #endif\n        #endif\n\n        #ifdef HAS_SPECULARGLOSSINESSMAP\n\n            vec4 specularGlossinessColor = texture2D(u_specularGlossinessSampler, v_uv );\n            specularFactor *= specularGlossinessColor.rgb;\n            glossinessFactor *= specularGlossinessColor.a;\n\n        #endif\n\n\n        #ifdef IS_METALLIC_WORKFLOW\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n            material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n//          material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n            material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT /* pow2( reflectivity )*/ ), diffuseColor.rgb, metalnessFactor );\n        #else\n            float specularStrength = max( max( specularFactor.r, specularFactor.g ), specularFactor.b );\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - specularStrength );\n            material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );\n            material.specularColor = specularFactor;\n        #endif\n\n        geometry.position = v_pos;\n        geometry.normal = normal;\n        geometry.viewDir = normalize( u_cameraPos - v_pos );\n";

var pbr_direct_irradiance_frag = "        #if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            DirectLight directionalLight;\n\n            for ( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i ++ ) {\n\n                directionalLight = u_directLights[ i ];\n\n                getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n\n        #if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            PointLight pointLight;\n\n            for ( int i = 0; i < O3_POINT_LIGHT_COUNT; i ++ ) {\n\n                pointLight = u_pointLights[ i ];\n\n                getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n\n        #if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            SpotLight spotLight;\n\n            for ( int i = 0; i < O3_SPOT_LIGHT_COUNT; i ++ ) {\n\n                spotLight = u_spotLights[ i ];\n\n                getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n";

var pbr_ibl_diffuse_frag = "#if defined(RE_IndirectDiffuse)\n\n    vec3 irradiance = vec3(0);\n\n    #if defined(O3_HAS_AMBIENT_LIGHT)\n        irradiance += getAmbientLightIrradiance(u_ambientLight.lightColor);\n    #endif\n\n    #if defined(O3_HAS_ENVMAP_LIGHT)\n\n        #ifdef O3_USE_DIFFUSE_ENV\n            vec3 lightMapIrradiance = textureCube(u_env_diffuseSampler, geometry.normal).rgb * u_envMapLight.diffuseIntensity;\n        #else\n            vec3 lightMapIrradiance = u_envMapLight.diffuse * u_envMapLight.diffuseIntensity;\n        #endif\n\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n            lightMapIrradiance *= PI;\n        #endif\n\n        irradiance += lightMapIrradiance;\n\n    #endif\n\n    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n\n";

var pbr_ibl_specular_frag = "#if defined( RE_IndirectSpecular )\n\n    vec3 radiance = vec3( 0.0 );\n\n#endif\n\n\n\n#if defined( O3_HAS_ENVMAP_LIGHT ) && defined( RE_IndirectSpecular )\n\n    radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), int(u_envMapLight.mipMapLevel) );\n\n#endif\n\n\n#if defined( RE_IndirectSpecular )\n\n    RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n\n#endif\n";

var pbr_end_frag = "#ifdef HAS_OCCLUSIONMAP\n\n    float ambientOcclusion = (texture2D(u_occlusionSampler, v_uv).r - 1.0) * u_occlusionStrength + 1.0;\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n    #if defined(O3_USE_SPECULAR_ENV)\n\n        float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n        reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n\n    #endif\n\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n\n    vec4 emissiveMapColor = texture2D(u_emissiveSampler, v_uv);\n    emissiveMapColor = SRGBtoLINEAR(emissiveMapColor);\n    totalEmissiveRadiance += u_emissiveFactor * emissiveMapColor.rgb;\n\n#endif\n\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n#endif\n";

var PBRShaderLib = {
  pbr_common_frag_define: pbr_common_frag_define,
  pbr_util_frag_define: pbr_util_frag_define,
  pbr_envmap_light_frag_define: pbr_envmap_light_frag_define,
  pbr_base_frag_define: pbr_base_frag_define,
  pbr_texture_frag_define: pbr_texture_frag_define,
  pbr_runtime_frag_define: pbr_runtime_frag_define,
  pbr_normal_frag_define: pbr_normal_frag_define,
  pbr_brdf_cook_torrance_frag_define: pbr_brdf_cook_torrance_frag_define,
  pbr_direct_irradiance_frag_define: pbr_direct_irradiance_frag_define,
  pbr_ibl_specular_frag_define: pbr_ibl_specular_frag_define,
  pbr_ibl_diffuse_frag_define: pbr_ibl_diffuse_frag_define,
  pbr_begin_frag: pbr_begin_frag,
  pbr_direct_irradiance_frag: pbr_direct_irradiance_frag,
  pbr_ibl_diffuse_frag: pbr_ibl_diffuse_frag,
  pbr_ibl_specular_frag: pbr_ibl_specular_frag,
  pbr_end_frag: pbr_end_frag
};

var oit_frag = "#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\n    if(gl_FragCoord.z > texture2D(u_depthSampler, gl_FragCoord.xy / u_resolution).r){\n        discard;\n    }\n    vec4 oitColor = gl_FragColor;\n\n    // Bavoil and Myers’ Method\n    gl_FragData[0]= vec4(oitColor.rgb * oitColor.a, oitColor.a);\n    gl_FragData[1]= vec4(1)/ 255.0; // 兼容非浮点输出\n\n\n    // Depth Weights Improve Occlusion\n//    float w = weight(gl_FragCoord.z, oitColor.a);\n//    gl_FragData[0] = vec4(oitColor.rgb * oitColor.a * w, oitColor.a);\n//    gl_FragData[1].r =oitColor.a * w;\n#endif\n";

var oit_frag_define = "#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\n\n    uniform sampler2D u_depthSampler;\n\n    float weight(float z, float a) {\n        return a * clamp(3e3 * pow(1.0 - z, 3.0), 1e-2, 3e3);\n//          return pow(z,-5.0);\n    }\n#endif\n";

var ShaderLib = _objectSpread2({
  common: common,
  common_vert: common_vert,
  common_frag: common_frag,
  color_share: color_share,
  normal_share: normal_share,
  uv_share: uv_share,
  worldpos_share: worldpos_share,
  shadow_share: shadow_share,
  fog_share: fog_share,
  begin_normal_vert: begin_normal_vert,
  begin_position_vert: begin_position_vert,
  morph_target_vert: morph_target_vert,
  position_vert: position_vert,
  color_vert: color_vert,
  normal_vert: normal_vert,
  skinning_vert: skinning_vert,
  uv_vert: uv_vert,
  worldpos_vert: worldpos_vert,
  shadow_vert: shadow_vert,
  morph_vert: morph_vert,
  fog_vert: fog_vert,
  ambient_light_frag: ambient_light_frag,
  direct_light_frag: direct_light_frag,
  point_light_frag: point_light_frag,
  spot_light_frag: spot_light_frag,
  mobile_material_frag: mobile_material_frag,
  fog_frag: fog_frag,
  begin_mobile_frag: begin_mobile_frag,
  begin_normal_frag: begin_normal_frag,
  begin_viewdir_frag: begin_viewdir_frag,
  mobile_blinnphong_frag: mobile_blinnphong_frag,
  mobile_lambert_frag: mobile_lambert_frag,
  noise_common: noise_common,
  noise_cellular_2D: noise_cellular_2D,
  noise_cellular_2x2: noise_cellular_2x2,
  noise_cellular_2x2x2: noise_cellular_2x2x2,
  noise_cellular_3D: noise_cellular_3D,
  noise_cellular: noise_cellular,
  noise_perlin_2D: noise_perlin_2D,
  noise_perlin_3D: noise_perlin_3D,
  noise_perlin_4D: noise_perlin_4D,
  noise_perlin: noise_perlin,
  noise_psrd_2D: noise_psrd_2D,
  noise_simplex_2D: noise_simplex_2D,
  noise_simplex_3D_grad: noise_simplex_3D_grad,
  noise_simplex_3D: noise_simplex_3D,
  noise_simplex_4D: noise_simplex_4D,
  noise_simplex: noise_simplex,
  perturbation_share: perturbation_share,
  perturbation_frag: perturbation_frag,
  refraction_share: refraction_share,
  refraction_frag: refraction_frag,
  clipPlane_vert_define: clipPlane_vert_define,
  clipPlane_vert: clipPlane_vert,
  clipPlane_frag_define: clipPlane_frag_define,
  clipPlane_frag: clipPlane_frag,
  gamma_frag: gamma_frag,
  oit_frag: oit_frag,
  oit_frag_define: oit_frag_define
}, PBRShaderLib);
function InjectShaderSlices(obj) {
  _extends(ShaderLib, obj);
}

var ShaderFactory = /*#__PURE__*/function () {
  function ShaderFactory() {
    _classCallCheck(this, ShaderFactory);
  }

  _createClass(ShaderFactory, null, [{
    key: "parseVersion",

    /**
     * GLSL 版本
     * @param {string} version - "100" | "300 es"
     * */
    value: function parseVersion() {
      var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "100";
      return "#version ".concat(version, "\n");
    }
  }, {
    key: "parsePrecision",
    value: function parsePrecision(vertP, fragP, compileVert) {
      var downgrade = "mediump";
      return "\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n          precision ".concat(compileVert ? vertP : fragP, " float;\n          precision ").concat(compileVert ? vertP : fragP, " int;\n\n          #define O3_VERTEX_PRECISION ").concat(vertP, "\n          #define O3_FRAGMENT_PRECISION ").concat(fragP, "\n        #else\n          precision ").concat(downgrade, " float;\n          precision ").concat(downgrade, " int;\n\n          #define O3_VERTEX_PRECISION ").concat(downgrade, "\n          #define O3_FRAGMENT_PRECISION ").concat(downgrade, "\n        #endif\n      ");
    }
  }, {
    key: "parseShaderName",
    value: function parseShaderName(name) {
      return "#define O3_SHADER_NAME ".concat(name, "\n");
    }
  }, {
    key: "parseAttributeMacros",
    value: function parseAttributeMacros(macros) {
      return "#define O3_ATTRIBUTE_MACROS_START\n" + macros.map(function (m) {
        return "#define ".concat(m, "\n");
      }).join("") + "#define O3_ATTRIBUTE_MACROS_END\n";
    }
  }, {
    key: "parseCustomMacros",
    value: function parseCustomMacros(macros) {
      return "#define O3_CUSTOM_MACROS_START\n" + macros.map(function (m) {
        return "#define ".concat(m, "\n");
      }).join("") + "#define O3_CUSTOM_MACROS_END\n";
    }
  }, {
    key: "parseShader",
    value: function parseShader(src) {
      return ShaderFactory.parseIncludes(src);
    }
  }, {
    key: "parseIncludes",
    value: function parseIncludes(src) {
      var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;

      function replace(match, slice) {
        var replace = ShaderLib[slice];

        if (replace === undefined) {
          Logger.error("Shader slice \"".concat(match.trim(), "\" not founded."));
          return "";
        }

        return ShaderFactory.parseIncludes(replace);
      }

      return src.replace(regex, replace);
    }
  }, {
    key: "InjectShaderSlices",
    value: function InjectShaderSlices$1(slices) {
      InjectShaderSlices(slices);
    }
    /**
     * 相应版本的 extension
     * @param {string[]} extensions - such as ["GL_EXT_shader_texture_lod"]
     * */

  }, {
    key: "parseExtension",
    value: function parseExtension(extensions) {
      return "#define O3_EXTENSION_START\n" + extensions.map(function (e) {
        return "#extension ".concat(e, " : enable\n");
      }).join("") + "#define O3_EXTENSION_END\n";
    }
    /**
     * 切换低版本 GLSL 到 GLSL 300 es
     * @param {string} shader - code
     * @param {boolean} isFrag - 是否为片元着色器。
     * */

  }, {
    key: "convertTo300",
    value: function convertTo300(shader, isFrag) {
      var isGLSL300 = shader.includes("#version 300 es"); // 如果本来就是新版本着色器，则无需转换。

      if (isGLSL300) return shader;
      /** 替换版本 */

      shader = shader.replace(/#version 100/, "#version 300 es");
      /** 修饰符替换 */

      shader = shader.replace(/\battribute\b/g, "in");
      shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
      /** 内置变量替换 */

      shader = shader.replace(/\btexture(2D|Cube)\s*\(/g, "texture(");
      shader = shader.replace(/\btexture(2D|Cube)LodEXT\s*\(/g, "textureLod(");

      if (isFrag) {
        var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);

        if (isMRT) {
          shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
          var result = shader.match(/\bgl_FragData\[.+?\]/g);
          shader = this.replaceMRTShader(shader, result);
        } else {
          shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
          shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
        }
      }

      return shader;
    }
    /**
     * 返回相应 shaderCode 中的 draw buffer 长度
     * @param shader - shader code
     */

  }, {
    key: "getMaxDrawBuffers",
    value: function getMaxDrawBuffers(shader) {
      var mrtIndexSet = new Set();
      var result = shader.match(/\bgl_FragData\[.+?\]/g) || [];

      for (var i = 0; i < result.length; i++) {
        var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
        mrtIndexSet.add(res[1]);
      }

      return mrtIndexSet.size;
    }
    /**
     * 1. 兼容 gl_FragColor 和 gl_FragData 同时存在的报错
     * */

  }, {
    key: "compatible",
    value: function compatible(fragmentShader) {
      var hasFragData = /\bgl_FragData\[.+?\]/g.test(fragmentShader);

      if (hasFragData) {
        fragmentShader = fragmentShader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
      }

      return fragmentShader;
    }
  }, {
    key: "replaceMRTShader",
    value: function replaceMRTShader(shader, result) {
      var declaration = "";
      var mrtIndexSet = new Set();

      for (var i = 0; i < result.length; i++) {
        var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
        mrtIndexSet.add(res[1]);
      }

      mrtIndexSet.forEach(function (index) {
        declaration += "layout(location=".concat(index, ") out vec4 fragOutColor").concat(index, ";\n");
      });
      declaration += "void main(";
      shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
      shader = shader.replace(/void\s+?main\s*\(/g, declaration);
      return shader;
    }
  }]);

  return ShaderFactory;
}();

/**
 * 渲染单个对象所需的控制对象，作为 Material 的模块使用。对应 glTF 里面的 technique 对象
 */
var RenderTechnique = /*#__PURE__*/function (_AssetObject) {
  _inherits(RenderTechnique, _AssetObject);

  var _super = _createSuper(RenderTechnique);

  // 是否可用
  // 是否可用
  // Unifrom记录数组
  // Attribute记录对象

  /**
   * 渲染状态控制对象
   * {
   *  enable:[],
   *  disable:[],
   *  functions:{
   *    "func_name":[]
   *  }
   * }
   *
   * function name: "blendColor", "blendEquationSeparate", "blendFuncSeparate",
   * "colorMask", "cullFace", "depthFunc", "depthMask", "depthRange", "frontFace",
   * "lineWidth", "polygonOffset", and "scissor"
   * @member {object}
   */

  /**
   * Vertex Shader 代码
   * @member {string}
   */

  /**
   * Fragment Shader 代码
   * @member {string}
   */

  /**
   * GLSL 原始版本
   * 若 autoConvert = true, WebGL 2 时着色器为旧版本，则升级到 300 版本
   * @member {String} - "100" | "300 es"
   */

  /** 自动转换 GLSL 版本 */

  /**
   * Vertex Shader 的精度
   * @member {String}
   */

  /**
   * Fragment Shader 的精度
   * @member {String}
   */

  /**
   * 自定义宏
   * @member {Array}
   */

  /**
   * WebGL 1.0 时着色器中使用的拓展
   * @member {Array}
   */

  /**
   * WebGL 2.0 时着色器中使用的拓展
   * @member {Array}
   */

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function RenderTechnique(name) {
    var _this;

    _classCallCheck(this, RenderTechnique);

    _this = _super.call(this, null);
    _this.name = name;
    _this._glTechnique = void 0;
    _this.isValid = false;
    _this._uniforms = RenderTechnique.commonUniforms;
    _this._attributes = RenderTechnique.commonAttributes;
    _this.states = null;
    _this.vertexShader = "";
    _this.fragmentShader = "";
    _this.version = "100";
    _this.autoConvert = true;
    _this.vertexPrecision = "highp";
    _this.fragmentPrecision = "mediump";
    _this.customMacros = [];
    _this.shaderExtension100 = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];
    _this.shaderExtension300 = [];
    _this._needCompile = true;
    _this._recreateHeader = void 0;
    _this._vsHeader = void 0;
    _this._vsCode = void 0;
    _this._fsHeader = void 0;
    _this._fsCode = void 0;
    _this._fogMacro = void 0;
    _this.attribLocSet = void 0;
    return _this;
  }

  _createClass(RenderTechnique, [{
    key: "compile",
    value: function compile(camera, component, primitive, material) {
      this.parseFog(camera);

      if (this._needCompile) {
        var _material$preCompile, _material$postCompile;

        var rhi = camera.engine._hardwareRenderer;
        var isWebGL2 = rhi === null || rhi === void 0 ? void 0 : rhi.isWebGL2;
        (_material$preCompile = material.preCompile) === null || _material$preCompile === void 0 ? void 0 : _material$preCompile.call(material, this);
        var attribMacros = this.getAttributeDefines(camera, component, primitive, material);

        if (this._recreateHeader) {
          // reset configs
          this.attributes = this.attributes;
          this.uniforms = this.uniforms;
        }

        if (!this._vsHeader || this._recreateHeader) this._vsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || "VOID").toUpperCase() + "_VERT") + "\n" + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision, true) + "\n" + ShaderFactory.parseAttributeMacros(attribMacros) + "\n" + ShaderFactory.parseCustomMacros(this.customMacros) + "\n";
        if (!this._vsCode) this._vsCode = ShaderFactory.parseShader(this.vertexShader);
        this.vertexShader = this._vsHeader + this._vsCode;
        if (!this._fsHeader || this._recreateHeader) this._fsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || "VOID").toUpperCase() + "_FRAG") + "\n" + ShaderFactory.parseExtension(isWebGL2 ? this.shaderExtension300 : this.shaderExtension100) + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision) + "\n" + ShaderFactory.parseAttributeMacros(attribMacros) + "\n" + ShaderFactory.parseCustomMacros(this.customMacros) + "\n";
        if (!this._fsCode) this._fsCode = ShaderFactory.parseShader(this.fragmentShader);
        this.fragmentShader = this._fsHeader + this._fsCode;
        /**
         * 若 autoConvert = true,  WebGL 2 时着色器为旧版本，则升级到 300 版本
         * 若 WebGL1,兼容 gl_FragColor 和 gl_FragData 同时存在的报错
         * */

        if (this.autoConvert && isWebGL2 && this.version !== "300 es") {
          var maxDrawBuffers = rhi.capability.maxDrawBuffers;
          var shaderMaxDrawBuffers = ShaderFactory.getMaxDrawBuffers(this.fragmentShader);

          if (shaderMaxDrawBuffers <= maxDrawBuffers) {
            this.vertexShader = ShaderFactory.convertTo300(this.vertexShader);
            this.fragmentShader = ShaderFactory.convertTo300(this.fragmentShader, true);
          }
        } else if (!isWebGL2 && this.version !== "300es") {
          this.fragmentShader = ShaderFactory.compatible(this.fragmentShader);
        }

        this._needCompile = false;
        this._recreateHeader = false;
        (_material$postCompile = material.postCompile) === null || _material$postCompile === void 0 ? void 0 : _material$postCompile.call(material, this);
      }
    }
  }, {
    key: "getAttributeDefines",
    value: function getAttributeDefines(camera, component, primitive, material) {
      var rhi = camera.scene.engine._hardwareRenderer;
      var gl = rhi.gl;
      var _macros = [];
      if (!primitive) return _macros;
      var attribNames = Object.keys(primitive._vertexElementMap);
      if (attribNames.indexOf("TEXCOORD_0") > -1) _macros.push("O3_HAS_UV");
      if (attribNames.indexOf("NORMAL") > -1) _macros.push("O3_HAS_NORMAL");
      if (attribNames.indexOf("TANGENT") > -1) _macros.push("O3_HAS_TANGENT");

      if (attribNames.indexOf("JOINTS_0") > -1) {
        var _component$jointNodes;

        _macros.push("O3_HAS_SKIN");

        if ((_component$jointNodes = component.jointNodes) !== null && _component$jointNodes !== void 0 && _component$jointNodes.length) {
          var maxAttribUniformVec4 = rhi.renderStates.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
          var joints = component.jointNodes.length;

          if (joints > maxJoints) {
            /** 是否使用骨骼纹理 */
            if (rhi.canIUseMoreJoints) {
              _macros.push("O3_USE_JOINT_TEXTURE");
            } else {
              Logger.error("component's joints count(".concat(joints, ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number ").concat(maxAttribUniformVec4, ", suggest joint count less than ").concat(maxJoints, "."), component);
            }
          } else if (material.maxJointsNum > 0) {
            // 使用最大关节数，保证所有 SkinnedMeshRenderer 都可以共用材质
            _macros.push("O3_JOINTS_NUM ".concat(material.maxJointsNum));
          }
        }
      }

      if (attribNames.indexOf("COLOR_0") > -1) {
        _macros.push("O3_HAS_VERTEXCOLOR");

        if (primitive._vertexElementMap["COLOR_0"].format === exports.VertexElementFormat.Vector4) _macros.push("O3_HAS_VERTEXALPHA");
      } // if (component.weights) {
      //   const maxAttribs = rhi.renderStates.getParameter(gl.MAX_VERTEX_ATTRIBS);
      //   if (attribNames.length > maxAttribs) {
      //     Logger.warn(`too many morph targets, beyond the MAX_VERTEX_ATTRIBS limit ${maxAttribs}`);
      //   }
      //   const targetNum = component.weights.length;
      //   _macros.push("O3_HAS_MORPH");
      //   _macros.push(`O3_MORPH_NUM ${targetNum}`);
      //   if (attribNames.indexOf("POSITION_0") > -1) _macros.push("O3_MORPH_POSITION");
      //   if (attribNames.indexOf("NORMAL_0") > -1) _macros.push("O3_MORPH_NORMAL");
      //   if (attribNames.indexOf("TANGENT_0") > -1) _macros.push("O3_MORPH_TANGENT");
      //   this._attributes = Object.assign(this.attributes, this.createMorphConfig(primitive, targetNum));
      //   this._uniforms.u_morphWeights = {
      //     name: "u_morphWeights",
      //     semantic: UniformSemantic.MORPHWEIGHTS,
      //     type: DataType.FLOAT
      //   };
      //   // }
      // }


      var scene = camera.scene;

      if (scene.hasFogFeature) {
        _macros.push.apply(_macros, _toConsumableArray(scene.getFogMacro()));
      }

      return _macros;
    }
  }, {
    key: "parseFog",
    value: function parseFog(camera) {
      var scene = camera.scene;

      if (scene.hasFogFeature) {
        var fogMacro = scene.getFogMacro();

        if (this._fogMacro !== fogMacro) {
          this._needCompile = true;
          this._recreateHeader = true;
          this._fogMacro = fogMacro;
        }
      }
    }
  }, {
    key: "createMorphConfig",
    value: function createMorphConfig(primitive, targetNum) {
      var attributes = Object.keys(primitive._vertexElementMap);
      var morphConfig = {};

      for (var i = 0; i < targetNum; i++) {
        if (attributes.indexOf("POSITION_".concat(i)) > -1) morphConfig["a_position".concat(i)] = {
          name: "a_position".concat(i),
          semantic: "POSITION_".concat(i),
          type: exports.DataType.FLOAT_VEC3
        };
        if (attributes.indexOf("NORMAL_".concat(i)) > -1) morphConfig["a_normal".concat(i)] = {
          name: "a_normal".concat(i),
          semantic: "NORMAL_".concat(i),
          type: exports.DataType.FLOAT_VEC3
        };
        if (attributes.indexOf("TANGENT_".concat(i)) > -1) morphConfig["a_tangent".concat(i)] = {
          name: "a_tangent".concat(i),
          semantic: "TANGENT_".concat(i),
          type: exports.DataType.FLOAT_VEC3
        };
      }

      return morphConfig;
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      if (this._glTechnique) {
        this._glTechnique.finalize(true);

        this._glTechnique = null;
      }
    }
  }, {
    key: "attributes",
    get: function get() {
      return this._attributes;
    },
    set: function set(v) {
      this._attributes = _extends({}, RenderTechnique.commonAttributes, v);
    }
  }, {
    key: "uniforms",
    get: function get() {
      return this._uniforms;
    },
    set: function set(v) {
      this._uniforms = _extends({}, RenderTechnique.commonUniforms, v);
    }
  }]);

  return RenderTechnique;
}(AssetObject);
RenderTechnique.commonAttributes = {
  a_position: {
    name: "a_position",
    semantic: "POSITION",
    type: exports.DataType.FLOAT_VEC3
  },
  a_uv: {
    name: "a_uv",
    semantic: "TEXCOORD_0",
    type: exports.DataType.FLOAT_VEC2
  },
  a_normal: {
    name: "a_noraml",
    semantic: "NORMAL",
    type: exports.DataType.FLOAT_VEC3
  },
  a_tangent: {
    name: "a_tangent",
    semantic: "TANGENT",
    type: exports.DataType.FLOAT_VEC4
  },
  a_color: {
    name: "a_color",
    semantic: "COLOR_0",
    type: exports.DataType.FLOAT_VEC4
  },
  a_joint: {
    name: "a_joint",
    semantic: "JOINTS_0",
    type: exports.DataType.FLOAT_VEC4
  },
  a_weight: {
    name: "a_weight",
    semantic: "WEIGHTS_0",
    type: exports.DataType.FLOAT_VEC4
  }
};
RenderTechnique.commonUniforms = {
  u_localMat: {
    name: "u_localMat",
    semantic: exports.UniformSemantic.LOCAL,
    type: exports.DataType.FLOAT_MAT4
  },
  u_modelMat: {
    name: "u_modelMat",
    semantic: exports.UniformSemantic.MODEL,
    type: exports.DataType.FLOAT_MAT4
  },
  u_viewMat: {
    name: "u_viewMat",
    semantic: exports.UniformSemantic.VIEW,
    type: exports.DataType.FLOAT_MAT4
  },
  u_projMat: {
    name: "u_projMat",
    semantic: exports.UniformSemantic.PROJECTION,
    type: exports.DataType.FLOAT_MAT4
  },
  u_MVMat: {
    name: "u_MVMat",
    semantic: exports.UniformSemantic.MODELVIEW,
    type: exports.DataType.FLOAT_MAT4
  },
  u_MVPMat: {
    name: "u_MVPMat",
    semantic: exports.UniformSemantic.MODELVIEWPROJECTION,
    type: exports.DataType.FLOAT_MAT4
  },
  u_normalMat: {
    name: "u_normalMat",
    semantic: exports.UniformSemantic.MODELINVERSETRANSPOSE,
    type: exports.DataType.FLOAT_MAT3
  },
  u_cameraPos: {
    name: "u_cameraPos",
    type: exports.DataType.FLOAT_VEC3,
    semantic: exports.UniformSemantic.EYEPOS
  },
  u_time: {
    name: "u_time",
    type: exports.DataType.FLOAT,
    semantic: exports.UniformSemantic.TIME
  },
  u_jointMatrix: {
    name: "u_jointMatrix",
    semantic: exports.UniformSemantic.JOINTMATRIX,
    type: exports.DataType.FLOAT_MAT4_ARRAY
  },
  u_jointSampler: {
    name: "u_jointSampler",
    semantic: exports.UniformSemantic.JOINTTEXTURE,
    type: exports.DataType.SAMPLER_2D
  },
  u_jointCount: {
    name: "u_jointCount",
    semantic: exports.UniformSemantic.JOINTCOUNT,
    type: exports.DataType.FLOAT
  },
  u_fogColor: {
    name: "u_fogColor",
    type: exports.DataType.FLOAT_VEC3
  },
  u_fogDensity: {
    name: "u_fogDensity",
    type: exports.DataType.FLOAT
  },
  u_fogNear: {
    name: "u_fogNear",
    type: exports.DataType.FLOAT
  },
  u_fogFar: {
    name: "u_fogFar",
    type: exports.DataType.FLOAT
  }
};

/**
 * 立方体纹理面。
 */

(function (TextureCubeFace) {
  TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
})(exports.TextureCubeFace || (exports.TextureCubeFace = {}));

/**
 * 立方体纹理。
 * @todo 日后调整为TextureCube命名
 */

var TextureCubeMap = /*#__PURE__*/function (_Texture) {
  _inherits(TextureCubeMap, _Texture);

  var _super = _createSuper(TextureCubeMap);

  _createClass(TextureCubeMap, [{
    key: "format",

    /** 向下兼容 WebGL1.0 */

    /**
     * 纹理的格式。
     */
    get: function get() {
      return this._format;
    }
    /**
     * 创建立方体纹理。
     * @param engine - 所属引擎
     * @param size - 尺寸
     * @param format - 格式，默认 TextureFormat.R8G8B8A8
     * @param mipmap - 是否使用多级纹理
     */

  }]);

  function TextureCubeMap(engine, size) {
    var _this;

    var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.TextureFormat.R8G8B8A8;
    var mipmap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    _classCallCheck(this, TextureCubeMap);

    _this = _super.call(this, engine);
    _this._format = void 0;
    _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;

    if (!Texture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:".concat(exports.TextureFormat[format]));
    }

    if (mipmap && !isWebGL2 && !Texture._isPowerOf2(size)) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }

    var formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);

    _this._glTexture = gl.createTexture();
    _this._formatDetail = formatDetail;
    _this._rhi = rhi;
    _this._target = gl.TEXTURE_CUBE_MAP;
    _this._mipmap = mipmap;
    _this._width = size;
    _this._height = size;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
    _this.filterMode = exports.TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = exports.TextureWrapMode.Clamp;
    return _this;
  }
  /**
   * 通过指定立方体面、像素缓冲数据、区域和纹理层级设置像素，同样适用于压缩格式。
   * 压缩纹理在 WebGL1 时必须先填满纹理，才能写子区域
   * @param face - 立方体面
   * @param colorBuffer - 颜色缓冲
   * @param mipLevel - 多级纹理层级
   * @param x - 区域起始X坐标
   * @param y - 区域起始Y坐标
   * @param width - 区域宽。如果为空的话 width 为 mipLevel 对应的宽度减去 x , mipLevel 对应的宽度为 Math.max(1, this.width >> mipLevel)
   * @param height - 区域高。如果为空的话 height 为 mipLevel 对应的高度减去 y , mipLevel 对应的高度为 Math.max(1, this.height >> mipLevel)
   */


  _createClass(TextureCubeMap, [{
    key: "setPixelBuffer",
    value: function setPixelBuffer(face, colorBuffer) {
      var mipLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var x = arguments.length > 3 ? arguments[3] : undefined;
      var y = arguments.length > 4 ? arguments[4] : undefined;
      var width = arguments.length > 5 ? arguments[5] : undefined;
      var height = arguments.length > 6 ? arguments[6] : undefined;
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;
      var _this$_formatDetail = this._formatDetail,
          internalFormat = _this$_formatDetail.internalFormat,
          baseFormat = _this$_formatDetail.baseFormat,
          dataType = _this$_formatDetail.dataType,
          isCompressed = _this$_formatDetail.isCompressed;
      var mipSize = Math.max(1, this._width >> mipLevel);
      x = x || 0;
      y = y || 0;
      width = width || mipSize - x;
      height = height || mipSize - y;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

      if (isCompressed) {
        var mipBit = 1 << mipLevel;

        if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
        } else {
          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
          this._compressedFaceFilled[face] |= mipBit;
        }
      } else {
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
      }

      this._unbind();
    }
    /**
     * 通过指定立方体面、图源、区域和纹理层级设置像素。
     * @param face - 立方体面
     * @param imageSource - 纹理源
     * @param mipLevel - 多级纹理层级
     * @param flipY - 是否翻转Y轴
     * @param premultipltAlpha - 是否预乘透明通道
     * @param x - 区域起始X坐标
     * @param y - 区域起始Y坐标
     */

  }, {
    key: "setImageSource",
    value: function setImageSource(face, imageSource) {
      var mipLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var flipY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var premultiplyAlpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var x = arguments.length > 5 ? arguments[5] : undefined;
      var y = arguments.length > 6 ? arguments[6] : undefined;
      var gl = this._rhi.gl;
      var _this$_formatDetail2 = this._formatDetail,
          baseFormat = _this$_formatDetail2.baseFormat,
          dataType = _this$_formatDetail2.dataType;

      this._bind();

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);

      this._unbind();
    }
    /**
     * 根据立方体面和指定区域获得像素颜色缓冲。
     * @param face - 可以选择读取第几个面
     * @param x - 区域起始X坐标
     * @param y - 区域起始Y坐标
     * @param width - 区域宽
     * @param height - 区域高
     * @param out - 颜色数据缓冲
     */

  }, {
    key: "getPixelBuffer",
    value: function getPixelBuffer(face, x, y, width, height, out) {
      if (this._formatDetail.isCompressed) {
        throw new Error("Unable to read compressed texture");
      }

      _get(_getPrototypeOf(TextureCubeMap.prototype), "_getPixelBuffer", this).call(this, face, x, y, width, height, out);
    }
  }]);

  return TextureCubeMap;
}(Texture);

/**
 * 类应用于渲染深度纹理。
 */

var RenderDepthTexture = /*#__PURE__*/function (_Texture) {
  _inherits(RenderDepthTexture, _Texture);

  var _super = _createSuper(RenderDepthTexture);

  _createClass(RenderDepthTexture, [{
    key: "format",

    /** @internal */

    /**
     * 格式。
     */
    get: function get() {
      return this._format;
    }
    /**
     * 是否自动生成多级纹理。
     */

  }, {
    key: "autoGenerateMipmaps",
    get: function get() {
      return this._autoMipmap;
    },
    set: function set(value) {
      this._autoMipmap = value;
    }
    /**
     * 构造渲染深度纹理。
     * @param engine - 所属引擎
     * @param width - 宽
     * @param height - 高
     * @param format - 格式。默认 RenderBufferDepthFormat.Depth,深度纹理,自动选择精度
     * @param mipmap - 是否使用多级纹理
     * @param isCube - 是否为立方体模式
     */

  }]);

  function RenderDepthTexture(engine, width, height) {
    var _this;

    var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.RenderBufferDepthFormat.Depth;
    var mipmap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var isCube = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, RenderDepthTexture);

    _this = _super.call(this, engine);
    _this._isCube = false;
    _this._format = void 0;
    _this._autoMipmap = false;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;

    if (!Texture._supportRenderBufferDepthFormat(format, rhi, true)) {
      throw new Error("RenderBufferDepthFormat is not supported:".concat(exports.RenderBufferDepthFormat[format]));
    }

    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }

    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }

    _this._glTexture = gl.createTexture();
    _this._formatDetail = Texture._getRenderBufferDepthFormatDetail(format, gl, isWebGL2);
    _this._isCube = isCube;
    _this._rhi = rhi;
    _this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();

    _this._initMipmap(isCube);

    _this.filterMode = exports.TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = exports.TextureWrapMode.Clamp;
    return _this;
  }

  return RenderDepthTexture;
}(Texture);

/**
 * 用于离屏幕渲染的渲染目标。
 */

var RenderTarget = /*#__PURE__*/function (_EngineObject) {
  _inherits(RenderTarget, _EngineObject);

  var _super = _createSuper(RenderTarget);

  _createClass(RenderTarget, [{
    key: "width",

    /** 渲染目标宽。 */
    get: function get() {
      return this._width;
    }
    /** 渲染目标高。 */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * 颜色纹理数量。
     */

  }, {
    key: "colorTextureCount",
    get: function get() {
      return this._colorTextures.length;
    }
    /**
     * 深度纹理。
     */

  }, {
    key: "depthTexture",
    get: function get() {
      return this._depthTexture;
    }
    /**
     * 抗锯齿级别。
     * 如果设置的抗锯齿级别大于硬件支持的最大级别，将使用硬件的最大级别。
     */

  }, {
    key: "antiAliasing",
    get: function get() {
      return this._antiAliasing;
    }
    /**
     * 通过颜色纹理和深度格式创建渲染目标，使用内部深度缓冲，无法获取深度纹理。
     * @param engine - 所属引擎
     * @param width - 宽
     * @param height - 高
     * @param colorTexture - 颜色纹理
     * @param depthFormat - 深度格式,默认 RenderBufferDepthFormat.Depth,自动选择精度
     * @param antiAliasing - 抗锯齿级别,默认 1
     */

  }]);

  /**
   * @internal
   */
  function RenderTarget(engine, width, height, renderTexture) {
    var _this;

    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : exports.RenderBufferDepthFormat.Depth;
    var antiAliasing = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

    _classCallCheck(this, RenderTarget);

    _this = _super.call(this, engine);
    _this._frameBuffer = void 0;
    _this._MSAAFrameBuffer = void 0;
    _this._rhi = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._antiAliasing = void 0;
    _this._colorTextures = void 0;
    _this._depthTexture = void 0;
    _this._depthRenderBuffer = void 0;
    _this._MSAAColorRenderBuffers = [];
    _this._MSAADepthRenderBuffer = void 0;
    _this._oriDrawBuffers = void 0;
    _this._blitDrawBuffers = void 0;
    var rhi = engine._hardwareRenderer;
    /** todo
     * MRT + Cube + [,MSAA]
     * MRT + MSAA
     */

    var gl = rhi.gl;

    if (!(depth instanceof RenderDepthTexture) && !Texture._supportRenderBufferDepthFormat(depth, rhi, false)) {
      throw new Error("RenderBufferDepthFormat is not supported:".concat(exports.RenderBufferDepthFormat[depth]));
    }

    if ((renderTexture === null || renderTexture === void 0 ? void 0 : renderTexture.length) > 1 && !rhi.canIUse(exports.GLCapabilityType.drawBuffers)) {
      throw new Error("MRT is not supported");
    } // handle this._colorTextures


    if (renderTexture) {
      _this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
    } else {
      _this._colorTextures = [];
    }

    if (_this._colorTextures.some(function (v) {
      return v.width !== width || v.height !== height;
    })) {
      throw new Error("RenderColorTexture's size must as same as RenderTarget");
    }

    if (depth instanceof RenderDepthTexture && (depth.width !== width || depth.height !== height)) {
      throw new Error("RenderDepthTexture's size must as same as RenderTarget");
    } // todo: necessary to support MRT + Cube + [,MSAA] ?


    if (_this._colorTextures.length > 1 && _this._colorTextures.some(function (v) {
      return v._isCube;
    })) {
      throw new Error("MRT+Cube+[,MSAA] is not supported");
    }

    var maxAntiAliasing = rhi.capability.maxAntiAliasing;

    if (antiAliasing > maxAntiAliasing) {
      Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:".concat(maxAntiAliasing));
      antiAliasing = maxAntiAliasing;
    }

    _this._rhi = rhi;
    _this._width = width;
    _this._height = height;
    _this._frameBuffer = gl.createFramebuffer();
    _this._antiAliasing = antiAliasing;

    if (depth instanceof RenderDepthTexture) {
      _this._depthTexture = depth;
    } // 绑定主 FBO


    _this._bindMainFBO(depth); // 绑定 MSAA FBO


    if (antiAliasing > 1) {
      _this._MSAAFrameBuffer = gl.createFramebuffer();

      _this._bindMSAAFBO(depth);
    }

    return _this;
  }
  /**
   * 通过索引获取颜色纹理。
   * @param index
   */


  _createClass(RenderTarget, [{
    key: "getColorTexture",
    value: function getColorTexture() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this._colorTextures[index];
    }
    /**
     * 销毁。
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var gl = this._rhi.gl;
      gl.deleteFramebuffer(this._frameBuffer);
      this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
      this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
      this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);

      for (var i = 0; i < this._colorTextures.length; i++) {
        this._colorTextures[i].destroy();
      }

      for (var _i = 0; _i < this._MSAAColorRenderBuffers.length; _i++) {
        gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[_i]);
      }

      this._depthTexture && this._depthTexture.destroy();
      this._frameBuffer = null;
      this._colorTextures.length = 0;
      this._depthTexture = null;
      this._depthRenderBuffer = null;
      this._MSAAFrameBuffer = null;
      this._MSAAColorRenderBuffers.length = 0;
      this._MSAADepthRenderBuffer = null;
    }
    /**
     * 激活 RenderTarget 对象
     * 如果开启 MSAA,则激活 MSAA FBO,后续进行 this._blitRenderTarget() 进行交换 FBO
     * 如果未开启 MSAA,则激活主 FBO
     */

  }, {
    key: "_activeRenderTarget",
    value: function _activeRenderTarget() {
      var gl = this._rhi.gl;

      if (this._MSAAFrameBuffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      }
    }
    /**
     * 设置渲染到立方体纹理的哪个面
     * @param faceIndex - 立方体纹理面
     */

  }, {
    key: "_setRenderTargetFace",
    value: function _setRenderTargetFace(faceIndex) {
      var gl = this._rhi.gl;
      var colorTexture = this._colorTextures[0];
      var depthTexture = this._depthTexture;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer); // 绑定颜色纹理

      if (colorTexture !== null && colorTexture !== void 0 && colorTexture._isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, colorTexture._glTexture, 0);
      } // 绑定深度纹理


      if (depthTexture !== null && depthTexture !== void 0 && depthTexture._isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthTexture._glTexture, 0);
      } // 还原当前激活的 FBO


      this._activeRenderTarget();
    }
    /**
     * Blit FBO.
     */

  }, {
    key: "_blitRenderTarget",
    value: function _blitRenderTarget() {
      var gl = this._rhi.gl;
      var mask = gl.COLOR_BUFFER_BIT | (this._depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
      var colorTextureLength = this._colorTextures.length;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);

      for (var textureIndex = 0; textureIndex < colorTextureLength; textureIndex++) {
        var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
        this._blitDrawBuffers[textureIndex] = attachment;
        gl.readBuffer(attachment);
        gl.drawBuffers(this._blitDrawBuffers);
        gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, mask, gl.NEAREST);
        this._blitDrawBuffers[textureIndex] = gl.NONE;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    /**
     * 绑定主 FBO
     */

  }, {
    key: "_bindMainFBO",
    value: function _bindMainFBO(renderDepth) {
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;
      var colorTextureLength = this._colorTextures.length;
      var drawBuffers = new Array(colorTextureLength);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
      /** color render buffer */

      for (var i = 0; i < colorTextureLength; i++) {
        var _colorTexture = this._colorTextures[i];
        var attachment = gl.COLOR_ATTACHMENT0 + i;
        drawBuffers[i] = attachment; // 立方体纹理请调用 _setRenderTargetFace()

        if (!_colorTexture._isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, _colorTexture._glTexture, 0);
        }
      }

      if (colorTextureLength > 1) {
        gl.drawBuffers(drawBuffers);
      }

      this._oriDrawBuffers = drawBuffers;
      /** depth render buffer */

      if (renderDepth !== null) {
        if (renderDepth instanceof RenderDepthTexture) {
          // 立方体纹理请调用 _setRenderTargetFace()
          if (!renderDepth._isCube) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, renderDepth._formatDetail.attachment, gl.TEXTURE_2D, renderDepth._glTexture, 0);
          }
        } else if (this._antiAliasing <= 1) {
          var _Texture$_getRenderBu = Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2),
              internalFormat = _Texture$_getRenderBu.internalFormat,
              _attachment = _Texture$_getRenderBu.attachment;

          var depthRenderBuffer = gl.createRenderbuffer();
          this._depthRenderBuffer = depthRenderBuffer;
          gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, this._width, this._height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
        }
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    /**
     * 绑定 MSAA FBO
     */

  }, {
    key: "_bindMSAAFBO",
    value: function _bindMSAAFBO(renderDepth) {
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;
      var MSAADepthRenderBuffer = gl.createRenderbuffer();
      var colorTextureLength = this._colorTextures.length;
      this._blitDrawBuffers = new Array(colorTextureLength);
      this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer); // prepare MRT+MSAA color RBOs

      for (var i = 0; i < colorTextureLength; i++) {
        var MSAAColorRenderBuffer = gl.createRenderbuffer();
        this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
        this._blitDrawBuffers[i] = gl.NONE;
        gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, this._colorTextures[i]._formatDetail.internalFormat, this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
      }

      gl.drawBuffers(this._oriDrawBuffers); // prepare MSAA depth RBO

      if (renderDepth !== null) {
        var _ref = renderDepth instanceof RenderDepthTexture ? renderDepth._formatDetail : Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2),
            internalFormat = _ref.internalFormat,
            attachment = _ref.attachment;

        gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, internalFormat, this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
      }

      this._checkFrameBuffer();

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    /**
     * 检查 FBO
     */

  }, {
    key: "_checkFrameBuffer",
    value: function _checkFrameBuffer() {
      var gl = this._rhi.gl;
      var isWebGL2 = this._rhi.isWebGL2;
      var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

      switch (e) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");

        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("There is no attachment");

        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(" Height and width of the attachment are not the same.");

        case gl.FRAMEBUFFER_UNSUPPORTED:
          throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
      }

      if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
        throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
      }
    }
  }]);

  return RenderTarget;
}(EngineObject);

/**
 * 类应用于渲染颜色纹理。
 */

var RenderColorTexture = /*#__PURE__*/function (_Texture) {
  _inherits(RenderColorTexture, _Texture);

  var _super = _createSuper(RenderColorTexture);

  _createClass(RenderColorTexture, [{
    key: "format",

    /** @internal */

    /**
     * 格式。
     */
    get: function get() {
      return this._format;
    }
    /**
     * 是否自动生成多级纹理。
     */

  }, {
    key: "autoGenerateMipmaps",
    get: function get() {
      return this._autoMipmap;
    },
    set: function set(value) {
      this._autoMipmap = value;
    }
    /**
     * 构造渲染纹理。
     * @param engine - 所属引擎
     * @param width - 宽
     * @param height - 高
     * @param format - 格式，默认 RenderBufferColorFormat.R8G8B8A8
     * @param mipmap - 是否使用多级纹理
     * @param isCube - 是否为立方体模式
     */

  }]);

  function RenderColorTexture(engine, width, height) {
    var _this;

    var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.RenderBufferColorFormat.R8G8B8A8;
    var mipmap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var isCube = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, RenderColorTexture);

    _this = _super.call(this, engine);
    _this._isCube = false;
    _this._format = void 0;
    _this._autoMipmap = false;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;

    if (!Texture._supportRenderBufferColorFormat(format, rhi)) {
      throw new Error("RenderBufferColorFormat is not supported:".concat(exports.RenderBufferColorFormat[format]));
    }

    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }

    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }

    _this._glTexture = gl.createTexture();
    _this._formatDetail = Texture._getRenderBufferColorFormatDetail(format, gl, isWebGL2);
    _this._isCube = isCube;
    _this._rhi = rhi;
    _this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();

    _this._initMipmap(isCube);

    _this.filterMode = exports.TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = exports.TextureWrapMode.Clamp;
    return _this;
  }
  /**
   * 根据立方体面和指定区域获得颜色像素缓冲。
   * @param face - 如果是立方体纹理，可以选择读取第几个面;立方体纹理读取面，isCube=true时生效
   * @param x - 区域起始X坐标
   * @param y - 区域起始Y坐标
   * @param width - 区域宽
   * @param height - 区域高
   * @param out - 颜色像素缓冲
   */


  _createClass(RenderColorTexture, [{
    key: "getPixelBuffer",
    value: function getPixelBuffer(face, x, y, width, height, out) {
      _get(_getPrototypeOf(RenderColorTexture.prototype), "_getPixelBuffer", this).call(this, face, x, y, width, height, out);
    }
  }]);

  return RenderColorTexture;
}(Texture);

/**
 * Sprite渲染管理器
 * @class
 */
var SpriteRenderer = /*#__PURE__*/function (_RenderableComponent) {
  _inherits(SpriteRenderer, _RenderableComponent);

  var _super = _createSuper(SpriteRenderer);

  /**
   * 渲染方式，2D或3D，默认是2D。TODO: 3D
   */

  /**
   * 调节色，控制 Sprite 颜色变化
   */

  /**
   * 构造函数
   * @param {Entity} entity
   */
  function SpriteRenderer(entity) {
    var _this;

    _classCallCheck(this, SpriteRenderer);

    _this = _super.call(this, entity);
    _this._uvRect = void 0;
    _this._worldSize = [];
    _this._positionQuad = void 0;
    _this._rotationAngle = 0;
    _this._anchor = void 0;
    _this._texture = void 0;
    _this._rect = void 0;
    _this._worldSizeFactor = void 0;
    _this.renderMode = "2D";
    _this.tintColor = new miniprogram.Vector4(1, 1, 1, 1);
    _this.transformMatrix = void 0;
    _this._worldSizeFactor = 100;

    _this.setTexture(undefined);

    _this.setRect(undefined);

    _this.setAnchor(undefined);

    _this.setUvRect();

    _this.setWorldSize();

    _this._positionQuad = {
      leftTop: new miniprogram.Vector3(),
      leftBottom: new miniprogram.Vector3(),
      rightTop: new miniprogram.Vector3(),
      rightBottom: new miniprogram.Vector3()
    };
    return _this;
  }

  _createClass(SpriteRenderer, [{
    key: "setTexture",
    value: function setTexture(texture) {
      // TODO：临时兼容Resource
      if (texture && texture.asset) {
        texture = texture.asset;
      }

      this._texture = texture;
    }
    /**
     * 旋转角度
     * @member {Vector4}
     */

  }, {
    key: "setRect",
    value: function setRect(rect) {
      var _this$_texture$width, _this$_texture, _this$_texture$height, _this$_texture2;

      var rectObject;

      try {
        if (rect) {
          rectObject = JSON.parse(rect);
        }
      } catch (error) {
        Logger.warn("Rect is not valid JSON format");
      }

      this._rect = rect || {
        x: 0,
        y: 0,
        width: (_this$_texture$width = (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.width) !== null && _this$_texture$width !== void 0 ? _this$_texture$width : 0,
        height: (_this$_texture$height = (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.height) !== null && _this$_texture$height !== void 0 ? _this$_texture$height : 0
      };
    }
  }, {
    key: "setAnchor",
    value: function setAnchor(anchor) {
      this._anchor = anchor || [0.5, 0.5];
    }
  }, {
    key: "setWorldSize",
    value: function setWorldSize() {
      var _worldSizeFactor = this._worldSizeFactor;
      this._worldSize = [this._rect.width / _worldSizeFactor, this._rect.height / _worldSizeFactor];
    }
  }, {
    key: "setUvRect",
    value: function setUvRect() {
      var w, h;

      if (this._texture) {
        w = this._texture.width;
        h = this._texture.height;
      } else {
        w = this._rect.width;
        h = this._rect.height;
      }

      this._uvRect = {
        u: this._rect.x / w,
        v: this._rect.y / h,
        width: this._rect.width / w,
        height: this._rect.height / h
      };
    }
    /**
     * 更新位置，将数据对象加入渲染队列
     * @param {Camera} camera
     */

  }, {
    key: "render",
    value: function render(camera) {
      this._updatePositionQuad(camera);

      this._transformByMatrix();

      camera._renderPipeline.pushSprite(this, this._positionQuad, this._uvRect, this.tintColor, this.texture, this.renderMode, camera);
    }
  }, {
    key: "_transformByMatrix",
    value: function _transformByMatrix() {
      if (!this.transformMatrix) return;
      var matrix = this.transformMatrix;
      var temp = this._positionQuad.leftTop;
      var leftTop = SpriteRenderer._tempVec40;
      leftTop.setValue(temp.x, temp.y, temp.z, 1);
      temp = this._positionQuad.leftBottom;
      var leftBottom = SpriteRenderer._tempVec41;
      leftBottom.setValue(temp.x, temp.y, temp.z, 1);
      temp = this._positionQuad.rightTop;
      var rightTop = SpriteRenderer._tempVec42;
      rightTop.setValue(temp.x, temp.y, temp.z, 1);
      temp = this._positionQuad.rightBottom;
      var rightBottom = SpriteRenderer._tempVec43;
      rightBottom.setValue(temp.x, temp.y, temp.z, 1);
      miniprogram.Vector4.transform(leftTop, matrix, leftTop);
      miniprogram.Vector4.transform(leftBottom, matrix, leftBottom);
      miniprogram.Vector4.transform(rightTop, matrix, rightTop);
      miniprogram.Vector4.transform(rightBottom, matrix, rightBottom);

      this._positionQuad.leftTop.setValue(leftTop.x, leftTop.y, leftTop.z);

      this._positionQuad.leftBottom.setValue(leftBottom.x, leftBottom.y, leftBottom.z);

      this._positionQuad.rightTop.setValue(rightTop.x, rightTop.y, rightTop.z);

      this._positionQuad.rightBottom.setValue(rightBottom.x, rightBottom.y, rightBottom.z);
    }
    /**
     * 更新顶点位置
     * @param {Camera} camera
     * @private
     */

  }, {
    key: "_updatePositionQuad",
    value: function _updatePositionQuad(camera) {
      if (this.renderMode === "2D") {
        var m = camera.viewMatrix.elements;
        var vx = new miniprogram.Vector3(m[0], m[4], m[8]);
        var vy = new miniprogram.Vector3(m[1], m[5], m[9]); //-- center pos

        var c = this.entity.worldPosition.clone();
        var s = this._worldSize;
        var ns = this.entity.scale;
        vx.scale(s[0] * ns.x);
        vy.scale(s[1] * ns.y);

        if (this._rotationAngle !== 0) {
          var vz = new miniprogram.Vector3(m[2], m[6], m[10]);
          var rotation = new miniprogram.Quaternion();
          miniprogram.Quaternion.rotationAxisAngle(vz, this._rotationAngle, rotation);
          miniprogram.Vector3.transformByQuat(vx, rotation, vx);
          miniprogram.Vector3.transformByQuat(vy, rotation, vy);
        }

        var cx = new miniprogram.Vector3();
        var cy = new miniprogram.Vector3();
        miniprogram.Vector3.scale(vx, (this.anchor[0] - 0.5) * 2, cx);
        miniprogram.Vector3.scale(vy, (this.anchor[1] - 0.5) * 2, cy);
        c.subtract(cx).add(cy); //-- quad pos

        var leftTop = this._positionQuad.leftTop;
        miniprogram.Vector3.subtract(c, vx, leftTop);
        leftTop.add(vy);
        var leftBottom = this._positionQuad.leftBottom;
        miniprogram.Vector3.subtract(c, vx, leftBottom);
        leftBottom.subtract(vy);
        var rightBottom = this._positionQuad.rightBottom;
        miniprogram.Vector3.add(c, vx, rightBottom);
        rightBottom.subtract(vy);
        var rightTop = this._positionQuad.rightTop;
        miniprogram.Vector3.add(c, vx, rightTop);
        rightTop.add(vy);
      }
    }
  }, {
    key: "texture",
    set: function set(v) {
      this.setTexture(v);
      this.setRect();
      this.setUvRect();
      this.setWorldSize();
    },
    get: function get() {
      return this._texture;
    }
  }, {
    key: "anchor",
    set: function set(v) {
      this._anchor = v || [0.5, 0.5];
    },
    get: function get() {
      return this._anchor;
    }
  }, {
    key: "rect",
    set: function set(v) {
      this.setRect(v);
      this.setUvRect();
      this.setWorldSize();
    },
    get: function get() {
      return this._rect;
    }
  }, {
    key: "rotationAngle",
    get: function get() {
      return this._rotationAngle;
    },
    set: function set(v) {
      this._rotationAngle = v;
    }
  }]);

  return SpriteRenderer;
}(RenderableComponent);
SpriteRenderer._tempVec40 = new miniprogram.Vector4();
SpriteRenderer._tempVec41 = new miniprogram.Vector4();
SpriteRenderer._tempVec42 = new miniprogram.Vector4();
SpriteRenderer._tempVec43 = new miniprogram.Vector4();

/**
 * 动画循环播放模式
 * @readonly
 */
/**
 * 动画事件类型
 * @readonly
 */

(function (WrapMode) {
  WrapMode[WrapMode["ONCE"] = 0] = "ONCE";
  WrapMode[WrapMode["LOOP"] = 1] = "LOOP";
})(exports.WrapMode || (exports.WrapMode = {}));
/**
 * 动画插值方式
 * @readonly
 */

(function (AnimationEventType) {
  AnimationEventType[AnimationEventType["FINISHED"] = 0] = "FINISHED";
  AnimationEventType[AnimationEventType["LOOP_END"] = 1] = "LOOP_END";
  AnimationEventType[AnimationEventType["FRAME_EVENT"] = 2] = "FRAME_EVENT";
})(exports.AnimationEvent || (exports.AnimationEvent = {}));

(function (InterpolationType) {
  InterpolationType[InterpolationType["LINEAR"] = 0] = "LINEAR";
  InterpolationType[InterpolationType["CUBICSPLINE"] = 1] = "CUBICSPLINE";
  InterpolationType[InterpolationType["STEP"] = 2] = "STEP";
})(exports.InterpolationType || (exports.InterpolationType = {}));

var TagetType;
/**
 * Data for an animation, set of Samples and Channels
 * @extends AssetObject
 */

(function (TagetType) {
  TagetType[TagetType["position"] = 0] = "position";
  TagetType[TagetType["rotation"] = 1] = "rotation";
  TagetType[TagetType["scale"] = 2] = "scale";
  TagetType[TagetType["other"] = 3] = "other";
})(TagetType || (TagetType = {}));

var AnimationClip = /*#__PURE__*/function (_AssetObject) {
  _inherits(AnimationClip, _AssetObject);

  var _super = _createSuper(AnimationClip);

  /**
   * @constructor
   * @param {string} name
   */
  function AnimationClip(name) {
    var _this;

    _classCallCheck(this, AnimationClip);

    _this = _super.call(this, null);
    /** @member {Array} */

    _this.name = name;
    _this.duration = void 0;
    _this.durationIndex = void 0;
    _this.samplers = void 0;
    _this.channels = void 0;
    _this.samplers = [];
    /** @member {Array} */

    _this.channels = [];
    return _this;
  }
  /**
   * 添加一个 sampler
   * @param {Float32Array} _input
   * @param {Float32Array} _output
   * @param {number} _outputSize
   * @param {constant} _interpolation
   */


  _createClass(AnimationClip, [{
    key: "addSampler",
    value: function addSampler(_input, _output, _outputSize) {
      var _interpolation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.InterpolationType.LINEAR;

      // FIXME - adapt old error animation export file
      if (_interpolation === exports.InterpolationType.CUBICSPLINE) {
        if (_outputSize <= 4) {
          _interpolation = exports.InterpolationType.LINEAR;
        } else {
          _outputSize /= 3;
        }
      } // sampler object, defines an curve


      var sampler = {
        input: _input,
        output: _output,
        outputSize: _outputSize,
        interpolation: _interpolation
      };
      this.samplers.push(sampler);
    }
    /**
     * 添加 channel
     * @param {number} samplerIndex
     * @param {string} targetID, Entity name
     * @param {string} targetPath, Transform property name: position, rotation, scale
     */

  }, {
    key: "addChannel",
    value: function addChannel(samplerIndex, targetID, targetPath) {
      var bindSampler = this.samplers[samplerIndex];
      var tagetType = AnimationClip._tagetTypeMap[targetPath]; // channel object, bind a Sample to an Object property

      var channel = {
        sampler: bindSampler,
        target: {
          id: targetID,
          path: targetPath,
          pathType: tagetType !== null && tagetType !== void 0 ? tagetType : TagetType.other
        }
      };
      this.channels.push(channel);
    }
    /**
     * 取得 channel 的总数
     * @return {number} number of channels
     */

  }, {
    key: "getChannelCount",
    value: function getChannelCount() {
      return this.channels.length;
    }
    /**
     * 取得 channel 的作用的 object
     * @return channel objects
     * @param {number} channelIndex
     */

  }, {
    key: "getChannelObject",
    value: function getChannelObject(channelIndex) {
      return this.channels[channelIndex];
    }
    /**
     * 取得 channel 的 frame count
     * @return channel frame count
     * @param {number} channelIndex
     */

  }, {
    key: "getFrameCount",
    value: function getFrameCount(channelIndex) {
      var sampler = this.channels[channelIndex].sampler;
      return sampler.input.length;
    }
    /**
     * 取得 channel 的 frame time
     * @return channel frame time
     * @param {number} channelIndex
     * @param {number} frameIndex
     */

  }, {
    key: "getFrameTime",
    value: function getFrameTime(channelIndex, frameIndex) {
      var sampler = this.channels[channelIndex].sampler;
      return sampler.input[frameIndex];
    }
    /**
     * 取得 channel 的时间长度
     * @return channel time length
     * @param {number} channelIndex
     */

  }, {
    key: "getChannelTimeLength",
    value: function getChannelTimeLength(channelIndex) {
      var sampler = this.channels[channelIndex].sampler;
      var frameCount = sampler.input.length;
      return sampler.input[frameCount - 1];
    }
    /**
     * 取得 channel 的值
     * @return channel value
     * @param {number} channelIndex
     */

  }, {
    key: "createChannelValue",
    value: function createChannelValue(channelIndex) {
      var sampler = this.channels[channelIndex].sampler;
      return new Float32Array(sampler.outputSize);
    }
    /**
     * @private
     * @param {Value} outValue
     * @param {number} channelIndex
     * @param {number} frameIndex
     * @param {number} nextFrameIndex
     * @param {number} alpha
     */

  }, {
    key: "evaluate",
    value: function evaluate(outValue, channelIndex, frameIndex, nextFrameIndex, alpha) {
      var channel = this.channels[channelIndex];
      var output = channel.sampler.output;
      var outputSize = channel.sampler.outputSize;

      switch (channel.sampler.interpolation) {
        case exports.InterpolationType.CUBICSPLINE:
          this.evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
          break;

        case exports.InterpolationType.LINEAR:
          this.evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
          break;
      }

      return outValue;
    }
  }, {
    key: "evaluateCubicSpline",
    value: function evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
      var squared = alpha * alpha;
      var cubed = alpha * squared;
      var part1 = 2.0 * cubed - 3.0 * squared + 1.0;
      var part2 = -2.0 * cubed + 3.0 * squared;
      var part3 = cubed - 2.0 * squared + alpha;
      var part4 = cubed - squared;

      for (var i = outputSize; i >= 0; i--) {
        var t1 = output[frameIndex * outputSize * 3 + i];
        var v1 = output[frameIndex * outputSize * 3 + outputSize + i];
        var t2 = output[frameIndex * outputSize * 3 + outputSize * 2 + i];
        var v2 = output[nextFrameIndex * outputSize * 3 + outputSize + i];
        outValue[i] = v1 * part1 + v2 * part2 + t1 * part3 + t2 * part4;
      }
    }
  }, {
    key: "evaluateLinear",
    value: function evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
      switch (outputSize) {
        case 1:
          outValue[0] = output[frameIndex] * (1 - alpha) + output[nextFrameIndex] * alpha;
          break;

        case 4:
          // const start = new Quaternion(
          //   output[frameIndex * outputSize],
          //   output[frameIndex * outputSize + 1],
          //   output[frameIndex * outputSize + 2],
          //   output[frameIndex * outputSize + 3]
          // );
          // const end = new Quaternion(
          //   output[nextFrameIndex * outputSize],
          //   output[nextFrameIndex * outputSize + 1],
          //   output[nextFrameIndex * outputSize + 2],
          //   output[nextFrameIndex * outputSize + 3]
          // );
          // Quaternion.slerp(start, end, alpha, <Quaternion>outValue);
          this._quaSlerp(outValue, output, frameIndex * outputSize, output, nextFrameIndex * outputSize, alpha);

          break;

        default:
          for (var i = outputSize; i >= 0; i--) {
            outValue[i] = output[frameIndex * outputSize + i] * (1 - alpha) + output[nextFrameIndex * outputSize + i] * alpha;
          }

          break;
      } // end of switch

    }
  }, {
    key: "_quaSlerp",
    value: function _quaSlerp(out, a, aIndex, b, bIndex, t) {
      // benchmarks:
      //    http://jsperf.com/quaternion-slerp-implementations
      var ax = a[0 + aIndex],
          ay = a[1 + aIndex],
          az = a[2 + aIndex],
          aw = a[3 + aIndex];
      var bx = b[0 + bIndex],
          by = b[1 + bIndex],
          bz = b[2 + bIndex],
          bw = b[3 + bIndex];
      var omega, cosom, sinom, scale0, scale1; // calc cosine

      cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      } // calculate coefficients


      if (1.0 - cosom > 0.000001) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
      } // calculate final values


      out[0] = scale0 * ax + scale1 * bx;
      out[1] = scale0 * ay + scale1 * by;
      out[2] = scale0 * az + scale1 * bz;
      out[3] = scale0 * aw + scale1 * bw;
      return out;
    }
  }]);

  return AnimationClip;
}(AssetObject);
AnimationClip._tagetTypeMap = {
  position: TagetType.position,
  rotation: TagetType.rotation,
  scale: TagetType.scale
};

/**
 * AnimationClip playback
 * @extends EventDispatcher
 * @see class AnimationClip
 * @private
 */
var AnimationLayer = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(AnimationLayer, _EventDispatcher);

  var _super = _createSuper(AnimationLayer);

  _createClass(AnimationLayer, [{
    key: "isPlaying",

    /**
     * @return is playing˝
     */
    get: function get() {
      return this._animClip && this._isPlaying;
    }
  }]);

  /**
   * @constructor
   */
  function AnimationLayer() {
    var _this;

    _classCallCheck(this, AnimationLayer);

    _this = _super.call(this, null);
    _this.layerWeight = void 0;
    _this.mixTagetLayer = void 0;
    _this.isFading = void 0;
    _this.fadeDeltaTime = void 0;
    _this.crossFadeDuration = void 0;
    _this.fadeDuration = void 0;
    _this.crossFadeDeltaTime = void 0;
    _this.isMixLayer = void 0;
    _this.hasMixLayer = void 0;
    _this.mixEntity = void 0;
    _this._activedEvents = void 0;
    _this._animClip = void 0;
    _this._isPlaying = void 0;
    _this._wrapMode = void 0;
    _this._channelStates = void 0;
    _this._animClipLength = void 0;
    _this._frameEvents = void 0;
    _this.layerWeight = 1.0;
    _this._activedEvents = [];
    return _this;
  }
  /**
   * @param {AnimationClip} nextAnimClip, anim clip to playback next
   * @param {Entity} rootEntity
   * @return can mix with current AnimationClip
   */


  _createClass(AnimationLayer, [{
    key: "canMix",
    value: function canMix(nextAnimClip, rootEntity) {
      if (!this._animClip || !this._isPlaying || this.isMixLayer || this.isFading) {
        return false;
      }

      if (this._animClip.getChannelCount() !== nextAnimClip.getChannelCount()) {
        return false;
      }

      var count = this._animClip.getChannelCount();

      for (var i = count - 1; i >= 0; i--) {
        var curChannel = this._animClip.getChannelObject(i);

        var curTargetObject = this._findChannelTarget(rootEntity, curChannel.target);

        var nextChannel = nextAnimClip.getChannelObject(i);

        var nextTargetObject = this._findChannelTarget(rootEntity, nextChannel.target);

        if (curTargetObject !== nextTargetObject) {
          return false;
        }
      }

      return true;
    }
    /**
     * mix animClip with target animationLayer
     * @param {AnimationClip} animClip, anim clip to mix
     * @param {AnimationLayer} targetLayer, target animationLayer
     * @param {Entity} rootEntity, root node of skeleton animation
     * @param {Entity} mixNode, mix bone node
     * @param {AnimationOptions} options, animation events options
     */

  }, {
    key: "mix",
    value: function mix(animClip, targetLayer, rootEntity, mixEntity) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      this._isPlaying = targetLayer.isPlaying;
      this._animClip = animClip;
      this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : targetLayer._wrapMode;

      this._addEvents(options);

      this._channelStates = [];
      this._animClipLength = 0; // -- create new state object

      if (this._isPlaying) {
        var targetChannelStates = targetLayer._channelStates;

        var count = this._animClip.getChannelCount();

        for (var i = count - 1; i >= 0; i--) {
          var channel = this._animClip.getChannelObject(i);

          var targetObject = this._findChannelTarget(mixEntity, channel.target);

          this._channelStates[i] = {
            frameTime: 0.0,
            currentFrame: 0,
            currentValue: this._animClip.createChannelValue(i),
            mixWeight: targetObject ? 1 : 0
          };
          targetChannelStates[i].mixWeight = targetChannelStates[i].mixWeight === undefined ? 1 : targetChannelStates[i].mixWeight;

          if (targetChannelStates[i].mixWeight === 1) {
            targetChannelStates[i].mixWeight = targetObject ? 0 : 1;
          }

          var channelTimeLength = this._animClip.getChannelTimeLength(i);

          this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
        } // end of for


        return true;
      }

      return false;
    }
  }, {
    key: "removeMixWeight",
    value: function removeMixWeight() {
      var count = this._channelStates.length;

      for (var i = count - 1; i >= 0; i--) {
        if (this._channelStates[i].mixWeight === 1) {
          this.mixTagetLayer._channelStates[i].mixWeight = 1;
        }
      }
    }
    /**
     * play specify anim clip
     * @param {AnimationClip} animClip, anim clip to playback
     * @param {Entity} rootEntity, root node of Skeleton Animation
     * @param {AnimationOptions} options
     */

  }, {
    key: "play",
    value: function play(animClip, rootEntity) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        wrapMode: exports.WrapMode.LOOP
      };
      this._isPlaying = !!animClip;
      this._animClip = animClip;
      this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : exports.WrapMode.LOOP;

      this._addEvents(options);

      this._channelStates = [];
      this._animClipLength = 0; // -- create new state object

      if (this._isPlaying) {
        var count = this._animClip.getChannelCount();

        var channelTargets = [];

        for (var i = count - 1; i >= 0; i--) {
          var channel = this._animClip.getChannelObject(i);

          var targetObject = this._findChannelTarget(rootEntity, channel.target);

          if (!targetObject) {
            Logger.warn("Can not find channel target:" + channel.target.id);
          }

          this._channelStates[i] = {
            frameTime: 0.0,
            currentFrame: 0,
            currentValue: this._animClip.createChannelValue(i)
          };
          channelTargets[i] = {
            targetObject: targetObject,
            path: channel.target.path,
            pathType: channel.target.pathType,
            outputSize: channel.sampler.outputSize
          };

          var channelTimeLength = this._animClip.getChannelTimeLength(i);

          this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
        } // end of for


        return channelTargets;
      }

      return false;
    }
    /**
     * stop play anim clip
     * @param {boolean} rightnow stop it immediately, or it will stop at the end of the clip
     */

  }, {
    key: "stop",
    value: function stop(rightnow) {
      if (!this._animClip || !this._isPlaying) {
        return;
      }

      if (rightnow) {
        this._isPlaying = false;
      } else {
        this._wrapMode = exports.WrapMode.ONCE;
      }
    }
    /**
     * update animation states only
     * @param {number} deltaTime
     */

  }, {
    key: "updateState",
    value: function updateState(deltaTime) {
      if (!this._animClip || !this._isPlaying) {
        return;
      } // 更新Animation Layer 的权重


      if (this.isFading) {
        this.fadeDeltaTime += deltaTime;
        this.layerWeight = 1.0 - this.fadeDeltaTime / this.fadeDuration;

        if (this.layerWeight <= 0) {
          this._isPlaying = false;
        }
      } else if (this.crossFadeDuration) {
        this.crossFadeDeltaTime += deltaTime;
        this.layerWeight = this.crossFadeDeltaTime / this.crossFadeDuration;

        if (this.layerWeight >= 1.0) {
          this.layerWeight = 1.0;
          delete this.crossFadeDuration;
        }
      }

      deltaTime = deltaTime / 1000;

      this._activeEvents(deltaTime); // -- update channelStates


      var count = this._animClip.getChannelCount();

      var playingCount = 0;

      for (var i = count - 1; i >= 0; i--) {
        if (this._updateChannelState(deltaTime, i)) {
          playingCount++;
        }
      }

      if (playingCount === 0) {
        this._isPlaying = false;

        if (this.isMixLayer) {
          this.removeMixWeight();
        }
      }
    }
    /**
     * @return channel layer weight
     * @param {number} channelIndex
     */

  }, {
    key: "getChannelLayerWeight",
    value: function getChannelLayerWeight(channelIndex) {
      if ((this.hasMixLayer || this.isMixLayer) && channelIndex < this._channelStates.length) {
        var mixWeight = this._channelStates[channelIndex].mixWeight;
        var layerWeight = this.isMixLayer ? this.mixTagetLayer.layerWeight : this.layerWeight;
        return mixWeight * layerWeight;
      }

      return this.layerWeight;
    }
    /**
     * @return channel value
     * @param {number} channelIndex
     */

  }, {
    key: "getChannelValue",
    value: function getChannelValue(channelIndex) {
      return this._channelStates[channelIndex].currentValue;
    }
    /**
     * 触发动画事件
     */

  }, {
    key: "triggerEvents",
    value: function triggerEvents() {
      var _this2 = this;

      this._activedEvents && this._activedEvents.forEach(function (event) {
        _this2.trigger(event);
      });
      this._activedEvents.length = 0;
    }
    /**
     * 跳转到某一帧
     * @param {number} frameTime
     */

  }, {
    key: "jumpToFrame",
    value: function jumpToFrame(frameTime) {
      var count = this._animClip.getChannelCount();

      for (var i = count - 1; i >= 0; i--) {
        // 1. - clear pre frameTime
        var channelState = this._channelStates[i];
        channelState.frameTime = 0; // 2. - update new frameTime

        this._updateChannelState(frameTime, i);
      }
    }
    /**
     * update state and value of channel
     * @param {float} deltaTime
     * @param {number} channelIndex
     * @private
     */

  }, {
    key: "_updateChannelState",
    value: function _updateChannelState(deltaTime, channelIndex) {
      var animClip = this._animClip;
      var channelState = this._channelStates[channelIndex];
      var animClipLength = animClip.getChannelTimeLength(channelIndex);
      channelState.frameTime += deltaTime;

      if (channelState.frameTime > animClipLength) {
        switch (this._wrapMode) {
          case exports.WrapMode.ONCE:
            channelState.frameTime = animClipLength;
            break;

          case exports.WrapMode.LOOP:
            channelState.frameTime = channelState.frameTime % this._animClipLength;
            break;

          default:
            Logger.error("Unknown Anim wrap Mode: " + this._wrapMode);
        }
      } // end of if


      if (channelState.mixWeight && channelState.mixWeight === 0) {
        return true;
      }

      var frameTime = Math.min(channelState.frameTime, animClipLength);

      var lerpState = this._getKeyAndAlpha(animClip.getChannelObject(channelIndex), frameTime);

      channelState.currentValue = animClip.evaluate(channelState.currentValue, channelIndex, lerpState.currentKey, lerpState.nextKey, lerpState.alpha);

      if (this._wrapMode === exports.WrapMode.ONCE && channelState.frameTime >= animClipLength) {
        return false;
      }

      return true;
    } // -- private ----------------------------------------------------------

    /**
     * @param {Object} add animation events
     * @private
     */

  }, {
    key: "_addEvents",
    value: function _addEvents(options) {
      var _this3 = this;

      this.removeAllEventListeners();
      this._frameEvents = [];

      if (options.events) {
        var frameEventIndex = 0;

        var _loop = function _loop(i) {
          var event = options.events[i];
          var eventType = event.type;

          if (event.type === exports.AnimationEvent.FRAME_EVENT) {
            eventType = "frameEvent" + frameEventIndex;
            frameEventIndex++;

            _this3._frameEvents.push({
              eventType: eventType,
              triggerTime: event.triggerTime,
              triggered: false
            });
          }

          _this3.addEventListener(eventType, function (e) {
            event.callback();
          });
        };

        for (var i = options.events.length - 1; i >= 0; i--) {
          _loop(i);
        } // end of for

      } // end of if

    }
    /**
     * 激活动画事件
     * @param {number} deltaTime
     * @private
     */

  }, {
    key: "_activeEvents",
    value: function _activeEvents(deltaTime) {
      // 触发Frame Event
      var index = this._animClip.durationIndex;

      if (this._frameEvents.length > 0 && this._channelStates.length > 0) {
        var curFrameTime = this._channelStates[index].frameTime + deltaTime;

        for (var i = this._frameEvents.length - 1; i >= 0; i--) {
          var frameEvent = this._frameEvents[i];

          if (!frameEvent.triggered && curFrameTime > frameEvent.triggerTime) {
            this._activedEvents.push(new Event(frameEvent.eventType, this));

            frameEvent.triggered = true;
          }
        }
      }

      if (this._channelStates.length > 0 && this._channelStates[index].frameTime + deltaTime >= this._animClip.duration) {
        if (this._wrapMode === exports.WrapMode.LOOP) {
          // 重置Frame Event状态
          if (this._frameEvents.length > 0) {
            for (var _i = this._frameEvents.length - 1; _i >= 0; _i--) {
              this._frameEvents[_i].triggered = false;
            }
          } // 激活Loop End Event
          // @ts-ignore


          if (this.hasEvent(exports.AnimationEvent.LOOP_END)) {
            this._activedEvents.push(new Event(exports.AnimationEvent.LOOP_END, this));
          } // @ts-ignore

        } else if (this.hasEvent(exports.AnimationEvent.FINISHED)) {
          // 激活Finish Event
          this._activedEvents.push(new Event(exports.AnimationEvent.FINISHED, this));
        }
      }
    }
    /**
     * update state of channel
     * @param {Entity} rootNode
     * @param {object} target
     * @private
     */

  }, {
    key: "_findChannelTarget",
    value: function _findChannelTarget(rootNode, target) {
      var targetID = target.id;
      var targetSceneObject = null;

      if (rootNode.name === targetID) {
        targetSceneObject = rootNode;
      } else {
        targetSceneObject = rootNode.findByName(targetID);
      }

      if (target.path === "weights") {
        return targetSceneObject.getComponent(SkinnedMeshRenderer);
      } else {
        return targetSceneObject;
      }
    }
    /**
     * @return current and next key id, current alpha
     * @param {number} channel
     * @param {float} time
     * @private
     */

  }, {
    key: "_getKeyAndAlpha",
    value: function _getKeyAndAlpha(channel, time) {
      var keyTime = 0;
      var currentKey = 0;
      var nextKey = 0;
      var timeKeys = channel.sampler.input;
      var numKeys = timeKeys.length;

      for (var i = numKeys - 1; i >= 0; i--) {
        if (time > timeKeys[i]) {
          keyTime = time - timeKeys[i];
          currentKey = i;
          break;
        }
      }

      nextKey = currentKey + 1;

      if (nextKey >= numKeys) {
        switch (this._wrapMode) {
          case exports.WrapMode.ONCE:
            nextKey = numKeys - 1;
            break;

          case exports.WrapMode.LOOP:
            nextKey = 0;
            break;
        }
      }

      var keyLength = timeKeys[nextKey] - timeKeys[currentKey];
      var alpha = nextKey === currentKey || keyLength < 0.00001 ? 1 : keyTime / keyLength;
      return {
        currentKey: currentKey,
        nextKey: nextKey,
        alpha: alpha
      };
    }
  }]);

  return AnimationLayer;
}(EventDispatcher);

var _class$9, _descriptor$9, _descriptor2$8, _descriptor3$6, _descriptor4$6, _descriptor5$5, _temp$9;

/**
 * 播放动画片段，动画片段所引用的对象必须是此组件的 Entity 及其子物体
 */
var Animation = (_class$9 = (_temp$9 = /*#__PURE__*/function (_Component) {
  _inherits(Animation, _Component);

  var _super = _createSuper(Animation);

  _createClass(Animation, [{
    key: "timeScale",

    /**
     * 缩放播放速度
     * @member {number}
     */
    get: function get() {
      return this._timeScale;
    }
    /**
     * 设置播放速度
     */
    ,
    set: function set(val) {
      if (val > 0) {
        this._timeScale = val;
      }
    }
    /**
     * @param {Float32Array | number} outValue
     * @param {number} startValue
     * @param {number} endValue
     * @param {number} outputSize
     * @param {number} alpha
     * @private
     */

  }], [{
    key: "lerp",
    value: function lerp(outValue, startValue, endValue, alpha, outputSize) {
      switch (outputSize) {
        case 1:
          outValue = startValue * (1 - alpha) + endValue * alpha;
          break;

        case 4:
          var start = _construct(miniprogram.Quaternion, _toConsumableArray(startValue));

          var end = _construct(miniprogram.Quaternion, _toConsumableArray(endValue));

          var quat = new miniprogram.Quaternion();
          miniprogram.Quaternion.slerp(start, end, alpha, quat);
          outValue[0] = quat.x;
          outValue[1] = quat.y;
          outValue[2] = quat.z;
          outValue[3] = quat.w;
          break;

        default:
          for (var i = outputSize; i >= 0; i--) {
            outValue[i] = startValue[i] * (1 - alpha) + endValue[i] * alpha;
          }

          break;
      } // end of switch


      return outValue;
    }
    /** @internal */

  }]);

  /**
   * @param {Entity} entity
   */
  function Animation(entity) {
    var _this;

    _classCallCheck(this, Animation);

    _this = _super.call(this, entity);

    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor$9, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_animSet", _descriptor2$8, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_animLayers", _descriptor3$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_timeScale", _descriptor4$6, _assertThisInitialized(_this));

    _initializerDefineProperty(_this, "_channelTargets", _descriptor5$5, _assertThisInitialized(_this));

    return _this;
  }
  /**
   * 动画更新计算
   * @param {number} deltaTime
   * @private
   */


  _createClass(Animation, [{
    key: "update",
    value: function update(deltaTime) {
      if (!this.isPlaying()) {
        return;
      }

      deltaTime = deltaTime * this._timeScale; // update state

      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        var animLayer = this._animLayers[i];
        animLayer.updateState(deltaTime);
      } // update value


      this._updateValues(); // trigger events and destroy no use layer


      for (var _i = this._animLayers.length - 1; _i >= 0; _i--) {
        var _animLayer = this._animLayers[_i];

        _animLayer.triggerEvents();

        if (!_animLayer.isPlaying && (_animLayer.isFading || _animLayer.isMixLayer)) {
          this._animLayers.splice(_i, 1);

          this._removeRefMixLayers(_animLayer);
        }
      }
    }
    /**
     * 加载一个animClip
     * @param {AnimationClip} animClip 动画片段对象
     * @param {string} name 动画片段名称
     */

  }, {
    key: "addAnimationClip",
    value: function addAnimationClip(animClip, name) {
      this._animSet[name] = animClip;
    }
    /**
     * 移除一个animClip
     * @param {string} name 动画片段的名称
     */

  }, {
    key: "removeAnimationClip",
    value: function removeAnimationClip(name) {
      var animClip = this._animSet[name];

      if (animClip) {
        delete this._animSet[name];
      }
    }
    /**
     * 取得指定的 AnimationClip 的时间长度
     * @param {string} name 动画片段的名称
     * @return {number}
     */

  }, {
    key: "getAnimationClipLength",
    value: function getAnimationClipLength(name) {
      var animClip = this._animSet[name];

      if (animClip) {
        return animClip.getChannelTimeLength(0);
      } else {
        return 0.0;
      }
    }
    /**
     * 取得指定的 AnimationClip
     * @param {string} name 动画片段的名称
     * @return {number}
     */

  }, {
    key: "getAnimationClip",
    value: function getAnimationClip(name) {
      return this._animSet[name] || null;
    }
    /**
     * 是否正在播放
     * @return {boolean}
     */

  }, {
    key: "isPlaying",
    value: function isPlaying() {
      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        if (this._animLayers[i].isPlaying) {
          return true;
        }
      }

      return false;
    }
    /**
     * 动画事件参数
     * @typedef {Object} AnimationEventOpt
     * @param {AnimationEvent} type 动画事件类型
     * @param {function} callback 回调
     * @param {float} triggerTime 触发时间，只有type === AnimationEvent.FRAME_EVENT 时配置
     */

    /**
     * 配置动画播放的参数
     * @typedef {Object} AnimationOptions
     * @param {WrapMode} wrapMode 动画播放方式，LOOP：循环，ONCE：仅一次
     * @param {AnimationEventOpt[]} events 动画事件
     */

    /**
     * 播放动画
     * @param {String} name 动画片段的名称
     * @param {AnimationOptions} options 动画参数
     */

  }, {
    key: "playAnimationClip",
    value: function playAnimationClip(name, options) {
      var animClip = this._animSet[name];

      if (!animClip) {
        Logger.error("can not find anim clip: " + name);
        return;
      }

      var animLayer = null;

      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        if (!this._animLayers[i].isFading && !this._animLayers[i].isMixLayer) {
          animLayer = this._animLayers[i];
          break;
        }
      }

      if (!animLayer) {
        animLayer = new AnimationLayer();

        this._animLayers.push(animLayer);
      }

      this._removeRefMixLayers(animLayer);

      this._channelTargets = animLayer.play(animClip, this.entity, options);
    }
    /**
     * 动画混合过渡，因为动画混合过渡是一个比较消耗性能的操作，这里使用单独的接口crossFade
     * @param {string} name 动画片段的名称
     * @param {number} crossFadeDuration 动画切换需要的毫秒数
     * @param {AnimationOptions} options 动画参数
     */

  }, {
    key: "crossFade",
    value: function crossFade(name, crossFadeDuration, options) {
      var animClip = this._animSet[name];

      if (!animClip) {
        Logger.error("can not find anim clip: " + name);
        return;
      }

      if (!crossFadeDuration || crossFadeDuration < 0) {
        Logger.error("crossFadeDuration can not less than 0!");
        return;
      } // 寻找可以进行混合的目标


      var targetAnimLayer = null;

      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        if (this._animLayers[i].canMix(animClip, this.entity)) {
          targetAnimLayer = this._animLayers[i];
          break;
        }
      }

      if (targetAnimLayer) {
        // 先清除还未结束的crossFading动作
        for (var _i2 = this._animLayers.length - 1; _i2 >= 0; _i2--) {
          if (this._animLayers[_i2].isFading) {
            this._animLayers.splice(_i2, 1);
          }
        }

        targetAnimLayer.isFading = true;
        targetAnimLayer.fadeDuration = crossFadeDuration;
        targetAnimLayer.fadeDeltaTime = 0;
        var animLayer = new AnimationLayer();
        animLayer.crossFadeDuration = crossFadeDuration;
        animLayer.crossFadeDeltaTime = 0;
        animLayer.play(animClip, this.entity, options);

        this._animLayers.push(animLayer);
      } else {
        this.playAnimationClip(name, options);
      }
    }
    /**
     * 动画混合切换，因为动画混合是一个比较消耗性能的操作，这里使用单独的接口mix
     * @param {string} name 混合动画片段的名称
     * @param {string} mixBoneName 混合动画对名为mixBoneName的骨骼以及附属在其上的子骨骼生效
     * @param {AnimationOptions} options 动画参数
     */

  }, {
    key: "mix",
    value: function mix(name, mixBoneName, options) {
      var animClip = this._animSet[name];

      if (!animClip) {
        Logger.error("can not find anim clip: " + name);
        return;
      }

      var mixNode = this.entity.findByName(mixBoneName);

      if (!mixNode) {
        Logger.error("can not find mix bone!");
        return;
      } // 寻找可以进行混合的目标


      var targetAnimLayer = null;

      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        if (this._animLayers[i].canMix(animClip, this.entity)) {
          targetAnimLayer = this._animLayers[i];
          break;
        }
      }

      if (targetAnimLayer) {
        this._removeRefMixLayers(null, mixNode);

        targetAnimLayer.hasMixLayer = true;
        var animLayer = new AnimationLayer();
        animLayer.isMixLayer = true;
        animLayer.mixTagetLayer = targetAnimLayer;
        animLayer.mixEntity = mixNode;
        animLayer.mix(animClip, targetAnimLayer, this.entity, mixNode, options);

        this._animLayers.push(animLayer);
      }
    }
    /**
     * 停止播放
     * @param {boolean} rightnow, stop it immediately, or it will stop at the end of the clip
     */

  }, {
    key: "stop",
    value: function stop(rightnow) {
      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        if (this._animLayers[i].isFading) {
          this._animLayers.splice(i, 1);
        } else {
          this._animLayers[i].stop(rightnow);
        }
      }
    }
    /**
     * 跳转到动画的某一帧，立刻生效
     * @param {float} frameTime
     */

  }, {
    key: "jumpToFrame",
    value: function jumpToFrame(frameTime) {
      frameTime = frameTime / 1000;

      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        this._animLayers[i].jumpToFrame(frameTime);
      }

      this._updateValues();
    } // -- private ----------------------------------------------------------

    /**
     * 移除和mixTargetLayer关联的混合动画
     * @param {AnimationLayer} mixTargetLayer
     * @private
     */

  }, {
    key: "_removeRefMixLayers",
    value: function _removeRefMixLayers(targetLayer, mixNode) {
      if (targetLayer && targetLayer.hasMixLayer) {
        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          var animLayer = this._animLayers[i];

          if (animLayer.isMixLayer && animLayer.mixTagetLayer === targetLayer) {
            animLayer.removeMixWeight();

            this._animLayers.splice(i, 1);
          }
        }
      }

      if (mixNode) {
        for (var _i3 = this._animLayers.length - 1; _i3 >= 0; _i3--) {
          var _animLayer2 = this._animLayers[_i3];

          if (_animLayer2.isMixLayer && (_animLayer2.mixEntity === mixNode || _animLayer2.mixEntity.findByName(mixNode) || mixNode.findByName(_animLayer2.mixEntity))) {
            _animLayer2.removeMixWeight();

            this._animLayers.splice(_i3, 1);
          }
        }
      }
    }
    /**
     * update animation value
     * @private
     */

  }, {
    key: "_updateValues",
    value: function _updateValues() {
      if (this._animLayers.length === 0 || !this._channelTargets) {
        return;
      }

      for (var i = this._channelTargets.length - 1; i >= 0; i--) {
        var channelTarget = this._channelTargets[i];

        var val = this._getChannelValue(i, channelTarget.outputSize);

        var targetObject = channelTarget.targetObject;
        var path = channelTarget.path;

        if (path === "weights") {
          // SkinnedMeshRenderer
          targetObject.setWeights(val);
        } else {
          var v = val; //CM: 临时优化 val 应该为Vector3/Quaternion类型，避免转换开销
          //CM: 未来Animation统一所有动画系统后 非常用pathType为other，继续走反射
          //CM: 由于pathType种类比较少，未来可以通过预分类避免switch开销，比如骨骼动画就三种类型

          var transform = targetObject.transform;

          switch (channelTarget.pathType) {
            case TagetType.position:
              var position = transform.position;
              position.setValue(v[0], v[1], v[2]);
              transform.position = position;
              break;

            case TagetType.rotation:
              var rotation = transform.rotationQuaternion;
              rotation.setValue(v[0], v[1], v[2], v[3]);
              transform.rotationQuaternion = rotation;
              break;

            case TagetType.scale:
              var scale = transform.scale;
              scale.setValue(v[0], v[1], v[2]);
              transform.scale = scale;
              break;

            default:
              targetObject[path] = val;
          }
        }
      } // end of for

    }
    /**
     * @return channel value
     * @param {number} channelIndex
     * @param {number} outputSize
     * @private
     */

  }, {
    key: "_getChannelValue",
    value: function _getChannelValue(channelIndex, outputSize) {
      var weights = [];
      var values = [];

      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        var weight = this._animLayers[i].getChannelLayerWeight(channelIndex);

        if (weight > 0) {
          weights.push(weight);
          values.push(this._animLayers[i].getChannelValue(channelIndex));
        }
      }

      if (values.length === 1) {
        // 一个值生效，直接返回结果
        return values[0];
      } else if (values.length === 2) {
        // 两个值生效，插值返回
        return Animation.lerp(values[0], values[0], values[1], weights[1], outputSize);
      } // 其他情况，是暂时处理不了的


      Logger.error("Can not get channel value!");
      return false;
    }
    /**
     * 被激活时调用
     * @override
     * @internal
     */

  }, {
    key: "_onEnable",
    value: function _onEnable() {
      this.engine._componentsManager.addOnUpdateAnimations(this);
    }
    /**
     * entity inActiveInHierarchy时 或 组件销毁前调用
     * @override
     * @internal
     */

  }, {
    key: "_onDisable",
    value: function _onDisable() {
      this.engine._componentsManager.removeOnUpdateAnimations(this);
    }
  }]);

  return Animation;
}(Component), _temp$9), (_descriptor$9 = _applyDecoratedDescriptor(_class$9.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return -1;
  }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class$9.prototype, "_animSet", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return {};
  }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class$9.prototype, "_animLayers", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return [new AnimationLayer()];
  }
}), _descriptor4$6 = _applyDecoratedDescriptor(_class$9.prototype, "_timeScale", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return 1.0;
  }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class$9.prototype, "_channelTargets", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class$9);

var VertexShader = "#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <morph_target_vert>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n\n    #include <morph_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <shadow_vert>\n    #include <position_vert>\n\n    #include <fog_vert>\n\n}\n";

/**
 * 材质的通用参数管理，其他常用材质的基类
 * @class
 */

var CommonMaterial = /*#__PURE__*/function (_Material) {
  _inherits(CommonMaterial, _Material);

  var _super = _createSuper(CommonMaterial);

  function CommonMaterial(engine, name) {
    var _this;

    _classCallCheck(this, CommonMaterial);

    _this = _super.call(this, engine, name);
    _this._ambientLightCount = void 0;
    _this.renderStates = {
      enable: [],
      disable: [],
      functions: {}
    };
    _this.emission = new miniprogram.Vector4(0, 0, 0, 1);
    _this.ambient = new miniprogram.Vector4(0, 0, 0, 1);
    /**
     * Technique 渲染状态控制
     * @member {object}
     */

    _this.renderStates = {};
    return _this;
  }
  /**
   * 自发光属性
   * @member {Vector4|Texture2D}
   */


  _createClass(CommonMaterial, [{
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive) {
      var camera = context.camera;
      var lightMgr = camera.scene.findFeature(LightFeature);
      /** 光源 uniform values */

      lightMgr.bindMaterialValues(this);
      var ambientLightCount = lightMgr.lightSortAmount.ambientLightCount;

      if (!this._technique || this._ambientLightCount !== ambientLightCount) {
        this._ambientLightCount = ambientLightCount;

        this._generateTechnique();

        this.bindLightUniformDefine(camera);
      }

      _get(_getPrototypeOf(CommonMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
    }
    /**
     * 绑定灯光相关 Uniform Define
     * */

  }, {
    key: "bindLightUniformDefine",
    value: function bindLightUniformDefine(camera) {
      var lightMgr = camera.scene.findFeature(LightFeature);
      this._technique.uniforms = _objectSpread2(_objectSpread2({}, lightMgr.getUniformDefine()), this._technique.uniforms);
    }
    /**
     * 生成内部的 Technique 对象
     * @private
     */

  }, {
    key: "_internalGenerate",
    value: function _internalGenerate(name, fragmentShader) {
      var customMacros = this._generateMacros();

      var uniforms = this._generateFragmentUniform(); //--


      var tech = new RenderTechnique(name);
      tech.isValid = true;
      tech.uniforms = uniforms;
      tech.attributes = {};
      tech.states = this.renderStates;
      tech.customMacros = customMacros;
      tech.vertexShader = VertexShader;
      tech.fragmentShader = fragmentShader; //-- set default values

      this._technique = tech;
    }
  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = [];
      if (this.emission instanceof Texture2D) macros.push("O3_EMISSION_TEXTURE");
      if (this.ambient instanceof Texture2D) macros.push("O3_AMBIENT_TEXTURE");

      if (this._ambientLightCount) {
        macros.push("O3_HAS_AMBIENT_LIGHT");
      }

      return macros;
    }
    /**
     * 根据自身的参数类型，生成相应的 Fragment Shader 所需的 Uniform 定义
     * @private
     */

  }, {
    key: "_generateFragmentUniform",
    value: function _generateFragmentUniform() {
      var fragmentUniform = {
        u_emission: {
          name: "u_emission",
          type: exports.DataType.FLOAT_VEC4
        },
        u_ambient: {
          name: "u_ambient",
          type: exports.DataType.FLOAT_VEC4
        }
      };

      if (this.emission instanceof Texture2D) {
        fragmentUniform.u_emission.type = exports.DataType.SAMPLER_2D;
      }

      if (this.ambient instanceof Texture2D) {
        fragmentUniform.u_ambient.type = exports.DataType.SAMPLER_2D;
      }

      return fragmentUniform;
    }
  }, {
    key: "emission",
    get: function get() {
      return this.getValue("u_emission");
    },
    set: function set(val) {
      this.setValue("u_emission", val);
    }
    /**
     * 环境光反射属性
     * @member {vec4|Texture2D}
     */

  }, {
    key: "ambient",
    get: function get() {
      return this.getValue("u_ambient");
    },
    set: function set(val) {
      this.setValue("u_ambient", val);
    }
  }]);

  return CommonMaterial;
}(Material);

var ConstantShader = "#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <mobile_material_frag>\n\n#include <fog_share>\n#include <ambient_light_frag>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n\n    gl_FragColor = emission + ambient;\n\n    #include <fog_frag>\n\n}\n";

/**
 * 显示固定颜色（不计算光照）的材质
 * color = <emission> + <ambient> * al
 */

var ConstantMaterial = /*#__PURE__*/function (_CommonMaterial) {
  _inherits(ConstantMaterial, _CommonMaterial);

  var _super = _createSuper(ConstantMaterial);

  function ConstantMaterial() {
    _classCallCheck(this, ConstantMaterial);

    return _super.apply(this, arguments);
  }

  _createClass(ConstantMaterial, [{
    key: "_generateTechnique",

    /**
     * 生成内部所使用的 Technique 对象
     * @private
     */
    value: function _generateTechnique() {
      this._internalGenerate("ConstantMaterial", ConstantShader);
    }
  }]);

  return ConstantMaterial;
}(CommonMaterial);

var LambertShader = "#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <mobile_material_frag>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_normal_frag>\n    #include <mobile_lambert_frag>\n\n    gl_FragColor = emission + ambient + diffuse;\n\n    #include <fog_frag>\n\n}\n";

/**
 * 实现 Lambert 光照模型的材质
 * color = <emission> + <ambient> * al + <diffuse> * max(N * L, 0)
 */

var LambertMaterial = /*#__PURE__*/function (_CommonMaterial) {
  _inherits(LambertMaterial, _CommonMaterial);

  var _super = _createSuper(LambertMaterial);

  /**
   * Lambert 光照模型材质
   * @param {String} name 名称
   */
  function LambertMaterial(engine, name) {
    var _this;

    _classCallCheck(this, LambertMaterial);

    _this = _super.call(this, engine, name);
    _this._directLightCount = void 0;
    _this._directLightCount = 0;
    _this.diffuse = new miniprogram.Vector4(1, 1, 1, 1);
    return _this;
  }
  /**
   * 环境光反射颜色
   * @member {Vector4|Texture2D}
   */


  _createClass(LambertMaterial, [{
    key: "_generateTechnique",

    /**
     * 生成内部的 Technique 对象
     * @private
     */
    value: function _generateTechnique() {
      this._internalGenerate("LambertMaterial", LambertShader);
    }
    /**
     * 重写基类方法，添加方向光计算
     * @private
     */

  }, {
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive) {
      var camera = context.camera;
      var scene = camera.scene;
      var lightMgr = scene.findFeature(LightFeature);
      var directLightCount = lightMgr.lightSortAmount.directLightCount;

      if (this._technique === null || this._directLightCount != directLightCount) {
        this._directLightCount = directLightCount;

        this._generateTechnique();

        this.bindLightUniformDefine(camera);
      }

      _get(_getPrototypeOf(LambertMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
    }
    /**
     * 添加方向光相关的 uniform 定义
     * @private
     */

  }, {
    key: "_generateFragmentUniform",
    value: function _generateFragmentUniform() {
      var uniforms = {};

      if (this.diffuse instanceof Texture2D) {
        uniforms.u_diffuse = {
          name: "u_diffuse",
          type: exports.DataType.SAMPLER_2D
        };
      } else {
        uniforms.u_diffuse = {
          name: "u_diffuse",
          type: exports.DataType.FLOAT_VEC4
        };
      }

      var baseUniforms = _get(_getPrototypeOf(LambertMaterial.prototype), "_generateFragmentUniform", this).call(this);

      return _extends(baseUniforms, uniforms);
    }
    /**
     * 根据方向光的个数，添加相应的宏定义
     * @private
     */

  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = _get(_getPrototypeOf(LambertMaterial.prototype), "_generateMacros", this).call(this);

      macros.push("O3_NEED_WORLDPOS");
      if (this._directLightCount > 0) macros.push("O3_DIRECT_LIGHT_COUNT ".concat(this._directLightCount));
      if (this.diffuse instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
      return macros;
    }
  }, {
    key: "diffuse",
    get: function get() {
      return this.getValue("u_diffuse");
    },
    set: function set(val) {
      this.setValue("u_diffuse", val);
    }
  }]);

  return LambertMaterial;
}(CommonMaterial);

var BlinnPhongShader = "#include <common>\n#include <common_frag>\n\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_normal_frag>\n    #include <begin_viewdir_frag>\n    #include <mobile_blinnphong_frag>\n\n    gl_FragColor = emission + ambient + diffuse + specular;\n\n    #include <fog_frag>\n\n}\n";

/**
 * 实现 Blinn 光照模型的材质
 * https://dl.acm.org/citation.cfm?id=563893
 * color = <emission> + <ambient> * al + <diffuse> * max(N * L, 0) + <specular> * max(H * N, 0)^<shininess>
 */

var BlinnPhongMaterial = /*#__PURE__*/function (_CommonMaterial) {
  _inherits(BlinnPhongMaterial, _CommonMaterial);

  var _super = _createSuper(BlinnPhongMaterial);

  /**
   * 实现 Blinn 光照模型的材质
   * @param {String} name 名称
   */
  function BlinnPhongMaterial(engine, name) {
    var _this;

    _classCallCheck(this, BlinnPhongMaterial);

    _this = _super.call(this, engine, name);
    _this._directLightCount = void 0;
    _this._spotLightCount = void 0;
    _this._pointLightCount = void 0;
    _this._directLightCount = 0;
    _this._pointLightCount = 0;
    _this._spotLightCount = 0;
    _this.diffuse = new miniprogram.Vector4(1, 1, 1, 1);
    _this.specular = new miniprogram.Vector4(1, 1, 1, 1);
    _this.shininess = 16.0;
    return _this;
  }
  /**
   * 环境光反射颜色
   * @member {Vector4|Texture2D}
   */


  _createClass(BlinnPhongMaterial, [{
    key: "_generateTechnique",

    /**
     * 生成内部的 Technique 对象
     * @private
     */
    value: function _generateTechnique() {
      this._internalGenerate("BlinnPhongMaterial", BlinnPhongShader);
    }
    /**
     * 获取宏
     * @private
     */

  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "_generateMacros", this).call(this);

      macros.push("O3_NEED_WORLDPOS");
      if (this.diffuse instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
      if (this.specular instanceof Texture2D) macros.push("O3_SPECULAR_TEXTURE");
      if (this._directLightCount > 0) macros.push("O3_DIRECT_LIGHT_COUNT ".concat(this._directLightCount));
      if (this._pointLightCount > 0) macros.push("O3_POINT_LIGHT_COUNT ".concat(this._pointLightCount));
      if (this._spotLightCount > 0) macros.push("O3_SPOT_LIGHT_COUNT ".concat(this._spotLightCount));
      return macros;
    }
    /**
     * 重写基类方法，添加方向光计算
     * @private
     */

  }, {
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive) {
      var camera = context.camera;
      var scene = camera.scene;
      var lightMgr = scene.findFeature(LightFeature);
      var _lightMgr$lightSortAm = lightMgr.lightSortAmount,
          directLightCount = _lightMgr$lightSortAm.directLightCount,
          pointLightCount = _lightMgr$lightSortAm.pointLightCount,
          spotLightCount = _lightMgr$lightSortAm.spotLightCount;

      if (this._technique === null || this._directLightCount != directLightCount || this._pointLightCount != pointLightCount || this._spotLightCount != spotLightCount) {
        this._directLightCount = directLightCount;
        this._pointLightCount = pointLightCount;
        this._spotLightCount = spotLightCount;

        this._generateTechnique();

        this.bindLightUniformDefine(camera);
      }

      _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
    }
    /**
     * 添加方向光相关的 uniform 定义
     * @private
     */

  }, {
    key: "_generateFragmentUniform",
    value: function _generateFragmentUniform() {
      var uniforms = {};

      if (this.diffuse instanceof Texture2D) {
        uniforms.u_diffuse = {
          name: "u_diffuse",
          type: exports.DataType.SAMPLER_2D
        };
      } else {
        uniforms.u_diffuse = {
          name: "u_diffuse",
          type: exports.DataType.FLOAT_VEC4
        };
      }

      if (this.specular instanceof Texture2D) {
        uniforms.u_specular = {
          name: "u_specular",
          type: exports.DataType.SAMPLER_2D
        };
      } else {
        uniforms.u_specular = {
          name: "u_specular",
          type: exports.DataType.FLOAT_VEC4
        };
      }

      uniforms.u_shininess = {
        name: "u_shininess",
        type: exports.DataType.FLOAT
      };

      var baseUniforms = _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "_generateFragmentUniform", this).call(this);

      return _extends(baseUniforms, uniforms);
    }
  }, {
    key: "diffuse",
    get: function get() {
      return this.getValue("u_diffuse");
    },
    set: function set(val) {
      this.setValue("u_diffuse", val);
    }
    /**
     * 高光反射颜色
     * @member {Vector4|Texture2D}
     */

  }, {
    key: "specular",
    get: function get() {
      return this.getValue("u_specular");
    },
    set: function set(val) {
      this.setValue("u_specular", val);
    }
    /**
     * 高光系数，值越大高光效果越聚拢
     * @member {float}
     */

  }, {
    key: "shininess",
    get: function get() {
      return this.getValue("u_shininess");
    },
    set: function set(val) {
      this.setValue("u_shininess", val);
    }
  }]);

  return BlinnPhongMaterial;
}(CommonMaterial);

var FRAG_SHADER = "#include <common>\n#include <common_frag>\n\nuniform sampler2D u_diffuse;\nvarying vec3 v_pos;\nuniform vec4 u_tintColor;\nuniform float u_opacity;\n\nvoid main()\n{\n  #ifdef O3_DIFFUSE_TEXTURE\n    gl_FragColor = texture2D(u_diffuse, v_uv);\n  #else\n    gl_FragColor = vec4(1);\n  #endif\n}\n";

/**
 * 无光照贴图材质
 */

var TextureMaterial = /*#__PURE__*/function (_CommonMaterial) {
  _inherits(TextureMaterial, _CommonMaterial);

  var _super = _createSuper(TextureMaterial);

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function TextureMaterial(engine, name) {
    _classCallCheck(this, TextureMaterial);

    return _super.call(this, engine, name || "TextureMaterial");
  }

  _createClass(TextureMaterial, [{
    key: "_generateTechnique",
    value: function _generateTechnique() {
      this._internalGenerate("Texture", FRAG_SHADER);
    }
    /**
     * 设定材质参数值
     * @param {string} name 参数名称
     * @param {*} value 参数值
     */

  }, {
    key: "setValue",
    value: function setValue(name, value) {
      if (name === "doubleSided") {
        this._setDoubleSidedDisplay(value);
      }

      _get(_getPrototypeOf(TextureMaterial.prototype), "setValue", this).call(this, name, value);
    }
    /**
     * 纹理贴图
     * @member {Texture2D}
     */

  }, {
    key: "_generateFragmentUniform",

    /**
     * 添加 uniform 定义
     * @private
     */
    value: function _generateFragmentUniform() {
      var uniforms = {};

      if (this.texture instanceof Texture2D) {
        uniforms.u_diffuse = {
          name: "u_diffuse",
          paramName: "_MainTex",
          type: exports.DataType.SAMPLER_2D
        };
      }

      return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(TextureMaterial.prototype), "_generateFragmentUniform", this).call(this)), uniforms);
    }
  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = _get(_getPrototypeOf(TextureMaterial.prototype), "_generateMacros", this).call(this);

      if (this.texture instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
      return macros;
    }
    /**
     * 设置材质是否双面显示
     * @private
     */

  }, {
    key: "_setDoubleSidedDisplay",
    value: function _setDoubleSidedDisplay(value) {
      this._technique.states.disable = [];

      if (value) {
        this._technique.states.disable.push(exports.RenderState.CULL_FACE);
      }
    }
  }, {
    key: "texture",
    set: function set(v) {
      this.setValue("u_diffuse", v);
    },
    get: function get() {
      return this.getValue("u_diffuse");
    }
    /**
     * 是否双面显示
     * @member {boolean}
     */

  }, {
    key: "doubleSided",
    set: function set(v) {
      this.setValue("doubleSided", v);
    },
    get: function get() {
      return this.getValue("doubleSided");
    }
  }]);

  return TextureMaterial;
}(CommonMaterial);
TextureMaterial.TECH_NAME = "Texture";

/**
 * 支持透明的无光照贴图材质
 */

var TransparentMaterial = /*#__PURE__*/function (_CommonMaterial) {
  _inherits(TransparentMaterial, _CommonMaterial);

  var _super = _createSuper(TransparentMaterial);

  /**
   * 构造函数
   * @param {string} name 名称
   */
  function TransparentMaterial(engine, name) {
    _classCallCheck(this, TransparentMaterial);

    return _super.call(this, engine, name || "TransparentMaterial");
  }

  _createClass(TransparentMaterial, [{
    key: "_generateTechnique",
    value: function _generateTechnique() {
      this.renderStates = {
        enable: [exports.RenderState.BLEND],
        disable: [exports.RenderState.CULL_FACE],
        functions: {
          blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA],
          depthMask: [false]
        }
      };
      this.renderType = exports.MaterialType.TRANSPARENT;

      this._internalGenerate("Transparent", FRAG_SHADER);
    }
    /**
     * 纹理贴图
     * @member {Texture2D}
     */

  }, {
    key: "_generateFragmentUniform",

    /**
     * 添加 uniform 定义
     * @private
     */
    value: function _generateFragmentUniform() {
      var uniforms = {};

      if (this.texture instanceof Texture2D) {
        uniforms.u_diffuse = {
          name: "u_diffuse",
          paramName: "_MainTex",
          type: exports.DataType.SAMPLER_2D
        };
      }

      return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(TransparentMaterial.prototype), "_generateFragmentUniform", this).call(this)), uniforms);
    }
  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = _get(_getPrototypeOf(TransparentMaterial.prototype), "_generateMacros", this).call(this);

      if (this.texture instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
      return macros;
    }
  }, {
    key: "texture",
    set: function set(v) {
      this.setValue("u_diffuse", v);
    },
    get: function get() {
      return this.getValue("u_diffuse");
    }
  }]);

  return TransparentMaterial;
}(CommonMaterial);
TransparentMaterial.TECH_NAME = "Transparent";

var ShaderMaterial = /*#__PURE__*/function (_Material) {
  _inherits(ShaderMaterial, _Material);

  var _super = _createSuper(ShaderMaterial);

  // Vertex Shader 代码
  // Fragment Shader 代码
  // 是否可用
  // Attribute记录对象
  // Unifrom记录数组
  // 渲染状态控制对象
  // 渲染状态控制对象中的 enable 配置项
  // 渲染状态控制对象中的 disable 配置项
  // 渲染状态控制对象中的 function 配置项
  function ShaderMaterial(engine, name) {
    var _this;

    _classCallCheck(this, ShaderMaterial);

    _this = _super.call(this, engine, name);
    _this.vertexShader = "";
    _this.fragmentShader = "";
    _this.isValid = true;
    _this.attributes = {};
    _this._uniforms = ShaderMaterial.commonUniforms;
    _this._renderStates = {
      enable: [],
      disable: [],
      functions: {}
    };
    _this._enableConfig = [];
    _this._disableConfig = [];
    _this._functionsConfig = {
      blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA]
    };
    return _this;
  } // 开始渲染指定对象


  _createClass(ShaderMaterial, [{
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive) {
      var camera = context.camera;

      if (!this._technique) {
        var tech = this._generateTechnique(camera, component, primitive);

        this._technique = tech;
      }

      _get(_getPrototypeOf(ShaderMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
    } // 更新technique

  }, {
    key: "updateTechnique",
    value: function updateTechnique() {
      this._technique = null;
    } // 生成内部的 Technique 对象

  }, {
    key: "_generateTechnique",
    value: function _generateTechnique(camera, component, primitive) {
      var tech = new RenderTechnique("ShaderMaterial");
      tech.isValid = this.isValid;
      tech.uniforms = this.uniforms;
      tech.attributes = this.attributes;
      tech.states = this.renderStates;
      tech.vertexShader = this.vertexShader;
      tech.fragmentShader = this.fragmentShader;
      return tech;
    }
  }, {
    key: "addState",
    value: function addState(key, state) {
      this.renderStates[key] = union(this.renderStates[key], state);
    }
  }, {
    key: "removeState",
    value: function removeState(key, state) {
      this.renderStates[key] = this.renderStates[key].filter(function (value) {
        return value !== state;
      });
    }
  }, {
    key: "renderStates",
    get: function get() {
      return this._renderStates;
    },
    set: function set(value) {
      var _value$enable = value.enable,
          enable = _value$enable === void 0 ? [] : _value$enable,
          _value$disable = value.disable,
          disable = _value$disable === void 0 ? [] : _value$disable,
          _value$functions = value.functions,
          functions = _value$functions === void 0 ? {} : _value$functions; // 为了防止冲突，把预置的几个属性放在_enableConfig里面，此处需过滤掉

      var enableState = enable.filter(function (value) {
        return ShaderMaterial.commonEnable.indexOf(value) < 0;
      });
      var disableState = disable.filter(function (value) {
        return ShaderMaterial.commonDisable.indexOf(value) < 0;
      });
      this._renderStates.enable = union(enableState, this._enableConfig);
      this._renderStates.disable = union(disableState, this._disableConfig);
      this._renderStates.functions = _extends({}, functions, this._functionsConfig);
    }
  }, {
    key: "uniforms",
    get: function get() {
      return this._uniforms;
    },
    set: function set(value) {
      this._uniforms = _extends({}, ShaderMaterial.commonUniforms, value);
    } // 是否开启片元的颜色融合计算

  }, {
    key: "blend",
    set: function set(value) {
      if (value) {
        this._enableConfig = union(this._enableConfig, [exports.RenderState.BLEND]);
      } else {
        this._enableConfig = this._enableConfig.filter(function (state) {
          return state !== exports.RenderState.BLEND;
        });
        this.removeState("enable", exports.RenderState.BLEND);
      }

      this.renderStates = this._renderStates;
    } // 混合源因子

  }, {
    key: "blendSrcFactor",
    set: function set(value) {
      this._functionsConfig.blendFunc[0] = value;
      this.renderStates = this._renderStates;
    } // 混合目标因子

  }, {
    key: "blendDstFactor",
    set: function set(value) {
      this._functionsConfig.blendFunc[1] = value;
      this.renderStates = this._renderStates;
    } // 是否双面显示

  }, {
    key: "doubleSide",
    set: function set(value) {
      if (value) {
        this._disableConfig = union(this._disableConfig, [exports.RenderState.CULL_FACE]);
      } else {
        this._disableConfig = this._disableConfig.filter(function (state) {
          return state !== exports.RenderState.CULL_FACE;
        });
        this.removeState("disable", exports.RenderState.CULL_FACE);
      }

      this.renderStates = this._renderStates;
    } // 是否开启深度测试

  }, {
    key: "depthTest",
    set: function set(value) {
      if (!value) {
        this._disableConfig = union(this._disableConfig, [exports.RenderState.DEPTH_TEST]);
      } else {
        this._disableConfig = this._disableConfig.filter(function (state) {
          return state !== exports.RenderState.DEPTH_TEST;
        });
        this.removeState("disable", exports.RenderState.DEPTH_TEST);
      }

      this.renderStates = this._renderStates;
    }
  }]);

  return ShaderMaterial;
}(Material);
ShaderMaterial.commonUniforms = {
  matModelViewProjection: {
    name: "matModelViewProjection",
    semantic: exports.UniformSemantic.MODELVIEWPROJECTION,
    type: exports.DataType.FLOAT_MAT4
  },
  matModelView: {
    name: "matModelView",
    semantic: exports.UniformSemantic.MODELVIEW,
    type: exports.DataType.FLOAT_MAT4
  }
};
ShaderMaterial.commonEnable = [exports.RenderState.BLEND];
ShaderMaterial.commonDisable = [exports.RenderState.CULL_FACE, exports.RenderState.DEPTH_TEST];
function union(arr1, arr2) {
  return arr1.concat(arr2.filter(function (v) {
    return !(arr1.indexOf(v) > -1);
  }));
}

/**
 * 缓冲几何体。
 */
var BufferGeometry = /*#__PURE__*/function (_EngineObject) {
  _inherits(BufferGeometry, _EngineObject);

  var _super = _createSuper(BufferGeometry);

  _createClass(BufferGeometry, [{
    key: "vertexBufferBindings",

    /** 名称。*/

    /** @internal */

    /**
     * 顶点缓冲绑定信息集合。
     */
    get: function get() {
      return this._primitive.vertexBufferBindings;
    }
    /**
     * 索引缓冲绑定信息。
     */

  }, {
    key: "indexBufferBinding",
    get: function get() {
      return this._primitive.indexBufferBinding;
    }
    /**
     * 顶点元素集合。
     */

  }, {
    key: "vertexElements",
    get: function get() {
      return this._primitive.vertexElements;
    }
    /**
     * 首个子几何体,使用第一个材质渲染,设置多个几何体组详见 subGeometrys 属性。
     */

  }, {
    key: "subGeometry",
    get: function get() {
      return this._subGeometries[0] || null;
    }
    /**
     * 子几何体集合,每个子几何体可以使用独立的材质渲染。
     */

  }, {
    key: "subGeometries",
    get: function get() {
      return this._subGeometries;
    }
    /**
     * 实例数量,0 表示关闭。
     */

  }, {
    key: "instanceCount",
    get: function get() {
      return this._primitive.instanceCount;
    },
    set: function set(count) {
      this._primitive.instanceCount = count;
    }
    /**
     * 包围体。
     */

  }, {
    key: "bounds",
    get: function get() {
      return this._bounds;
    },
    set: function set(value) {
      this._bounds = value;
    }
    /**
     * 创建几何体缓冲。
     * @param engine - 所属引擎
     * @param name - 名称
     */

  }]);

  function BufferGeometry(engine, name) {
    var _this;

    _classCallCheck(this, BufferGeometry);

    _this = _super.call(this, engine);
    _this.name = void 0;
    _this._primitive = void 0;
    _this._bounds = void 0;
    _this._subGeometries = [];
    _this._primitive = new Primitive(engine);
    _this.name = name;
    return _this;
  }
  /**
   * 设置顶点缓冲绑定。
   * @param vertexBufferBindings - 顶点缓冲绑定
   * @param firstIndex - 第一个顶点缓冲索引，默认值为 0
   */


  _createClass(BufferGeometry, [{
    key: "setVertexBufferBinding",
    value: function setVertexBufferBinding(bufferOrBinding) {
      var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var firstIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      this._primitive.setVertexBufferBinding(bufferOrBinding, stride, firstIndex);
    }
    /**
     * 设置顶点缓冲集合。
     * @param vertexBufferBindings - 顶点缓冲绑定集合
     * @param firstIndex - 第一个顶点缓冲索引,默认值为 0
     */

  }, {
    key: "setVertexBufferBindings",
    value: function setVertexBufferBindings(vertexBufferBindings) {
      var firstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this._primitive.setVertexBufferBindings(vertexBufferBindings, firstIndex);
    }
    /**
     * 设置索引缓冲绑定。
     * @param buffer - 索引缓冲
     * @param format - 索引缓冲格式
     */

  }, {
    key: "setIndexBufferBinding",
    value: function setIndexBufferBinding(bufferOrBinding, format) {
      this._primitive.setIndexBufferBinding(bufferOrBinding, format);
    }
    /**
     * 设置顶点元素集合。
     * @param elements - 顶点元素集合。
     */

  }, {
    key: "setVertexElements",
    value: function setVertexElements(elements) {
      this._primitive.setVertexElements(elements);
    }
    /**
     * 添加子几何体，每一个子几何体可对应独立的材质。
     * @param start - 起始绘制偏移，如果设置了索引缓冲则表示在索引缓冲的偏移，如果没有设置则表示在顶点缓冲中的偏移
     * @param count - 绘制数量，如果设置了索引缓冲则表示在索引缓冲的数量，如果没有设置则表示在顶点缓冲中的数量
     * @param topology - 几何体拓扑，默认值是 PrimitiveTopology.Triangles
     */

  }, {
    key: "addSubGeometry",
    value: function addSubGeometry(start, count) {
      var topology = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.PrimitiveTopology.Triangles;
      var subGeometry = new SubPrimitive(start, count, topology);

      this._subGeometries.push(subGeometry);

      return subGeometry;
    }
    /**
     * 移除子几何体。
     * @param subGeometry - 子几何体
     */

  }, {
    key: "removeSubGeometry",
    value: function removeSubGeometry(subGeometry) {
      var subGeometries = this._subGeometries;
      var index = subGeometries.indexOf(subGeometry);

      if (index !== -1) {
        subGeometries.splice(index, 1);
      }
    }
    /**
     * 清空子几何体。
     */

  }, {
    key: "clearSubGeometry",
    value: function clearSubGeometry() {
      this._subGeometries.length = 0;
    }
    /**
     * 销毁。
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this._primitive) {
        this._primitive.destroy();

        this._primitive = null;
      }
    }
  }]);

  return BufferGeometry;
}(EngineObject);

/**
 * 几何体渲染器。
 */
var GeometryRenderer = /*#__PURE__*/function (_RenderableComponent) {
  _inherits(GeometryRenderer, _RenderableComponent);

  var _super = _createSuper(GeometryRenderer);

  function GeometryRenderer() {
    var _this;

    _classCallCheck(this, GeometryRenderer);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this._material = void 0;
    _this._geometry = void 0;
    return _this;
  }

  _createClass(GeometryRenderer, [{
    key: "render",
    value: function render(camera) {
      var geometry = this.geometry;

      if (geometry) {
        var subGeometries = geometry.subGeometries;
        var renderPipeline = camera._renderPipeline;
        var material = this._material;

        for (var i = 0, n = subGeometries.length; i < n; i++) {
          if (material) {
            var element = RenderElement.getFromPool();
            element.setValue(this, geometry._primitive, subGeometries[i], material); // CM: need to support multi material

            renderPipeline.pushPrimitive(element);
          }
        }
      } else {
        Logger.error("geometry is null.");
      }
    }
    /**
     * @override
     */

  }, {
    key: "_updateBounds",
    value: function _updateBounds(worldBounds) {
      var localBounds = this._geometry.bounds;

      if (localBounds) {
        var worldMatrix = this._entity.transform.worldMatrix;
        miniprogram.Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min); //TODO:简单模式，有漏洞，待AABB重构

        miniprogram.Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);
      } else {
        worldBounds.min.setValue(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        worldBounds.max.setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
      }
    }
  }, {
    key: "geometry",

    /**
     * 几何体
     */
    set: function set(value) {
      if (this._geometry) {
        this._geometry._primitive._addRefCount(-1);
      }

      value._primitive._addRefCount(1);

      this._geometry = value;
    },
    get: function get() {
      return this._geometry;
    }
    /**
     * 材质。
     */

  }, {
    key: "material",
    set: function set(value) {
      if (this._material) {
        this._material._addRefCount(-1);
      }

      value._addRefCount(1);

      this._material = value;
    },
    get: function get() {
      return this._material;
    }
  }]);

  return GeometryRenderer;
}(RenderableComponent);

/**
 * 基本形状几何体。
 */

var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inherits(ShapeGeometry, _BufferGeometry);

  var _super = _createSuper(ShapeGeometry);

  function ShapeGeometry() {
    _classCallCheck(this, ShapeGeometry);

    return _super.apply(this, arguments);
  }

  _createClass(ShapeGeometry, [{
    key: "_initialize",

    /**
     * @internal
     */
    value: function _initialize(engine, vertices, indices) {
      var vertexStride = 32;
      var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("NORMAL", 12, exports.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 24, exports.VertexElementFormat.Vector2, 0)];

      this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
    }
  }, {
    key: "_initBuffer",
    value: function _initBuffer(engine, vertices, indices, vertexStride, vertexElements) {
      var positionElement = vertexElements[0];
      var vertexBuffer = new Buffer(engine, exports.BufferBindFlag.VertexBuffer, vertices, exports.BufferUsage.Static);
      var indexBuffer = new Buffer(engine, exports.BufferBindFlag.IndexBuffer, indices, exports.BufferUsage.Static);
      this.setVertexBufferBinding(vertexBuffer, vertexStride);
      this.setIndexBufferBinding(indexBuffer, exports.IndexFormat.UInt16);
      this.setVertexElements(vertexElements);
      this.addSubGeometry(0, indices.length);

      this._computeBounds(positionElement, vertices);
    }
  }, {
    key: "_computeBounds",
    value: function _computeBounds(positionElement, vertices) {
      var vertexElement = positionElement;
      var bufferIndex = vertexElement.bindingIndex;
      var vertexBufferBinding = this._primitive.vertexBufferBindings[bufferIndex];
      var stride = vertexBufferBinding.stride;
      var offset = vertexElement.offset;
      var vertexCount = vertexBufferBinding.buffer.byteLength / stride;
      var arrayBuffer = vertices;

      if (!(arrayBuffer instanceof ArrayBuffer)) {
        arrayBuffer = arrayBuffer.buffer;
      }

      var dataView = new DataView(arrayBuffer, offset);
      var min = new miniprogram.Vector3(Infinity, Infinity, Infinity);
      var max = new miniprogram.Vector3(-Infinity, -Infinity, -Infinity);

      for (var i = 0; i < vertexCount; i++) {
        var base = offset + stride * i;
        var position = new miniprogram.Vector3(dataView.getFloat32(base, true), dataView.getFloat32(base + 4, true), dataView.getFloat32(base + 8, true));
        miniprogram.Vector3.min(min, position, min);
        miniprogram.Vector3.max(max, position, max);
      }

      var bounds = this.bounds;

      if (bounds) {
        min.cloneTo(bounds.min);
        max.cloneTo(bounds.max);
      } else {
        bounds = {
          min: min,
          max: max
        };
        this.bounds = bounds;
      }
    }
  }]);

  return ShapeGeometry;
}(BufferGeometry);

/**
 * 长方体
 */

var CuboidGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(CuboidGeometry, _ShapeGeometry);

  var _super = _createSuper(CuboidGeometry);

  /**
   * 创建长方体。
   * @param engine - 引擎
   * @param width - 宽
   * @param height - 高
   * @param depth - 深
   */
  function CuboidGeometry(engine) {
    var _this;

    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, CuboidGeometry);

    _this = _super.call(this, engine);
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2; // prettier-ignore

    var vertices = new Float32Array([// up
    -halfWidth, halfHeight, -halfDepth, 0, 1, 0, 0, 0, halfWidth, halfHeight, -halfDepth, 0, 1, 0, 1, 0, halfWidth, halfHeight, halfDepth, 0, 1, 0, 1, 1, -halfWidth, halfHeight, halfDepth, 0, 1, 0, 0, 1, // down
    -halfWidth, -halfHeight, -halfDepth, 0, -1, 0, 0, 1, halfWidth, -halfHeight, -halfDepth, 0, -1, 0, 1, 1, halfWidth, -halfHeight, halfDepth, 0, -1, 0, 1, 0, -halfWidth, -halfHeight, halfDepth, 0, -1, 0, 0, 0, // left
    -halfWidth, halfHeight, -halfDepth, -1, 0, 0, 0, 0, -halfWidth, halfHeight, halfDepth, -1, 0, 0, 1, 0, -halfWidth, -halfHeight, halfDepth, -1, 0, 0, 1, 1, -halfWidth, -halfHeight, -halfDepth, -1, 0, 0, 0, 1, // right
    halfWidth, halfHeight, -halfDepth, 1, 0, 0, 1, 0, halfWidth, halfHeight, halfDepth, 1, 0, 0, 0, 0, halfWidth, -halfHeight, halfDepth, 1, 0, 0, 0, 1, halfWidth, -halfHeight, -halfDepth, 1, 0, 0, 1, 1, // fornt
    -halfWidth, halfHeight, halfDepth, 0, 0, 1, 0, 0, halfWidth, halfHeight, halfDepth, 0, 0, 1, 1, 0, halfWidth, -halfHeight, halfDepth, 0, 0, 1, 1, 1, -halfWidth, -halfHeight, halfDepth, 0, 0, 1, 0, 1, // back
    -halfWidth, halfHeight, -halfDepth, 0, 0, -1, 1, 0, halfWidth, halfHeight, -halfDepth, 0, 0, -1, 0, 0, halfWidth, -halfHeight, -halfDepth, 0, 0, -1, 0, 1, -halfWidth, -halfHeight, -halfDepth, 0, 0, -1, 1, 1]); // prettier-ignore

    var indices = new Uint16Array([// up
    0, 2, 1, 2, 0, 3, // donw
    4, 6, 7, 6, 4, 5, // left
    8, 10, 9, 10, 8, 11, // right
    12, 14, 15, 14, 12, 13, // fornt
    16, 18, 17, 18, 16, 19, // back
    20, 22, 23, 22, 20, 21]);

    _this._initialize(engine, vertices, indices);

    return _this;
  }

  return CuboidGeometry;
}(ShapeGeometry);

/**
 * SphereGeometry 球体创建类
 */

var SphereGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(SphereGeometry, _ShapeGeometry);

  var _super = _createSuper(SphereGeometry);

  /**
   * @param  radius - 半径
   * @param  horizontalSegments - 水平分段数
   * @param  verticalSegments - 垂直分段数
   * @param  alphaStart - 水平开始角度
   * @param  alphaRange - 水平角度范围
   * @param  thetaStart - 垂直开始角度
   * @param  thetaRange - 垂直角度范围
   */
  function SphereGeometry(engine) {
    var _this;

    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var horizontalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
    var verticalSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6;
    var alphaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var alphaRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
    var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var thetaRange = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI;

    _classCallCheck(this, SphereGeometry);

    _this = _super.call(this, engine);
    _this._parameters = void 0;
    _this._thetaEnd = void 0;
    _this._parameters = {
      radius: radius || 1,
      horizontalSegments: Math.max(3, Math.floor(horizontalSegments)),
      verticalSegments: Math.max(2, Math.floor(verticalSegments)),
      alphaStart: alphaStart,
      alphaRange: alphaRange,
      thetaStart: thetaStart,
      thetaRange: thetaRange
    };
    _this._thetaEnd = _this._parameters.thetaStart + _this._parameters.thetaRange;

    _this.initialize(engine);

    return _this;
  }
  /**
   * 构造球体数据
   * @private
   */


  _createClass(SphereGeometry, [{
    key: "initialize",
    value: function initialize(engine) {
      var _this$_parameters = this._parameters,
          verticalSegments = _this$_parameters.verticalSegments,
          horizontalSegments = _this$_parameters.horizontalSegments; // 生成经纬线上的几何体顶点的数据

      var index = 0;
      var grid = [];
      var vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
      var indices = []; // const positions = [];

      for (var iy = 0; iy <= verticalSegments; iy++) {
        var verticesRow = [];
        var v = iy / verticalSegments;

        for (var ix = 0; ix <= horizontalSegments; ix++) {
          var u = ix / horizontalSegments;
          var posX = -this._parameters.radius * Math.cos(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
          var posY = this._parameters.radius * Math.cos(this._parameters.thetaStart + v * this._parameters.thetaRange);
          var posZ = this._parameters.radius * Math.sin(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
          posX = Math.abs(posX) < 1e-6 ? 0 : posX;
          posY = Math.abs(posY) < 1e-6 ? 0 : posY;
          posZ = Math.abs(posZ) < 1e-6 ? 0 : posZ;
          var offset = index * 8; // POSITION

          vertices[offset] = posX;
          vertices[offset + 1] = posY;
          vertices[offset + 2] = posZ; // NORMAL

          vertices[offset + 3] = posX;
          vertices[offset + 4] = posY;
          vertices[offset + 5] = posZ; // TEXCOORD_0

          vertices[offset + 6] = u;
          vertices[offset + 7] = 1 - v;
          verticesRow.push(index++);
        }

        grid.push(verticesRow);
      } // 生成所有三角形顶点序号


      for (var _iy = 0; _iy < verticalSegments; _iy++) {
        for (var _ix = 0; _ix < horizontalSegments; _ix++) {
          var a = grid[_iy][_ix + 1];
          var b = grid[_iy][_ix];
          var c = grid[_iy + 1][_ix];
          var d = grid[_iy + 1][_ix + 1];
          if (_iy !== 0 || this._parameters.thetaStart > 0) indices.push(a, b, d);
          if (_iy !== verticalSegments - 1 || this._thetaEnd < Math.PI) indices.push(b, c, d);
        }
      }

      this._initialize(engine, vertices, Uint16Array.from(indices));
    }
  }]);

  return SphereGeometry;
}(ShapeGeometry);

/**
 * CubeGeometry 平面创建类
 */

var PlaneGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(PlaneGeometry, _ShapeGeometry);

  var _super = _createSuper(PlaneGeometry);

  /**
   * @param engine - 所属引擎
   * @param width 宽
   * @param height 高
   * @param horizontalSegments 水平分段数
   * @param verticalSegments 垂直分段数
   */
  function PlaneGeometry(engine) {
    var _this;

    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var horizontalSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var verticalSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

    _classCallCheck(this, PlaneGeometry);

    _this = _super.call(this, engine);
    _this._parameters = void 0;
    _this.halfWidth = void 0;
    _this.halfHeight = void 0;
    _this._parameters = {
      width: width,
      height: height,
      horizontalSegments: Math.floor(horizontalSegments),
      verticalSegments: Math.floor(verticalSegments)
    };
    _this.halfWidth = _this._parameters.width / 2;
    _this.halfHeight = _this._parameters.height / 2;

    _this.initialize(engine);

    return _this;
  }

  _createClass(PlaneGeometry, [{
    key: "initialize",
    value: function initialize(engine) {
      var _this$_parameters = this._parameters,
          verticalSegments = _this$_parameters.verticalSegments,
          horizontalSegments = _this$_parameters.horizontalSegments; // 生成经纬线上的几何体顶点的数据

      var index = 0;
      var offset = 0;
      var grid = [];
      var vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
      var indices = new Uint16Array(verticalSegments * horizontalSegments * 6);

      for (var iy = 0; iy <= verticalSegments; iy++) {
        var verticesRow = [];
        var v = iy / verticalSegments;

        for (var ix = 0; ix <= horizontalSegments; ix++) {
          var u = ix / horizontalSegments;
          var posX = u * this._parameters.width - this.halfWidth;
          var posY = v * this._parameters.height - this.halfHeight; // POSITION

          vertices[offset++] = posX;
          vertices[offset++] = posY;
          vertices[offset++] = 0; // NORMAL

          vertices[offset++] = 0;
          vertices[offset++] = 0;
          vertices[offset++] = 1; // TEXCOORD_0

          vertices[offset++] = u;
          vertices[offset++] = 1 - v;
          verticesRow.push(index++);
        }

        grid.push(verticesRow);
      } // 生成所有三角形顶点序号


      index = 0;

      for (var _iy = 0; _iy < verticalSegments; _iy++) {
        for (var _ix = 0; _ix < horizontalSegments; _ix++) {
          var a = grid[_iy][_ix + 1];
          var b = grid[_iy][_ix];
          var c = grid[_iy + 1][_ix];
          var d = grid[_iy + 1][_ix + 1];
          indices[index++] = a;
          indices[index++] = c;
          indices[index++] = b;
          indices[index++] = a;
          indices[index++] = d;
          indices[index++] = c;
        }
      }

      this._initialize(engine, vertices, indices);
    }
  }]);

  return PlaneGeometry;
}(ShapeGeometry);

/**
 * SphereGeometry 球体创建类
 */

var CylinderGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(CylinderGeometry, _ShapeGeometry);

  var _super = _createSuper(CylinderGeometry);

  /**
   * @param  engine - 所属引擎
   * @param  radiusTop - 顶部圆柱的半径。 默认值为1。
   * @param  radiusBottom - 底部圆柱的半径。 默认值为1。
   * @param  height - 圆柱的高度 。 默认值为1。
   * @param  radialSegments - 圆柱体圆周周围的分割面数。 默认值为8
   * @param  heightSegments - 沿圆柱高度的面的行数。 默认值为1。
   * @param  openEnded - 一个布尔值，指示圆柱的末端是打开还是加盖。 默认值为false，表示上限。
   * @param  thetaStart - 第一段的起始角度，默认= 0（三点钟位置）。
   * @param  thetaLength - 圆形扇区的中心角，通常称为theta。 默认值为2 * Pi，这样可以获得完整的柱面。
   */
  function CylinderGeometry(engine) {
    var _this;

    var radiusTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var radiusBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var radialSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 8;
    var heightSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var openEnded = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var thetaStart = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var thetaLength = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 2 * Math.PI;
    var frontFace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : exports.FrontFace.CCW;

    _classCallCheck(this, CylinderGeometry);

    _this = _super.call(this, engine);
    _this.FrontFace = void 0;
    _this.index = void 0;
    _this.indexArray = void 0;
    _this.halfHeight = void 0;
    _this._parameters = void 0;
    _this._vertices = void 0;
    _this._indices = void 0;
    _this.FrontFace = frontFace;
    _this._parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    _this._vertices = [];
    _this._indices = [];
    _this.index = 0;
    _this.indexArray = [];
    _this.halfHeight = _this._parameters.height / 2;

    _this.generateTorso();

    if (_this._parameters.openEnded === false) {
      if (_this._parameters.radiusTop > 0) _this.generateCap(true);
      if (_this._parameters.radiusBottom > 0) _this.generateCap(false);
    }

    _this._initialize(engine, Float32Array.from(_this._vertices), Uint16Array.from(_this._indices));

    return _this;
  }

  _createClass(CylinderGeometry, [{
    key: "generateTorso",
    value: function generateTorso() {
      var _this$_parameters = this._parameters,
          radialSegments = _this$_parameters.radialSegments,
          heightSegments = _this$_parameters.heightSegments,
          radiusBottom = _this$_parameters.radiusBottom,
          radiusTop = _this$_parameters.radiusTop,
          height = _this$_parameters.height;
      var x, y;
      var normal = new miniprogram.Vector3();
      var slope = (radiusBottom - radiusTop) / height;

      for (y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta); // vertex

          var vertX = radius * sinTheta;
          var vertY = -v * height + this.halfHeight;
          var vertZ = radius * cosTheta;

          this._vertices.push(vertX, vertY, vertZ); // normal


          normal.setValue(sinTheta, slope, cosTheta);
          normal.normalize();

          this._vertices.push(normal.x, normal.y, normal.z); // uv


          if (this.FrontFace === exports.FrontFace.CCW) {
            this._vertices.push(u, v);
          } else {
            this._vertices.push(1 - u, v);
          }

          indexRow.push(this.index++);
        }

        this.indexArray.push(indexRow);
      }

      for (x = 0; x < radialSegments; x++) {
        for (y = 0; y < heightSegments; y++) {
          var a = this.indexArray[y][x];
          var b = this.indexArray[y + 1][x];
          var c = this.indexArray[y + 1][x + 1];
          var d = this.indexArray[y][x + 1]; // faces

          this._indices.push(a, b, d);

          this._indices.push(b, c, d);
        }
      }
    }
  }, {
    key: "generateCap",
    value: function generateCap(isTop) {
      var radialSegments = this._parameters.radialSegments;
      var x;
      var radius = isTop === true ? this._parameters.radiusTop : this._parameters.radiusBottom;
      var sign = isTop === true ? 1 : -1;
      var centerIndexStart = this.index;

      for (x = 1; x <= radialSegments; x++) {
        // vertex
        this._vertices.push(0, this.halfHeight * sign, 0); // normal


        this._vertices.push(0, sign, 0); // uv


        this._vertices.push(0.5, 0.5); // increase index


        this.index++;
      }

      var centerIndexEnd = this.index;

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta); // vertex

        var vertexX = radius * sinTheta;
        var vertexY = this.halfHeight * sign;
        var vertexZ = radius * cosTheta;

        this._vertices.push(vertexX, vertexY, vertexZ); // normal


        this._vertices.push(0, sign, 0); // uv


        var uvX = cosTheta * 0.5 + 0.5;
        var uvY = sinTheta * 0.5 * sign + 0.5;

        this._vertices.push(uvX, uvY); // increase index


        this.index++;
      }

      for (x = 0; x < radialSegments; x++) {
        var c = centerIndexStart + x;
        var i = centerIndexEnd + x;

        if (isTop === true) {
          // face top
          this._indices.push(i, i + 1, c);
        } else {
          // face bottom
          this._indices.push(i + 1, i, c);
        }
      }
    }
  }]);

  return CylinderGeometry;
}(ShapeGeometry);

var CircleGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(CircleGeometry, _ShapeGeometry);

  var _super = _createSuper(CircleGeometry);

  /**
   * 顶点
   */

  /**
   * @param engien - 所属引擎
   * @param radius - 半径
   */
  function CircleGeometry(engine) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, CircleGeometry);

    _this = _super.call(this, engine);
    _this.radius = 1;
    _this.segments = 16;
    _this.thetaStart = 0;
    _this.thetaLength = Math.PI * 2;
    _this.radius = options.radius || _this.radius;
    _this.segments = options.segments || _this.segments;
    _this.thetaStart = options.thetaStart || _this.thetaStart;
    _this.thetaLength = options.thetaLength || _this.thetaLength;

    var _assertThisInitialize = _assertThisInitialized(_this),
        segments = _assertThisInitialize.segments,
        radius = _assertThisInitialize.radius; // init with center point


    var vertices = new Float32Array((segments + 2) * 8); // POSITION NORMAL TEXCOORD_0

    vertices.set([0, 0, 0, 0, 0, 1, 0.5, 0.5]);
    var index = 8;

    for (var s = 0; s <= segments; s++) {
      var segment = _this.thetaStart + s / segments * _this.thetaLength;
      var x = radius * Math.cos(segment);
      var y = radius * Math.sin(segment); // POSITION

      vertices[index++] = x;
      vertices[index++] = y;
      vertices[index++] = 0; // NORMAL

      vertices[index++] = 0;
      vertices[index++] = 0;
      vertices[index++] = 1; // TEXCOORD_0

      vertices[index++] = (x / radius + 1) * 0.5;
      vertices[index++] = (y / radius + 1) * 0.5;
    }

    var indices = new Uint16Array(segments * 3);
    index = 0;

    for (var i = 1; i <= segments; i++) {
      indices[index++] = i;
      indices[index++] = i + 1;
      indices[index++] = 0;
    }

    _this._initialize(engine, vertices, indices);

    return _this;
  }

  return CircleGeometry;
}(ShapeGeometry);

/**
 * 覆盖整个屏幕的一个矩形
 * @private
 */

var ScreenQuadGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(ScreenQuadGeometry, _ShapeGeometry);

  var _super = _createSuper(ScreenQuadGeometry);

  function ScreenQuadGeometry(engine) {
    var _this;

    _classCallCheck(this, ScreenQuadGeometry);

    _this = _super.call(this, engine);
    var vertices = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
    var indices = new Uint16Array([0, 1, 2, 3]);

    _this._initialize(engine, vertices, indices);

    _this.subGeometry.topology = exports.PrimitiveTopology.TriangleFan;
    return _this;
  }

  _createClass(ScreenQuadGeometry, [{
    key: "_initialize",
    value: function _initialize(engine, vertices, indices) {
      var vertexStride = 20;
      var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, exports.VertexElementFormat.Vector2, 0)];

      this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
    }
  }]);

  return ScreenQuadGeometry;
}(ShapeGeometry);

var TorusGeometry = /*#__PURE__*/function (_ShapeGeometry) {
  _inherits(TorusGeometry, _ShapeGeometry);

  var _super = _createSuper(TorusGeometry);

  function TorusGeometry() {
    var _this;

    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var engine = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, TorusGeometry);

    _this = _super.call(this, engine);
    _this.parameters = parameters;
    var radius = _this.parameters.radius || 1;
    var tube = _this.parameters.tube || 0.4;
    var radialSegments = Math.floor(_this.parameters.radialSegments) || 8;
    var tubularSegments = Math.floor(_this.parameters.tubularSegments) || 6;
    var arc = _this.parameters.arc || Math.PI * 2; // buffers

    var vertices = new Float32Array((radialSegments + 1) * (tubularSegments + 1) * 3);
    var indices = new Uint16Array(radialSegments * tubularSegments * 6); // generate vertices, normals and uvs

    var index = 0;

    for (var j = 0; j <= radialSegments; j++) {
      for (var i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2; // POSITION

        vertices[index++] = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertices[index++] = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertices[index++] = tube * Math.sin(v);
      }
    } // generate indices


    index = 0;

    for (var _j = 1; _j <= radialSegments; _j++) {
      for (var _i = 1; _i <= tubularSegments; _i++) {
        // indices
        var a = (tubularSegments + 1) * _j + _i - 1;
        var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
        var c = (tubularSegments + 1) * (_j - 1) + _i;
        var d = (tubularSegments + 1) * _j + _i; // faces

        indices[index++] = a;
        indices[index++] = b;
        indices[index++] = d;
        indices[index++] = b;
        indices[index++] = c;
        indices[index++] = d;
      }
    }

    _this._initialize(engine, vertices, indices);

    return _this;
  }

  _createClass(TorusGeometry, [{
    key: "_initialize",
    value: function _initialize(engine, vertices, indices) {
      var vertexStride = 12;
      var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0)];

      this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
    }
  }]);

  return TorusGeometry;
}(ShapeGeometry);

var Model = /*#__PURE__*/function (_GeometryRenderer) {
  _inherits(Model, _GeometryRenderer);

  var _super = _createSuper(Model);

  _createClass(Model, [{
    key: "geometryType",
    set: function set(value) {
      switch (value) {
        case "Sphere":
          var _ref = this._props,
              sphereRadius = _ref.sphereRadius,
              sphereHorizontalSegments = _ref.sphereHorizontalSegments,
              sphereVerticalSegments = _ref.sphereVerticalSegments,
              sphereAlphaStart = _ref.sphereAlphaStart,
              sphereAlphaRange = _ref.sphereAlphaRange,
              sphereThetaStart = _ref.sphereThetaStart,
              sphereThetaRange = _ref.sphereThetaRange;
          this.geometry = new SphereGeometry(this.engine, sphereRadius, sphereHorizontalSegments, sphereVerticalSegments, sphereAlphaStart, sphereAlphaRange, sphereThetaStart, sphereThetaRange);
          break;

        case "Cylinder":
          var _ref2 = this._props,
              cylinderRadiusTop = _ref2.cylinderRadiusTop,
              cylinderRadiusBottom = _ref2.cylinderRadiusBottom,
              cylinderHeight = _ref2.cylinderHeight,
              cylinderRadialSegments = _ref2.cylinderRadialSegments,
              cylinderHeightSegments = _ref2.cylinderHeightSegments,
              cylinderOpenEnded = _ref2.cylinderOpenEnded;
          this.geometry = new CylinderGeometry(this.engine, cylinderRadiusTop, cylinderRadiusBottom, cylinderHeight, cylinderRadialSegments, cylinderHeightSegments, cylinderOpenEnded, undefined, undefined, undefined);
          break;

        case "Plane":
          var _ref3 = this._props,
              planeWidth = _ref3.planeWidth,
              planeHeight = _ref3.planeHeight,
              planeHorizontalSegments = _ref3.planeHorizontalSegments,
              planeVerticalSegments = _ref3.planeVerticalSegments;
          this.geometry = new PlaneGeometry(this.engine, planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments);
          break;

        case "Box":
          var _ref4 = this._props,
              boxWidth = _ref4.boxWidth,
              boxHeight = _ref4.boxHeight,
              boxDepth = _ref4.boxDepth;
          this.geometry = new CuboidGeometry(this.engine, boxWidth, boxHeight, boxDepth);
          break;
      }

      this._geometryType = value;
    },
    get: function get() {
      return this._geometryType;
    }
  }]);

  function Model(entity) {
    var _this;

    _classCallCheck(this, Model);

    _this = _super.call(this, entity);
    _this._props = void 0;
    _this._geometryType = void 0;
    return _this;
  }

  _createClass(Model, [{
    key: "init",
    value: function init(props) {
      this._props = props;
      var _props$geometryType = props.geometryType,
          geometryType = _props$geometryType === void 0 ? GeometryType.Box : _props$geometryType;
      this.material = props.material;
      this.geometryType = geometryType;
    }
  }, {
    key: "setProp",
    value: function setProp(key, value) {
      this._props[key] = value;

      if (key === "material") {
        this.material = value;
      } else {
        this.geometryType = this._props.geometryType;
      }
    }
  }, {
    key: "material",
    get: function get() {
      return this._material;
    },
    set: function set(mtl) {
      if (!mtl) {
        this._material = new BlinnPhongMaterial(this.engine, "mtl");
      } else {
        this._material = mtl;
      }
    }
  }]);

  return Model;
}(GeometryRenderer);
var GeometryType;

(function (GeometryType) {
  GeometryType["Box"] = "Box";
  GeometryType["Cylinder"] = "Cylinder";
  GeometryType["Plane"] = "Plane";
  GeometryType["Sphere"] = "Sphere";
})(GeometryType || (GeometryType = {}));

var fs = "uniform samplerCube u_cube;\n\nvarying vec3 v_cubeUV;\n\nvoid main() {\n\n    gl_FragColor = textureCube( u_cube, v_cubeUV );\n\n}\n";

var vs = "#include <common_vert>\n\nuniform mat4 u_mvpNoscale;\n\nvarying vec3 v_cubeUV;\n\nvoid main() {\n\n    v_cubeUV = a_position.xyz;\n    gl_Position = u_mvpNoscale * vec4( a_position, 1.0 );\n    gl_Position.z = gl_Position.w;\n\n}\n";

/**
 * 天空盒材质
 */

var SkyBoxMaterial = /*#__PURE__*/function (_Material) {
  _inherits(SkyBoxMaterial, _Material);

  var _super = _createSuper(SkyBoxMaterial);

  function SkyBoxMaterial(engine) {
    var _this;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SkyBoxMaterial.defaultName;

    _classCallCheck(this, SkyBoxMaterial);

    _this = _super.call(this, engine, name);
    _this._cacheMat1 = void 0;
    _this._cacheMat2 = void 0;
    _this.modelMatrix = void 0;
    return _this;
  }

  _createClass(SkyBoxMaterial, [{
    key: "setModel",
    value: function setModel(modelMatrix) {
      this.modelMatrix = modelMatrix;
    }
    /**
     * 渲染前调用
     * @private
     */

  }, {
    key: "prepareDrawing",
    value: function prepareDrawing(context, component) {
      if (this._technique === null) {
        this._generateTechnique();
      }

      if (!this._cacheMat1) {
        this._cacheMat1 = new miniprogram.Matrix();
        this._cacheMat2 = new miniprogram.Matrix();
      }

      var view = context.viewMatrix;
      var proj = context.projectionMatrix;
      miniprogram.Matrix.multiply(view, this.modelMatrix, this._cacheMat1);
      var e = this._cacheMat1.elements;
      e[12] = e[13] = e[14] = 0;
      miniprogram.Matrix.multiply(proj, this._cacheMat1, this._cacheMat2);
      this.setValue("u_mvpNoscale", this._cacheMat2);

      _get(_getPrototypeOf(SkyBoxMaterial.prototype), "prepareDrawing", this).call(this, context, component, undefined);
    }
    /**
     * 创建Technique
     * @private
     */

  }, {
    key: "_generateTechnique",
    value: function _generateTechnique() {
      var tech = new RenderTechnique(SkyBoxMaterial.techniqueName);
      tech.isValid = true;
      tech.uniforms = SkyBoxMaterial.techniqueConfig.uniforms;
      tech.attributes = SkyBoxMaterial.techniqueConfig.attributes;
      tech.states = SkyBoxMaterial.techniqueConfig.states;
      tech.vertexShader = SkyBoxMaterial.vertexShader;
      tech.fragmentShader = SkyBoxMaterial.fragmentShader;
      this._technique = tech;
    }
  }]);

  return SkyBoxMaterial;
}(Material);
SkyBoxMaterial.defaultName = "SKY_BOX_MATERIAL";
SkyBoxMaterial.techniqueName = "SKY_BOX_TECHNIQUE";
SkyBoxMaterial.vertexShader = vs;
SkyBoxMaterial.fragmentShader = fs;
SkyBoxMaterial.techniqueConfig = {
  attributes: {},
  uniforms: {
    u_mvpNoscale: {
      name: "u_mvpNoscale",
      type: exports.DataType.FLOAT_MAT4
    },
    u_cube: {
      name: "u_cube",
      type: exports.DataType.SAMPLER_CUBE
    }
  },
  states: {
    disable: [exports.RenderState.CULL_FACE],
    functions: {
      depthFunc: exports.CompFunc.LEQUAL
    }
  }
};

/**
 * 天空盒组件
 * @class
 */

var SkyBox = /*#__PURE__*/function (_GeometryRenderer) {
  _inherits(SkyBox, _GeometryRenderer);

  var _super = _createSuper(SkyBox);

  /**
   * 天空盒组件
   * @param {Entity} entity 挂载节点
   */
  function SkyBox(entity) {
    var _this;

    _classCallCheck(this, SkyBox);

    _this = _super.call(this, entity);
    _this._skyBoxMap = void 0;
    _this.geometry = new CuboidGeometry(_this.engine, 2, 2, 2);
    _this.material = new SkyBoxMaterial(_this.engine);
    return _this;
  }

  _createClass(SkyBox, [{
    key: "update",
    value: function update() {
      this.material.setModel(this.entity.transform.worldMatrix);
    }
  }, {
    key: "render",
    value: function render(camera) {
      if (!this._skyBoxMap) return;

      _get(_getPrototypeOf(SkyBox.prototype), "render", this).call(this, camera);
    }
    /**
     * 天空盒贴图
     * @type {TextureCubeMap}
     */

  }, {
    key: "skyBoxMap",
    get: function get() {
      return this._skyBoxMap;
    },
    set: function set(v) {
      this._skyBoxMap = v;
      this.material.setValue("u_cube", v);
    }
  }]);

  return SkyBox;
}(GeometryRenderer);

var fs$1 = "#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n\n#include <fog_share>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <refraction_share>\n#include <perturbation_share>\n#include <clipPlane_frag_define>\n\n// light\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n\n// prop & texture\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n\n// runtime context\n#include <pbr_runtime_frag_define>\n\n// todo: generalize\n#include <pbr_normal_frag_define>\n\n\n// todo: BxDF\n#include <pbr_brdf_cook_torrance_frag_define>\n\n\n// direct + indirect\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\n\n#include <oit_frag_define>\n\n\nvoid main() {\n    #include <clipPlane_frag>\n\n    #include <pbr_begin_frag>\n    #include <pbr_direct_irradiance_frag>\n    #include <pbr_ibl_diffuse_frag>\n    #include <pbr_ibl_specular_frag>\n    // todo: generalize texture logic\n    #include <pbr_end_frag>\n    #include <gamma_frag>\n    #include <refraction_frag>\n    #include <perturbation_frag>\n    #include <fog_frag>\n\n    #include <oit_frag>\n\n    // gl_FragColor = texture2D( u_baseColorSampler, v_uv );\n}\n";

var vs$1 = "#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <clipPlane_vert_define>\n#include <morph_target_vert>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n\n    #include <morph_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <clipPlane_vert>\n    #include <position_vert>\n\n    #include <fog_vert>\n}\n";

/**
 * PBR（Physically-Based Rendering）材质
 */

var PBRMaterial = /*#__PURE__*/function (_Material) {
  _inherits(PBRMaterial, _Material);

  var _super = _createSuper(PBRMaterial);

  /**
   * PBR 材质
   * @param {String} [name='PBR_MATERIAL'] 材质名
   * @param {Object} [props] 包含以下参数
   * @param {Vector4} [props.baseColorFactor=[1, 1, 1, 1]] 基础颜色因子
   * @param {Texture2D} [props.baseColorTexture] 基础颜色纹理
   * @param {Number} [props.metallicFactor=1] 金属度
   * @param {Number} [props.roughnessFactor=1] 粗糙度
   * @param {Texture2D} [props.metallicTexture] 金属纹理
   * @param {Texture2D} [props.roughnessTexture] 粗糙度纹理
   * @param {Texture2D} [props.metallicRoughnessTexture] 金属粗糙度纹理
   * @param {Texture2D} [props.normalTexture] 法线纹理
   * @param {Number} [props.normalScale=1] 法线缩放量
   * @param {Texture2D} [props.emissiveTexture] 发散光纹理
   * @param {Vector3} [props.emissiveFactor=[0, 0, 0]] 发散光因子
   * @param {Texture2D} [props.occlusionTexture] 遮蔽纹理
   * @param {Number} [props.occlusionStrength=1] 遮蔽强度
   * @param {Number} [props.alphaCutoff=0.5] alpha裁剪值
   * @param {String} [props.alphaMode='OPAQUE'] alpha混合模式
   * @param {Boolean} [props.doubleSided=false] 是否显示双面
   * @param {Side} [props.side=Side.Front] 显示哪一个面，向下兼容doubleSided
   * @param {Boolean} [props.unlit=false] 是否不使用光照
   * @param {Boolean} [props.srgb=false] 是否为 SRGB 色彩空间
   * @param {Boolean} [props.srgbFast=true] sRGB线性校正是否使用近似快速算法
   * @param {Boolean} [props.gamma=false] 是否使用 Gamma 纠正
   * @param {Number} [props.opacity=1] 透明度
   * @param {Texture2D} [props.opacityTexture] 透明度贴图
   * @param {boolean} [props.getOpacityFromRGB=false] true:取透明度贴图的rgb亮度，false:取alpha通道
   *
   * @param {boolean} [props.isMetallicWorkflow=true] ture:金属粗糙度模式，false：高光光泽度模式
   * @param {Vector3} [props.specularFactor=[1，1，1]] 高光度因子
   * @param {number} [props.glossinessFactor=0] 光泽度
   * @param {Texture2D} [props.specularGlossinessTexture] 高光光泽度纹理
   *
   * @param {number} [props.envMapIntensity] 反射模式时的反射强度；
   *
   *  todo: IOR 更加符合材质的属性，但是需要增加额外的属性来表示非真空折射率，如摄像机在水中等情况。
   * @param {number} [props.refractionRatio] 折射模式时的折射率的比例，如真空折射率/水折射率=1/1.33;
   * @param {boolean} [props.envMapModeRefract=false] 全局环境贴图使用 反射或者折射 模式;
   * @param {Texture2D} [props.refractionTexture] 局部 折射纹理;
   * @param {number} [props.refractionDepth] 局部 折射纹理 深度值，用来模拟折射距离;
   *
   * @param {Texture2D} [props.perturbationTexture] 扰动纹理
   * @param {number} [props.perturbationUOffset] 扰动纹理U偏移
   * @param {number} [props.perturbationVOffset] 扰动纹理V偏移
   *
   * @param {TextureCubeMap} [props.reflectionTexture] 局部反射贴图，可以覆盖 AEnvironmentMapLight
   *
   */
  function PBRMaterial(engine) {
    var _this;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PBRMaterial.MATERIAL_NAME;
    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, PBRMaterial);

    _this = _super.call(this, engine, name);
    _this._uniformObj = void 0;
    _this._stateObj = void 0;
    _this._ambientLightCount = void 0;
    _this._envMapLightCount = void 0;
    _this._spotLightCount = void 0;
    _this._directLightCount = void 0;
    _this._pointLightCount = void 0;
    _this._useDiffuseEnv = void 0;
    _this._useSpecularEnv = void 0;
    _this._clipPlaneCount = void 0;
    _this._useOIT = void 0;

    _this.createDefaulteValues();

    _this.setUniforms(props);

    _this.setStates(props);

    return _this;
  }
  /**
   * 创建默认的参数值
   * @private
   */


  _createClass(PBRMaterial, [{
    key: "createDefaulteValues",
    value: function createDefaulteValues() {
      var _this2 = this;

      this._uniformObj = {
        baseColorFactor: new miniprogram.Vector4(1.0, 1.0, 1.0, 1.0),
        metallicFactor: 1,
        roughnessFactor: 1,
        metallicRoughness: new miniprogram.Vector2(1.0, 1.0),
        normalScale: 1,
        emissiveFactor: new miniprogram.Vector3(0.0, 0.0, 0.0),
        occlusionStrength: 1,
        alphaCutoff: 0.5,
        // specular-glossiness workflow
        specularFactor: new miniprogram.Vector3(1.0, 1.0, 1.0),
        glossinessFactor: 0,
        // reflect,refract
        envMapIntensity: 1,
        refractionRatio: 1 / 1.33,
        refractionDepth: 1,
        // perturbation
        perturbationUOffset: 0,
        perturbationVOffset: 0
      };
      this._stateObj = {
        alphaMode: "OPAQUE",
        doubleSided: false,
        side: exports.Side.FRONT,
        unlit: false,
        srgb: false,
        srgbFast: false,
        gamma: false,
        blendFunc: [],
        blendFuncSeparate: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA, exports.BlendFunc.ONE, exports.BlendFunc.ONE],
        depthMask: [false],
        getOpacityFromRGB: false,
        isMetallicWorkflow: true,
        envMapModeRefract: false
      };
      Object.keys(this._uniformObj).forEach(function (k) {
        return _this2.setValueByParamName(k, _this2._uniformObj[k]);
      });
    }
    /**
     * 设置使用到的Uniform信息
     * @param {Object} obj 使用到的Uniform信息
     * @private
     */

  }, {
    key: "setUniforms",
    value: function setUniforms(obj) {
      var _this3 = this;

      Object.keys(obj).forEach(function (key) {
        switch (key) {
          case "baseColorFactor":
            _this3.baseColorFactor = obj[key];
            break;

          case "opacity":
            _this3.opacity = obj[key];
            break;

          case "opacityTexture":
            _this3.opacityTexture = obj[key];
            break;

          case "baseColorTexture":
            _this3.baseColorTexture = obj[key];
            break;

          case "metallicFactor":
            _this3.metallicFactor = obj[key];
            break;

          case "roughnessFactor":
            _this3.roughnessFactor = obj[key];
            break;

          case "metallicTexture":
            _this3.metallicTexture = obj[key];
            break;

          case "roughnessTexture":
            _this3.roughnessTexture = obj[key];
            break;

          case "metallicRoughnessTexture":
            _this3.metallicRoughnessTexture = obj[key];
            break;

          case "normalTexture":
            _this3.normalTexture = obj[key];
            break;

          case "normalScale":
            _this3.normalScale = obj[key];
            break;

          case "emissiveTexture":
            _this3.emissiveTexture = obj[key];
            break;

          case "emissiveFactor":
            _this3.emissiveFactor = obj[key];
            break;

          case "occlusionTexture":
            _this3.occlusionTexture = obj[key];
            break;

          case "occlusionStrength":
            _this3.occlusionStrength = obj[key];
            break;

          case "alphaCutoff":
            _this3.alphaCutoff = obj[key];
            break;

          case "specularFactor":
            _this3.specularFactor = obj[key];
            break;

          case "glossinessFactor":
            _this3.glossinessFactor = obj[key];
            break;

          case "specularGlossinessTexture":
            _this3.specularGlossinessTexture = obj[key];
            break;

          case "reflectionTexture":
            _this3.reflectionTexture = obj[key];
            break;

          case "envMapIntensity":
            _this3.envMapIntensity = obj[key];
            break;

          case "refractionRatio":
            _this3.refractionRatio = obj[key];
            break;

          case "refractionDepth":
            _this3.refractionDepth = obj[key];
            break;

          case "refractionTexture":
            _this3.refractionTexture = obj[key];
            break;

          case "perturbationTexture":
            _this3.perturbationTexture = obj[key];
            break;

          case "perturbationUOffset":
            _this3.perturbationUOffset = obj[key];
            break;

          case "perturbationVOffset":
            _this3.perturbationVOffset = obj[key];
            break;
        }
      });
    }
    /**
     * 设置渲染状态信息
     * @param {Object} obj 渲染状态信息
     * @private
     */

  }, {
    key: "setStates",
    value: function setStates(obj) {
      var _this4 = this;

      Object.keys(obj).forEach(function (key) {
        switch (key) {
          case "doubleSided":
            _this4.doubleSided = obj[key];
            break;

          case "side":
            _this4.side = obj[key];
            break;

          case "alphaMode":
            _this4.alphaMode = obj[key];
            break;

          case "unlit":
            _this4.unlit = obj[key];
            break;

          case "srgb":
            _this4.srgb = obj[key];
            break;

          case "srgbFast":
            _this4.srgbFast = obj[key];
            break;

          case "gamma":
            _this4.gamma = obj[key];
            break;

          case "blendFunc":
            _this4.blendFunc = obj[key];
            break;

          case "blendFuncSeparate":
            _this4.blendFuncSeparate = obj[key];
            break;

          case "depthMask":
            _this4.depthMask = obj[key];
            break;

          case "getOpacityFromRGB":
            _this4.getOpacityFromRGB = obj[key];
            break;

          case "isMetallicWorkflow":
            _this4.isMetallicWorkflow = obj[key];
            break;

          case "envMapModeRefract":
            _this4.envMapModeRefract = obj[key];
            break;
        }
      });
    }
    /**
     * 根据 uniform 的参数名设置材质值
     * @private
     */

  }, {
    key: "setValueByParamName",
    value: function setValueByParamName(paramName, value) {
      var uniforms = PBRMaterial.TECH_CONFIG.uniforms;
      var uniformName = Object.keys(uniforms).find(function (key) {
        return uniforms[key].paramName === paramName;
      });

      if (uniformName) {
        this.setValue(uniformName, value);
      }
    }
    /** 根据 state 跟新 technique */

  }, {
    key: "updateTechnique",
    value: function updateTechnique(stateName, v) {
      var _this$technique;

      if (this[stateName] === v) return;
      this._stateObj[stateName] = v;
      var states = (_this$technique = this.technique) === null || _this$technique === void 0 ? void 0 : _this$technique.states;
      if (!states) return;

      switch (stateName) {
        case "doubleSided":
        case "side":
          if (this.doubleSided) {
            states.disable.push(exports.RenderState.CULL_FACE);
          } else {
            var index = states.disable.indexOf(exports.RenderState.CULL_FACE);

            if (index > -1) {
              states.disable.splice(index, 1);
            }

            switch (this.side) {
              case exports.Side.FRONT:
                states.functions.cullFace = [exports.CullFace.BACK];
                break;

              case exports.Side.BACK:
                states.functions.cullFace = [exports.CullFace.FRONT];
                break;

              case exports.Side.NONE:
                states.functions.cullFace = [exports.CullFace.FRONT_AND_BACK];
                break;

              default:
                delete states.functions.cullFace;
            }
          }

          break;

        case "blendFunc":
        case "blendFuncSeparate":
          if (this.blendFunc.length) {
            states.functions.blendFunc = this.blendFunc;
          } else {
            states.functions.blendFuncSeparate = this.blendFuncSeparate;
          }

          break;

        case "depthMask":
          states.functions.depthMask = v;
          break;

        default:
          this._technique = null;
      }
    }
    /****************************************   uniform start **************************************** /
      /**
     * 基础颜色因子
     * @type {Vector4}
     */

  }, {
    key: "prepareDrawing",

    /****************************************   state end **************************************** /
     /**
     * 绘制前准备
     * @param {Camera} camera 相机
     * @param {Component} component 组件
     * @private
     */
    value: function prepareDrawing(context, component, primitive) {
      var _scene$clipPlanes;

      var camera = context.camera;
      var scene = camera.scene;
      var canvas = scene.engine.canvas;
      var lightMgr = scene.findFeature(LightFeature);
      var canOIT = camera._renderPipeline.canOIT;
      /** 光源 uniform values */

      lightMgr.bindMaterialValues(this);
      /** 分辨率 */

      this.setValue("u_resolution", new miniprogram.Vector2(canvas.width, canvas.height));
      /** clipPlane */

      for (var i = 0; i < this._clipPlaneCount; i++) {
        this.setValue("u_clipPlanes[".concat(i, "]"), scene.clipPlanes[i]);
      }
      /** oit  depth texture */


      if (canOIT) {
        this.setValue("u_depthSampler", camera._renderPipeline.depthTexture);
      }
      /** 是否需要重新编译 technique */


      var _lightMgr$lightSortAm = lightMgr.lightSortAmount,
          ambientLightCount = _lightMgr$lightSortAm.ambientLightCount,
          directLightCount = _lightMgr$lightSortAm.directLightCount,
          pointLightCount = _lightMgr$lightSortAm.pointLightCount,
          spotLightCount = _lightMgr$lightSortAm.spotLightCount,
          envMapLightCount = _lightMgr$lightSortAm.envMapLightCount,
          useDiffuseEnv = _lightMgr$lightSortAm.useDiffuseEnv,
          useSpecularEnv = _lightMgr$lightSortAm.useSpecularEnv;

      if (!this._technique || this._ambientLightCount !== ambientLightCount || this._envMapLightCount !== envMapLightCount || this._useDiffuseEnv !== useDiffuseEnv || this._useSpecularEnv !== useSpecularEnv || this._directLightCount !== directLightCount || this._pointLightCount !== pointLightCount || this._spotLightCount !== spotLightCount || this._clipPlaneCount !== ((_scene$clipPlanes = scene.clipPlanes) === null || _scene$clipPlanes === void 0 ? void 0 : _scene$clipPlanes.length) || this._useOIT !== canOIT) {
        var _scene$clipPlanes2;

        this._ambientLightCount = ambientLightCount;
        this._envMapLightCount = envMapLightCount;
        this._useDiffuseEnv = useDiffuseEnv;
        this._useSpecularEnv = useSpecularEnv;
        this._directLightCount = directLightCount;
        this._pointLightCount = pointLightCount;
        this._spotLightCount = spotLightCount;
        this._clipPlaneCount = (_scene$clipPlanes2 = scene.clipPlanes) === null || _scene$clipPlanes2 === void 0 ? void 0 : _scene$clipPlanes2.length;
        this._useOIT = canOIT;

        this._generateTechnique(camera, component, primitive);
      }

      _get(_getPrototypeOf(PBRMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
    }
    /**
     * 创建Technique
     * @param {Camera} camera 相机
     * @param {Ability} component 组件
     * @private
     */

  }, {
    key: "_generateTechnique",
    value: function _generateTechnique(camera, component, primitive) {
      var customMacros = this._generateShaderMacros(camera, component, primitive);

      var techName = PBRMaterial.TECHNIQUE_NAME;
      var vertex = PBRMaterial.STATIC_VERTEX_SHADER;
      var frag = PBRMaterial.STATIC_FRAGMENT_SHADER;

      var config = this._generateConfig();

      var lightMgr = camera.scene.findFeature(LightFeature);
      var tech = new RenderTechnique(techName);
      tech.isValid = true;
      tech.uniforms = _objectSpread2(_objectSpread2({}, lightMgr.getUniformDefine()), config.uniforms);
      tech.attributes = config.attributes;
      tech.fragmentPrecision = "highp";
      tech.customMacros = customMacros;
      tech.states = config.states;
      tech.vertexShader = vertex;
      tech.fragmentShader = frag;
      this._technique = tech;
      return tech;
    }
    /**
     * 创建宏
     * @param {Camera} camera 相机
     * @param {Ability} component 组件
     * @private
     */

  }, {
    key: "_generateShaderMacros",
    value: function _generateShaderMacros(camera, component, primitive) {
      var rhi = camera.scene.engine._hardwareRenderer;
      var _macros = ["O3_NEED_WORLDPOS"];
      if (!primitive._vertexElementMap.NORMAL || !primitive._vertexElementMap.TANGENT) if (rhi.canIUse(exports.GLCapabilityType.standardDerivatives)) _macros.push("HAS_DERIVATIVES");
      var uniforms = Object.keys(this._values);
      if (uniforms.indexOf("u_baseColorSampler") > -1) _macros.push("HAS_BASECOLORMAP");
      if (uniforms.indexOf("u_normalSampler") > -1) _macros.push("O3_HAS_NORMALMAP");
      if (uniforms.indexOf("u_metallicSampler") > -1) _macros.push("HAS_METALMAP");
      if (uniforms.indexOf("u_roughnessSampler") > -1) _macros.push("HAS_ROUGHNESSMAP");
      if (uniforms.indexOf("u_metallicRoughnessSampler") > -1) _macros.push("HAS_METALROUGHNESSMAP");
      if (uniforms.indexOf("u_emissiveSampler") > -1) _macros.push("HAS_EMISSIVEMAP");
      if (uniforms.indexOf("u_occlusionSampler") > -1) _macros.push("HAS_OCCLUSIONMAP");
      if (uniforms.indexOf("u_specularGlossinessSampler") > -1) _macros.push("HAS_SPECULARGLOSSINESSMAP");
      if (uniforms.indexOf("u_perturbationSampler") > -1) _macros.push("HAS_PERTURBATIONMAP");
      if (uniforms.indexOf("u_reflectionSampler") > -1) _macros.push("HAS_REFLECTIONMAP");

      if (uniforms.indexOf("u_refractionSampler") > -1) {
        this.setValueByParamName("PTMMatrix", new miniprogram.Matrix(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0));

        _macros.push("HAS_REFRACTIONMAP");
      }

      if (this.alphaMode === "MASK") {
        _macros.push("ALPHA_MASK");
      } else if (this.alphaMode === "BLEND" && !this.refractionTexture) {
        _macros.push("ALPHA_BLEND");

        if (uniforms.indexOf("u_opacitySampler") > -1) {
          _macros.push("HAS_OPACITYMAP");

          if (this.getOpacityFromRGB) {
            _macros.push("GETOPACITYFROMRGB");
          }
        }
      }

      if (this._envMapLightCount) {
        _macros.push("O3_HAS_ENVMAP_LIGHT");

        if (this._useDiffuseEnv) _macros.push("O3_USE_DIFFUSE_ENV");
        if (this._useSpecularEnv) _macros.push("O3_USE_SPECULAR_ENV");
        if (rhi.canIUse(exports.GLCapabilityType.shaderTextureLod)) _macros.push("HAS_TEX_LOD");
      }

      if (this._ambientLightCount) {
        _macros.push("O3_HAS_AMBIENT_LIGHT");
      }

      if (this._directLightCount) _macros.push("O3_DIRECT_LIGHT_COUNT ".concat(this._directLightCount));
      if (this._pointLightCount) _macros.push("O3_POINT_LIGHT_COUNT ".concat(this._pointLightCount));
      if (this._spotLightCount) _macros.push("O3_SPOT_LIGHT_COUNT ".concat(this._spotLightCount));
      if (this._clipPlaneCount) _macros.push("O3_CLIPPLANE_NUM ".concat(this._clipPlaneCount));
      if (this._stateObj.unlit) _macros.push("UNLIT");
      if (this._stateObj.srgb) _macros.push("MANUAL_SRGB");
      if (this._stateObj.srgbFast) _macros.push("SRGB_FAST_APPROXIMATION");
      if (this._stateObj.gamma) _macros.push("GAMMA");
      if (this._stateObj.isMetallicWorkflow) _macros.push("IS_METALLIC_WORKFLOW");
      if (this._stateObj.envMapModeRefract) _macros.push("ENVMAPMODE_REFRACT");

      if (camera._renderPipeline.canOIT) {
        _macros.push("OIT_ENABLE");
      }

      return _macros;
    }
    /**
     * 创建Technique配置信息
     */

  }, {
    key: "_generateConfig",
    value: function _generateConfig() {
      var defaultState = PBRMaterial.TECH_CONFIG.states;
      var states = {
        disable: defaultState.disable.slice(),
        enable: defaultState.enable.slice(),
        functions: _extends({}, defaultState.functions)
      };

      if (this.doubleSided) {
        states.disable.push(exports.RenderState.CULL_FACE);
      } else {
        switch (this.side) {
          case exports.Side.FRONT:
            states.functions.cullFace = [exports.CullFace.BACK];
            break;

          case exports.Side.BACK:
            states.functions.cullFace = [exports.CullFace.FRONT];
            break;

          case exports.Side.NONE:
            states.functions.cullFace = [exports.CullFace.FRONT_AND_BACK];
            break;

          default:
            delete states.functions.cullFace;
        }
      }

      if (this.alphaMode === "BLEND" && !this.refractionTexture) {
        states.enable.push(exports.RenderState.BLEND);

        if (this.blendFunc.length) {
          states.functions.blendFunc = this._stateObj.blendFunc;
        } else {
          states.functions.blendFuncSeparate = this._stateObj.blendFuncSeparate;
        }

        states.functions.depthMask = this._stateObj.depthMask;
        this.renderType = exports.MaterialType.TRANSPARENT;
      } else {
        this.renderType = exports.MaterialType.OPAQUE;
      }

      var clipPlaneUniforms = {};

      for (var i = 0; i < this._clipPlaneCount; i++) {
        clipPlaneUniforms["u_clipPlanes[".concat(i, "]")] = {
          name: "u_clipPlanes[".concat(i, "]"),
          type: exports.DataType.FLOAT_VEC4
        };
      }

      PBRMaterial.TECH_CONFIG.uniforms = _extends({}, PBRMaterial.TECH_CONFIG.uniforms, clipPlaneUniforms);
      return _extends({}, PBRMaterial.TECH_CONFIG, {
        states: states
      });
    }
    /**
     * 创建一个副本
     * @param {string} name - name
     */

  }, {
    key: "clone",
    value: function clone(name) {
      var newMtl = new PBRMaterial(this._engine, name || this.name);
      newMtl.renderType = this.renderType;
      newMtl.useFog = this.useFog;

      for (var _name in this._uniformObj) {
        var value = this._uniformObj[_name];

        if (value instanceof Texture) {
          newMtl[_name] = value;
        } else {
          newMtl[_name] = Util.clone(value);
        }
      }

      if (this._stateObj) {
        newMtl._stateObj = Util.clone(this._stateObj);
      }

      return newMtl;
    }
    /**
     * 默认材质名 ‘PBR_MATERIAL’
     * @private
     */

  }, {
    key: "baseColorFactor",
    get: function get() {
      return this._uniformObj.baseColorFactor;
    },
    set: function set(v) {
      this._uniformObj.baseColorFactor = v;
      this.setValueByParamName("baseColorFactor", v);
    }
  }, {
    key: "opacity",
    get: function get() {
      return this.baseColorFactor.w;
    },
    set: function set(val) {
      this.baseColorFactor.w = val;
    }
    /**
     * 基础颜色纹理
     * @type {Texture2D}
     */

  }, {
    key: "baseColorTexture",
    get: function get() {
      return this._uniformObj.baseColorTexture;
    },
    set: function set(v) {
      this.setValueByParamName("baseColorTexture", v);
      this._uniformObj.baseColorTexture = v;
    }
    /**
     * 透明贴图
     * @type {Texture2D}
     * */

  }, {
    key: "opacityTexture",
    get: function get() {
      return this._uniformObj.opacityTexture;
    },
    set: function set(v) {
      this.setValueByParamName("opacityTexture", v);
      this._uniformObj.opacityTexture = v;
    }
    /**
     * 金属度
     * @type {Number}
     */

  }, {
    key: "metallicFactor",
    get: function get() {
      return this._uniformObj.metallicFactor;
    },
    set: function set(v) {
      this._uniformObj.metallicFactor = v;
      this._uniformObj.metallicRoughness.x = v;
      this.setValueByParamName("metallicRoughness", this._uniformObj.metallicRoughness);
    }
    /**
     * 粗糙度
     * @type {Number}
     */

  }, {
    key: "roughnessFactor",
    get: function get() {
      return this._uniformObj.roughnessFactor;
    },
    set: function set(v) {
      this._uniformObj.roughnessFactor = v;
      this._uniformObj.metallicRoughness.y = v;
      this.setValueByParamName("metallicRoughness", this._uniformObj.metallicRoughness);
    }
    /**
     * 金属纹理
     * @type {Texture2D}
     */

  }, {
    key: "metallicTexture",
    get: function get() {
      return this._uniformObj.metallicTexture;
    },
    set: function set(v) {
      this.setValueByParamName("metallicTexture", v);
      this._uniformObj.metallicTexture = v;
    }
    /**
     * 粗糙度纹理
     * @type {Texture2D}
     */

  }, {
    key: "roughnessTexture",
    get: function get() {
      return this._uniformObj.roughnessTexture;
    },
    set: function set(v) {
      this.setValueByParamName("roughnessTexture", v);
      this._uniformObj.roughnessTexture = v;
    }
    /**
     * 金属粗糙度纹理
     * @type {Texture2D}
     */

  }, {
    key: "metallicRoughnessTexture",
    get: function get() {
      return this._uniformObj.metallicRoughnessTexture;
    },
    set: function set(v) {
      this.setValueByParamName("metallicRoughnessTexture", v);
      this._uniformObj.metallicRoughnessTexture = v;
    }
    /**
     * 法线纹理
     * @type {Texture2D}
     */

  }, {
    key: "normalTexture",
    get: function get() {
      return this._uniformObj.normalTexture;
    },
    set: function set(v) {
      this.setValueByParamName("normalTexture", v);
      this._uniformObj.normalTexture = v;
    }
    /**
     * 法线缩放量
     * @type {Number}
     */

  }, {
    key: "normalScale",
    get: function get() {
      return this._uniformObj.normalScale;
    },
    set: function set(v) {
      this._uniformObj.normalScale = v;
      this.setValueByParamName("normalScale", v);
    }
    /**
     * 发散光纹理
     * @type {Texture2D}
     */

  }, {
    key: "emissiveTexture",
    get: function get() {
      return this._uniformObj.emissiveTexture;
    },
    set: function set(v) {
      this.setValueByParamName("emissiveTexture", v);
      this._uniformObj.emissiveTexture = v;
    }
    /**
     * 发散光因子
     * @type {Vector3}
     */

  }, {
    key: "emissiveFactor",
    get: function get() {
      return this._uniformObj.emissiveFactor;
    },
    set: function set(v) {
      this._uniformObj.emissiveFactor = v;
      this.setValueByParamName("emissiveFactor", v);
    }
    /**
     * 遮蔽纹理
     * @type {Texture2D}
     */

  }, {
    key: "occlusionTexture",
    get: function get() {
      return this._uniformObj.occlusionTexture;
    },
    set: function set(v) {
      this.setValueByParamName("occlusionTexture", v);
      this._uniformObj.occlusionTexture = v;
    }
    /**
     * 遮蔽强度
     * @type {Number}
     */

  }, {
    key: "occlusionStrength",
    get: function get() {
      return this._uniformObj.occlusionStrength;
    },
    set: function set(v) {
      this._uniformObj.occlusionStrength = v;
      this.setValueByParamName("occlusionStrength", v);
    }
    /**
     * alpha裁剪值
     * @type {Number}
     */

  }, {
    key: "alphaCutoff",
    get: function get() {
      return this._uniformObj.alphaCutoff;
    },
    set: function set(v) {
      this._uniformObj.alphaCutoff = v;
      this.setValueByParamName("alphaCutoff", v);
    }
    /**
     * 高光度因子
     * @type {Vector3}
     */

  }, {
    key: "specularFactor",
    get: function get() {
      return this._uniformObj.specularFactor;
    },
    set: function set(v) {
      this.setValueByParamName("specularFactor", v);
      this._uniformObj.specularFactor = v;
    }
    /**
     * 光泽度
     * @type {Array}
     */

  }, {
    key: "glossinessFactor",
    get: function get() {
      return this._uniformObj.glossinessFactor;
    },
    set: function set(v) {
      this.setValueByParamName("glossinessFactor", v);
      this._uniformObj.glossinessFactor = v;
    }
    /**
     * 高光光泽度纹理
     * @type {Texture2D}
     */

  }, {
    key: "specularGlossinessTexture",
    get: function get() {
      return this._uniformObj.specularGlossinessTexture;
    },
    set: function set(v) {
      this.setValueByParamName("specularGlossinessTexture", v);
      this._uniformObj.specularGlossinessTexture = v;
    }
    /**
     * 镜面反射纹理
     * @type {TextureCubeMap}
     */

  }, {
    key: "reflectionTexture",
    get: function get() {
      return this._uniformObj.reflectionTexture;
    },
    set: function set(v) {
      this.setValueByParamName("reflectionTexture", v);
      this._uniformObj.reflectionTexture = v;
    }
    /**
     * 反射强度
     * @type {number}
     */

  }, {
    key: "envMapIntensity",
    get: function get() {
      return this._uniformObj.envMapIntensity;
    },
    set: function set(v) {
      this.setValueByParamName("envMapIntensity", v);
      this._uniformObj.envMapIntensity = v;
    }
    /**
     * 折射率比
     * @type {number}
     */

  }, {
    key: "refractionRatio",
    get: function get() {
      return this._uniformObj.refractionRatio;
    },
    set: function set(v) {
      this.setValueByParamName("refractionRatio", v);
      this._uniformObj.refractionRatio = v;
    }
    /**
     * 局部折射纹理的深度值，用来模拟折射距离
     * @type {number}
     */

  }, {
    key: "refractionDepth",
    get: function get() {
      return this._uniformObj.refractionDepth;
    },
    set: function set(v) {
      this.setValueByParamName("refractionDepth", v);
      this._uniformObj.refractionDepth = v;
    }
    /**
     * 局部折射纹理
     * @type {Texture2D}
     */

  }, {
    key: "refractionTexture",
    get: function get() {
      return this._uniformObj.refractionTexture;
    },
    set: function set(v) {
      this.setValueByParamName("refractionTexture", v);
      this._uniformObj.refractionTexture = v;
    }
    /**
     * 扰动纹理
     * @type {Texture2D}
     */

  }, {
    key: "perturbationTexture",
    get: function get() {
      return this._uniformObj.perturbationTexture;
    },
    set: function set(v) {
      this.setValueByParamName("perturbationTexture", v);
      this._uniformObj.perturbationTexture = v;
    }
    /**
     * 扰动纹理U偏移
     * @type {number}
     */

  }, {
    key: "perturbationUOffset",
    get: function get() {
      return this._uniformObj.perturbationUOffset;
    },
    set: function set(v) {
      this.setValueByParamName("perturbationUOffset", v);
      this._uniformObj.perturbationUOffset = v;
    }
    /**
     * 扰动纹理V偏移
     * @type {number}
     */

  }, {
    key: "perturbationVOffset",
    get: function get() {
      return this._uniformObj.perturbationVOffset;
    },
    set: function set(v) {
      this.setValueByParamName("perturbationVOffset", v);
      this._uniformObj.perturbationVOffset = v;
    }
    /****************************************   uniform end **************************************** /
      /****************************************   state start **************************************** /
      /**
     * alpha混合模式
     * @type {'OPAQUE'|'MASK'|'BLEND'}
     */

  }, {
    key: "alphaMode",
    get: function get() {
      return this._stateObj.alphaMode;
    },
    set: function set(v) {
      this.updateTechnique("alphaMode", v);
    }
    /**
     * 是否显示双面
     * @type {Boolean}
     */

  }, {
    key: "doubleSided",
    get: function get() {
      return this._stateObj.doubleSided;
    },
    set: function set(v) {
      if (v) {
        this._stateObj.side = exports.Side.DOUBLE;
      } else if (this._stateObj.side === exports.Side.DOUBLE) {
        this._stateObj.side = exports.Side.FRONT;
      }

      this.updateTechnique("doubleSided", v);
    }
    /**
     * 显示哪个面
     * @type {Side}
     * */

  }, {
    key: "side",
    get: function get() {
      return this._stateObj.side;
    },
    set: function set(v) {
      // 向下兼容doubleSided
      if (v === exports.Side.DOUBLE) {
        this._stateObj.doubleSided = true;
      } else {
        this._stateObj.doubleSided = false;
      }

      this.updateTechnique("side", v);
    }
    /**
     * 是否使用光源
     * @type {Boolean}
     */

  }, {
    key: "unlit",
    get: function get() {
      return this._stateObj.unlit;
    },
    set: function set(v) {
      this.updateTechnique("unlit", v);
    }
    /**
     * 是否 SRGB 色彩空间
     * @type {Boolean}
     */

  }, {
    key: "srgb",
    get: function get() {
      return this._stateObj.srgb;
    },
    set: function set(v) {
      this.updateTechnique("srgb", v);
    }
    /**
     * sRGB线性校正是否使用近似快速算法
     * */

  }, {
    key: "srgbFast",
    get: function get() {
      return this._stateObj.srgbFast;
    },
    set: function set(v) {
      this.updateTechnique("srgbFast", v);
    }
    /**
     * 是否使用 Gamma 纠正
     * @type {Boolean}
     */

  }, {
    key: "gamma",
    get: function get() {
      return this._stateObj.gamma;
    },
    set: function set(v) {
      this.updateTechnique("gamma", v);
    }
  }, {
    key: "blendFunc",
    get: function get() {
      return this._stateObj.blendFunc;
    },
    set: function set(v) {
      this.updateTechnique("blendFunc", v);
    }
  }, {
    key: "blendFuncSeparate",
    get: function get() {
      return this._stateObj.blendFuncSeparate;
    },
    set: function set(v) {
      this.updateTechnique("blendFuncSeparate", v);
    }
  }, {
    key: "depthMask",
    get: function get() {
      return this._stateObj.depthMask;
    },
    set: function set(v) {
      this.updateTechnique("depthMask", v);
    }
    /**
     * 透明度通道选择
     * true:取透明度贴图的rgb亮度，false:取alpha通道
     * @type{boolean}
     * */

  }, {
    key: "getOpacityFromRGB",
    get: function get() {
      return this._stateObj.getOpacityFromRGB;
    },
    set: function set(v) {
      this.updateTechnique("getOpacityFromRGB", v);
    }
    /**
     * pbr工作流是否是金属粗糙度模式
     * @type{boolean}
     * */

  }, {
    key: "isMetallicWorkflow",
    get: function get() {
      return this._stateObj.isMetallicWorkflow;
    },
    set: function set(v) {
      this.updateTechnique("isMetallicWorkflow", v);
    }
    /**
     * 是否使用折射模式，默认反射模式
     * @type{boolean}
     * */

  }, {
    key: "envMapModeRefract",
    get: function get() {
      return this._stateObj.envMapModeRefract;
    },
    set: function set(v) {
      this.updateTechnique("envMapModeRefract", v);
    }
  }]);

  return PBRMaterial;
}(Material);

PBRMaterial.MATERIAL_NAME = "PBR_MATERIAL";
PBRMaterial.TECHNIQUE_NAME = "PBR_TECHNIQUE";
PBRMaterial.STATIC_VERTEX_SHADER = vs$1;
PBRMaterial.STATIC_FRAGMENT_SHADER = fs$1;
PBRMaterial.attribUniformVec4 = 12;
PBRMaterial.TECH_CONFIG = {
  attributes: {},
  uniforms: _extends({
    u_baseColorSampler: {
      name: "u_baseColorSampler",
      paramName: "baseColorTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_baseColorFactor: {
      name: "u_baseColorFactor",
      paramName: "baseColorFactor",
      type: exports.DataType.FLOAT_VEC4
    },
    u_normalSampler: {
      name: "u_normalSampler",
      paramName: "normalTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_normalScale: {
      name: "u_normalScale",
      paramName: "normalScale",
      type: exports.DataType.FLOAT
    },
    u_lightDirection: {
      name: "u_lightDirection",
      type: exports.DataType.FLOAT_VEC3
    },
    u_lightColor: {
      name: "u_lightColor",
      type: exports.DataType.FLOAT_VEC3
    },
    u_metallicRoughnessValue: {
      name: "u_metallicRoughnessValue",
      paramName: "metallicRoughness",
      type: exports.DataType.FLOAT_VEC2
    },
    u_metallicSampler: {
      name: "u_metallicSampler",
      paramName: "metallicTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_roughnessSampler: {
      name: "u_roughnessSampler",
      paramName: "roughnessTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_metallicRoughnessSampler: {
      name: "u_metallicRoughnessSampler",
      paramName: "metallicRoughnessTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_emissiveFactor: {
      name: "u_emissiveFactor",
      paramName: "emissiveFactor",
      type: exports.DataType.FLOAT_VEC3
    },
    u_emissiveSampler: {
      name: "u_emissiveSampler",
      paramName: "emissiveTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_occlusionSampler: {
      name: "u_occlusionSampler",
      paramName: "occlusionTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_occlusionStrength: {
      name: "u_occlusionStrength",
      paramName: "occlusionStrength",
      type: exports.DataType.FLOAT
    },
    u_alphaCutoff: {
      name: "u_alphaCutoff",
      paramName: "alphaCutoff",
      type: exports.DataType.FLOAT
    },
    u_opacitySampler: {
      name: "u_opacitySampler",
      paramName: "opacityTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_specularFactor: {
      name: "u_specularFactor",
      paramName: "specularFactor",
      type: exports.DataType.FLOAT_VEC3
    },
    u_glossinessFactor: {
      name: "u_glossinessFactor",
      paramName: "glossinessFactor",
      type: exports.DataType.FLOAT
    },
    u_specularGlossinessSampler: {
      name: "u_specularGlossinessSampler",
      paramName: "specularGlossinessTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_reflectionSampler: {
      name: "u_reflectionSampler",
      paramName: "reflectionTexture",
      type: exports.DataType.SAMPLER_CUBE
    },
    u_PTMMatrix: {
      name: "u_PTMMatrix",
      paramName: "PTMMatrix",
      type: exports.DataType.FLOAT_MAT4
    },
    u_envMapIntensity: {
      name: "u_envMapIntensity",
      paramName: "envMapIntensity",
      type: exports.DataType.FLOAT
    },
    u_refractionRatio: {
      name: "u_refractionRatio",
      paramName: "refractionRatio",
      type: exports.DataType.FLOAT
    },
    u_refractionDepth: {
      name: "u_refractionDepth",
      paramName: "refractionDepth",
      type: exports.DataType.FLOAT
    },
    u_refractionSampler: {
      name: "u_refractionSampler",
      paramName: "refractionTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_resolution: {
      name: "u_resolution",
      paramName: "resolution",
      type: exports.DataType.FLOAT_VEC2
    },
    u_perturbationSampler: {
      name: "u_perturbationSampler",
      paramName: "perturbationTexture",
      type: exports.DataType.SAMPLER_2D
    },
    u_perturbationUOffset: {
      name: "u_perturbationUOffset",
      paramName: "perturbationUOffset",
      type: exports.DataType.FLOAT
    },
    u_perturbationVOffset: {
      name: "u_perturbationVOffset",
      paramName: "perturbationVOffset",
      type: exports.DataType.FLOAT
    },
    u_depthSampler: {
      name: "u_depthSampler",
      type: exports.DataType.SAMPLER_2D
    }
  }),
  states: {
    disable: [],
    enable: [],
    functions: {}
  }
};

/**
 * GPU粒子系统渲染类
 * @extends GeometryRenderer
 */

var GPUParticleSystem = /*#__PURE__*/function (_GeometryRenderer) {
  _inherits(GPUParticleSystem, _GeometryRenderer);

  var _super = _createSuper(GPUParticleSystem);

  /**
   * @constructor
   * @param {Entity} entity 节点对象
   */
  function GPUParticleSystem(entity) {
    var _this;

    _classCallCheck(this, GPUParticleSystem);

    _this = _super.call(this, entity);
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._time = void 0;
    _this._isInit = void 0;
    _this._isStart = void 0;
    _this.maxCount = void 0;
    _this.options = void 0;
    _this.getOptions = void 0;
    _this.rotateToVelocity = void 0;
    _this.blendFunc = void 0;
    _this.blendFuncSeparate = void 0;
    _this.useOriginColor = void 0;
    _this.fragmentShader = void 0;
    _this.vertexShader = void 0;
    _this.particleTex = void 0;
    _this.fadeIn = void 0;
    _this.fadeOut = void 0;
    _this.particleMaskTex = void 0;
    _this.isScaleByLifetime = void 0;
    _this.scaleFactor = void 0;
    _this.spriteSheet = void 0;
    _this.is2d = void 0;
    _this.interleaved = void 0;
    _this._time = 0; // 渲染时间，单位秒

    _this._isInit = false; // 是否完成初始化

    _this._isStart = false; // 是否开始粒子动画

    return _this;
  }
  /**
   * 粒子发射参数
   * @typedef {Object} ParticleParam
   * @property {Vector3} position 位置，默认[0, 0, 0]
   * @property {Vector3} velocity 速度，默认[0, 0, 0]
   * @property {Vector3} acceleration 加速度，默认[0, 0, 0]
   * @property {Vector3} color  颜色，默认[1, 1, 1]，范围 0 ~ 1
   * @property {number} size  大小，默认 10，范围  >0
   * @property {number} startAngle  初始旋转角度，默认0，范围 0 ~ 2*PI
   * @property {number} rotateRate  自转旋转角速率，默认0
   * @property {number} lifetime  生命周期，默认5，范围  >0
   * @property {number} alpha 透明度，默认1，范围 0 ~ 1
   * @property {Vector3} positionRandomness  位置随机因子，默认[0,0,0]，范围  >0
   * @property {Array} positionArray  固定位置数组
   * @property {Vector3} velocityRandomness  速度随机因子，默认[0, 0, 0]，范围  >0
   * @property {Vector3} accelerationRandomness  加速度随机因子，默认[0, 0, 0]，范围  >0
   * @property {number} colorRandomness  颜色随机因子，默认0，范围  0 ~ 1
   * @property {number} sizeRandomness  大小随机因子，默认0，范围  0 ~ 1
   * @property {number} alphaRandomness  透明度随机因子，默认0，范围 0 ~ 1
   * @property {number} startAngleRandomness  初始旋转角度随机因子，默认0，范围 0 ~ 1
   * @property {number} rotateRateRandomness  自转旋转角速率随机因子，默认0，范围   >0
   * @property {number} startTimeRandomness  每个粒子出现的时间点随机因子，单位秒   >0
   */

  /**
   * 初始化
   * @param {ParticleProps} props 初始化参数
   * @param {number} [ParticleProps.maxCount = 1000] 最大粒子数
   * @param {boolean} [ParticleProps.once = false] 是否只发射一帧, 默认
   * @param {ParticleParam} [ParticleProps.options] 发射参数
   * @param {Function} [ParticleProps.getOptions] 获取更新参数（每帧回调）
   * @param {boolean} [ParticleProps.rotateToVelocity] 是否跟随粒子运动速度的方向。
   * @param {Array} [ParticleProps.blendFunc] webgl 混合因子，默认透明度混合 [SRC_ALPHA, ONE_MINUS_SRC_ALPHA]
   * @param {Array} [ParticleProps.blendFuncSeparate] webgl 混合因子alpha通道分离，优先级高于blendFunc，如无指定使用blendFunc
   * @param {boolean} [ParticleProps.useOriginColor = true] 是否使用图片原色: true(使用图片原色)、 false(图片原色混合生成的颜色)
   * @param {string} [ParticleProps.fragmentShader] 自定义片元着色器
   * @param {string} [ParticleProps.vertexShader] 自定义定点着色器
   * @param {Texture} [ParticleProps.texture] 粒子贴图
   * @param {Texture} [ParticleProps.maskTexture] 粒子遮罩贴图
   * @param {boolean} [ParticleProps.isScaleByLifetime = false] 是否随生命周期缩小至消失
   * @param {boolean} [ParticleProps.fadeIn = false] 是否添加淡入效果
   * @param {boolean} [ParticleProps.fadeOut = false] 是否添加淡出效果
   * @param {number} [ParticleProps.scaleFactor = 1] 粒子随时间scale参数
   * @param {Array} [ParticleProps.spriteSheet] 雪碧图数据
   * @param {boolean} [ParticleProps.is2d] 是否是2D旋转
   */


  _createClass(GPUParticleSystem, [{
    key: "initialize",
    value: function initialize(props) {
      this.maxCount = props.maxCount !== undefined ? props.maxCount : 1000;
      this.once = props.once || false;
      this.options = props.options || {};
      this.getOptions = props.getOptions;
      this.rotateToVelocity = props.rotateToVelocity || false;

      if (props.blendFuncSeparate) {
        this.blendFuncSeparate = props.blendFuncSeparate;
      }

      this.blendFunc = props.blendFunc || [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA];
      this.useOriginColor = props.useOriginColor !== undefined ? props.useOriginColor : true;
      this.fragmentShader = props.fragmentShader || null;
      this.vertexShader = props.vertexShader || null;
      this.particleTex = props.texture || null;
      this.fadeIn = props.fadeIn || false;
      this.fadeOut = props.fadeOut === undefined ? true : props.fadeOut;
      this.particleMaskTex = props.maskTexture || null;
      this.isScaleByLifetime = props.isScaleByLifetime || false;
      this.scaleFactor = props.scaleFactor || 1;
      this.spriteSheet = props.spriteSheet || null;
      this.is2d = props.is2d === undefined ? true : props.is2d;
      this.interleaved = props.spriteSheet || true;
      this.setMaterial();
      /** @private */

      this.geometry = this._createGeometry();
      this._isInit = true;
      var options = this.getOptions ? this.getOptions(this._time) : this.options;

      for (var x = 0; x < this.maxCount; x++) {
        this._spawnParticle(options, x);
      }

      this._vertexBuffer.setData(this._vertices);

      return this;
    }
    /**
     * 更新参数
     * @param {number} deltaTime 帧间隔时间
     * @private
     */

  }, {
    key: "update",
    value: function update(deltaTime) {
      if (!this._isInit || !this._isStart) {
        return;
      }

      this._time += deltaTime / 1000;
      this.material.setValue("uTime", this._time);
    }
    /**
     * 设置粒子发射参数
     * @param {ParticleParam} options 发射参数
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      if (options !== undefined) {
        this.options = _objectSpread2(_objectSpread2({}, this.options), options);
      }

      return this;
    }
    /**
     * 激活发射模块，重新开始发射 */

  }, {
    key: "start",
    value: function start() {
      this._isStart = true;
      this._time = 0;
      this.material.setValue("uActive", 1.0);
    }
    /**
     * 停止发射
     */

  }, {
    key: "stop",
    value: function stop() {
      this.material.setValue("uActive", 0.0);
    }
    /**
     * 销毁资源
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf(GPUParticleSystem.prototype), "destroy", this).call(this);

      this.options = null;

      if (this.particleTex) {
        this.particleTex = null;
      }

      if (this.particleMaskTex) {
        this.particleMaskTex = null;
      }
    }
    /**
     * 创建材质
     * @private
     */

  }, {
    key: "setMaterial",
    value: function setMaterial() {
      var technique = this._createTechnique();

      var material = new Material(this.engine, "particleMaterial");
      material.technique = technique;
      material.renderType = exports.MaterialType.TRANSPARENT;
      material.setValue("uOnce", this.once ? 1.0 : 0.0);
      material.setValue("uTime", this._time);

      if (this.particleTex) {
        this.particleTex.wrapModeU = this.particleTex.wrapModeV = exports.TextureWrapMode.Clamp;
        material.setValue("particleTex", this.particleTex);
      }

      if (this.particleMaskTex) {
        this.particleMaskTex.wrapModeU = this.particleTex.wrapModeV = exports.TextureWrapMode.Clamp;
        material.setValue("particleMaskTex", this.particleMaskTex);
      }

      this.material = material;
    }
    /**
     * 创建 Technique
     * @private
     */

  }, {
    key: "_createTechnique",
    value: function _createTechnique() {
      var cfg = {
        attributes: {
          positionStart: {
            name: "positionStart",
            semantic: "POSITIONSTART",
            type: exports.DataType.FLOAT_VEC3
          },
          color: {
            name: "color",
            semantic: "COLOR",
            type: exports.DataType.FLOAT_VEC3
          },
          alpha: {
            name: "alpha",
            semantic: "ALPHA",
            type: exports.DataType.FLOAT
          },
          acceleration: {
            name: "acceleration",
            semantic: "ACCELERATION",
            type: exports.DataType.FLOAT_VEC3
          },
          velocity: {
            name: "velocity",
            semantic: "VELOCITY",
            type: exports.DataType.FLOAT_VEC3
          },
          startAngle: {
            name: "startAngle",
            semantic: "STARTANGLE",
            type: exports.DataType.FLOAT
          },
          lifeTime: {
            name: "lifeTime",
            semantic: "LIFETIME",
            type: exports.DataType.FLOAT
          },
          startTime: {
            name: "startTime",
            semantic: "STARTTIME",
            type: exports.DataType.FLOAT
          },
          size: {
            name: "size",
            semantic: "SIZE",
            type: exports.DataType.FLOAT
          },
          rotateRate: {
            name: "rotateRate",
            semantic: "ROTATERATE",
            type: exports.DataType.FLOAT
          },
          scaleFactor: {
            name: "scaleFactor",
            semantic: "SCALEFACTOR",
            type: exports.DataType.FLOAT
          },
          uv: {
            name: "uv",
            semantic: "UV",
            type: exports.DataType.FLOAT_VEC3
          },
          normalizedUv: {
            name: "normalizedUv",
            semantic: "NORMALIZED_UV",
            type: exports.DataType.FLOAT_VEC2
          }
        },
        uniforms: {
          uOnce: {
            name: "uOnce",
            type: exports.DataType.FLOAT
          },
          uActive: {
            name: "uActive",
            type: exports.DataType.FLOAT
          },
          uTime: {
            name: "uTime",
            type: exports.DataType.FLOAT
          },
          matModelViewProjection: {
            name: "matModelViewProjection",
            semantic: exports.UniformSemantic.MODELVIEWPROJECTION,
            type: exports.DataType.FLOAT_MAT4
          },
          matModelView: {
            name: "matModelView",
            semantic: exports.UniformSemantic.MODELVIEW,
            type: exports.DataType.FLOAT_MAT4
          }
        },
        states: {
          enable: [exports.RenderState.BLEND],
          functions: {
            // blendFunc: this.blendFunc,
            // todo question
            depthMask: [false]
          }
        }
      };

      if (this.is2d) {
        cfg.uniforms.matViewInverse = {
          name: "matViewInverse",
          semantic: exports.UniformSemantic.VIEWINVERSE,
          type: exports.DataType.FLOAT_MAT4
        };
        cfg.uniforms.matProjection = {
          name: "matProjection",
          semantic: exports.UniformSemantic.PROJECTION,
          type: exports.DataType.FLOAT_MAT4
        };
        cfg.uniforms.matView = {
          name: "matView",
          semantic: exports.UniformSemantic.VIEW,
          type: exports.DataType.FLOAT_MAT4
        };
        cfg.uniforms.matWorld = {
          name: "matWorld",
          semantic: exports.UniformSemantic.MODEL,
          type: exports.DataType.FLOAT_MAT4
        };
      } else {
        // @ts-ignore
        cfg.states.disable = [exports.RenderState.CULL_FACE];
      }

      if (this.blendFuncSeparate) {
        // @ts-ignore
        cfg.states.functions.blendFuncSeparate = this.blendFuncSeparate;
      } else {
        // @ts-ignore
        cfg.states.functions.blendFunc = this.blendFunc;
      }

      if (this.particleTex) {
        cfg.uniforms.particleTex = {
          name: "particleTex",
          type: exports.DataType.SAMPLER_2D
        };
      }

      if (this.particleMaskTex) {
        cfg.uniforms.particleMaskTex = {
          name: "particleMaskTex",
          type: exports.DataType.SAMPLER_2D
        };
      }

      var tech = new RenderTechnique("particleTech");
      tech.isValid = true;
      tech.uniforms = cfg.uniforms;
      tech.attributes = cfg.attributes;
      tech.states = cfg.states;
      tech.vertexShader = this._createVertexShader();
      tech.fragmentShader = this._createFragmentShader();
      return tech;
    }
    /**
     * 创建几何体
     * @private
     */

  }, {
    key: "_createGeometry",
    value: function _createGeometry() {
      var geometry = new BufferGeometry(this._entity.engine, "particleGeometry");
      var vertexStride = 96;
      var vertexFloatCount = this.maxCount * 4 * vertexStride;
      var vertices = new Float32Array(vertexFloatCount);
      var indices = new Uint16Array(6 * this.maxCount);

      for (var i = 0, idx = 0; i < this.maxCount; ++i) {
        var startIndex = i * 4;
        indices[idx++] = startIndex + 0;
        indices[idx++] = startIndex + 1;
        indices[idx++] = startIndex + 2;
        indices[idx++] = startIndex + 0;
        indices[idx++] = startIndex + 2;
        indices[idx++] = startIndex + 3;
      }

      var vertexElements = [new VertexElement("POSITIONSTART", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("VELOCITY", 12, exports.VertexElementFormat.Vector3, 0), new VertexElement("ACCELERATION", 24, exports.VertexElementFormat.Vector3, 0), new VertexElement("COLOR", 36, exports.VertexElementFormat.Vector3, 0), new VertexElement("ALPHA", 48, exports.VertexElementFormat.Float, 0), new VertexElement("SIZE", 52, exports.VertexElementFormat.Float, 0), new VertexElement("ROTATERATE", 56, exports.VertexElementFormat.Float, 0), new VertexElement("STARTTIME", 60, exports.VertexElementFormat.Float, 0), new VertexElement("LIFETIME", 64, exports.VertexElementFormat.Float, 0), new VertexElement("STARTANGLE", 68, exports.VertexElementFormat.Float, 0), new VertexElement("SCALEFACTOR", 72, exports.VertexElementFormat.Float, 0), new VertexElement("UV", 76, exports.VertexElementFormat.Vector3, 0), new VertexElement("NORMALIZED_UV", 88, exports.VertexElementFormat.Vector2, 0)];
      var vertexBuffer = new Buffer(this.engine, exports.BufferBindFlag.VertexBuffer, vertexFloatCount * 4, exports.BufferUsage.Dynamic);
      var indexBuffer = new Buffer(this.engine, exports.BufferBindFlag.IndexBuffer, indices, exports.BufferUsage.Dynamic);
      geometry.setVertexBufferBinding(vertexBuffer, vertexStride);
      geometry.setIndexBufferBinding(indexBuffer, exports.IndexFormat.UInt16);
      geometry.setVertexElements(vertexElements);
      geometry.addSubGeometry(0, indices.length);
      this._vertexBuffer = vertexBuffer;
      this._vertexStride = vertexStride;
      this._vertices = vertices;
      return geometry;
    }
    /**
     * 粒子发射
     * @param {Options} options
     * @private
     */

  }, {
    key: "_spawnParticle",
    value: function _spawnParticle(options, i) {
      var position = options.position !== undefined ? options.position.clone() : new miniprogram.Vector3();
      var positionRandomness = options.positionRandomness !== undefined ? options.positionRandomness.clone() : new miniprogram.Vector3();
      var positionArray = options.positionArray;
      var velocity = options.velocity !== undefined ? options.velocity.clone() : new miniprogram.Vector3();
      var velocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness.clone() : new miniprogram.Vector3();
      var color = options.color !== undefined ? options.color.clone() : new miniprogram.Vector3(1, 1, 1);
      var colorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1;
      var alpha = options.alpha !== undefined ? options.alpha : 1;
      var alphaRandomness = options.alphaRandomness !== undefined ? options.alphaRandomness : 0;
      var lifetime = options.lifetime !== undefined ? options.lifetime : 5;
      var size = options.size !== undefined ? options.size : 1;
      var sizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0;
      var smoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;
      var startTimeRandomness = options.startTimeRandomness !== undefined ? options.startTimeRandomness : 0;
      var acceleration = options.acceleration !== undefined ? options.acceleration.clone() : new miniprogram.Vector3();
      var accelerationRandomness = options.accelerationRandomness !== undefined ? options.accelerationRandomness.clone() : new miniprogram.Vector3();
      var startAngle = options.startAngle !== undefined ? options.startAngle : 0;
      var startAngleRandomness = options.startAngleRandomness !== undefined ? options.startAngleRandomness : 0;
      var rotateRate = options.rotateRate !== undefined ? options.rotateRate : 0;
      var rotateRateRandomness = options.rotateRateRandomness !== undefined ? options.rotateRateRandomness : 0;
      var scaleFactor = options.scaleFactor !== undefined ? options.scaleFactor : 1;
      var x = position.x;
      var y = position.y;
      var z = position.z;

      if (positionArray) {
        if (positionArray.length !== this.maxCount) {
          throw Error("The length of positionArray must be equal to maxCount.");
        }

        x += positionArray[i].x;
        y += positionArray[i].y;
        z += positionArray[i].z;
      } else {
        x += this._getRandom() * positionRandomness.x;
        y += this._getRandom() * positionRandomness.y;
        z += this._getRandom() * positionRandomness.z;
      }

      if (smoothPosition === true) {
        x += -(velocity.x * this._getRandom());
        y += -(velocity.y * this._getRandom());
        z += -(velocity.z * this._getRandom());
      }

      var velX = velocity.x + this._getRandom() * velocityRandomness.x;
      var velY = velocity.y + this._getRandom() * velocityRandomness.y;
      var velZ = velocity.z + this._getRandom() * velocityRandomness.z;
      var accX = acceleration.x + this._getRandom() * accelerationRandomness.x;
      var accY = acceleration.y + this._getRandom() * accelerationRandomness.y;
      var accZ = acceleration.z + this._getRandom() * accelerationRandomness.z;
      color.x = miniprogram.MathUtil.clamp(color.x + this._getRandom() * colorRandomness, 0, 1);
      color.y = miniprogram.MathUtil.clamp(color.y + this._getRandom() * colorRandomness, 0, 1);
      color.z = miniprogram.MathUtil.clamp(color.z + this._getRandom() * colorRandomness, 0, 1);
      size = Math.max(size + this._getRandom() * sizeRandomness * size * 2, 0);
      var lifeTime = lifetime + this._getRandom() * lifetime;
      var sa = startAngle + this._getRandom() * Math.PI * startAngleRandomness * 2;
      var rr = rotateRate + this._getRandom() * rotateRateRandomness;
      var particleAlpha = miniprogram.MathUtil.clamp(alpha + this._getRandom() * alphaRandomness, 0, 1);
      var startTime = Math.random() * startTimeRandomness;
      var vertices = this._vertices;

      for (var j = 0; j < 4; j++) {
        var k = (i * 4 + j) * this._vertexStride / 4; // POSITIONSTART

        vertices[k] = x;
        vertices[k + 1] = y;
        vertices[k + 2] = z; // VELOCITY

        vertices[k + 3] = velX;
        vertices[k + 4] = velY;
        vertices[k + 5] = velZ; // ACCELERATION

        vertices[k + 6] = accX;
        vertices[k + 7] = accY;
        vertices[k + 8] = accZ; //COLOR

        vertices[k + 9] = color[0];
        vertices[k + 10] = color[1];
        vertices[k + 11] = color[2]; //ALPHA

        vertices[k + 12] = particleAlpha; //SIZE

        vertices[k + 13] = size; //ROTATERATE

        vertices[k + 14] = rr; //STARTTIME

        vertices[k + 15] = startTime; //LIFETIME

        vertices[k + 16] = lifeTime; //STARTANGLE

        vertices[k + 17] = sa; //SCALEFACTOR

        vertices[k + 18] = scaleFactor;

        this._setUvs(i, j, k);
      }
    }
    /**
     * 设置每个粒子的uv
     * @param i {number} 第i个粒子
     * @param j {number} 单个粒子四个顶点中的第j个
     * @param k {number} 所有粒子顶点中的第k个
     */

  }, {
    key: "_setUvs",
    value: function _setUvs(i, j, k) {
      var spriteSheet = this.spriteSheet;
      var particleTex = this.particleTex;
      var rects;
      var normalizedRects = [[-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]];

      if (particleTex) {
        var width = particleTex.image ? particleTex.image.width : particleTex.width;
        var height = particleTex.image ? particleTex.image.height : particleTex.height;

        if (spriteSheet) {
          var _spriteSheet = spriteSheet[i % spriteSheet.length],
              x = _spriteSheet.x,
              y = _spriteSheet.y,
              w = _spriteSheet.w,
              h = _spriteSheet.h;
          var u = x / width;
          var v = y / height;
          var p = u + w / width;
          var q = v + h / height;
          rects = [[u, q, h / w], // left bottom
          [p, q, h / w], // right bottom
          [p, v, h / w], // right top
          [u, v, h / w] // left top
          ];
        } else {
          rects = [[0, 0, height / width], [1, 0, height / width], [1, 1, height / width], [0, 1, height / width]];
        }
      } else {
        rects = [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
      }

      var vertices = this._vertices; //UV

      var uv = rects[j];
      vertices[k + 19] = uv[0];
      vertices[k + 20] = uv[1];
      vertices[k + 21] = uv[2]; //NORMALIZED_U

      var nuv = normalizedRects[j];
      vertices[k + 22] = nuv[0];
      vertices[k + 23] = nuv[1];
    }
    /**
     * 获取随机数
     * @returns {number}
     * @private
     */

  }, {
    key: "_getRandom",
    value: function _getRandom() {
      return Math.random() - 0.5;
    }
    /**
     * 获取着色器代码
     * @returns {string}
     * @private
     */

  }, {
    key: "_getShader",
    value: function _getShader() {
      return {
        vertexShader: "\n        precision highp float;\n        precision highp int;\n\n        attribute float lifeTime;\n        attribute float startTime;\n        attribute float size;\n        attribute float rotateRate;\n        attribute vec3 velocity;\n        attribute vec3 acceleration;\n        attribute vec3 positionStart;\n        attribute vec3 color;\n        attribute float alpha;\n        attribute float startAngle;\n        attribute float scaleFactor;\n        attribute vec3 uv;\n        attribute vec2 normalizedUv;\n        \n        uniform float uTime;\n        uniform float uOnce;\n        uniform float uActive;\n        uniform mat4 matModelViewProjection;\n        uniform mat4 matModelView;\n        uniform mat4 matViewInverse;\n        uniform mat4 matView;\n        uniform mat4 matProjection;\n        uniform mat4 matWorld;\n\n        varying vec3 v_color;\n        varying float v_alpha;\n        varying float lifeLeft;\n        varying mat2 vTextureMat;\n        varying vec2 v_uv;\n\n        mat2 rotation2d(float angle) {\n          float s = sin(angle);\n          float c = cos(angle);\n        \n          return mat2(\n            c, -s,\n            s, c\n          );\n        }\n\n        void main()\n        {\n          v_color = color;\n          v_uv = uv.xy;\n          v_alpha = alpha;\n          \n          // float deltaTime = max(mod(uTime, lifeTime), 0.0);\n          // \u771F\u5B9E\u7684\u751F\u547D\u5468\u671F\n          float life = lifeTime + startTime;\n          // \u5F53\u524D\u5DF2\u8FC7\u53BB\u7684\u65F6\u95F4\n          float deltaTime = max(mod(uTime, life) - startTime, 0.0);\n\n          bool isDying = false;\n\n          if (uOnce == 1.0 || uActive == 0.0) {\n            isDying = true;\n          }\n\n          if ((isDying && uTime > life)) {\n            deltaTime = life;\n          }\n\n          // \u6CA1\u51FA\u751F\u5C31\u4EE3\u8868\u6B7B\u4EA1\uFF0C\u5426\u5219\u6CA1\u51FA\u751F\u5C31\u663E\u793A\u4E86\n          if (deltaTime == 0.0) {\n            deltaTime = life;\n          }\n\n          lifeLeft = 1.0 - deltaTime / lifeTime;\n          float scale = size;\n          vec3 position = positionStart + (velocity + acceleration * deltaTime * 0.5) * deltaTime;\n      ",
        postionShader: "\n        gl_Position = matModelViewProjection * vec4(position, 1.0 );\n      ",
        sizeVertexShader: "\n          scale *= pow(scaleFactor, deltaTime);\n      ",
        isScaleByLifetimeVertexShader: "\n          scale *= lifeLeft;\n      ",
        rotateToVelocityVertexShader: "\n        vec3 v = velocity + acceleration * deltaTime;\n        float angle = atan(v.z, v.x) * 2.0;\n        float s = sin(angle);\n        float c = cos(angle);\n      ",
        rotationVertexShader: "\n        float deltaAngle = deltaTime * rotateRate;\n        float angle = startAngle + deltaAngle;\n        float s = sin(angle);\n        float c = cos(angle);\n\n      ",
        rotation2dShader: "\n        vec2 rotatedPoint = rotation2d(angle) * vec2(normalizedUv.x, normalizedUv.y * uv.z);\n\n        vec3 basisX = matViewInverse[0].xyz;\n        vec3 basisZ = matViewInverse[1].xyz;\n\n        vec3 localPosition = vec3(basisX * rotatedPoint.x + \n                    basisZ * rotatedPoint.y) * scale + position;\n\n        gl_Position = matProjection * matView * vec4(localPosition + matWorld[3].xyz, 1.);\n      ",
        rotation3dShader: "\n        vec4 rotatedPoint = vec4((normalizedUv.x * c + normalizedUv.y * uv.z * s) * scale , 0., \n                                 (normalizedUv.x * s - normalizedUv.y * uv.z * c) * scale, 1.);\n      \n        vec4 orientation = vec4(0, 0, 0, 1);\n        vec4 q2 = orientation + orientation;\n        vec4 qx = orientation.xxxw * q2.xyzx;\n        vec4 qy = orientation.xyyw * q2.xyzy;\n        vec4 qz = orientation.xxzw * q2.xxzz;\n      \n        mat4 localMatrix = mat4(\n            (1.0 - qy.y) - qz.z, \n            qx.y + qz.w, \n            qx.z - qy.w,\n            0,\n      \n            qx.y - qz.w, \n            (1.0 - qx.x) - qz.z, \n            qy.z + qx.w,\n            0,\n      \n            qx.z + qy.w, \n            qy.z - qx.w, \n            (1.0 - qx.x) - qy.y,\n            0,\n      \n            position.x, position.y, position.z, 1);\n\n        rotatedPoint = localMatrix * rotatedPoint;\n\n        gl_Position = matModelViewProjection * rotatedPoint;\n      ",
        fragmentShader: "\n        precision mediump float;\n        precision mediump int;\n\n        varying vec3 v_color;\n        varying float v_alpha;\n        varying float lifeLeft;\n        varying vec2 v_uv;\n        uniform sampler2D particleTex;\n        uniform sampler2D particleMaskTex;\n\n        void main()\n        {\n          float alphaFactor = 1.0;\n      ",
        fadeInFragmentShader: "\n        float fadeInFactor = step(0.5, lifeLeft);\n        alphaFactor = 2.0 * fadeInFactor * (1.0 - lifeLeft) + (1.0 - fadeInFactor);\n      ",
        fadeOutFragmentShader: "\n        float fadeOutFactor = step(0.5, lifeLeft);\n        alphaFactor = alphaFactor * 2.0 * (1.0 - fadeOutFactor) * lifeLeft + alphaFactor * fadeOutFactor;\n      ",
        noImgFragmentShader: " \n        gl_FragColor = vec4( v_color, alphaFactor * v_alpha);\n      ",
        imgFragmentShader: "\n        vec4 tex = texture2D(particleTex, v_uv);\n      ",
        originColorFragmentShader: "\n        gl_FragColor = vec4(tex.rgb, alphaFactor * tex.a * v_alpha);\n      ",
        createColorFragmentShader: "\n        gl_FragColor = vec4(v_color * tex.rgb, alphaFactor * tex.a * v_alpha);\n      ",
        createColorWithMaskFragmentShader: "\n        vec4 maskTex = texture2D( particleMaskTex, v_uv);\n        gl_FragColor = vec4(v_color * tex.rgb + maskTex.a, alphaFactor * tex.a * v_alpha);\n      "
      };
    }
    /**
     * 创建顶点着色器
     * @returns {string}
     * @private
     */

  }, {
    key: "_createVertexShader",
    value: function _createVertexShader() {
      var shader = this._getShader();

      var vertexShader = "";

      if (this.vertexShader) {
        vertexShader = this.vertexShader;
      } else {
        vertexShader = shader.vertexShader;

        if (this.isScaleByLifetime) {
          vertexShader += shader.isScaleByLifetimeVertexShader;
        } else {
          vertexShader += shader.sizeVertexShader;
        }

        if (this.rotateToVelocity) {
          vertexShader += shader.rotateToVelocityVertexShader;
        } else {
          vertexShader += shader.rotationVertexShader;
        } // 2D 和 3D 的旋转算法不同


        if (this.is2d) {
          vertexShader += shader.rotation2dShader;
        } else {
          vertexShader += shader.rotation3dShader;
        }

        vertexShader += "}";
      }

      return vertexShader;
    }
    /**
     * 创建片元着色器
     * @returns {string}
     * @private
     */

  }, {
    key: "_createFragmentShader",
    value: function _createFragmentShader() {
      var shader = this._getShader();

      var fragmentShader = "";

      if (this.fragmentShader) {
        fragmentShader = this.fragmentShader;
      } else {
        fragmentShader = shader.fragmentShader;

        if (this.fadeIn) {
          fragmentShader += shader.fadeInFragmentShader;
        }

        if (this.fadeOut) {
          fragmentShader += shader.fadeOutFragmentShader;
        }

        if (!this.particleTex) {
          fragmentShader += shader.noImgFragmentShader;
        } else {
          fragmentShader += shader.imgFragmentShader;

          if (this.useOriginColor) {
            fragmentShader += shader.originColorFragmentShader;
          } else {
            if (this.particleMaskTex) {
              fragmentShader += shader.createColorWithMaskFragmentShader;
            } else {
              fragmentShader += shader.createColorFragmentShader;
            }
          }
        }

        fragmentShader += "}";
      }

      return fragmentShader;
    }
  }]);

  return GPUParticleSystem;
}(GeometryRenderer);

/**
 * 暂时只为编辑器使用
 */

var Particle = /*#__PURE__*/function (_GPUParticleSystem) {
  _inherits(Particle, _GPUParticleSystem);

  var _super = _createSuper(Particle);

  function Particle(entity) {
    var _this;

    _classCallCheck(this, Particle);

    _this = _super.call(this, entity);
    _this._config = void 0;
    _this._options = void 0;
    return _this;
  }

  _createClass(Particle, [{
    key: "init",
    value: function init(props) {
      this._options = {
        position: props.__position,
        positionRandomness: props.__positionRandomness,
        velocity: props.__velocity,
        velocityRandomness: props.__velocityRandomness,
        acceleration: props.__acceleration,
        accelerationRandomness: props.__accelerationRandomness,
        color: props.__color,
        colorRandomness: props.__colorRandomness,
        lifetime: props.__lifetime,
        size: props.__size,
        sizeRandomness: props.__sizeRandomness,
        startAngle: props.__startAngle,
        startAngleRandomness: props.__startAngleRandomness,
        rotateRate: props.__rotateRate,
        rotateRateRandomness: props.__rotateRateRandomness,
        scaleFactor: props.__scaleFactor,
        alpha: props.__alpha,
        alphaRandomness: props.__alphaRandomness,
        startTimeRandomness: props.__startTimeRandomness
      }; // 粒子发射器环境参数

      this._config = {
        maxCount: props.__maxCount,
        once: props.__once,
        rotateToVelocity: props.__rotateToVelocity,
        isScaleByLifetime: props.__isScaleByLifetime,
        fadeIn: props.__fadeIn,
        fadeOut: props.__fadeOut,
        texture: props.__texture ? props.__texture : null,
        maskTexture: props.__maskTexture ? props.__maskTexture : null,
        // blendFunc: [props.__blendFunc01, props.__blendFunc02],
        useOriginColor: props.__useOriginColor,
        is2d: props.__is2d,
        options: this._options
      };

      if (props.__spriteSheet) {
        if (_typeof(props.__spriteSheet) === "object" && props.__spriteSheet.length) {
          this._config.spriteSheet = props.__spriteSheet;
        } else if (typeof props.__spriteSheet === "string") {
          try {
            var spriteSheet = JSON.parse(props.__spriteSheet);

            if (spriteSheet.length) {
              this._config.spriteSheet = spriteSheet;
            }
          } catch (e) {}
        }
      }

      if (props.__positionArray) {
        if (_typeof(props.__positionArray) === "object" && props.__positionArray.length) {
          this._options.positionArray = props.__positionArray;
        } else if (typeof props.__positionArray === "string") {
          try {
            var positionArray = JSON.parse(props.__positionArray);

            if (positionArray.length) {
              this._options.positionArray = positionArray;
            }
          } catch (e) {}
        }
      }

      if (props.__separate) {
        this._config.blendFuncSeparate = [exports.BlendFunc[props.__srcRGB || "SRC_ALPHA"], exports.BlendFunc[props.__dstRGB || "ONE_MINUS_SRC_ALPHA"], exports.BlendFunc[props.__srcAlpha || "SRC_ALPHA"], exports.BlendFunc[props.__dstAlpha || "ONE_MINUS_SRC_ALPHA"]];
      } else if (props.__src && props.__dst) {
        this._config.blendFunc = [exports.BlendFunc[props.__src], exports.BlendFunc[props.__dst]];
      }

      this.initialize(this._config);

      if (props.__defaultStart === true || props.__defaultStart === undefined) {
        this.start();
      }
    }
  }, {
    key: "updateOption",
    value: function updateOption(key, value) {
      this._options = _objectSpread2(_objectSpread2({}, this._options), {}, _defineProperty({}, key, value));
      this._config = _objectSpread2(_objectSpread2({}, this._config), {}, {
        options: _objectSpread2({}, this._options)
      });
      this.initialize(this._config);
      this.start();
    }
  }, {
    key: "updateConfig",
    value: function updateConfig(key, value) {
      this._config = _objectSpread2(_objectSpread2({}, this._config), {}, _defineProperty({}, key, value));
      this.initialize(this._config);
      this.start();
    }
  }, {
    key: "__position",
    set: function set(value) {
      this.updateOption("position", value);
    }
  }, {
    key: "__positionRandomness",
    set: function set(value) {
      this.updateOption("positionRandomness", value);
    }
  }, {
    key: "__velocity",
    set: function set(value) {
      this.updateOption("velocity", value);
    }
  }, {
    key: "__velocityRandomness",
    set: function set(value) {
      this.updateOption("velocityRandomness", value);
    }
  }, {
    key: "__acceleration",
    set: function set(value) {
      this.updateOption("acceleration", value);
    }
  }, {
    key: "__accelerationRandomness",
    set: function set(value) {
      this.updateOption("accelerationRandomness", value);
    }
  }, {
    key: "__color",
    set: function set(value) {
      this.updateOption("color", value);
    }
  }, {
    key: "__colorRandomness",
    set: function set(value) {
      this.updateOption("colorRandomness", value);
    }
  }, {
    key: "__lifetime",
    set: function set(value) {
      this.updateOption("lifetime", value);
    }
  }, {
    key: "__size",
    set: function set(value) {
      this.updateOption("size", value);
    }
  }, {
    key: "__sizeRandomness",
    set: function set(value) {
      this.updateOption("sizeRandomness", value);
    }
  }, {
    key: "__startAngle",
    set: function set(value) {
      this.updateOption("startAngle", value);
    }
  }, {
    key: "__startAngleRandomness",
    set: function set(value) {
      this.updateOption("startAngleRandomness", value);
    }
  }, {
    key: "__rotateRate",
    set: function set(value) {
      this.updateOption("rotateRate", value);
    }
  }, {
    key: "__rotateRateRandomness",
    set: function set(value) {
      this.updateOption("rotateRateRandomness", value);
    }
  }, {
    key: "__scaleFactor",
    set: function set(value) {
      this.updateOption("scaleFactor", value);
    }
  }, {
    key: "__alpha",
    set: function set(value) {
      this.updateOption("alpha", value);
    }
  }, {
    key: "__alphaRandomness",
    set: function set(value) {
      this.updateOption("alphaRandomness", value);
    }
  }, {
    key: "__startTimeRandomness",
    set: function set(value) {
      this.updateOption("startTimeRandomness", value);
    }
  }, {
    key: "__positionArray",
    set: function set(value) {
      if (_typeof(value) === "object" && value.length) {
        this.updateOption("positionArray", value);
      } else if (typeof value === "string") {
        try {
          var positionArray = JSON.parse(value);

          if (positionArray.length) {
            this.updateOption("positionArray", positionArray);
          } else {
            this.updateOption("positionArray", null);
          }
        } catch (e) {
          this.updateOption("positionArray", null);
        }
      } else {
        this.updateOption("positionArray", null);
      }
    }
  }, {
    key: "__maxCount",
    set: function set(value) {
      this.updateConfig("maxCount", value);
    }
  }, {
    key: "__useOriginColor",
    set: function set(value) {
      this.updateConfig("useOriginColor", value);
    }
  }, {
    key: "__once",
    set: function set(value) {
      this.updateConfig("once", value);
    }
  }, {
    key: "__rotateToVelocity",
    set: function set(value) {
      this.updateConfig("rotateToVelocity", value);
    }
  }, {
    key: "__isScaleByLifetime",
    set: function set(value) {
      this.updateConfig("isScaleByLifetime", value);
    }
  }, {
    key: "__fadeIn",
    set: function set(value) {
      this.updateConfig("fadeIn", value);
    }
  }, {
    key: "__fadeOut",
    set: function set(value) {
      this.updateConfig("fadeOut", value);
    }
  }, {
    key: "__texture",
    set: function set(value) {
      this.updateConfig("texture", value);
    }
  }, {
    key: "__maskTexture",
    set: function set(value) {
      this.updateConfig("maskTexture", value);
    }
  }, {
    key: "__spriteSheet",
    set: function set(value) {
      if (_typeof(value) === "object" && value.length) {
        this.updateConfig("spriteSheet", value);
      } else if (typeof value === "string") {
        try {
          var spriteSheet = JSON.parse(value);

          if (spriteSheet.length) {
            this.updateConfig("spriteSheet", spriteSheet);
          } else {
            this.updateConfig("spriteSheet", null);
          }
        } catch (e) {
          this.updateConfig("spriteSheet", null);
        }
      } else {
        this.updateConfig("spriteSheet", null);
      }
    }
  }, {
    key: "__is2d",
    set: function set(value) {
      this.updateConfig("is2d", value);
    } // set __blendFunc01(value) {
    //   this._config.blendFunc[0] = value;
    //   this.updateConfig('blendFunc', this._config.blendFunc);
    // }
    // set __blendFunc02(value) {
    //   this._config.blendFunc[1] = value;
    //   this.updateConfig('blendFunc', this._config.blendFunc);
    // }

  }]);

  return Particle;
}(GPUParticleSystem);

var FRAG_SHADER$1 = "varying vec2 v_uv;\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n\n  gl_FragColor = texture2D(u_texture, v_uv);\n\n}\n";

var VERT_SHADER = "attribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nuniform mat4 u_projMat;\nuniform mat4 u_viewMat;\n\nvoid main() {\n\n  gl_Position = u_projMat * u_viewMat * vec4( a_position, 1.0 );\n  v_uv = a_uv;\n\n}\n";

var TrailMaterial = /*#__PURE__*/function (_Material) {
  _inherits(TrailMaterial, _Material);

  var _super = _createSuper(TrailMaterial);

  function TrailMaterial() {
    _classCallCheck(this, TrailMaterial);

    return _super.apply(this, arguments);
  }

  _createClass(TrailMaterial, [{
    key: "_generateTechnique",

    /**
     * 生成内部所使用的 Technique 对象
     * @private
     */
    value: function _generateTechnique() {
      //--
      var tech = new RenderTechnique("trail_tech");
      tech.isValid = true;
      tech.uniforms = {
        u_texture: {
          name: "u_texture",
          type: exports.DataType.SAMPLER_2D
        }
      };
      tech.attributes = {};
      tech.states = {
        enable: [exports.RenderState.BLEND],
        functions: {
          blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE],
          depthMask: [false]
        }
      };
      tech.customMacros = [];
      tech.vertexShader = VERT_SHADER;
      tech.fragmentShader = FRAG_SHADER$1;
      this._technique = tech;
      this.renderType = exports.MaterialType.TRANSPARENT;
    }
    /**
     * 重写基类方法
     * @private
     */

  }, {
    key: "prepareDrawing",
    value: function prepareDrawing(context, component, primitive) {
      if (this._technique === null) {
        this._generateTechnique();
      }

      _get(_getPrototypeOf(TrailMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
    }
  }]);

  return TrailMaterial;
}(Material);

var _tempVector3 = new miniprogram.Vector3();
/**
 * 拖尾效果渲染组件
 */


var TrailRenderer = /*#__PURE__*/function (_GeometryRenderer) {
  _inherits(TrailRenderer, _GeometryRenderer);

  var _super = _createSuper(TrailRenderer);

  /**
   * 纹理对象基类
   * @param {Entity} entity 所属的Node对象
   * @param {Object} props 可选配置，包含以下参数
   * @param {float} [props.stroke=0.2] 拖尾的宽度
   * @param {float} [props.minSeg=0.02] 拖尾形状由物体运动轨迹上的点构成，描述相邻点之间最小间隔距离
   * @param {Number} [props.lifetime=1000] 物体运动时，拖尾效果持续的时长
   * @param {Material} [props.material=TrailMaterial] 拖尾使用的材质，默认使用内置的TrailMaterial
   */
  function TrailRenderer(entity, props) {
    var _this;

    _classCallCheck(this, TrailRenderer);

    _this = _super.call(this, entity);
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._stroke = void 0;
    _this._minSeg = void 0;
    _this._lifetime = void 0;
    _this._maxPointNum = void 0;
    _this._points = void 0;
    _this._pointStates = void 0;
    _this._strapPoints = void 0;
    _this._curPointNum = void 0;
    _this._prePointsNum = void 0;
    _this._stroke = props.stroke || 0.2;
    _this._minSeg = props.minSeg || 0.02;
    _this._lifetime = props.lifetime || 1000;
    _this._maxPointNum = _this._lifetime / 1000.0 * entity.engine.targetFrameRate;
    _this._points = [];
    _this._pointStates = [];
    _this._strapPoints = [];

    for (var i = 0; i < _this._maxPointNum; i++) {
      _this._points.push(new miniprogram.Vector3());

      _this._pointStates.push(_this._lifetime);

      _this._strapPoints.push(new miniprogram.Vector3());

      _this._strapPoints.push(new miniprogram.Vector3());
    }

    _this._curPointNum = 0;
    var mtl = props.material || new TrailMaterial(_this.engine, "trial_mtl");
    _this.material = mtl;

    _this.setTexture(props.texture);

    _this._initGeometry();

    return _this;
  }
  /**
   * 每帧的更新函数
   * @private
   */


  _createClass(TrailRenderer, [{
    key: "update",
    value: function update(deltaTime) {
      var mov = 0,
          newIdx = 0;

      for (var i = 0; i < this._curPointNum; i++) {
        this._pointStates[i] -= deltaTime;

        if (this._pointStates[i] < 0) {
          mov++;
        } else if (mov > 0) {
          newIdx = i - mov; // Move data

          this._pointStates[newIdx] = this._pointStates[i]; // Move point

          this._points[i].cloneTo(this._points[newIdx]);
        }
      }

      this._curPointNum -= mov;
      var appendNewPoint = true;

      if (this._curPointNum === this._maxPointNum) {
        appendNewPoint = false;
      } else if (this._curPointNum > 0) {
        var lastPoint = this._points[this._points.length - 1];

        if (miniprogram.Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {
          appendNewPoint = false;
        }
      }

      if (appendNewPoint) {
        this._pointStates[this._curPointNum] = this._lifetime;
        this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);
        this._curPointNum++;
      }
    }
    /**
     * 更新位置，将数据对象加入渲染队列
     * @param {Camera} camera
     * @private
     */

  }, {
    key: "render",
    value: function render(camera) {
      this._updateStrapVertices(camera, this._points);

      this._updateStrapCoords();

      this._vertexBuffer.setData(this._vertices);

      _get(_getPrototypeOf(TrailRenderer.prototype), "render", this).call(this, camera);
    }
    /**
     * 设置当前拖尾的纹理
     * @param {Texture2D} texture
     */

  }, {
    key: "setTexture",
    value: function setTexture(texture) {
      if (texture) {
        this.material.setValue("u_texture", texture);
      }
    } // ----------  private  -------------------

    /**
     * 初始化 geometry
     * @private
     */

  }, {
    key: "_initGeometry",
    value: function _initGeometry() {
      var geometry = new BufferGeometry(this._entity.engine);
      var vertexStride = 20;
      var vertexCount = this._maxPointNum * 2;
      var vertexFloatCount = vertexCount * vertexStride;
      var vertices = new Float32Array(vertexFloatCount);
      var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, exports.VertexElementFormat.Vector2, 0)];
      var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, exports.BufferUsage.Dynamic);
      geometry.setVertexBufferBinding(vertexBuffer, vertexStride);
      geometry.setVertexElements(vertexElements);
      geometry.addSubGeometry(0, vertexCount, exports.PrimitiveTopology.TriangleStrip);
      this._vertexBuffer = vertexBuffer;
      this._vertexStride = vertexStride;
      this._vertices = vertices;
      this.geometry = geometry;
    }
    /**
     * 更新拖尾顶点位置
     * @private
     */

  }, {
    key: "_updateStrapVertices",
    value: function _updateStrapVertices(camera, points) {
      var m = camera.viewMatrix;
      var e = m.elements;
      var vx = new miniprogram.Vector3(e[0], e[4], e[8]);
      var vy = new miniprogram.Vector3(e[1], e[5], e[9]);
      var vz = new miniprogram.Vector3(e[2], e[6], e[10]);
      var s = this._stroke;
      vy.scale(s);
      var up = new miniprogram.Vector3();
      var down = new miniprogram.Vector3();
      var rotation = new miniprogram.Quaternion();
      miniprogram.Vector3.transformByQuat(vx, rotation, vx);
      miniprogram.Vector3.transformByQuat(vy, rotation, vy);
      var dy = new miniprogram.Vector3();
      var cross = new miniprogram.Vector3();
      var perpVector = new miniprogram.Vector3();
      vx.normalize();
      var vertieces = this._vertices; //-- quad pos

      for (var i = 0; i < this._maxPointNum; i++) {
        //-- center pos
        if (i < this._curPointNum) {
          var p = points[i];

          if (i === this._curPointNum - 1 && i !== 0) {
            miniprogram.Vector3.subtract(p, points[i - 1], perpVector);
          } else {
            miniprogram.Vector3.subtract(points[i + 1], p, perpVector);
          }

          this._projectOnPlane(perpVector, vz, perpVector);

          perpVector.normalize(); // Calculate angle between vectors

          var angle = Math.acos(miniprogram.Vector3.dot(vx, perpVector));
          miniprogram.Vector3.cross(vx, perpVector, cross);

          if (miniprogram.Vector3.dot(cross, vz) <= 0) {
            angle = Math.PI * 2 - angle;
          }

          miniprogram.Quaternion.rotationAxisAngle(vz, angle, rotation);
          miniprogram.Vector3.transformByQuat(vy, rotation, dy);
          miniprogram.Vector3.add(p, dy, up);
          miniprogram.Vector3.subtract(p, dy, down);
        }

        var p0 = i * 2 * this._vertexStride / 4;
        var p1 = (i * 2 + 1) * this._vertexStride / 4;
        vertieces[p0] = up.x;
        vertieces[p0 + 1] = up.y;
        vertieces[p0 + 2] = up.z;
        vertieces[p1] = down.x;
        vertieces[p1 + 1] = down.y;
        vertieces[p1 + 2] = down.z;
      }
    }
    /**
     * 更新拖尾 uv 位置
     * @private
     */

  }, {
    key: "_updateStrapCoords",
    value: function _updateStrapCoords() {
      if (this._prePointsNum === this._curPointNum) {
        return;
      }

      this._prePointsNum = this._curPointNum;
      var count = this._curPointNum;
      var texDelta = 1.0 / count;
      var vertieces = this._vertices;

      for (var i = 0; i < count; i++) {
        var d = 1.0 - i * texDelta;
        var p0 = i * 2 * this._vertexStride / 4;
        var p1 = (i * 2 + 1) * this._vertexStride / 4;
        vertieces[p0] = 0;
        vertieces[p0 + 1] = d;
        vertieces[p1] = 1.0;
        vertieces[p1 + 1] = d;
      }
    }
    /**
     * 将向量 a 投影到向 p 上。
     * @param a - 要投影的向量
     * @param p - 目标向量
     * @param out - 向量 a 投影到向量 p 的结果向量
     */

  }, {
    key: "_projectOnVector",
    value: function _projectOnVector(a, p, out) {
      var n_p = p.clone();
      miniprogram.Vector3.normalize(n_p, n_p);
      var cosine = miniprogram.Vector3.dot(a, n_p);
      out.x = n_p.x * cosine;
      out.y = n_p.y * cosine;
      out.z = n_p.z * cosine;
    }
    /**
     * 将向量 a 投影到和法向量 n 正交的平面上。
     * @param a - 输入向量
     * @param n - 法向量
     * @param out - 投影到平面上的向量
     */

  }, {
    key: "_projectOnPlane",
    value: function _projectOnPlane(a, n, out) {
      this._projectOnVector(a, n, _tempVector3);

      miniprogram.Vector3.subtract(a, _tempVector3, out);
    }
  }]);

  return TrailRenderer;
}(GeometryRenderer);

var BoxCollider = /*#__PURE__*/function (_ABoxCollider) {
  _inherits(BoxCollider, _ABoxCollider);

  var _super = _createSuper(BoxCollider);

  _createClass(BoxCollider, [{
    key: "center",
    get: function get() {
      return this._center;
    },
    set: function set(value) {
      this._center = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(value) {
      this._size = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }]);

  function BoxCollider(entity) {
    var _this;

    _classCallCheck(this, BoxCollider);

    _this = _super.call(this, entity);
    _this._center = new miniprogram.Vector3();
    _this._size = new miniprogram.Vector3();
    _this.isShowCollider = true;
    _this.center = _this.center;
    _this.size = _this.size;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }

  return BoxCollider;
}(ABoxCollider);

var SphereCollider = /*#__PURE__*/function (_ASphereCollider) {
  _inherits(SphereCollider, _ASphereCollider);

  var _super = _createSuper(SphereCollider);

  _createClass(SphereCollider, [{
    key: "_center",
    get: function get() {
      return this.__center;
    },
    set: function set(value) {
      this.__center = value;
      this.setSphere(this.__center, this.__radius);
    }
  }, {
    key: "_radius",
    get: function get() {
      return this.__radius;
    },
    set: function set(value) {
      this.__radius = value;
      this.setSphere(this.__center, this.__radius);
    }
  }]);

  function SphereCollider(entity) {
    var _this;

    _classCallCheck(this, SphereCollider);

    _this = _super.call(this, entity);
    _this.__center = new miniprogram.Vector3();
    _this.__radius = 1.0;
    _this.isShowCollider = true;
    _this._center = _this._center;
    _this._radius = _this._radius;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }

  return SphereCollider;
}(ASphereCollider);

Scene.registerFeature(ColliderFeature); //-- colliders

/**
 * AABBox = {
 *  min: [-1,-1,-1],
 *  max: [1,1,1]
 * };
 *
 * Sphere = {
 *  center: [0,0,0],
 *  radius: 1
 * };
 */

/**
 * 两个 AABBox 是否相交
 * @private
 */

function intersectBox2Box(boxA, boxB) {
  return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;
}
/**
 * 两个球体是否相交
 * @private
 */

function intersectSphere2Sphere(sphereA, sphereB) {
  var distance = miniprogram.Vector3.distance(sphereA.center, sphereB.center);
  return distance < sphereA.radius + sphereA.radius;
}
/**
 * 球体和AABBox是否相交
 * @private
 */

function intersectSphere2Box(sphere, box) {
  var center = sphere.center;
  var closestPoint = new miniprogram.Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));
  var distance = miniprogram.Vector3.distance(center, closestPoint);
  return distance < sphere.radius;
}

/**
 * 检测当前 Entity 上的 Collider 与场景中其他 Collider 的碰撞
 * 发出事件：collision
 */

var CollisionDetection = /*#__PURE__*/function (_Script) {
  _inherits(CollisionDetection, _Script);

  var _super = _createSuper(CollisionDetection);

  /**
   * 构造函数
   * @param {Entity} entity 对象所在节点
   */
  function CollisionDetection(entity) {
    var _this;

    _classCallCheck(this, CollisionDetection);

    _this = _super.call(this, entity);
    _this._colliderManager = void 0;
    _this._myCollider = void 0;
    _this._overlopCollider = void 0;
    _this._sphere = void 0;
    _this._box = void 0;
    _this._colliderManager = null;
    _this._myCollider = null;
    _this._overlopCollider = null; // this.addEventListener("start", this._onStart);

    return _this;
  }
  /**
   * 和当前 Entity 上的 Collider 相交的 Collider 对象
   */


  _createClass(CollisionDetection, [{
    key: "onUpdate",

    /**
     * 每帧更新时，计算与其他 collider 的碰撞
     */
    value: function onUpdate(deltaTime) {
      _get(_getPrototypeOf(CollisionDetection.prototype), "onUpdate", this).call(this, deltaTime);

      var overlopCollider = null;

      if (this._colliderManager && this._myCollider) {
        var colliders = this._colliderManager.colliders;

        if (this._myCollider instanceof ABoxCollider) {
          this._box = this._getWorldBox(this._myCollider);

          for (var i = 0, len = colliders.length; i < len; i++) {
            var collider = colliders[i];

            if (collider != this._myCollider && this._boxCollision(collider)) {
              overlopCollider = collider;
              this.trigger(new Event("collision", this, {
                collider: collider
              }));
            }
          } // end of for

        } else if (this._myCollider instanceof ASphereCollider) {
          this._sphere = this._getWorldSphere(this._myCollider);

          for (var _i = 0, _len = colliders.length; _i < _len; _i++) {
            var _collider = colliders[_i];

            if (_collider != this._myCollider && this._sphereCollision(_collider)) {
              overlopCollider = _collider;
              this.trigger(new Event("collision", this, {
                collider: _collider
              }));
            }
          } // end of for

        }
      } // end of if
      //-- overlop events


      if (overlopCollider != null && this._overlopCollider != overlopCollider) {
        this.trigger(new Event("begin_overlop", this, {
          collider: overlopCollider
        }));
      }

      if (this._overlopCollider != null && this._overlopCollider != overlopCollider) {
        var e = this._overlopCollider;
        this.trigger(new Event("end_overlop", this, {
          collider: e
        }));
      }

      this._overlopCollider = overlopCollider;
    }
    /**
     * 获得世界空间中的 Box 坐标
     * @param boxCollider
     */

  }, {
    key: "_getWorldBox",
    value: function _getWorldBox(boxCollider) {
      var mat = boxCollider.entity.transform.worldMatrix;
      var max = new miniprogram.Vector3();
      var min = new miniprogram.Vector3();
      miniprogram.Vector3.transformCoordinate(boxCollider.boxMax, mat, max);
      miniprogram.Vector3.transformCoordinate(boxCollider.boxMin, mat, min); //--

      var temp = CollisionDetection._tempVec3;
      var corners = boxCollider.getCorners();

      for (var i = 0; i < 8; i++) {
        miniprogram.Vector3.transformCoordinate(corners[i], mat, temp);
        if (temp.x > max.x) max.x = temp.x;
        if (temp.y > max.y) max.y = temp.y;
        if (temp.z > max.z) max.z = temp.z;
        if (temp.x < min.x) min.x = temp.x;
        if (temp.y < min.y) min.y = temp.y;
        if (temp.z < min.z) min.z = temp.z;
      }

      return {
        min: min,
        max: max
      };
    }
    /**
     * 获得世界空间中的 Sphere 坐标
     * @param {SphereCollider} sphereCollider
     */

  }, {
    key: "_getWorldSphere",
    value: function _getWorldSphere(sphereCollider) {
      var center = new miniprogram.Vector3();
      miniprogram.Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);
      return {
        radius: sphereCollider.radius,
        center: center
      };
    }
    /**
     * 自身的 Collider 与另一个 Collider 做碰撞检测
     * @param {ABoxCollider|ASphereCollider} other
     */

  }, {
    key: "_boxCollision",
    value: function _boxCollision(other) {
      if (other instanceof ABoxCollider) {
        var box = this._getWorldBox(other);

        return intersectBox2Box(box, this._box);
      } else if (other instanceof ASphereCollider) {
        var sphere = this._getWorldSphere(other);

        return intersectSphere2Box(sphere, this._box);
      }

      return false;
    }
    /**
     * 自身的 Collider 与另一个 Collider 做碰撞检测
     * @param {ABoxCollider|ASphereCollider} other
     */

  }, {
    key: "_sphereCollision",
    value: function _sphereCollision(other) {
      if (other instanceof ABoxCollider) {
        var box = this._getWorldBox(other);

        return intersectSphere2Box(this._sphere, box);
      } else if (other instanceof ASphereCollider) {
        var sphere = this._getWorldSphere(other);

        return intersectSphere2Sphere(sphere, this._sphere);
      }

      return false;
    }
    /**
     * 在 start 事件时，查找其他组件并记录下来
     */

  }, {
    key: "onAwake",
    value: function onAwake() {
      this._colliderManager = this.scene.findFeature(ColliderFeature);
      this._myCollider = this.entity.getComponent(Collider);
    }
  }, {
    key: "overlopCollider",
    get: function get() {
      return this._overlopCollider;
    }
  }]);

  return CollisionDetection;
}(Script);
CollisionDetection._tempVec3 = new miniprogram.Vector3();

/**
 * 雾基类
 */

var Fog = /*#__PURE__*/function (_Component) {
  _inherits(Fog, _Component);

  var _super = _createSuper(Fog);

  function Fog(node) {
    var _this;

    _classCallCheck(this, Fog);

    _this = _super.call(this, node);
    _this.color = new miniprogram.Vector3(1, 0, 0);
    return _this;
  }
  /**
   * @private
   */


  _createClass(Fog, [{
    key: "_onEnable",
    value: function _onEnable() {
      this.scene.findFeature(FogFeature).fog = this;
    }
    /**
     * @private
     */

  }, {
    key: "_onDisable",
    value: function _onDisable() {
      this.scene.findFeature(FogFeature).fog = null;
    }
    /**
     * @private
     */

  }, {
    key: "bindMaterialValues",
    value: function bindMaterialValues(mtl) {}
  }]);

  return Fog;
}(Component);

/**
 * 指数雾
 */

var EXP2Fog = /*#__PURE__*/function (_Fog) {
  _inherits(EXP2Fog, _Fog);

  var _super = _createSuper(EXP2Fog);

  function EXP2Fog() {
    var _this;

    _classCallCheck(this, EXP2Fog);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.density = 0.0025;
    return _this;
  }

  _createClass(EXP2Fog, [{
    key: "bindMaterialValues",

    /**
     * @private
     */
    value: function bindMaterialValues(mtl) {
      mtl.setValue("u_fogColor", this.color);
      mtl.setValue("u_fogDensity", this.density);
    }
  }]);

  return EXP2Fog;
}(Fog);

/**
 * 是否有雾效特性
 * @private
 */

function hasFogFeature() {
  return true;
}
/**
 * 获取雾效相关宏
 * @private
 */

function getFogMacro() {
  return this.findFeature(FogFeature).macro;
}
/**
 * 设置雾参数到材质
 * @param {Material} mtl 材质
 * @private
 */

function bindFogToMaterial(mtl) {
  this.findFeature(FogFeature).bindFogToMaterial(mtl);
}
/**
 * 雾效场景特性
 * @private
 */

var FogFeature = /*#__PURE__*/function (_SceneFeature) {
  _inherits(FogFeature, _SceneFeature);

  var _super = _createSuper(FogFeature);

  function FogFeature() {
    var _this;

    _classCallCheck(this, FogFeature);

    _this = _super.call(this);
    _this._fog = void 0;
    _this._macros = void 0;
    _this._fog = null;
    _this._macros = [];
    return _this;
  }
  /**
   * 雾
   */


  _createClass(FogFeature, [{
    key: "bindFogToMaterial",

    /**
     * @private
     * 绑定雾参数到材质
     * @param {Material} mtl 材质
     */
    value: function bindFogToMaterial(mtl) {
      if (this.fog && mtl.useFog) {
        this.fog.bindMaterialValues(mtl);
      }

      return this;
    }
  }, {
    key: "fog",
    get: function get() {
      return this._fog;
    },
    set: function set(v) {
      if (v !== this._fog) {
        this._fog = v;
        var macro = [];

        if (v instanceof Fog) {
          macro.push("O3_HAS_FOG");

          if (v instanceof EXP2Fog) {
            macro.push("O3_FOG_EXP2");
          }
        }

        if (this._macros.length !== macro.length) {
          this._macros = macro;
        }
      }
    }
    /**
     * 宏
     */

  }, {
    key: "macro",
    get: function get() {
      return this._macros;
    }
  }]);

  return FogFeature;
}(SceneFeature);

/**
 * 线性雾，根据镜头距离线性差值雾浓度
 */

var LinearFog = /*#__PURE__*/function (_Fog) {
  _inherits(LinearFog, _Fog);

  var _super = _createSuper(LinearFog);

  function LinearFog() {
    var _this;

    _classCallCheck(this, LinearFog);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.near = 1;
    _this.far = 1000;
    _this.color = void 0;
    return _this;
  }

  _createClass(LinearFog, [{
    key: "bindMaterialValues",

    /**
     * @private
     */
    value: function bindMaterialValues(mtl) {
      mtl.setValue("u_fogColor", this.color);
      mtl.setValue("u_fogNear", this.near);
      mtl.setValue("u_fogFar", this.far);
    }
  }]);

  return LinearFog;
}(Fog);

Scene.registerFeature(FogFeature);
Scene.prototype.hasFogFeature = hasFogFeature;
Scene.prototype.getFogMacro = getFogMacro;
Scene.prototype.bindFogToMaterial = bindFogToMaterial;

var cacheId = 0;
/**
 * 环境探针类，提供诸如反射折射等需要的功能
 * */

var Probe = /*#__PURE__*/function (_Component) {
  _inherits(Probe, _Component);

  var _super = _createSuper(Probe);

  _createClass(Probe, [{
    key: "camera",

    /** 优先级 excludeRenderList > renderAll > renderList */

    /** 裁剪面 */
    set: function set(camera) {
      if (camera === this._camera) return;
      this._camera && this.renderPipeline.removeRenderPass(this.renderPass);
      this._camera = camera;
      camera && this.renderPipeline.addRenderPass(this.renderPass);
    },
    get: function get() {
      return this._camera;
    }
    /**
     * 探针所得 2D 纹理
     * */

  }, {
    key: "texture",
    get: function get() {
      var _this$renderPass$rend;

      return (_this$renderPass$rend = this.renderPass.renderTarget) === null || _this$renderPass$rend === void 0 ? void 0 : _this$renderPass$rend.getColorTexture();
    }
    /**
     * 探针所得 深度 纹理
     * */

  }, {
    key: "depthTexture",
    get: function get() {
      var _this$renderPass$rend2;

      return (_this$renderPass$rend2 = this.renderPass.renderTarget) === null || _this$renderPass$rend2 === void 0 ? void 0 : _this$renderPass$rend2.depthTexture;
    }
    /**
     * 探针所得 立方体 纹理
     * */

  }, {
    key: "cubeTexture",
    get: function get() {
      var _this$renderPass$rend3;

      return (_this$renderPass$rend3 = this.renderPass.renderTarget) === null || _this$renderPass$rend3 === void 0 ? void 0 : _this$renderPass$rend3.getColorTexture();
    }
  }, {
    key: "renderPipeline",
    get: function get() {
      return this.camera._renderPipeline;
    }
    /**
     * @deperated
     */

  }, {
    key: "rhi",
    get: function get() {
      return this.camera.scene.engine._hardwareRenderer;
    }
    /**
     * 获取需要渲染的真实队列.
     * 优先级 excludeRenderList > renderAll > renderList
     */

  }, {
    key: "renderItems",
    get: function get() {
      var _this2 = this;

      var opaqueQueue = this.renderPipeline.opaqueQueue;
      var transparentQueue = this.renderPipeline.transparentQueue;
      return opaqueQueue.items.concat(transparentQueue.items).filter(function (item) {
        if (!item.primitive) return false;
        if (_this2.excludeRenderList.includes(item.material)) return false;
        if (_this2.renderAll) return true;
        if (_this2.renderList.includes(item.material)) return true;
      });
    }
    /** WebGL2 时，可以开启硬件层的 MSAA */

  }, {
    key: "samples",
    get: function get() {
      return this.renderTarget.antiAliasing;
    }
    /**
     * 探针基类
     * @param {Entity} entity
     */

  }]);

  function Probe(entity) {
    var _this;

    _classCallCheck(this, Probe);

    _this = _super.call(this, entity);
    _this.cacheId = void 0;
    _this.isCube = void 0;
    _this.oriClipPlane = void 0;
    _this._camera = void 0;
    _this.excludeRenderList = void 0;
    _this.renderAll = void 0;
    _this.renderList = void 0;
    _this.renderPass = void 0;
    _this.renderTarget = void 0;
    _this.renderTargetSwap = void 0;
    _this.clipPlanes = void 0;
    _this.cacheId = cacheId++;
    _this.renderPass = new RenderPass("_renderPass" + _this.cacheId, -10);
    /** 自定义渲染管道 */

    _this.renderPass.renderOverride = true;
    _this.renderPass.preRender = _this.preRender.bind(_assertThisInitialized(_this));
    _this.renderPass.render = _this.render.bind(_assertThisInitialized(_this));
    _this.renderPass.postRender = _this.postRender.bind(_assertThisInitialized(_this));
    /**
     * 继续 RTT
     * */

    _this.addEventListener("enabled", function () {
      _this.renderPass.enabled = true;
    });
    /**
     * 暂停 RTT（ render target to texture）
     * */


    _this.addEventListener("disabled", function () {
      _this.renderPass.enabled = false;
    });

    return _this;
  }
  /**
   * 初始化探针。
   * @param config - 初始化配置
   */


  _createClass(Probe, [{
    key: "init",
    value: function init() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.isCube = !!config.isCube;
      this.camera = config.camera || this.scene._activeCameras[0];
      this.excludeRenderList = config.excludeRenderList || [];
      this.renderAll = !!config.renderAll;
      this.renderList = config.renderList || [];
      this.clipPlanes = config.clipPlanes || [];
      var width = config.width || 1024;
      var height = config.height || 1024;
      var samples = config.samples || 1;
      this.renderTarget = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, undefined, false, this.isCube), exports.RenderBufferDepthFormat.Depth, samples);
      this.renderTargetSwap = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, undefined, false, this.isCube), exports.RenderBufferDepthFormat.Depth, samples);
      this.renderPass.renderTarget = this.renderTarget;
    }
  }, {
    key: "preRender",
    value: function preRender() {
      this.oriClipPlane = this.scene.clipPlanes;
      this.scene.clipPlanes = this.clipPlanes;
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var context = RenderContext._getRenderContext(this.camera);

      this.renderItems.forEach(function (item) {
        var component = item.component,
            primitive = item.primitive,
            subPrimitive = item.subPrimitive,
            material = item.material;
        if (!(component.renderPassFlag & _this3.renderPassFlag)) return;
        material.prepareDrawing(context, component, primitive);

        _this3.rhi.drawPrimitive(primitive, subPrimitive, material);
      });
    }
  }, {
    key: "postRender",
    value: function postRender() {
      this.scene.clipPlanes = this.oriClipPlane; // 交换 FBO
      // prevent issue: Feedback Loops Between Textures and the Framebuffer.

      if (this.renderPass.enabled) {
        // 钩子
        if (this.onTextureChange) {
          if (this.isCube) {
            this.onTextureChange(this.cubeTexture);
          } else {
            this.onTextureChange(this.texture, this.depthTexture);
          }
        }

        if (this.renderPass.renderTarget === this.renderTarget) {
          this.renderPass.renderTarget = this.renderTargetSwap;
        } else {
          this.renderPass.renderTarget = this.renderTarget;
        }
      }
    }
    /**
     * 销毁 probe 以及 renderPass
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.enabled = false;
      this.renderPipeline.removeRenderPass(this.renderPass);

      _get(_getPrototypeOf(Probe.prototype), "destroy", this).call(this); // todo:delete


      this.renderTarget.destroy();
      this.renderTargetSwap.destroy();
    }
    /**
     * prevent issue: Feedback Loops Between Textures and the Framebuffer
     * 提供钩子让用户进行交换 Texture
     * @example
     * probe.onTextureChange = cubeTexture => {
     *   envLight.specularMap = cubeTexture;
     *   skybox.specularMap = cubeTexture;
     * }
     * */

  }, {
    key: "onTextureChange",
    value: function onTextureChange(texture, depthTexture) {}
  }]);

  return Probe;
}(Component);

/**
 * 平面探针，用于生成 折射/纹理扰动 等效果
 * */
var PlaneProbe = /*#__PURE__*/function (_Probe) {
  _inherits(PlaneProbe, _Probe);

  var _super = _createSuper(PlaneProbe);

  /**
   * 创建探针
   * @param {Entity} node
   * */
  function PlaneProbe(node) {
    _classCallCheck(this, PlaneProbe);

    return _super.call(this, node);
  }
  /**
   * 初始化探针。
   * @param config - 初始化配置
   */


  _createClass(PlaneProbe, [{
    key: "init",
    value: function init() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(PlaneProbe.prototype), "init", this).call(this, config);
    }
    /**
     * 预处理材质，保存初始状态
     * */

  }, {
    key: "storeMaterial",
    value: function storeMaterial() {
      this.renderItems.forEach(function (item) {
        var material = item.material;
        item.initialSide = material.side;
        material.side = exports.Side.BACK;
      });
    }
    /**
     * 后处理材质，还原初始状态
     * */

  }, {
    key: "restoreMaterial",
    value: function restoreMaterial() {
      this.renderItems.forEach(function (item) {
        var material = item.material;
        material.side = item.initialSide;
        delete item.initialSide;
      });
    }
  }, {
    key: "preRender",
    value: function preRender() {
      _get(_getPrototypeOf(PlaneProbe.prototype), "preRender", this).call(this);

      this.storeMaterial();
    }
  }, {
    key: "postRender",
    value: function postRender() {
      _get(_getPrototypeOf(PlaneProbe.prototype), "postRender", this).call(this);

      this.restoreMaterial();
    }
  }]);

  return PlaneProbe;
}(Probe);

var cacheTarget = new miniprogram.Vector3();
var cacheUp = new miniprogram.Vector3();
var cacheDir = new miniprogram.Vector3();
var fovRadian = 90 * Math.PI / 180;
/**
 * 立方体探针,生成 cubeTexture,用于 动态环境反射 等效果
 * */

var CubeProbe = /*#__PURE__*/function (_Probe) {
  _inherits(CubeProbe, _Probe);

  var _super = _createSuper(CubeProbe);

  /** 可以设置探针的位置，默认为原点 [0,0,0] */

  /**
   * 创建探针
   * @param {Entity} node
   * */
  function CubeProbe(node) {
    var _this;

    _classCallCheck(this, CubeProbe);

    _this = _super.call(this, node);
    _this.position = void 0;
    _this.oriViewMatrix = new miniprogram.Matrix();
    _this.oriInverseViewMatrix = new miniprogram.Matrix();
    _this.oriProjectionMatrix = new miniprogram.Matrix();
    _this.oriInverseProjectionMatrix = new miniprogram.Matrix();
    return _this;
  }
  /**
   * 初始化探针。
   * @param config - 初始化配置
   */


  _createClass(CubeProbe, [{
    key: "init",
    value: function init() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(CubeProbe.prototype), "init", this).call(this, _objectSpread2(_objectSpread2({}, config), {}, {
        isCube: true
      }));

      this.position = config.position || new miniprogram.Vector3();
    }
    /**
     * 贮藏原相机参数
     * */

  }, {
    key: "storeCamera",
    value: function storeCamera() {
      this.camera.viewMatrix.cloneTo(this.oriViewMatrix);
      this.camera.inverseViewMatrix.cloneTo(this.oriInverseViewMatrix);
      this.camera.projectionMatrix.cloneTo(this.oriProjectionMatrix);
      this.camera.inverseProjectionMatrix.cloneTo(this.oriInverseProjectionMatrix);
    }
    /**
     * 还原相机参数
     * */

  }, {
    key: "restoreCamera",
    value: function restoreCamera() {
      this.oriViewMatrix.cloneTo(this.camera.viewMatrix);
      this.oriInverseViewMatrix.cloneTo(this.camera.inverseViewMatrix);
      this.oriProjectionMatrix.cloneTo(this.camera.projectionMatrix);
      this.oriInverseProjectionMatrix.cloneTo(this.camera.inverseProjectionMatrix);
    }
  }, {
    key: "preRender",
    value: function preRender() {
      _get(_getPrototypeOf(CubeProbe.prototype), "preRender", this).call(this);

      this.storeCamera();
    }
  }, {
    key: "render",
    value: function render() {
      // 渲染6个面
      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
        // 设置渲染面
        this.rhi.setRenderTargetFace(this.renderPass.renderTarget, faceIndex); // clear

        this.rhi.clearRenderTarget(this.renderPass.clearMode, this.renderPass.clearParam); // 改 camera 参数

        this.setCamera(faceIndex); // render

        _get(_getPrototypeOf(CubeProbe.prototype), "render", this).call(this); // MSAA need to blit
        // 6'th face will blit in pipeline


        if (faceIndex < 5) {
          this.rhi.blitRenderTarget(this.renderPass.renderTarget);
        }
      }
    }
  }, {
    key: "postRender",
    value: function postRender() {
      _get(_getPrototypeOf(CubeProbe.prototype), "postRender", this).call(this);

      this.restoreCamera();
    }
    /**
     * 根据渲染面设置相机参数
     * */

  }, {
    key: "setCamera",
    value: function setCamera(faceIndex) {
      switch (faceIndex) {
        // positive_x
        case 0:
          cacheUp.setValue(0, -1, 0);
          cacheDir.setValue(1, 0, 0);
          break;
        // negative_x

        case 1:
          cacheUp.setValue(0, -1, 0);
          cacheDir.setValue(-1, 0, 0);
          break;
        // positive_y

        case 2:
          cacheUp.setValue(0, 0, 1);
          cacheDir.setValue(0, 1, 0);
          break;
        // negative_y

        case 3:
          cacheUp.setValue(0, 0, -1);
          cacheDir.setValue(0, -1, 0);
          break;
        // positive_z

        case 4:
          cacheUp.setValue(0, -1, 0);
          cacheDir.setValue(0, 0, 1);
          break;
        // negative_z

        case 5:
          cacheUp.setValue(0, -1, 0);
          cacheDir.setValue(0, 0, -1);
          break;
      }

      miniprogram.Vector3.add(this.position, cacheDir, cacheTarget);
      miniprogram.Matrix.lookAt(this.position, cacheTarget, cacheUp, this.camera.viewMatrix);
      miniprogram.Matrix.invert(this.camera.viewMatrix, this.camera.inverseViewMatrix);
      miniprogram.Matrix.perspective(fovRadian, 1, this.camera.nearClipPlane, this.camera.farClipPlane, this.camera.projectionMatrix);
      miniprogram.Matrix.invert(this.camera.projectionMatrix, this.camera.inverseProjectionMatrix);
    }
  }]);

  return CubeProbe;
}(Probe);

/**
 * 阴影的管理类
 * @private
 */

var LightShadow = /*#__PURE__*/function () {
  function LightShadow() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      engine: null,
      width: 512,
      height: 512
    };

    _classCallCheck(this, LightShadow);

    this.rhi = void 0;
    this._mapSize = void 0;
    this._renderTarget = void 0;
    this.bias = void 0;
    this.intensity = void 0;
    this.radius = void 0;
    this.projectionMatrix = void 0;
    this._mapSize = new miniprogram.Vector2(props.width, props.height);
    this._renderTarget = new RenderTarget(props.engine, props.width, props.height, new RenderColorTexture(props.engine, props.width, props.height));
    /**
     * （偏斜）
     * @member {float}
     */

    this.bias = 0.005;
    /**
     * （投影强度）值越大投影越清晰越黑
     * @member {float}
     */

    this.intensity = 0.2;
    /**
     * 阴影 PCF 插值使用的像素范围
     * @member { float }
     */

    this.radius = 1.0;
    /**
     * 生成 shadow map 使用的投影矩阵
     * @member {Matrix}
     */

    this.projectionMatrix = new miniprogram.Matrix();
  }
  /**
   * shadow map 对应的 RenderTarget
   * @member {RenderTarget}
   * @readonly
   */


  _createClass(LightShadow, [{
    key: "initShadowProjectionMatrix",

    /**
     * 初始化光照的投影矩阵
     * @param {ALight} light
     */
    value: function initShadowProjectionMatrix(light) {
      /**
       * 方向光初始化投影矩阵，默认覆盖区域 left: -5, right: 5, bottom: -5, up: 5, near: 0.5, far: 50
       */
      if (light instanceof DirectLight) {
        miniprogram.Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
      }
      /**
       * 点光源初始化投影矩阵，默认配置：fov: 50, aspect: 1, near: 0.5, far: 50
       */


      if (light instanceof PointLight) {
        miniprogram.Matrix.perspective(miniprogram.MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
      }
      /**
       * 聚光灯初始化投影矩阵，默认配置：fov: this.angle * 2 * Math.sqrt(2), aspect: 1, near: 0.1, far: this.distance + 5
       */


      if (light instanceof SpotLight) {
        var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
        miniprogram.Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
      }
    }
    /**
     * 将阴影参数值提交到阴影材质对象
     * @param {Material} mtl
     * @param {number} index
     * @param {Component} component
     * @param {ALight} light
     */

  }, {
    key: "bindShadowValues",
    value: function bindShadowValues(mtl, index, light) {
      // 光源视点VP
      mtl.setValue("u_viewMatFromLight[".concat(index, "]"), light.viewMatrix);
      mtl.setValue("u_projMatFromLight[".concat(index, "]"), this.projectionMatrix); // shadow map

      var uniformName = "u_shadows[".concat(index, "]");
      mtl.setValue(uniformName + ".bias", this.bias);
      mtl.setValue(uniformName + ".intensity", this.intensity);
      mtl.setValue(uniformName + ".radius", this.radius);
      mtl.setValue(uniformName + ".mapSize", this._mapSize);
      mtl.setValue("u_shadowMaps[".concat(index, "]"), this.map);
    }
    /**
     * 生成 Technique 所需的 uniform 定义
     * @param {number} index ShadowMap Index
     */

  }, {
    key: "renderTarget",
    get: function get() {
      return this._renderTarget;
    }
    /**
     * shadow map 纹理对象
     * @member {Texture2D}
     * @readonly
     */

  }, {
    key: "map",
    get: function get() {
      return this._renderTarget.getColorTexture();
    }
    /**
     * shadow map 纹理大小
     * @member {Vector2}
     * @readonly
     */

  }, {
    key: "mapSize",
    get: function get() {
      return this._mapSize;
    }
  }], [{
    key: "getUniformDefine",
    value: function getUniformDefine(index) {
      var uniforms = {};
      uniforms["u_viewMatFromLight[".concat(index, "]")] = {
        name: "u_viewMatFromLight[".concat(index, "]"),
        type: exports.DataType.FLOAT_MAT4
      };
      uniforms["u_projMatFromLight[".concat(index, "]")] = {
        name: "u_projMatFromLight[".concat(index, "]"),
        type: exports.DataType.FLOAT_MAT4
      };
      var uniformName = "u_shadows[".concat(index, "]");
      uniforms[uniformName + ".bias"] = {
        name: uniformName + ".bias",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".intensity"] = {
        name: uniformName + ".intensity",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".radius"] = {
        name: uniformName + ".radius",
        type: exports.DataType.FLOAT
      };
      uniforms[uniformName + ".mapSize"] = {
        name: uniformName + ".mapSize",
        type: exports.DataType.FLOAT_VEC2
      };
      uniforms["u_shadowMaps[".concat(index, "]")] = {
        name: "u_shadowMaps[".concat(index, "]"),
        type: exports.DataType.SAMPLER_2D
      };
      return uniforms;
    }
  }]);

  return LightShadow;
}();

/**
 * 设置是否产生阴影
 * @param {boolean} enabled
 */

Object.defineProperty(Light.prototype, "enableShadow", {
  get: function get() {
    return this._enableShadow;
  },
  set: function set(enabled) {
    this._enableShadow = enabled;

    if (this._enableShadow) {
      if (this instanceof AmbientLight) {
        Logger.warn("Has no shadow!");
        return;
      }

      this.shadow = this.shadow || new LightShadow({
        engine: this.engine,
        width: 512,
        height: 512
      });
      this.shadow.initShadowProjectionMatrix(this);
    }
  }
});
/**
 * 设置是否接收阴影
 * @param {boolean} enabled
 */

Object.defineProperty(Component.prototype, "recieveShadow", {
  get: function get() {
    return this._recieveShadow;
  },
  set: function set(enabled) {
    this._recieveShadow = enabled;
  }
});
/**
 * 设置是否投射阴影
 * @param {boolean} enabled
 */

Object.defineProperty(Component.prototype, "castShadow", {
  get: function get() {
    return this._castShadow;
  },
  set: function set(enabled) {
    this._castShadow = enabled;
  }
});

var fs$2 = "precision mediump float;\n\n/**\n * 分解保存深度值\n*/\nvec4 pack (float depth) {\n\n  // 使用rgba 4字节共32位来存储z值,1个字节精度为1/256\n  const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n  const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);\n\n  vec4 rgbaDepth = fract(depth * bitShift); //计算每个点的z值\n\n  // Cut off the value which do not fit in 8 bits\n  rgbaDepth -= rgbaDepth.gbaa * bitMask;\n\n  return rgbaDepth;\n}\n\nvoid main() {\n\n  // 将z值分开存储到rgba分量中,阴影颜色的同时也是深度值z\n  gl_FragColor = pack(gl_FragCoord.z);\n\n}";

var vs$2 = "#include <common_vert>\n#include <normal_share>\n#include <shadow_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n    #include <shadow_vert>\n    #include <position_vert>\n\n}\n";

/**
 * 生成 Shadow Map 使用的材质
 * @private
 */

var ShadowMapMaterial = /*#__PURE__*/function (_ComplexMaterial) {
  _inherits(ShadowMapMaterial, _ComplexMaterial);

  var _super = _createSuper(ShadowMapMaterial);

  function ShadowMapMaterial() {
    _classCallCheck(this, ShadowMapMaterial);

    return _super.apply(this, arguments);
  }

  _createClass(ShadowMapMaterial, [{
    key: "_generateTechnique",

    /**
     * 生成内部所使用的 Technique 对象
     * @private
     */
    value: function _generateTechnique(camera, component) {
      var customMacros = this._generateMacros();

      var uniforms = this._generateFragmentUniform(); //--


      var tech = new RenderTechnique(this.name);
      tech.isValid = true;
      tech.uniforms = uniforms;
      tech.attributes = {};
      tech.states = {};
      tech.customMacros = customMacros;
      tech.vertexShader = vs$2;
      tech.fragmentShader = fs$2;
      return tech;
    }
    /**
     * 添加阴影相关的 uniform 定义
     * @private
     */

  }, {
    key: "_generateFragmentUniform",
    value: function _generateFragmentUniform() {
      var uniforms = {
        u_viewMatFromLight: {
          name: "u_viewMatFromLight",
          type: exports.DataType.FLOAT_MAT4
        },
        u_projMatFromLight: {
          name: "u_projMatFromLight",
          type: exports.DataType.FLOAT_MAT4
        }
      };
      return uniforms;
    }
    /**
     * 根据阴影的个数，添加相应的宏定义
     * @private
     */

  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = [];
      macros.push("O3_GENERATE_SHADOW_MAP");
      return macros;
    }
  }]);

  return ShadowMapMaterial;
}(ComplexMaterial);

/**
 * RednerPass 对象
 * @private
 */
var ShadowMapPass = /*#__PURE__*/function (_RenderPass) {
  _inherits(ShadowMapPass, _RenderPass);

  var _super = _createSuper(ShadowMapPass);

  /**
   * RenderPass 构造函数
   * @param {string} name 这个 Pass 的名称
   * @param {number} priority 优先级，小于0在默认Pass之前，大于0在默认Pass之后
   * @param {RenderTarget} renderTarget 指定的 Render Target
   * @param {Material} replaceMaterial 替换模型的默认材质
   * @param {number} mask 与 Component.renderPassFlag 进行 bit and 操作，对这个 Pass 需要渲染的对象进行筛选
   * @param {ALight} light 需要生成 ShadowMap 的光源
   */
  function ShadowMapPass(name, priority, renderTarget, replaceMaterial, mask, light) {
    var _this;

    _classCallCheck(this, ShadowMapPass);

    _this = _super.call(this, name, priority, renderTarget, replaceMaterial, mask);
    _this.light = void 0;
    _this.light = light;
    return _this;
  }
  /**
   * Pass 渲染前调用
   * @param {Camera} camera 相机
   * @param {RenderQueue} opaqueQueue 不透明物体渲染队列
   * @param {RenderQueue} transparentQueue 透明物体渲染队列
   */


  _createClass(ShadowMapPass, [{
    key: "preRender",
    value: function preRender(camera, opaqueQueue, transparentQueue) {
      // 光源视点 VP 矩阵
      this.replaceMaterial.setValue("u_viewMatFromLight", this.light.viewMatrix);
      this.replaceMaterial.setValue("u_projMatFromLight", this.light.shadow.projectionMatrix);
    }
  }]);

  return ShadowMapPass;
}(RenderPass);

var fs$3 = "varying vec2 v_uv;\n\nuniform vec4 u_ambientLight;\n\n#ifdef O3_SHADOW_MAP_COUNT\n\nstruct Shadow {\n  float     bias;\n  float     intensity;\n  vec2      mapSize;\n  float     radius;\n};\n\nuniform Shadow u_shadows[O3_SHADOW_MAP_COUNT];\n\nuniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];\n\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n\nconst vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n\n/**\n* 释出深度值\n*/\nfloat unpack(const in vec4 rgbaDepth) {\n  return dot(rgbaDepth, bitShift);\n}\n\n/**\n* 判断是否需要显示阴影\n*/\nfloat getVisibility(vec4 positionFromLight, const in sampler2D shadowMap, vec2 mapSize, float intensity, float bias, float radius) {\n\n    vec3 shadowCoord = (positionFromLight.xyz/positionFromLight.w)/2.0 + 0.5;\n    float filterX = step(0.0, shadowCoord.x) * (1.0 - step(1.0, shadowCoord.x));\n    float filterY = step(0.0, shadowCoord.y) * (1.0 - step(1.0, shadowCoord.y));\n\n    shadowCoord.z -= bias;\n    vec2 texelSize = vec2( 1.0 ) / mapSize;\n\n    float visibility = 0.0;\n    for (float y = -1.0 ; y <=1.0 ; y+=1.0) {\n      for (float x = -1.0 ; x <=1.0 ; x+=1.0) {\n        vec2 uv = shadowCoord.xy + texelSize * vec2(x, y) * radius;\n        vec4 rgbaDepth = texture2D(shadowMap, uv);\n        float depth = unpack(rgbaDepth);\n        visibility += step(depth, shadowCoord.z) * intensity;\n      }\n    }\n\n    visibility *= ( 1.0 / 9.0 );\n    return visibility * filterX * filterY;\n\n}\n\n#endif\n\nvoid main() {\n\n  vec4 shadowColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef O3_SHADOW_MAP_COUNT\n\n  float visibility = 1.0;\n\n  for(int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\n\n   visibility -= getVisibility(v_PositionFromLight[i], u_shadowMaps[i], u_shadows[i].mapSize, u_shadows[i].intensity, u_shadows[i].bias, u_shadows[i].radius);\n\n  }\n\n  visibility = clamp(visibility, 0.0, 1.0);\n  shadowColor = vec4(visibility, visibility, visibility, 1.0);\n\n#endif\n\n  gl_FragColor = shadowColor;\n}";

/**
 * 接收阴影的材质
 * @private
 */

var ShadowMaterial = /*#__PURE__*/function (_ComplexMaterial) {
  _inherits(ShadowMaterial, _ComplexMaterial);

  var _super = _createSuper(ShadowMaterial);

  function ShadowMaterial() {
    var _this;

    _classCallCheck(this, ShadowMaterial);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.shadowMapCount = void 0;
    return _this;
  }

  _createClass(ShadowMaterial, [{
    key: "_generateTechnique",

    /**
     * 生成内部所使用的 Technique 对象
     * @private
     */
    value: function _generateTechnique(camera, component) {
      var customMacros = this._generateMacros();

      var uniforms = this._generateFragmentUniform(); //--


      var tech = new RenderTechnique(this.name);
      tech.autoConvert = false;
      tech.isValid = true;
      tech.uniforms = uniforms;
      tech.attributes = {};
      tech.states = {};
      tech.customMacros = customMacros;
      tech.vertexShader = vs$2;
      tech.fragmentShader = fs$3;
      tech.states = {
        enable: [exports.RenderState.BLEND],
        functions: {
          depthFunc: [exports.CompFunc.LEQUAL],
          blendFunc: [exports.BlendFunc.DST_COLOR, exports.BlendFunc.ZERO]
        }
      };
      return tech;
    }
    /**
     * 添加阴影相关的 uniform 定义
     * @private
     */

  }, {
    key: "_generateFragmentUniform",
    value: function _generateFragmentUniform() {
      var uniforms = {};

      for (var i = 0; i < this.shadowMapCount; i++) {
        var lgtUniforms = LightShadow.getUniformDefine(i);
        uniforms = _objectSpread2(_objectSpread2({}, uniforms), lgtUniforms);
      } // end of for


      return uniforms;
    }
    /**
     * 根据阴影的个数，添加相应的宏定义
     * @private
     */

  }, {
    key: "_generateMacros",
    value: function _generateMacros() {
      var macros = [];

      if (this.shadowMapCount > 0) {
        macros.push("O3_SHADOW_MAP_COUNT ".concat(this.shadowMapCount));
      }

      return macros;
    }
  }]);

  return ShadowMaterial;
}(ComplexMaterial);

/**
 * RednerPass 对象
 * @private
 */

var ShadowPass = /*#__PURE__*/function (_RenderPass) {
  _inherits(ShadowPass, _RenderPass);

  var _super = _createSuper(ShadowPass);

  function ShadowPass() {
    var _this;

    _classCallCheck(this, ShadowPass);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.clearMode = exports.ClearMode.DONT_CLEAR;
    return _this;
  }
  /**
   * Pass 渲染前调用
   * @param {Camera} camera 相机
   * @param {RenderQueue} opaqueQueue 不透明物体渲染队列
   * @param {RenderQueue} transparentQueue 透明物体渲染队列
   */


  _createClass(ShadowPass, [{
    key: "preRender",
    value: function preRender(camera, opaqueQueue, transparentQueue) {
      this.enabled = false;
      var lightMgr = camera.scene.findFeature(LightFeature);

      if (lightMgr) {
        // keep render based on default render pass
        var pass = camera._renderPipeline.defaultRenderPass;
        this.renderTarget = pass.renderTarget;
        var lights = lightMgr.visibleLights;
        var shadowMapCount = 0;

        for (var i = 0, len = lights.length; i < len; i++) {
          var lgt = lights[i];

          if (lgt.enableShadow) {
            lgt.shadow.bindShadowValues(this.replaceMaterial, shadowMapCount, lgt);
            shadowMapCount++;
          }
        } // end of for


        if (shadowMapCount !== this.replaceMaterial.shadowMapCount) {
          this.replaceMaterial.shadowMapCount = shadowMapCount;
          this.replaceMaterial.clearTechniques();
        }

        if (shadowMapCount) this.enabled = true;
      }
    }
  }]);

  return ShadowPass;
}(RenderPass);

/**
 * Shadow Feature：场景中 Shadow 特性
 * @extends SceneFeature
 * @private
 */
var ShadowFeature = /*#__PURE__*/function (_SceneFeature) {
  _inherits(ShadowFeature, _SceneFeature);

  var _super = _createSuper(ShadowFeature);

  function ShadowFeature() {
    var _this;

    _classCallCheck(this, ShadowFeature);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this._shadowPass = void 0;
    _this._shadowMapMaterial = void 0;
    return _this;
  }

  _createClass(ShadowFeature, [{
    key: "preRender",

    /**
     * 场景渲染前的回调, 在此环节生成 Shadow Map
     * @param {Scene} scene
     * @param {Camera} camera
     */
    value: function preRender(scene, camera) {
      var lightMgr = camera.scene.findFeature(LightFeature);

      if (lightMgr && lightMgr.visibleLights.length > 0) {
        // 检查添加绘制 Shadow 的 RenderPass
        if (!this._shadowPass) {
          this.addShadowPass(camera);
        } // 检查添加绘制 Shadow Map 的 RenderPass


        var lights = lightMgr.visibleLights;

        for (var i = 0, len = lights.length; i < len; i++) {
          var lgt = lights[i];

          if (lgt.enableShadow && !lgt.shadowMapPass) {
            lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
          } else if (!lgt.enableShadow && lgt.shadowMapPass) {
            var renderer = camera._renderPipeline;
            renderer.removeRenderPass(lgt.shadowMapPass);
            lgt.shadowMapPass = null;
          }
        } // end of for


        this.updatePassRenderFlag(camera._renderPipeline.opaqueQueue);
        this.updatePassRenderFlag(camera._renderPipeline.transparentQueue);
      } // end of if

    }
    /**
     * 添加渲染阴影的 RendererPass
     * @param {Camera} camera
     */

  }, {
    key: "addShadowPass",
    value: function addShadowPass(camera) {
      var shadowMaterial = new ShadowMaterial(camera.engine, "shadowMaterial");
      this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, exports.MaskList.SHADOW);
      var renderer = camera._renderPipeline;
      renderer.addRenderPass(this._shadowPass);
    }
    /**
     * 添加渲染 shadow map 的 RendererPass
     * @param {Camera} camera
     * @param {ALight} light
     */

  }, {
    key: "addShadowMapPass",
    value: function addShadowMapPass(camera, light) {
      // 共用 shadow map 材质
      this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine, "shadowMapMaterial");
      var shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, exports.MaskList.SHADOW_MAP, light);
      var renderer = camera._renderPipeline;
      renderer.addRenderPass(shadowMapPass);
      return shadowMapPass;
    }
    /**
     * 用于更新场景中物体的 renderPassFlag 状态
     * @param {RenderQueue} renderQueue
     */

  }, {
    key: "updatePassRenderFlag",
    value: function updatePassRenderFlag(renderQueue) {
      var items = renderQueue.items;

      for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var ability = item.component;
        var recieveShadow = ability.recieveShadow;
        var castShadow = ability.castShadow;

        if (recieveShadow === true) {
          ability.addPassMasks(exports.MaskList.SHADOW);
        } else if (recieveShadow === false) {
          ability.removePassMasks(exports.MaskList.SHADOW);
        }

        if (castShadow === true) {
          ability.addPassMasks(exports.MaskList.SHADOW_MAP);
        } else if (castShadow === false) {
          ability.removePassMasks(exports.MaskList.SHADOW_MAP);
        }
      }
    }
  }]);

  return ShadowFeature;
}(SceneFeature);

Scene.registerFeature(ShadowFeature);

Scene.registerFeature(LightFeature);
Scene.prototype.hasLight = hasLight; // 引用了 raycast

exports.ABoxCollider = ABoxCollider;
exports.ACollider = Collider;
exports.ASphereCollider = ASphereCollider;
exports.AmbientLight = AmbientLight;
exports.Animation = Animation;
exports.AnimationClip = AnimationClip;
exports.AssetObject = AssetObject;
exports.AssetPromise = AssetPromise;
exports.BasicRenderPipeline = BasicRenderPipeline;
exports.BlinnPhongMaterial = BlinnPhongMaterial;
exports.BoxCollider = BoxCollider;
exports.Buffer = Buffer;
exports.BufferGeometry = BufferGeometry;
exports.BufferUtil = BufferUtil;
exports.Camera = Camera;
exports.CircleGeometry = CircleGeometry;
exports.ColliderFeature = ColliderFeature;
exports.CollisionDetection = CollisionDetection;
exports.CommonMaterial = CommonMaterial;
exports.ComplexMaterial = ComplexMaterial;
exports.Component = Component;
exports.ConstantMaterial = ConstantMaterial;
exports.CubeProbe = CubeProbe;
exports.CuboidGeometry = CuboidGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.DirectLight = DirectLight;
exports.EXP2Fog = EXP2Fog;
exports.Engine = Engine;
exports.EngineFeature = EngineFeature;
exports.EngineObject = EngineObject;
exports.Entity = Entity;
exports.EnvironmentMapLight = EnvironmentMapLight;
exports.Event = Event;
exports.EventDispatcher = EventDispatcher;
exports.FogFeature = FogFeature;
exports.GPUParticleSystem = GPUParticleSystem;
exports.GeometryRenderer = GeometryRenderer;
exports.IndexBufferBinding = IndexBufferBinding;
exports.LODGroup = LODGroup;
exports.LambertMaterial = LambertMaterial;
exports.Light = Light;
exports.LightFeature = LightFeature;
exports.LinearFog = LinearFog;
exports.Loader = Loader;
exports.Logger = Logger;
exports.Material = Material;
exports.Mesh = Mesh;
exports.MeshRenderer = MeshRenderer;
exports.Model = Model;
exports.ObjectValues = ObjectValues;
exports.PBRMaterial = PBRMaterial;
exports.Particle = Particle;
exports.PlaneCollider = PlaneCollider;
exports.PlaneGeometry = PlaneGeometry;
exports.PlaneProbe = PlaneProbe;
exports.PointLight = PointLight;
exports.Primitive = Primitive;
exports.Probe = Probe;
exports.RefObject = RefObject;
exports.RenderColorTexture = RenderColorTexture;
exports.RenderContext = RenderContext;
exports.RenderDepthTexture = RenderDepthTexture;
exports.RenderPass = RenderPass;
exports.RenderQueue = RenderQueue;
exports.RenderTarget = RenderTarget;
exports.RenderTechnique = RenderTechnique;
exports.RenderableComponent = RenderableComponent;
exports.ResourceManager = ResourceManager;
exports.Scene = Scene;
exports.SceneFeature = SceneFeature;
exports.SceneVisitor = SceneVisitor;
exports.ScreenQuadGeometry = ScreenQuadGeometry;
exports.Script = Script;
exports.ShaderFactory = ShaderFactory;
exports.ShaderMaterial = ShaderMaterial;
exports.ShapeGeometry = ShapeGeometry;
exports.Skin = Skin;
exports.SkinnedMeshRenderer = SkinnedMeshRenderer;
exports.SkyBox = SkyBox;
exports.SphereCollider = SphereCollider;
exports.SphereGeometry = SphereGeometry;
exports.SpotLight = SpotLight;
exports.SpriteRenderer = SpriteRenderer;
exports.SubPrimitive = SubPrimitive;
exports.SystemInfo = SystemInfo;
exports.Texture = Texture;
exports.Texture2D = Texture2D;
exports.TextureCubeMap = TextureCubeMap;
exports.TextureMaterial = TextureMaterial;
exports.Time = Time;
exports.TorusGeometry = TorusGeometry;
exports.TrailMaterial = TrailMaterial;
exports.TrailRenderer = TrailRenderer;
exports.Transform = Transform;
exports.TransparentMaterial = TransparentMaterial;
exports.UpdateFlag = UpdateFlag;
exports.Util = Util;
exports.VertexBufferBinding = VertexBufferBinding;
exports.VertexElement = VertexElement;
exports.bindFogToMaterial = bindFogToMaterial;
exports.dependencies = dependencies;
exports.getFogMacro = getFogMacro;
exports.hasFogFeature = hasFogFeature;
exports.request = request;
exports.resourceLoader = resourceLoader;
