'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var o3Core = require('@alipay/o3-core');

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var DRACOWorker = /*#__PURE__*/function () {
  _createClass(DRACOWorker, [{
    key: "currentLoad",
    // worker 实例
    // 记录每一个 task 的 byteLength
    // 当前政治处理的所有 task 的 byteLength 的和，排序用
    get: function get() {
      return this._currentLoad;
    }
  }]);

  function DRACOWorker(workerSourceURL, decoderWASMBinary) {
    var _this = this;

    _classCallCheck(this, DRACOWorker);

    this._worker = void 0;
    this._costs = {};
    this._currentLoad = 0;
    this._callbacks = {};
    this._worker = new Worker(workerSourceURL);

    this._worker.onmessage = function (e) {
      var message = e.data;

      switch (message.type) {
        case "decode":
          _this._callbacks[message.id].resolve(message.geometry);

          break;

        case "error":
          _this._callbacks[message.id].reject(message);

          break;

        default:
          o3Core.Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
      }
    };

    if (decoderWASMBinary) {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {
          wasmBinary: decoderWASMBinary
        }
      });
    } else {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {}
      });
    }
  }

  _createClass(DRACOWorker, [{
    key: "setCosts",
    value: function setCosts(taskId, cost) {
      this._costs[taskId] = cost;
    }
  }, {
    key: "addCurrentLoad",
    value: function addCurrentLoad(cost) {
      this._currentLoad += cost;
    }
  }, {
    key: "setCallback",
    value: function setCallback(taskId, resolve, reject) {
      this._callbacks[taskId] = {
        resolve: resolve,
        reject: reject
      };
    }
  }, {
    key: "decode",
    value: function decode(taskId, taskConfig, buffer) {
      this._worker.postMessage({
        type: "decode",
        id: taskId,
        taskConfig: taskConfig,
        buffer: buffer
      }, [buffer]);
    }
  }, {
    key: "releaseTask",
    value: function releaseTask(taskId) {
      this._currentLoad -= this._costs[taskId];
      delete this._callbacks[taskId];
      delete this._costs[taskId];
    }
  }]);

  return DRACOWorker;
}();

var DRACODecoder = /*#__PURE__*/function () {
  function DRACODecoder() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      type: "wasm",
      workerLimit: 4
    };

    _classCallCheck(this, DRACODecoder);

    this.pool = [];
    this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
    this.useJS = void 0;
    this.currentTaskId = 1;
    this.taskCache = new WeakMap();
    this.loadLibPromise = void 0;

    if (config.workerLimit > this.workerLimit) {
      o3Core.Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
    } else {
      var _config$workerLimit;

      this.workerLimit = (_config$workerLimit = config.workerLimit) !== null && _config$workerLimit !== void 0 ? _config$workerLimit : 4;
    }

    this.useJS = (typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== "object" || config.type === "js";
    this.loadLibPromise = this.preloadLib();
  }

  _createClass(DRACODecoder, [{
    key: "preloadLib",
    value: function preloadLib() {
      if (this.loadLibPromise) {
        return this.loadLibPromise;
      }

      if (this.useJS) ;

      return new Promise(function (resolve, reject) {// TODO: 直接使用Promise.all 和 新版加载函数
        // loadAll(loadQueue, (err, res) => {
        //   if (err) {
        //     reject(err);
        //     return;
        //   }
        //   const workerStrings = [this.useJS ? res["js"] : res["wrapper"], workerString];
        //   const body = workerStrings.join("\n");
        //   const workerSourceURL = URL.createObjectURL(new Blob([body]));
        //   let decoderWASMBinary = this.useJS ? null : res["wasm"];
        //   resolve({ workerSourceURL, decoderWASMBinary });
        // });
      });
    }
  }, {
    key: "getWorker",
    value: function getWorker() {
      var _this = this;

      return this.preloadLib().then(function (worderResources) {
        if (_this.pool.length < _this.workerLimit) {
          var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);

          _this.pool.push(dracoWorker);
        } else {
          _this.pool.sort(function (a, b) {
            return a.currentLoad > b.currentLoad ? -1 : 1;
          });
        }

        return _this.pool[_this.pool.length - 1];
      });
    }
  }, {
    key: "decode",
    value: function decode(buffer, taskConfig) {
      var _this2 = this;

      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred
      // again from this thread.

      if (this.taskCache.has(buffer)) {
        var cachedTask = this.taskCache.get(buffer);

        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          // 使用transferable传递数据后，原来环境中的数据会被清除，所以这里判断byteLength为0代表已经传输过
          // Technically, it would be possible to wait for the previous task to complete,
          // transfer the buffer back, and decode again with the second configuration. That
          // is complex, and I don't know of any reason to decode a Draco buffer twice in
          // different ways, so this is left unimplemented.
          throw new Error("DRACODecoder: Unable to re-decode a buffer with different " + "settings. Buffer has already been transferred.");
        }
      }

      var taskId = this.currentTaskId++;
      var cost = buffer.byteLength;
      var taskWorker;
      var task = new Promise(function (resolve, reject) {
        _this2.getWorker().then(function (worker) {
          taskWorker = worker;
          worker.setCosts(taskId, cost);
          worker.addCurrentLoad(cost);
          worker.setCallback(taskId, resolve, reject);
          worker.decode(taskId, taskConfig, buffer);
        })["catch"](function (e) {
          reject(e);
        });
      });
      task["finally"](function () {
        if (taskWorker && taskId) {
          taskWorker.releaseTask(taskId);
        }
      });
      this.taskCache.set(buffer, {
        key: taskKey,
        promise: task
      });
      return task;
    }
  }]);

  return DRACODecoder;
}();

exports.DRACODecoder = DRACODecoder;
//# sourceMappingURL=main.js.map
