import { Camera, Canvas, GLCapabilityType, HardwareRenderer, Primitive, RenderTarget, IPlatformPrimitive } from "@oasis-engine/core";
import { Vector4 } from "@oasis-engine/math";
import { GLAssetsCache } from "./GLAssetsCache";
import { GLCapability } from "./GLCapability";
import { GLRenderStates } from "./GLRenderStates";
import { WebGLExtension } from "./type";
import { WebGLEngine } from "./WebGLEngine";
/**
 * WebGL模式。默认 Auto
 */
export declare enum WebGLMode {
    /** 自动，如果设备支持优先选择WebGL2.0，不支持 WebGL2.0 会回滚至WebGL1.0 */
    Auto = 0,
    /** 使用 WebGL2.0 */
    WebGL2 = 1,
    /** 使用 WebGL1.0 */
    WebGL1 = 2
}
/**
 * WebGLRenderer的参数选项。
 */
export interface WebGLRendererOptions extends WebGLContextAttributes {
    /** WebGL API 模式。*/
    webGLMode?: WebGLMode;
}
/**
 * WebGL渲染器实现，包含了WebGL1.0/和WebGL2.0。
 */
export declare class WebGLRenderer implements HardwareRenderer {
    /** @internal */
    _engine: WebGLEngine;
    private _options;
    private _gl;
    private _renderStates;
    private _assetsCache;
    private _extensions;
    private _frameCount;
    private _spriteBatcher;
    private _capability;
    private _isWebGL2;
    /** 当前 RHI 是否为 WebGL 2.0 */
    get isWebGL2(): boolean;
    constructor(options?: WebGLRendererOptions);
    init(canvas: Canvas, engine: WebGLEngine): void;
    /**
     * 创建平台图元。
     */
    createPlatformPrimitive(primitive: Primitive): IPlatformPrimitive;
    /**
     * GL Context 对象
     * @member {WebGLRenderingContext}
     * @readonly
     */
    get gl(): (WebGLRenderingContext & WebGLExtension) | WebGL2RenderingContext;
    /**
     * GL 资源对象缓冲池
     */
    get assetsCache(): GLAssetsCache;
    /**
     * GL 状态管理器
     */
    get renderStates(): GLRenderStates;
    /**
     * GL 能力管理
     * */
    get capability(): GLCapability;
    /**
     * 当前帧的计数
     */
    get frameCount(): number;
    /**
     * 请求扩展
     * @param {String} ext 扩展名
     * @returns {Object|null} 请求结果，返回插件对象或null
     */
    requireExtension(ext: any): any;
    /**
     * 查询能否使用某些 GL 能力
     * */
    canIUse(capabilityType: GLCapabilityType): boolean;
    /**
     * 查询能否使用某种压缩纹理格式
     * */
    canIUseCompressedTextureInternalFormat(type: number): boolean;
    /** 是否能使用更多骨骼关节 */
    get canIUseMoreJoints(): boolean;
    /**
     * 设置视口区域
     * @param {number} x 用来设定视口的左下角水平坐标
     * @param {number} y 用来设定视口的左下角垂直坐标
     * @param {number} width 用来设定视口的宽度
     * @param {number} height 用来设定视口的高度
     */
    viewport(x: any, y: any, width: any, height: any): void;
    colorMask(r: any, g: any, b: any, a: any): void;
    /**
     * 在一帧的渲染开始时，处理内部状态
     */
    beginFrame(): void;
    /**
     * 清空渲染缓冲
     * @param {ClearMode} clearMode
     * @param {*} clearParam
     */
    clearRenderTarget(clearMode: any, clearParam: Vector4): void;
    /**
     * 使用指定的材质绘制一个 Primitive
     * @param {Primitive} primitive
     * @param {Material} mtl
     */
    drawPrimitive(primitive: any, group: any, mtl: any): void;
    /**
     * 把一个 Sprite 绘制需要的信息传进来
     * @param {Object} positionQuad  Sprite四个顶点的位置
     * @param {Object} uvRect        Sprite在texture上的纹理坐标
     * @param {vec4}   tintColor     颜色
     * @param {Texture}   texture    纹理信息
     * @param {String}    renderMode    绘制方式， '2D' 或者 '3D'
     * @param {Camera}   camera        相机信息
     */
    drawSprite(positionQuad: any, uvRect: any, tintColor: any, texture: any, renderMode: any, camera: Camera): void;
    /**
     * 给 SpriteRenderPass 在最后调用，确保所有 Sprite 绘制
     */
    flushSprite(): void;
    /**
     * 激活指定的RenderTarget
     * @param {RenderTarget} renderTarget  需要被激活的RenderTarget对象，如果未设置，则渲染到屏幕帧
     */
    activeRenderTarget(renderTarget: RenderTarget, camera: Camera): void;
    /** blit FBO */
    blitRenderTarget(renderTarget: RenderTarget): void;
    /**
     * 设置渲染到立方体纹理的面
     * @param {RenderTarget} renderTarget  需要设置的 RenderTarget 对象
     * @param {number} faceIndex - gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex
     * */
    setRenderTargetFace(renderTarget: RenderTarget, faceIndex: number): void;
    /**
     * 在一帧结束时，处理内部状态，释放 texture 缓存
     */
    endFrame(): void;
    /**
     * 释放资源
     */
    destroy(): void;
}
