'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var miniprogramAdapter = require('@ali/miniprogram-adapter');
var miniprogram = require('@oasis-engine/core/dist/miniprogram');

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var DRACOWorker = /*#__PURE__*/function () {
  _createClass(DRACOWorker, [{
    key: "currentLoad",
    // worker 实例
    // 记录每一个 task 的 byteLength
    // 当前政治处理的所有 task 的 byteLength 的和，排序用
    get: function get() {
      return this._currentLoad;
    }
  }]);

  function DRACOWorker(workerSourceURL, decoderWASMBinary) {
    var _this = this;

    _classCallCheck(this, DRACOWorker);

    this._worker = void 0;
    this._costs = {};
    this._currentLoad = 0;
    this._callbacks = {};
    this._worker = new Worker(workerSourceURL);

    this._worker.onmessage = function (e) {
      var message = e.data;

      switch (message.type) {
        case "decode":
          _this._callbacks[message.id].resolve(message.geometry);

          break;

        case "error":
          _this._callbacks[message.id].reject(message);

          break;

        default:
          miniprogram.Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
      }
    };

    if (decoderWASMBinary) {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {
          wasmBinary: decoderWASMBinary
        }
      });
    } else {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {}
      });
    }
  }

  _createClass(DRACOWorker, [{
    key: "setCosts",
    value: function setCosts(taskId, cost) {
      this._costs[taskId] = cost;
    }
  }, {
    key: "addCurrentLoad",
    value: function addCurrentLoad(cost) {
      this._currentLoad += cost;
    }
  }, {
    key: "setCallback",
    value: function setCallback(taskId, resolve, reject) {
      this._callbacks[taskId] = {
        resolve: resolve,
        reject: reject
      };
    }
  }, {
    key: "decode",
    value: function decode(taskId, taskConfig, buffer) {
      this._worker.postMessage({
        type: "decode",
        id: taskId,
        taskConfig: taskConfig,
        buffer: buffer
      }, [buffer]);
    }
  }, {
    key: "releaseTask",
    value: function releaseTask(taskId) {
      this._currentLoad -= this._costs[taskId];
      delete this._callbacks[taskId];
      delete this._costs[taskId];
    }
  }]);

  return DRACOWorker;
}();

var workerString = "let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n";

var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
var JS_FILE = "draco_decoder_gltf.js"; // basement cdn 不支持wasm后缀，暂时用r3bin后缀代替

var WASM_FILE = "draco_decoder_gltf.r3bin";
var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
var DRACODecoder = /*#__PURE__*/function () {
  function DRACODecoder() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      type: "wasm",
      workerLimit: 4
    };

    _classCallCheck(this, DRACODecoder);

    this.pool = [];
    this.workerLimit = Math.min(miniprogramAdapter.navigator.hardwareConcurrency || 4, 4);
    this.useJS = void 0;
    this.currentTaskId = 1;
    this.taskCache = new WeakMap();
    this.loadLibPromise = void 0;

    if (config.workerLimit > this.workerLimit) {
      miniprogram.Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
    } else {
      var _config$workerLimit;

      this.workerLimit = (_config$workerLimit = config.workerLimit) !== null && _config$workerLimit !== void 0 ? _config$workerLimit : 4;
    }

    this.useJS = (typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== "object" || config.type === "js";
    this.loadLibPromise = this.preloadLib();
  }

  _createClass(DRACODecoder, [{
    key: "preloadLib",
    value: function preloadLib() {
      var _this = this;

      if (this.loadLibPromise) {
        return this.loadLibPromise;
      }

      return new Promise(function (resolve, reject) {
        if (_this.useJS) {
          miniprogram.request("".concat(LIB_PATH).concat(JS_FILE), {
            type: "text"
          }).then(function (jsSource) {
            var body = [jsSource, workerString].join("\n");
            var workerSourceURL = URL.createObjectURL(new Blob([body]));
            resolve({
              workerSourceURL: workerSourceURL,
              decoderWASMBinary: null
            });
          })["catch"](function (reason) {
            reject(reason);
          });
        } else {
          Promise.all([miniprogram.request("".concat(LIB_PATH).concat(WASM_WRAPPER_FILE), {
            type: "text"
          }), miniprogram.request("".concat(LIB_PATH).concat(WASM_FILE), {
            type: "arraybuffer"
          })]).then(function (resources) {
            var _resources = _slicedToArray(resources, 2),
                wrapperSource = _resources[0],
                decoderWASMBinary = _resources[1];

            var body = [wrapperSource, workerString].join("\n");
            var workerSourceURL = URL.createObjectURL(new Blob([body]));
            resolve({
              workerSourceURL: workerSourceURL,
              decoderWASMBinary: decoderWASMBinary
            });
          })["catch"](function (reason) {
            reject(reason);
          });
        }
      });
    }
  }, {
    key: "getWorker",
    value: function getWorker() {
      var _this2 = this;

      return this.preloadLib().then(function (worderResources) {
        if (_this2.pool.length < _this2.workerLimit) {
          var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);

          _this2.pool.push(dracoWorker);
        } else {
          _this2.pool.sort(function (a, b) {
            return a.currentLoad > b.currentLoad ? -1 : 1;
          });
        }

        return _this2.pool[_this2.pool.length - 1];
      });
    }
  }, {
    key: "decode",
    value: function decode(buffer, taskConfig) {
      var _this3 = this;

      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred
      // again from this thread.

      if (this.taskCache.has(buffer)) {
        var cachedTask = this.taskCache.get(buffer);

        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          // 使用transferable传递数据后，原来环境中的数据会被清除，所以这里判断byteLength为0代表已经传输过
          // Technically, it would be possible to wait for the previous task to complete,
          // transfer the buffer back, and decode again with the second configuration. That
          // is complex, and I don't know of any reason to decode a Draco buffer twice in
          // different ways, so this is left unimplemented.
          throw new Error("DRACODecoder: Unable to re-decode a buffer with different " + "settings. Buffer has already been transferred.");
        }
      }

      var taskId = this.currentTaskId++;
      var cost = buffer.byteLength;
      var taskWorker;
      var task = new Promise(function (resolve, reject) {
        _this3.getWorker().then(function (worker) {
          taskWorker = worker;
          worker.setCosts(taskId, cost);
          worker.addCurrentLoad(cost);
          worker.setCallback(taskId, resolve, reject);
          worker.decode(taskId, taskConfig, buffer);
        })["catch"](function (e) {
          reject(e);
        });
      });
      task["finally"](function () {
        if (taskWorker && taskId) {
          taskWorker.releaseTask(taskId);
        }
      });
      this.taskCache.set(buffer, {
        key: taskKey,
        promise: task
      });
      return task;
    }
  }]);

  return DRACODecoder;
}();

exports.DRACODecoder = DRACODecoder;
