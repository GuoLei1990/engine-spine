'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var o3 = require('@alipay/o3');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

/**
 * Tween类
 * @class
 */
var Tween = /*#__PURE__*/function () {
  /**
   * @constructor
   */
  function Tween() {
    _classCallCheck(this, Tween);

    this._nextId = void 0;
    this.tweeners = void 0;
    this._nextId = 0;
    this.tweeners = {};
  }
  /**
   * 下一个id
   * @member {number}
   * @readonly
   */


  _createClass(Tween, [{
    key: "getId",
    value: function getId() {
      return this._nextId++;
    }
    /**
     * 增加关键帧
     * @param {Object} tweener 关键帧
     */

  }, {
    key: "add",
    value: function add(tweener) {
      if (!tweener.id) {
        tweener.id = this.getId();
      }

      this.tweeners[tweener.id] = tweener;
    }
    /**
     * 更新tween内部的状态,删除已经播放过且不需要的关键帧
     * @param {number}  deltaTime 两帧之间的时间
     */

  }, {
    key: "update",
    value: function update(deltaTime) {
      for (var tweenerId in this.tweeners) {
        var tweener = this.tweeners[tweenerId];
        tweener.update(deltaTime); // remove unused tweener

        if (tweener._played && tweener._paused && !tweener.preserved) {
          delete this.tweeners[tweenerId];
        }
      }
    }
  }]);

  return Tween;
}();

var LOOP_TYPE = {
  Restart: 0,
  Yoyo: 1 // 暂时不实现
  // Incremental: 2,

};

/**
 * Fork from https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */
// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === "function";

function A(aA1, aA2) {
  return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}

function B(aA1, aA2) {
  return 3.0 * aA2 - 6.0 * aA1;
}

function C(aA1) {
  return 3.0 * aA1;
} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


function getSlope(aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX,
      currentT,
      i = 0;

  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;

    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

  return currentT;
}

function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);

    if (currentSlope === 0.0) {
      return aGuessT;
    }

    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }

  return aGuessT;
}

function LinearEasing(x) {
  return x;
}

function bezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }

  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  } // Precompute samples table


  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }

  function getTForX(aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample; // Interpolate to provide an initial guess for t

    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing(x) {
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0 || x === 1) {
      return x;
    }

    return calcBezier(getTForX(x), mY1, mY2);
  };
}

function linear(t, b, c, d) {
  return c * t / d + b;
}
function easeInQuad(t, b, c, d) {
  return c * (t /= d) * t + b;
}
function easeOutQuad(t, b, c, d) {
  return -c * (t /= d) * (t - 2) + b;
}
function easeInOutQuad(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t + b;
  } else {
    return -c / 2 * (--t * (t - 2) - 1) + b;
  }
}
function easeInCubic(t, b, c, d) {
  return c * (t /= d) * t * t + b;
}
function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
function easeInOutCubic(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t + b;
  } else {
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }
}
function easeInQuart(t, b, c, d) {
  return c * (t /= d) * t * t * t + b;
}
function easeOutQuart(t, b, c, d) {
  return -c * ((t = t / d - 1) * t * t * t - 1) + b;
}
function easeInOutQuart(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t * t + b;
  } else {
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }
}
function easeInQuint(t, b, c, d) {
  return c * (t /= d) * t * t * t * t + b;
}
function easeOutQuint(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
}
function easeInOutQuint(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t * t * t + b;
  } else {
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }
}
function easeInSine(t, b, c, d) {
  return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
}
function easeOutSine(t, b, c, d) {
  return c * Math.sin(t / d * (Math.PI / 2)) + b;
}
function easeInOutSine(t, b, c, d) {
  return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
}
function easeInExpo(t, b, c, d) {
  var _ref;

  return (_ref = t === 0) !== null ? _ref : {
    b: c * Math.pow(2, 10 * (t / d - 1)) + b
  };
}
function easeOutExpo(t, b, c, d) {
  var _ref;

  return (_ref = t === d) !== null ? _ref : b + {
    c: c * (-Math.pow(2, -10 * t / d) + 1) + b
  };
}
function easeInOutExpo(t, b, c, d) {

  if ((t /= d / 2) < 1) {
    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
  } else {
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }
}
function easeInCirc(t, b, c, d) {
  return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
}
function easeOutCirc(t, b, c, d) {
  return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
}
function easeInOutCirc(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
  } else {
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }
}
function easeInElastic(t, b, c, d) {
  var a, p, s;
  s = 1.70158;
  p = 0;
  a = c;

  if (t === 0) ; else if ((t /= d) === 1) ;

  if (!p) {
    p = d * 0.3;
  }

  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }

  return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
}
function easeOutElastic(t, b, c, d) {
  var a, p, s;
  s = 1.70158;
  p = 0;
  a = c;

  if (t === 0) ; else if ((t /= d) === 1) ;

  if (!p) {
    p = d * 0.3;
  }

  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }

  return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
}
function easeInOutElastic(t, b, c, d) {
  var a, p, s;
  s = 1.70158;
  p = 0;
  a = c;

  if (t === 0) ; else if ((t /= d / 2) === 2) ;

  if (!p) {
    p = d * (0.3 * 1.5);
  }

  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }

  if (t < 1) {
    return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  } else {
    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
  }
}
function easeInBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }

  return c * (t /= d) * t * ((s + 1) * t - s) + b;
}
function easeOutBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }

  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
}
function easeInOutBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }

  if ((t /= d / 2) < 1) {
    return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
  } else {
    return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
  }
}
function easeInBounce(t, b, c, d) {
  var v;
  v = easeOutBounce(d - t, 0, c, d);
  return c - v + b;
}
function easeOutBounce(t, b, c, d) {
  if ((t /= d) < 1 / 2.75) {
    return c * (7.5625 * t * t) + b;
  } else if (t < 2 / 2.75) {
    return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
  } else if (t < 2.5 / 2.75) {
    return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
  } else {
    return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
  }
}
function easeInOutBounce(t, b, c, d) {
  var v;

  if (t < d / 2) {
    v = easeInBounce(t * 2, 0, c, d);
    return v * 0.5 + b;
  } else {
    v = easeOutBounce(t * 2 - d, 0, c, d);
    return v * 0.5 + c * 0.5 + b;
  }
}
/**
 * 通过bezier曲线控制点入参生成easing
 * Hats off to gre：https://github.com/gre/bezier-easing
 *
 * @param x1 控制点1的 x，范围 0-1
 * @param y1 控制点1的 y，范围 0-1
 * @param x2 控制点2的 x，范围 0-1
 * @param y2 控制点2的 y，范围 0-1
 */

function bezierEasing(x1, y1, x2, y2) {
  var easing = bezier(x1, y1, x2, y2);
  return function (t, b, c, d) {
    return c * easing(t / d) + b;
  };
}

var Easing = /*#__PURE__*/Object.freeze({
  __proto__: null,
  linear: linear,
  easeInQuad: easeInQuad,
  easeOutQuad: easeOutQuad,
  easeInOutQuad: easeInOutQuad,
  easeInCubic: easeInCubic,
  easeOutCubic: easeOutCubic,
  easeInOutCubic: easeInOutCubic,
  easeInQuart: easeInQuart,
  easeOutQuart: easeOutQuart,
  easeInOutQuart: easeInOutQuart,
  easeInQuint: easeInQuint,
  easeOutQuint: easeOutQuint,
  easeInOutQuint: easeInOutQuint,
  easeInSine: easeInSine,
  easeOutSine: easeOutSine,
  easeInOutSine: easeInOutSine,
  easeInExpo: easeInExpo,
  easeOutExpo: easeOutExpo,
  easeInOutExpo: easeInOutExpo,
  easeInCirc: easeInCirc,
  easeOutCirc: easeOutCirc,
  easeInOutCirc: easeInOutCirc,
  easeInElastic: easeInElastic,
  easeOutElastic: easeOutElastic,
  easeInOutElastic: easeInOutElastic,
  easeInBack: easeInBack,
  easeOutBack: easeOutBack,
  easeInOutBack: easeInOutBack,
  easeInBounce: easeInBounce,
  easeOutBounce: easeOutBounce,
  easeInOutBounce: easeInOutBounce,
  bezierEasing: bezierEasing
});

var noop = function noop() {}; // on events
// play, pause, complete, kill, rewind, update

/**
 * TweenBase类
 * @class
 * @private
 */


var TweenerBase = /*#__PURE__*/function () {
  function TweenerBase(getter, setter, endValue, interval) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, TweenerBase);

    this._time = void 0;
    this._paused = void 0;
    this._remainLoops = void 0;
    this._played = void 0;
    this.options = void 0;
    this.elapsedTime = void 0;
    this.interval = void 0;
    this.rewind = void 0;
    this.preserved = void 0;
    this.startValue = void 0;
    this.endValue = void 0;
    this.getter = void 0;
    this.setter = void 0;
    this.options = _objectSpread2({
      id: "",
      loops: {
        // set -1 as infinite
        count: 0,
        type: LOOP_TYPE.Yoyo
      },
      easing: linear,
      delay: 0,
      plugin: noop,
      pluginOptions: {},
      // callbacks
      onComplete: noop,
      onTick: noop
    }, options);
    this._time = 0;
    this._remainLoops = this.options.loops.count || 0;
    this._paused = true;
    this._played = false;
    this.rewind = false;
    this.preserved = false;
    this.elapsedTime = 0;
    this.startValue = getter();
    this.endValue = endValue;
    this.getter = getter;
    this.setter = setter;
    this.interval = interval;
  }

  _createClass(TweenerBase, [{
    key: "duration",
    value: function duration() {}
  }, {
    key: "update",
    value: function update(deltaTime) {}
    /**
     * 设置循环数
     * @param {number}  count 循环次数
     * @param {LOOP_TYPE} type 循环类型
     */

  }, {
    key: "setLoops",
    value: function setLoops(count) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LOOP_TYPE.Yoyo;
      this.options.loops = {
        count: count,
        type: type
      }; // reset loop

      this._remainLoops = count;
      return this;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      this.options = _objectSpread2(_objectSpread2({}, this.options), _defineProperty({}, key, value));
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.options.onComplete(this);
      this._paused = true;
      return this;
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this._paused) return false;
      this._paused = true;
      return this;
    }
  }, {
    key: "start",
    value: function start(tweenManager) {
      if (tweenManager) {
        tweenManager.add(this);
      }

      if (!this._paused) return false;
      this.elapsedTime = 0;
      this._paused = false;
      this._played = true;
      return this;
    }
  }]);

  return TweenerBase;
}();

// play, pause, complete, kill, rewind, update

/**
 * Tweener动画类
 * @extends TweenerBase
 */


var Tweener = /*#__PURE__*/function (_TweenerBase) {
  _inherits(Tweener, _TweenerBase);

  var _super = _createSuper(Tweener);

  /**
   * @constructor
   * @param {function} getter 获取函数
   * @param {function} setter 设置函数
   * @param {number} endValue 结束值
   * @param {number} interval 时间区间，以ms为单位
   * @param {Object} options 配置
   * @param target
   * @param {function} options.onComplete 完成时调用的函数
   */
  function Tweener(getter, setter, endValue, interval) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    var target = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

    _classCallCheck(this, Tweener);

    return _super.call(this, getter, setter, endValue, interval, options, target);
  }
  /** 计算Tween动画总时长
   * @member {number}
   */


  _createClass(Tweener, [{
    key: "duration",
    value: function duration() {
      // infinite
      var duration = 0;

      if (this.options.loops.count === -1) {
        duration = -1;
      } else {
        // FIXME: add rewind time
        duration = this.options.delay + this.options.loops.count * this.interval;
      }

      return duration;
    }
    /**
     * 更新tween中的状态,并检测动画是否要结束
     * @param {number} deltaTime 两帧之间的时间
     * @private
     */

  }, {
    key: "update",
    value: function update(deltaTime) {
      this._time += deltaTime;

      if (!this._paused) {
        // if delay don't update
        if (this.options.delay > this._time) {
          return true;
        }

        this.elapsedTime += deltaTime; // in case deltaTime is really big

        this.elapsedTime = this.elapsedTime > this.interval ? this.interval : this.elapsedTime; // on start callback

        this.options.plugin(this);
        this.options.onTick(this); // everything has an end....

        if (this.elapsedTime === this.interval) {
          // loop it
          if (this._remainLoops > 0 || this._remainLoops <= -1) {
            switch (this.options.loops.type) {
              case LOOP_TYPE.Yoyo:
                this.rewind = !this.rewind;
                this.elapsedTime = 0;

                if (!this.rewind) {
                  this._remainLoops--;
                }

                break;

              case LOOP_TYPE.Restart:
                // reset
                this.elapsedTime = 0;
                this._remainLoops--;
                break;
            }
          } else {
            this.stop();
          }
        }

        return true;
      }
    }
  }]);

  return Tweener;
}(TweenerBase);

var QuaternionPlugin = function QuaternionPlugin(tweener) {
  var easing = tweener.options.easing;
  var result = new o3.Quaternion();
  var percent = easing(tweener.elapsedTime, 0, 1, tweener.interval);
  o3.Quaternion.slerp(tweener.startValue, tweener.endValue, percent, result);
  tweener.setter(result);
};

var FloatPlugin = function FloatPlugin(tweener) {
  var easing = tweener.options.easing;
  var result = easing(tweener.elapsedTime, tweener.startValue, tweener.endValue - tweener.startValue, tweener.interval);
  tweener.setter(result);
};

var handleVecComp = function handleVecComp(tweener, comp, result) {
  var easing = tweener.options.easing;
  var startValue = tweener.startValue[comp];
  var offsetValue = tweener.endValue[comp] - tweener.startValue[comp];

  if (tweener.rewind) {
    startValue = tweener.endValue[comp];
    offsetValue = tweener.startValue[comp] - tweener.endValue[comp];
  }

  result[comp] = easing(tweener.elapsedTime, startValue, offsetValue, tweener.interval);
};

var VectorPluginGenerator = function VectorPluginGenerator(count) {
  return function (tweener) {
    var result;

    switch (count) {
      case 2:
        result = new o3.Vector2();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        break;

      case 3:
        result = new o3.Vector3();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        handleVecComp(tweener, "z", result);
        break;

      default:
        result = new o3.Vector4();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        handleVecComp(tweener, "z", result);
        handleVecComp(tweener, "w", result);
        break;
    }

    tweener.setter(result);
  };
};

var Vector2Plugin = VectorPluginGenerator(2);

var Vector3Plugin = VectorPluginGenerator(3);

var Vector4Plugin = VectorPluginGenerator(4);



var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  QuaternionPlugin: QuaternionPlugin,
  FloatPlugin: FloatPlugin,
  Vector2Plugin: Vector2Plugin,
  Vector3Plugin: Vector3Plugin,
  Vector4Plugin: Vector4Plugin
});

/***  做旋转的插值变换
 * @param {Object}  obj 物体
 * @param {quat} endValue 旋转终值(四元数)
 * @param {number} interval 时间区间
 * @param {Object} options 选项
 * @param {function} options.onComplete 完成后调用函数
 */

var doTransformRotate = function doTransformRotate(obj, endValue, interval) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  options.plugin = options.plugin || QuaternionPlugin;
  return new Tweener(function () {
    return obj.rotation.clone();
  }, function (value) {
    return obj.rotation = value;
  }, endValue, interval, options, obj);
};
/*** 做平移的插值变换
 * @param {Object}  obj 物体
 * @param {Vector3} endValue 平移终值
 * @param {number} interval 时间区间
 * @param {Object} options 选项
 * @param {function} options.onComplete 完成后调用函数
 */


var doTransformTranslate = function doTransformTranslate(obj, endValue, interval) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(function () {
    return obj.position.clone();
  }, function (value) {
    return obj.position = value;
  }, endValue, interval, options, obj);
};
/*** 做缩放的插值变换
 * @param {Object}  obj 物体
 * @param {Vector3} endValue 缩放终值
 * @param {number} interval 时间区间
 * @param {Object} options 选项
 * @param {function} options.onComplete 完成后调用函数
 */


var doTransformScale = function doTransformScale(obj, endValue, interval) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(function () {
    return obj.scale.clone();
  }, function (value) {
    return obj.scale = value;
  }, endValue, interval, options, obj);
};
/*** 做材质参数的插值变换
 * @param {Material}  mtl 材质
 * @param {*} endValue 材质参数终值
 * @param {string} property 材质属性
 * @param {number} interval 时间区间
 * @param {Object} options 选项
 * @param {function} options.onComplete 完成后调用函数
 */


var doMaterialValue = function doMaterialValue(mtl, endValue) {
  var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var interval = arguments.length > 3 ? arguments[3] : undefined;
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  options.plugin = options.plugin || FloatPlugin;
  return new Tweener(function () {
    return mtl.getValue(property);
  }, function (value) {
    return mtl.setValue(property, value);
  }, endValue, interval, options, mtl);
};
/*** 做材质颜色的插值变换
 * @param {Material}  mtl 材质
 * @param {Vector3} endValue 材质颜色终值
 * @param {string} property 材质属性
 * @param {number} interval 时间区间
 * @param {Object} options 选项
 * @param {function} options.onComplete 完成后调用函数
 */


var doMaterialColor = function doMaterialColor(mtl, endValue) {
  var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var interval = arguments.length > 3 ? arguments[3] : undefined;
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(function () {
    return mtl.getValue(property);
  }, function (value) {
    mtl.setValue(property, [value[0] / 255, value[1] / 255, value[2] / 255]);
  }, endValue, interval, options, mtl);
};
/*** 做一般数值的插值变换
 * @param {number|Vector2|Vector3|Vector4}  startValue 起始值
 * @param {function} setter 设置函数
 * @param {number|Vector2|Vector3|Vector4} endValue 终止值
 * @param interval
 * @param {Object} options 选项
 * @param {DataType} options.dataType
 * @param {function} options.onComplete 完成后调用函数
 */


var doTransformByDataType = function doTransformByDataType(startValue, setter, endValue, interval) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  if (options.dataType === o3.DataType.FLOAT_VEC2) {
    options.plugin = options.plugin || Vector2Plugin;
    return new Tweener(function () {
      return startValue.clone();
    }, setter, endValue, interval, options);
  } else if (options.dataType === o3.DataType.FLOAT_VEC3) {
    options.plugin = options.plugin || Vector3Plugin;
    return new Tweener(function () {
      return startValue.clone();
    }, setter, endValue, interval, options);
  } else if (options.dataType === o3.DataType.FLOAT_VEC4) {
    options.plugin = options.plugin || Vector3Plugin;
    return new Tweener(function () {
      return startValue.clone();
    }, setter, endValue, interval, options);
  } else {
    options.plugin = options.plugin || FloatPlugin;
    return new Tweener(function () {
      return startValue;
    }, setter, endValue, interval, options);
  }
};

var doTransform = {
  Rotate: doTransformRotate,
  Translate: doTransformTranslate,
  Scale: doTransformScale,
  DataType: doTransformByDataType
};
var doMaterial = {
  Float: doMaterialValue,
  Color: doMaterialColor
};

exports.Easing = Easing;
exports.LOOP_TYPE = LOOP_TYPE;
exports.Tween = Tween;
exports.TweenPlugins = index;
exports.Tweener = Tweener;
exports.doMaterial = doMaterial;
exports.doTransform = doTransform;
//# sourceMappingURL=main.js.map
