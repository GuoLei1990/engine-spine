{"version":3,"file":"module.js","sources":["../src/DRACOWorker.ts","../src/decoder.ts"],"sourcesContent":["import { Logger } from \"@oasis-engine/core\";\n\nexport class DRACOWorker {\n  // worker 实例\n  private _worker: Worker;\n  // 记录每一个 task 的 byteLength\n  private _costs: { [taskId: number]: number } = {};\n  // 当前政治处理的所有 task 的 byteLength 的和，排序用\n  private _currentLoad: number = 0;\n  private _callbacks: { [taskId: number]: IResolveReject } = {};\n  get currentLoad(): number {\n    return this._currentLoad;\n  }\n\n  constructor(workerSourceURL: string, decoderWASMBinary?: ArrayBuffer) {\n    this._worker = new Worker(workerSourceURL);\n    this._worker.onmessage = (e) => {\n      const message = e.data;\n      switch (message.type) {\n        case \"decode\":\n          this._callbacks[message.id].resolve(message.geometry);\n          break;\n\n        case \"error\":\n          this._callbacks[message.id].reject(message);\n          break;\n        default:\n          Logger.error('DRACOWorker: Unexpected message, \"' + message.type + '\"');\n      }\n    };\n    if (decoderWASMBinary) {\n      this._worker.postMessage({ type: \"init\", decoderConfig: { wasmBinary: decoderWASMBinary } });\n    } else {\n      this._worker.postMessage({ type: \"init\", decoderConfig: {} });\n    }\n  }\n\n  setCosts(taskId: number, cost: number) {\n    this._costs[taskId] = cost;\n  }\n\n  addCurrentLoad(cost: number) {\n    this._currentLoad += cost;\n  }\n\n  setCallback(taskId: number, resolve: (any) => void, reject: (any) => void) {\n    this._callbacks[taskId] = { resolve, reject };\n  }\n\n  decode(taskId: number, taskConfig: ITaskConfig, buffer: ArrayBuffer) {\n    this._worker.postMessage({ type: \"decode\", id: taskId, taskConfig, buffer }, [buffer]);\n  }\n\n  releaseTask(taskId: number) {\n    this._currentLoad -= this._costs[taskId];\n    delete this._callbacks[taskId];\n    delete this._costs[taskId];\n  }\n}\n\ninterface IResolveReject {\n  resolve: (any) => void;\n  reject: (any) => void;\n}\n\nexport interface ITaskConfig {\n  attributeIDs: { [attribute: string]: number };\n  attributeTypes: { [attribute: string]: string };\n  useUniqueIDs: boolean;\n  indexType: string;\n}\n","import { Logger, request } from \"@oasis-engine/core\";\n\nimport { DRACOWorker, ITaskConfig } from \"./DRACOWorker\";\n\nimport workerString from \"./worker/worker.js\";\n\nconst LIB_PATH = \"https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/\";\nconst JS_FILE = \"draco_decoder_gltf.js\";\n// basement cdn 不支持wasm后缀，暂时用r3bin后缀代替\nconst WASM_FILE = \"draco_decoder_gltf.r3bin\";\nconst WASM_WRAPPER_FILE = \"draco_wasm_wrapper_gltf.js\";\n\nexport class DRACODecoder {\n  private pool: DRACOWorker[] = [];\n  private workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);\n  private useJS: boolean;\n  private currentTaskId: number = 1;\n  private taskCache = new WeakMap();\n  private loadLibPromise: Promise<any>;\n\n  constructor(config: IDecoderConfig = { type: \"wasm\", workerLimit: 4 }) {\n    if (config.workerLimit > this.workerLimit) {\n      Logger.warn(\"DRACOWorkerPool: Can not initialize worker pool with limit:\" + config.workerLimit);\n    } else {\n      this.workerLimit = config.workerLimit ?? 4;\n    }\n    this.useJS = typeof WebAssembly !== \"object\" || config.type === \"js\";\n    this.loadLibPromise = this.preloadLib();\n  }\n\n  private preloadLib(): Promise<any> {\n    if (this.loadLibPromise) {\n      return this.loadLibPromise;\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.useJS) {\n        request(`${LIB_PATH}${JS_FILE}`, { type: \"text\" })\n          .then((jsSource) => {\n            const body = [jsSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary: null });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      } else {\n        Promise.all([\n          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, { type: \"text\" }),\n          request(`${LIB_PATH}${WASM_FILE}`, { type: \"arraybuffer\" })\n        ])\n          .then((resources) => {\n            const [wrapperSource, decoderWASMBinary] = resources;\n            const body = [wrapperSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      }\n    });\n  }\n\n  private getWorker(): Promise<DRACOWorker> {\n    return this.preloadLib().then((worderResources) => {\n      if (this.pool.length < this.workerLimit) {\n        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);\n        this.pool.push(dracoWorker);\n      } else {\n        this.pool.sort(function (a, b) {\n          return a.currentLoad > b.currentLoad ? -1 : 1;\n        });\n      }\n      return this.pool[this.pool.length - 1];\n    });\n  }\n\n  decode(buffer: ArrayBuffer, taskConfig: ITaskConfig): Promise<any> {\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (this.taskCache.has(buffer)) {\n      const cachedTask = this.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // 使用transferable传递数据后，原来环境中的数据会被清除，所以这里判断byteLength为0代表已经传输过\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          \"DRACODecoder: Unable to re-decode a buffer with different \" +\n            \"settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n\n    const taskId = this.currentTaskId++;\n    const cost = buffer.byteLength;\n    let taskWorker;\n    const task = new Promise((resolve, reject) => {\n      this.getWorker()\n        .then((worker) => {\n          taskWorker = worker;\n          worker.setCosts(taskId, cost);\n          worker.addCurrentLoad(cost);\n\n          worker.setCallback(taskId, resolve, reject);\n          worker.decode(taskId, taskConfig, buffer);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    task.finally(() => {\n      if (taskWorker && taskId) {\n        taskWorker.releaseTask(taskId);\n      }\n    });\n\n    this.taskCache.set(buffer, {\n      key: taskKey,\n      promise: task\n    });\n    return task;\n  }\n}\n\ninterface IDecoderConfig {\n  type?: \"js\" | \"wasm\";\n  workerLimit?: number;\n}\n"],"names":["DRACOWorker2"],"mappings":"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"}