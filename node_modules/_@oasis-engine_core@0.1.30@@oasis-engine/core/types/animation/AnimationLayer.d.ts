import { EventDispatcher } from "../base/EventDispatcher";
import { Entity } from "../Entity";
import { AnimationClip } from "./AnimationClip";
import { WrapMode } from "./AnimationConst";
import { AnimationOptions, IChannelTarget } from "./types";
/**
 * AnimationClip playback
 * @extends EventDispatcher
 * @see class AnimationClip
 * @private
 */
export declare class AnimationLayer extends EventDispatcher {
    /**
     * @return is playing˝
     */
    get isPlaying(): boolean;
    layerWeight: number;
    mixTagetLayer: AnimationLayer;
    isFading: number;
    fadeDeltaTime: number;
    crossFadeDuration: number;
    fadeDuration: number;
    crossFadeDeltaTime: number;
    isMixLayer: boolean;
    hasMixLayer: boolean;
    mixEntity: Entity;
    private _activedEvents;
    private _animClip;
    private _isPlaying;
    private _wrapMode;
    private _channelStates;
    private _animClipLength;
    private _frameEvents;
    /**
     * @constructor
     */
    constructor();
    /**
     * @param {AnimationClip} nextAnimClip, anim clip to playback next
     * @param {Entity} rootEntity
     * @return can mix with current AnimationClip
     */
    canMix(nextAnimClip: AnimationClip, rootEntity: Entity): boolean;
    /**
     * mix animClip with target animationLayer
     * @param {AnimationClip} animClip, anim clip to mix
     * @param {AnimationLayer} targetLayer, target animationLayer
     * @param {Entity} rootEntity, root node of skeleton animation
     * @param {Entity} mixNode, mix bone node
     * @param {AnimationOptions} options, animation events options
     */
    mix(animClip: AnimationClip, targetLayer: AnimationLayer, rootEntity: Entity, mixEntity: Entity, options?: {
        wrapMode?: WrapMode;
    }): boolean;
    removeMixWeight(): void;
    /**
     * play specify anim clip
     * @param {AnimationClip} animClip, anim clip to playback
     * @param {Entity} rootEntity, root node of Skeleton Animation
     * @param {AnimationOptions} options
     */
    play(animClip: AnimationClip, rootEntity: Entity, options?: AnimationOptions): false | IChannelTarget[];
    /**
     * stop play anim clip
     * @param {boolean} rightnow stop it immediately, or it will stop at the end of the clip
     */
    stop(rightnow: boolean): void;
    /**
     * update animation states only
     * @param {number} deltaTime
     */
    updateState(deltaTime: number): void;
    /**
     * @return channel layer weight
     * @param {number} channelIndex
     */
    getChannelLayerWeight(channelIndex: number): number;
    /**
     * @return channel value
     * @param {number} channelIndex
     */
    getChannelValue(channelIndex: number): import("./types").Value;
    /**
     * 触发动画事件
     */
    triggerEvents(): void;
    /**
     * 跳转到某一帧
     * @param {number} frameTime
     */
    jumpToFrame(frameTime: number): void;
    /**
     * update state and value of channel
     * @param {float} deltaTime
     * @param {number} channelIndex
     * @private
     */
    _updateChannelState(deltaTime: any, channelIndex: any): boolean;
    /**
     * @param {Object} add animation events
     * @private
     */
    private _addEvents;
    /**
     * 激活动画事件
     * @param {number} deltaTime
     * @private
     */
    private _activeEvents;
    /**
     * update state of channel
     * @param {Entity} rootNode
     * @param {object} target
     * @private
     */
    private _findChannelTarget;
    /**
     * @return current and next key id, current alpha
     * @param {number} channel
     * @param {float} time
     * @private
     */
    private _getKeyAndAlpha;
}
