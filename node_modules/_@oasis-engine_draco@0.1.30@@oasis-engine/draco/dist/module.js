import { Logger, request } from '@oasis-engine/core';

class DRACOWorker {
  constructor(workerSourceURL, decoderWASMBinary) {
    this._costs = {};
    this._currentLoad = 0;
    this._callbacks = {};
    this._worker = new Worker(workerSourceURL);
    this._worker.onmessage = (e) => {
      const message = e.data;
      switch (message.type) {
        case "decode":
          this._callbacks[message.id].resolve(message.geometry);
          break;
        case "error":
          this._callbacks[message.id].reject(message);
          break;
        default:
          Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
      }
    };
    if (decoderWASMBinary) {
      this._worker.postMessage({type: "init", decoderConfig: {wasmBinary: decoderWASMBinary}});
    } else {
      this._worker.postMessage({type: "init", decoderConfig: {}});
    }
  }
  get currentLoad() {
    return this._currentLoad;
  }
  setCosts(taskId, cost) {
    this._costs[taskId] = cost;
  }
  addCurrentLoad(cost) {
    this._currentLoad += cost;
  }
  setCallback(taskId, resolve, reject) {
    this._callbacks[taskId] = {resolve, reject};
  }
  decode(taskId, taskConfig, buffer) {
    this._worker.postMessage({type: "decode", id: taskId, taskConfig, buffer}, [buffer]);
  }
  releaseTask(taskId) {
    this._currentLoad -= this._costs[taskId];
    delete this._callbacks[taskId];
    delete this._costs[taskId];
  }
}

var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';

const LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
const JS_FILE = "draco_decoder_gltf.js";
const WASM_FILE = "draco_decoder_gltf.r3bin";
const WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
class DRACODecoder {
  constructor(config = {type: "wasm", workerLimit: 4}) {
    this.pool = [];
    this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
    this.currentTaskId = 1;
    this.taskCache = new WeakMap();
    if (config.workerLimit > this.workerLimit) {
      Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
    } else {
      this.workerLimit = config.workerLimit ?? 4;
    }
    this.useJS = typeof WebAssembly !== "object" || config.type === "js";
    this.loadLibPromise = this.preloadLib();
  }
  preloadLib() {
    if (this.loadLibPromise) {
      return this.loadLibPromise;
    }
    return new Promise((resolve, reject) => {
      if (this.useJS) {
        request(`${LIB_PATH}${JS_FILE}`, {type: "text"}).then((jsSource) => {
          const body = [jsSource, workerString].join("\n");
          const workerSourceURL = URL.createObjectURL(new Blob([body]));
          resolve({workerSourceURL, decoderWASMBinary: null});
        }).catch((reason) => {
          reject(reason);
        });
      } else {
        Promise.all([
          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, {type: "text"}),
          request(`${LIB_PATH}${WASM_FILE}`, {type: "arraybuffer"})
        ]).then((resources) => {
          const [wrapperSource, decoderWASMBinary] = resources;
          const body = [wrapperSource, workerString].join("\n");
          const workerSourceURL = URL.createObjectURL(new Blob([body]));
          resolve({workerSourceURL, decoderWASMBinary});
        }).catch((reason) => {
          reject(reason);
        });
      }
    });
  }
  getWorker() {
    return this.preloadLib().then((worderResources) => {
      if (this.pool.length < this.workerLimit) {
        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
        this.pool.push(dracoWorker);
      } else {
        this.pool.sort(function(a, b) {
          return a.currentLoad > b.currentLoad ? -1 : 1;
        });
      }
      return this.pool[this.pool.length - 1];
    });
  }
  decode(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (this.taskCache.has(buffer)) {
      const cachedTask = this.taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error("DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
    }
    const taskId = this.currentTaskId++;
    const cost = buffer.byteLength;
    let taskWorker;
    const task = new Promise((resolve, reject) => {
      this.getWorker().then((worker2) => {
        taskWorker = worker2;
        worker2.setCosts(taskId, cost);
        worker2.addCurrentLoad(cost);
        worker2.setCallback(taskId, resolve, reject);
        worker2.decode(taskId, taskConfig, buffer);
      }).catch((e) => {
        reject(e);
      });
    });
    task.finally(() => {
      if (taskWorker && taskId) {
        taskWorker.releaseTask(taskId);
      }
    });
    this.taskCache.set(buffer, {
      key: taskKey,
      promise: task
    });
    return task;
  }
}

export { DRACODecoder };
//# sourceMappingURL=module.js.map
