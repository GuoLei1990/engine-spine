import { D as DataType, Q as Quaternion, V as Vector4, a as Vector3, b as Vector2, S as Script, c as Spherical, M as MathUtil } from '../common/module-a3d382dc.js';

class Tween {
  constructor() {
    this._nextId = 0;
    this.tweeners = {};
  }
  getId() {
    return this._nextId++;
  }
  add(tweener) {
    if (!tweener.id) {
      tweener.id = this.getId();
    }
    this.tweeners[tweener.id] = tweener;
  }
  update(deltaTime) {
    for (const tweenerId in this.tweeners) {
      const tweener = this.tweeners[tweenerId];
      tweener.update(deltaTime);
      if (tweener._played && tweener._paused && !tweener.preserved) {
        delete this.tweeners[tweenerId];
      }
    }
  }
}

const LOOP_TYPE = {
  Restart: 0,
  Yoyo: 1
};

var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
function A(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
}
function B(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
}
function C(aA1) {
  return 3 * aA1;
}
function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
function getSlope(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
function LinearEasing(x) {
  return x;
}
function bezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }
  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return function BezierEasing(x) {
    if (x === 0 || x === 1) {
      return x;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
}

function linear(t, b, c, d) {
  return c * t / d + b;
}
function easeInQuad(t, b, c, d) {
  return c * (t /= d) * t + b;
}
function easeOutQuad(t, b, c, d) {
  return -c * (t /= d) * (t - 2) + b;
}
function easeInOutQuad(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t + b;
  } else {
    return -c / 2 * (--t * (t - 2) - 1) + b;
  }
}
function easeInCubic(t, b, c, d) {
  return c * (t /= d) * t * t + b;
}
function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
function easeInOutCubic(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t + b;
  } else {
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }
}
function easeInQuart(t, b, c, d) {
  return c * (t /= d) * t * t * t + b;
}
function easeOutQuart(t, b, c, d) {
  return -c * ((t = t / d - 1) * t * t * t - 1) + b;
}
function easeInOutQuart(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t * t + b;
  } else {
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }
}
function easeInQuint(t, b, c, d) {
  return c * (t /= d) * t * t * t * t + b;
}
function easeOutQuint(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
}
function easeInOutQuint(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * t * t * t * t * t + b;
  } else {
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }
}
function easeInSine(t, b, c, d) {
  return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
}
function easeOutSine(t, b, c, d) {
  return c * Math.sin(t / d * (Math.PI / 2)) + b;
}
function easeInOutSine(t, b, c, d) {
  return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
}
function easeInExpo(t, b, c, d) {
  let _ref;
  return (_ref = t === 0) !== null ? _ref : {
    b: c * Math.pow(2, 10 * (t / d - 1)) + b
  };
}
function easeOutExpo(t, b, c, d) {
  let _ref;
  return (_ref = t === d) !== null ? _ref : b + {
    c: c * (-Math.pow(2, -10 * t / d) + 1) + b
  };
}
function easeInOutExpo(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
  } else {
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }
}
function easeInCirc(t, b, c, d) {
  return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
}
function easeOutCirc(t, b, c, d) {
  return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
}
function easeInOutCirc(t, b, c, d) {
  if ((t /= d / 2) < 1) {
    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
  } else {
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }
}
function easeInElastic(t, b, c, d) {
  let a, p, s;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) ; else if ((t /= d) === 1) ;
  if (!p) {
    p = d * 0.3;
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
}
function easeOutElastic(t, b, c, d) {
  let a, p, s;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) ; else if ((t /= d) === 1) ;
  if (!p) {
    p = d * 0.3;
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
}
function easeInOutElastic(t, b, c, d) {
  let a, p, s;
  s = 1.70158;
  p = 0;
  a = c;
  if (t === 0) ; else if ((t /= d / 2) === 2) ;
  if (!p) {
    p = d * (0.3 * 1.5);
  }
  if (a < Math.abs(c)) {
    a = c;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(c / a);
  }
  if (t < 1) {
    return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  } else {
    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
  }
}
function easeInBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }
  return c * (t /= d) * t * ((s + 1) * t - s) + b;
}
function easeOutBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }
  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
}
function easeInOutBack(t, b, c, d, s) {
  if (s === void 0) {
    s = 1.70158;
  }
  if ((t /= d / 2) < 1) {
    return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
  } else {
    return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
  }
}
function easeInBounce(t, b, c, d) {
  let v;
  v = easeOutBounce(d - t, 0, c, d);
  return c - v + b;
}
function easeOutBounce(t, b, c, d) {
  if ((t /= d) < 1 / 2.75) {
    return c * (7.5625 * t * t) + b;
  } else if (t < 2 / 2.75) {
    return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
  } else if (t < 2.5 / 2.75) {
    return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
  } else {
    return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
  }
}
function easeInOutBounce(t, b, c, d) {
  let v;
  if (t < d / 2) {
    v = easeInBounce(t * 2, 0, c, d);
    return v * 0.5 + b;
  } else {
    v = easeOutBounce(t * 2 - d, 0, c, d);
    return v * 0.5 + c * 0.5 + b;
  }
}
function bezierEasing(x1, y1, x2, y2) {
  const easing = bezier(x1, y1, x2, y2);
  return (t, b, c, d) => {
    return c * easing(t / d) + b;
  };
}

var Easing = /*#__PURE__*/Object.freeze({
  __proto__: null,
  linear: linear,
  easeInQuad: easeInQuad,
  easeOutQuad: easeOutQuad,
  easeInOutQuad: easeInOutQuad,
  easeInCubic: easeInCubic,
  easeOutCubic: easeOutCubic,
  easeInOutCubic: easeInOutCubic,
  easeInQuart: easeInQuart,
  easeOutQuart: easeOutQuart,
  easeInOutQuart: easeInOutQuart,
  easeInQuint: easeInQuint,
  easeOutQuint: easeOutQuint,
  easeInOutQuint: easeInOutQuint,
  easeInSine: easeInSine,
  easeOutSine: easeOutSine,
  easeInOutSine: easeInOutSine,
  easeInExpo: easeInExpo,
  easeOutExpo: easeOutExpo,
  easeInOutExpo: easeInOutExpo,
  easeInCirc: easeInCirc,
  easeOutCirc: easeOutCirc,
  easeInOutCirc: easeInOutCirc,
  easeInElastic: easeInElastic,
  easeOutElastic: easeOutElastic,
  easeInOutElastic: easeInOutElastic,
  easeInBack: easeInBack,
  easeOutBack: easeOutBack,
  easeInOutBack: easeInOutBack,
  easeInBounce: easeInBounce,
  easeOutBounce: easeOutBounce,
  easeInOutBounce: easeInOutBounce,
  bezierEasing: bezierEasing
});

const noop = () => {
};
class TweenerBase {
  constructor(getter, setter, endValue, interval, options = {}, target) {
    this.options = {
      id: "",
      loops: {
        count: 0,
        type: LOOP_TYPE.Yoyo
      },
      easing: linear,
      delay: 0,
      plugin: noop,
      pluginOptions: {},
      onComplete: noop,
      onTick: noop,
      ...options
    };
    this._time = 0;
    this._remainLoops = this.options.loops.count || 0;
    this._paused = true;
    this._played = false;
    this.rewind = false;
    this.preserved = false;
    this.elapsedTime = 0;
    this.startValue = getter();
    this.endValue = endValue;
    this.getter = getter;
    this.setter = setter;
    this.interval = interval;
  }
  duration() {
  }
  update(deltaTime) {
  }
  setLoops(count, type = LOOP_TYPE.Yoyo) {
    this.options.loops = {count, type};
    this._remainLoops = count;
    return this;
  }
  set(key, value) {
    this.options = {...this.options, ...{[key]: value}};
    return this;
  }
  stop() {
    this.options.onComplete(this);
    this._paused = true;
    return this;
  }
  pause() {
    if (this._paused)
      return false;
    this._paused = true;
    return this;
  }
  start(tweenManager) {
    if (tweenManager) {
      tweenManager.add(this);
    }
    if (!this._paused)
      return false;
    this.elapsedTime = 0;
    this._paused = false;
    this._played = true;
    return this;
  }
}

class Tweener extends TweenerBase {
  constructor(getter, setter, endValue, interval, options = {}, target = null) {
    super(getter, setter, endValue, interval, options, target);
  }
  duration() {
    let duration = 0;
    if (this.options.loops.count === -1) {
      duration = -1;
    } else {
      duration = this.options.delay + this.options.loops.count * this.interval;
    }
    return duration;
  }
  update(deltaTime) {
    this._time += deltaTime;
    if (!this._paused) {
      if (this.options.delay > this._time) {
        return true;
      }
      this.elapsedTime += deltaTime;
      this.elapsedTime = this.elapsedTime > this.interval ? this.interval : this.elapsedTime;
      this.options.plugin(this);
      this.options.onTick(this);
      if (this.elapsedTime === this.interval) {
        if (this._remainLoops > 0 || this._remainLoops <= -1) {
          switch (this.options.loops.type) {
            case LOOP_TYPE.Yoyo:
              this.rewind = !this.rewind;
              this.elapsedTime = 0;
              if (!this.rewind) {
                this._remainLoops--;
              }
              break;
            case LOOP_TYPE.Restart:
              this.elapsedTime = 0;
              this._remainLoops--;
              break;
          }
        } else {
          this.stop();
        }
      }
      return true;
    }
  }
}

const QuaternionPlugin = (tweener) => {
  const {easing} = tweener.options;
  const result = new Quaternion();
  const percent = easing(tweener.elapsedTime, 0, 1, tweener.interval);
  Quaternion.slerp(tweener.startValue, tweener.endValue, percent, result);
  tweener.setter(result);
};

const FloatPlugin = (tweener) => {
  const easing = tweener.options.easing;
  const result = easing(tweener.elapsedTime, tweener.startValue, tweener.endValue - tweener.startValue, tweener.interval);
  tweener.setter(result);
};

const handleVecComp = (tweener, comp, result) => {
  const easing = tweener.options.easing;
  let startValue = tweener.startValue[comp];
  let offsetValue = tweener.endValue[comp] - tweener.startValue[comp];
  if (tweener.rewind) {
    startValue = tweener.endValue[comp];
    offsetValue = tweener.startValue[comp] - tweener.endValue[comp];
  }
  result[comp] = easing(tweener.elapsedTime, startValue, offsetValue, tweener.interval);
};
const VectorPluginGenerator = (count) => {
  return (tweener) => {
    let result;
    switch (count) {
      case 2:
        result = new Vector2();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        break;
      case 3:
        result = new Vector3();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        handleVecComp(tweener, "z", result);
        break;
      default:
        result = new Vector4();
        handleVecComp(tweener, "x", result);
        handleVecComp(tweener, "y", result);
        handleVecComp(tweener, "z", result);
        handleVecComp(tweener, "w", result);
        break;
    }
    tweener.setter(result);
  };
};

const Vector2Plugin = VectorPluginGenerator(2);

const Vector3Plugin = VectorPluginGenerator(3);

const doTransformRotate = (obj, endValue, interval, options = {}) => {
  options.plugin = options.plugin || QuaternionPlugin;
  return new Tweener(() => obj.rotation.clone(), (value) => obj.rotation = value, endValue, interval, options, obj);
};
const doTransformTranslate = (obj, endValue, interval, options = {}) => {
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(() => obj.position.clone(), (value) => obj.position = value, endValue, interval, options, obj);
};
const doTransformScale = (obj, endValue, interval, options = {}) => {
  options.plugin = options.plugin || Vector3Plugin;
  return new Tweener(() => obj.scale.clone(), (value) => obj.scale = value, endValue, interval, options, obj);
};
const doTransformByDataType = (startValue, setter, endValue, interval, options = {}) => {
  if (options.dataType === DataType.FLOAT_VEC2) {
    options.plugin = options.plugin || Vector2Plugin;
    return new Tweener(() => startValue.clone(), setter, endValue, interval, options);
  } else if (options.dataType === DataType.FLOAT_VEC3) {
    options.plugin = options.plugin || Vector3Plugin;
    return new Tweener(() => startValue.clone(), setter, endValue, interval, options);
  } else if (options.dataType === DataType.FLOAT_VEC4) {
    options.plugin = options.plugin || Vector3Plugin;
    return new Tweener(() => startValue.clone(), setter, endValue, interval, options);
  } else {
    options.plugin = options.plugin || FloatPlugin;
    return new Tweener(() => startValue, setter, endValue, interval, options);
  }
};
const doTransform = {
  Rotate: doTransformRotate,
  Translate: doTransformTranslate,
  Scale: doTransformScale,
  DataType: doTransformByDataType
};

const ESP = MathUtil.zeroTolerance;
function includes(array, ...filterArray) {
  return filterArray.some((e) => array.indexOf(e) !== -1);
}
const tween2 = new Tween();
class FreeControl extends Script {
  constructor(entity) {
    super(entity);
    this._forward = new Vector3();
    this._right = new Vector3();
    this.tempVec3 = new Vector3();
    this.camera = entity;
    this.mainElement = this.scene.engine.canvas._webCanvas;
    this.domElement = document;
    this.movementSpeed = 1;
    this.rotateSpeed = 1;
    this.floorMock = true;
    this.floorY = 0;
    this.jumpY = 1;
    this.jumpDuration = 600;
    this.press = false;
    this.keysForward = ["KeyW", "ArrowUp"];
    this.keysBackward = ["KeyS", "ArrowDown"];
    this.keysLeft = ["KeyA", "ArrowLeft"];
    this.keysRight = ["KeyD", "ArrowRight"];
    this.keysJump = ["Space"];
    this._theta = 0;
    this._phi = 0;
    this._moveForward = false;
    this._moveBackward = false;
    this._moveLeft = false;
    this._moveRight = false;
    this._moveJump = false;
    this._v3Cache = new Vector3();
    this._spherical = new Spherical();
    this._rotateOri = [0, 0];
    this._events = [
      {type: "mousemove", listener: this.onMouseMove.bind(this)},
      {type: "touchmove", listener: this.onMouseMove.bind(this)},
      {type: "mousedown", listener: this.onMouseDown.bind(this)},
      {type: "touchstart", listener: this.onMouseDown.bind(this)},
      {type: "mouseup", listener: this.onMouseUp.bind(this)},
      {type: "touchend", listener: this.onMouseUp.bind(this)},
      {type: "keydown", listener: this.onKeyDown.bind(this), element: window},
      {type: "keyup", listener: this.onKeyUp.bind(this), element: window},
      {type: "contextmenu", listener: this.onContextMenu.bind(this)}
    ];
    this.initEvents();
    this.updateSpherical();
  }
  onContextMenu(event) {
    event.preventDefault();
  }
  onKeyDown(event) {
    const {code, key, keyCode} = event;
    if (includes(this.keysForward, code, key, keyCode)) {
      this._moveForward = true;
    } else if (includes(this.keysBackward, code, key, keyCode)) {
      this._moveBackward = true;
    } else if (includes(this.keysLeft, code, key, keyCode)) {
      this._moveLeft = true;
    } else if (includes(this.keysRight, code, key, keyCode)) {
      this._moveRight = true;
    } else if (includes(this.keysJump, code, key, keyCode)) {
      this.jump();
    }
  }
  onKeyUp(event) {
    const {code, key, keyCode} = event;
    if (includes(this.keysForward, code, key, keyCode)) {
      this._moveForward = false;
    } else if (includes(this.keysBackward, code, key, keyCode)) {
      this._moveBackward = false;
    } else if (includes(this.keysLeft, code, key, keyCode)) {
      this._moveLeft = false;
    } else if (includes(this.keysRight, code, key, keyCode)) {
      this._moveRight = false;
    }
  }
  onMouseDown(event) {
    event.stopPropagation();
    event = event.changedTouches && event.changedTouches[0] || event;
    if (this.domElement !== document) {
      this.domElement.focus();
    }
    this.press = true;
    this._rotateOri = [event.clientX, event.clientY];
  }
  onMouseUp(event) {
    event.preventDefault();
    event.stopPropagation();
    this.press = false;
  }
  onMouseMove(event) {
    if (this.press === false)
      return;
    if (this.enabled === false)
      return;
    event.preventDefault();
    event.stopPropagation();
    event = event.changedTouches && event.changedTouches[0] || event;
    const movementX = event.clientX - this._rotateOri[0];
    const movementY = event.clientY - this._rotateOri[1];
    this._rotateOri[0] = event.clientX;
    this._rotateOri[1] = event.clientY;
    const factorX = 180 / this.mainElement.width;
    const factorY = 180 / this.mainElement.height;
    const actualX = movementX * factorX;
    const actualY = movementY * factorY;
    this.rotate(-actualX, actualY);
  }
  rotate(alpha = 0, beta = 0) {
    this._theta += MathUtil.degreeToRadian(alpha);
    this._phi += MathUtil.degreeToRadian(beta);
    this._phi = MathUtil.clamp(this._phi, ESP, Math.PI - ESP);
    this._spherical.theta = this._theta;
    this._spherical.phi = this._phi;
    this._spherical.setToVec3(this._v3Cache);
    Vector3.add(this.camera.position, this._v3Cache, this._v3Cache);
    this.camera.transform.lookAt(this._v3Cache, new Vector3(0, 1, 0));
  }
  jump() {
    if (this._moveJump)
      return;
    this._moveJump = true;
    let p = this.camera.position;
    doTransform.Translate(this.camera, new Vector3(p.x, this.jumpY, p.z), this.jumpDuration / 2, {
      easing: Easing.easeOutSine,
      onComplete: () => {
        doTransform.Translate(this.camera, new Vector3(p.x, this.floorY, p.z), this.jumpDuration / 2, {
          easing: Easing.easeInSine,
          onComplete: () => {
            this._moveJump = false;
          }
        }).start(tween2);
      }
    }).start(tween2);
  }
  translateOnAxis(axis, distance, v3 = this.camera.position) {
    const diff = new Vector3();
    Vector3.normalize(axis, diff);
    v3.add(diff.scale(distance));
  }
  onUpdate(delta) {
    if (this.enabled === false)
      return;
    const actualMoveSpeed = delta / 1e3 * this.movementSpeed;
    this.camera.transform.getWorldForward(this._forward);
    this.camera.transform.getWorldRight(this._right);
    if (this._moveForward) {
      this.translateOnAxis(this._forward, actualMoveSpeed);
    }
    if (this._moveBackward) {
      this.translateOnAxis(this._forward, -actualMoveSpeed);
    }
    if (this._moveLeft) {
      this.translateOnAxis(this._right, -actualMoveSpeed);
    }
    if (this._moveRight) {
      this.translateOnAxis(this._right, actualMoveSpeed);
    }
    tween2.update(delta);
    const position = this.camera.transform.position;
    if (this.floorMock && !this._moveJump) {
      position.setValue(position.x, this.floorY, position.z);
      this.camera.transform.position = position;
    }
  }
  initEvents() {
    this._events.forEach((ele) => {
      if (ele.element) {
        ele.element.addEventListener(ele.type, ele.listener, false);
      } else {
        this.mainElement.addEventListener(ele.type, ele.listener, false);
      }
    });
  }
  destroy() {
    this._events.forEach((ele) => {
      if (ele.element) {
        ele.element.removeEventListener(ele.type, ele.listener, false);
      } else {
        this.mainElement.removeEventListener(ele.type, ele.listener, false);
      }
    });
    super.destroy();
  }
  updateSpherical() {
    this._v3Cache.setValue(0, 0, -1);
    Vector3.transformByQuat(this._v3Cache, this.camera.rotation, this._v3Cache);
    this._spherical.setFromVec3(this._v3Cache);
    this._theta = this._spherical.theta;
    this._phi = this._spherical.phi;
  }
}

class OrbitControl extends Script {
  constructor(entity) {
    super(entity);
    this.camera = entity;
    this.mainElement = this.engine.canvas._webCanvas;
    this.domElement = document;
    this.fov = 45;
    this.target = new Vector3();
    this.up = new Vector3(0, 1, 0);
    this.minDistance = 0.1;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = true;
    this.dampingFactor = 0.1;
    this.zoomFactor = 0.2;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.enableKeys = false;
    this.keys = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      BOTTOM: 40
    };
    this.mouseButtons = {
      ORBIT: 0,
      ZOOM: 1,
      PAN: 2
    };
    this.touchFingers = {
      ORBIT: 1,
      ZOOM: 2,
      PAN: 3
    };
    this._position = new Vector3();
    this._offset = new Vector3();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._sphericalDump = new Spherical();
    this._zoomFrag = 0;
    this._scale = 1;
    this._panOffset = new Vector3();
    this._isMouseUp = true;
    this._vPan = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._zoomStart = new Vector2();
    this._zoomEnd = new Vector2();
    this._zoomDelta = new Vector2();
    this.STATE = {
      NONE: -1,
      ROTATE: 0,
      ZOOM: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_ZOOM: 4,
      TOUCH_PAN: 5
    };
    this._state = this.STATE.NONE;
    this.constEvents = [
      {type: "mousedown", listener: this.onMouseDown.bind(this)},
      {type: "wheel", listener: this.onMouseWheel.bind(this)},
      {type: "keydown", listener: this.onKeyDown.bind(this), element: window},
      {type: "touchstart", listener: this.onTouchStart.bind(this)},
      {type: "touchmove", listener: this.onTouchMove.bind(this)},
      {type: "touchend", listener: this.onTouchEnd.bind(this)},
      {type: "contextmenu", listener: this.onContextMenu.bind(this)}
    ];
    this.mouseUpEvents = [
      {type: "mousemove", listener: this.onMouseMove.bind(this)},
      {type: "mouseup", listener: this.onMouseUp.bind(this)}
    ];
    this.constEvents.forEach((ele) => {
      if (ele.element) {
        ele.element.addEventListener(ele.type, ele.listener, false);
      } else {
        this.mainElement.addEventListener(ele.type, ele.listener, false);
      }
    });
    this.addEventListener("disabled", () => {
      const element = this.domElement === document ? this.domElement.body : this.domElement;
      this.mainElement.removeEventListener(this.mouseUpEvents[0].type, this.mouseUpEvents[0].listener, false);
      element.removeEventListener(this.mouseUpEvents[1].type, this.mouseUpEvents[1].listener, false);
    });
  }
  destroy() {
    this.constEvents.forEach((ele) => {
      if (ele.element) {
        ele.element.removeEventListener(ele.type, ele.listener, false);
      } else {
        this.mainElement.removeEventListener(ele.type, ele.listener, false);
      }
    });
    const element = this.domElement === document ? this.domElement.body : this.domElement;
    this.mainElement.removeEventListener(this.mouseUpEvents[0].type, this.mouseUpEvents[0].listener, false);
    element.removeEventListener(this.mouseUpEvents[1].type, this.mouseUpEvents[1].listener, false);
    super.destroy();
  }
  setOneFingerRotate() {
    this.touchFingers.ORBIT = 1;
    this.touchFingers.ZOOM = 2;
    this.touchFingers.PAN = 3;
  }
  setOneFingerPan() {
    this.touchFingers.ORBIT = 3;
    this.touchFingers.ZOOM = 2;
    this.touchFingers.PAN = 1;
  }
  onUpdate(dtime) {
    if (!this.enabled)
      return;
    super.onUpdate(dtime);
    const position = this.camera.position;
    position.cloneTo(this._offset);
    this._offset.subtract(this.target);
    this._spherical.setFromVec3(this._offset);
    if (this.autoRotate && this._state === this.STATE.NONE) {
      this.rotateLeft(this.getAutoRotationAngle(dtime));
    }
    this._spherical.theta += this._sphericalDelta.theta;
    this._spherical.phi += this._sphericalDelta.phi;
    this._spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, this._spherical.theta));
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this._scale !== 1) {
      this._zoomFrag = this._spherical.radius * (this._scale - 1);
    }
    this._spherical.radius += this._zoomFrag;
    this._spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this._spherical.radius));
    this.target.add(this._panOffset);
    this._spherical.setToVec3(this._offset);
    this.target.cloneTo(this._position);
    this._position.add(this._offset);
    this.camera.position = this._position;
    this.camera.transform.lookAt(this.target, this.up);
    if (this.enableDamping === true) {
      this._sphericalDump.theta *= 1 - this.dampingFactor;
      this._sphericalDump.phi *= 1 - this.dampingFactor;
      this._zoomFrag *= 1 - this.zoomFactor;
      if (this._isMouseUp) {
        this._sphericalDelta.theta = this._sphericalDump.theta;
        this._sphericalDelta.phi = this._sphericalDump.phi;
      } else {
        this._sphericalDelta.set(0, 0, 0);
      }
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._zoomFrag = 0;
    }
    this._scale = 1;
    this._panOffset.setValue(0, 0, 0);
  }
  getAutoRotationAngle(dtime) {
    return 2 * Math.PI / this.autoRotateSpeed / 1e3 * dtime;
  }
  getZoomScale() {
    return Math.pow(0.95, this.zoomSpeed);
  }
  rotateLeft(radian) {
    this._sphericalDelta.theta -= radian;
    if (this.enableDamping) {
      this._sphericalDump.theta = -radian;
    }
  }
  rotateUp(radian) {
    this._sphericalDelta.phi -= radian;
    if (this.enableDamping) {
      this._sphericalDump.phi = -radian;
    }
  }
  panLeft(distance, worldMatrix) {
    const e = worldMatrix.elements;
    this._vPan.setValue(e[0], e[1], e[2]);
    this._vPan.scale(distance);
    this._panOffset.add(this._vPan);
  }
  panUp(distance, worldMatrix) {
    const e = worldMatrix.elements;
    this._vPan.setValue(e[4], e[5], e[6]);
    this._vPan.scale(distance);
    this._panOffset.add(this._vPan);
  }
  pan(deltaX, deltaY) {
    const element = this.domElement === document ? this.domElement.body : this.domElement;
    const position = this.camera.position;
    position.cloneTo(this._vPan);
    this._vPan.subtract(this.target);
    let targetDistance = this._vPan.length();
    targetDistance *= this.fov / 2 * (Math.PI / 180);
    this.panLeft(-2 * deltaX * (targetDistance / element.clientHeight), this.camera.transform.worldMatrix);
    this.panUp(2 * deltaY * (targetDistance / element.clientHeight), this.camera.transform.worldMatrix);
  }
  zoomIn(zoomScale) {
    this._scale *= zoomScale;
  }
  zoomOut(zoomScale) {
    this._scale /= zoomScale;
  }
  handleMouseDownRotate(event) {
    this._rotateStart.setValue(event.clientX, event.clientY);
  }
  handleMouseDownZoom(event) {
    this._zoomStart.setValue(event.clientX, event.clientY);
  }
  handleMouseDownPan(event) {
    this._panStart.setValue(event.clientX, event.clientY);
  }
  handleMouseMoveRotate(event) {
    this._rotateEnd.setValue(event.clientX, event.clientY);
    Vector2.subtract(this._rotateEnd, this._rotateStart, this._rotateDelta);
    const element = this.domElement === document ? document.body : this.domElement;
    this.rotateLeft(2 * Math.PI * (this._rotateDelta.x / element.clientWidth) * this.rotateSpeed);
    this.rotateUp(2 * Math.PI * (this._rotateDelta.y / element.clientHeight) * this.rotateSpeed);
    this._rotateEnd.cloneTo(this._rotateStart);
  }
  handleMouseMoveZoom(event) {
    this._zoomEnd.setValue(event.clientX, event.clientY);
    Vector2.subtract(this._zoomEnd, this._zoomStart, this._zoomDelta);
    if (this._zoomDelta.y > 0) {
      this.zoomOut(this.getZoomScale());
    } else if (this._zoomDelta.y < 0) {
      this.zoomIn(this.getZoomScale());
    }
    this._zoomEnd.cloneTo(this._zoomStart);
  }
  handleMouseMovePan(event) {
    this._panEnd.setValue(event.clientX, event.clientY);
    Vector2.subtract(this._panEnd, this._panStart, this._panDelta);
    this.pan(this._panDelta.x, this._panDelta.y);
    this._panEnd.cloneTo(this._panStart);
  }
  handleMouseWheel(event) {
    if (event.deltaY < 0) {
      this.zoomIn(this.getZoomScale());
    } else if (event.deltaY > 0) {
      this.zoomOut(this.getZoomScale());
    }
  }
  handleKeyDown(event) {
    switch (event.keyCode) {
      case this.keys.UP:
        this.pan(0, this.keyPanSpeed);
        break;
      case this.keys.BOTTOM:
        this.pan(0, -this.keyPanSpeed);
        break;
      case this.keys.LEFT:
        this.pan(this.keyPanSpeed, 0);
        break;
      case this.keys.RIGHT:
        this.pan(-this.keyPanSpeed, 0);
        break;
    }
  }
  handleTouchStartRotate(event) {
    this._rotateStart.setValue(event.touches[0].pageX, event.touches[0].pageY);
  }
  handleTouchStartZoom(event) {
    const dx = event.touches[0].pageX - event.touches[1].pageX;
    const dy = event.touches[0].pageY - event.touches[1].pageY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._zoomStart.setValue(0, distance);
  }
  handleTouchStartPan(event) {
    this._panStart.setValue(event.touches[0].pageX, event.touches[0].pageY);
  }
  handleTouchMoveRotate(event) {
    this._rotateEnd.setValue(event.touches[0].pageX, event.touches[0].pageY);
    Vector2.subtract(this._rotateEnd, this._rotateStart, this._rotateDelta);
    const element = this.domElement === document ? this.domElement.body : this.domElement;
    this.rotateLeft(2 * Math.PI * this._rotateDelta.x / element.clientWidth * this.rotateSpeed);
    this.rotateUp(2 * Math.PI * this._rotateDelta.y / element.clientHeight * this.rotateSpeed);
    this._rotateEnd.cloneTo(this._rotateStart);
  }
  handleTouchMoveZoom(event) {
    const dx = event.touches[0].pageX - event.touches[1].pageX;
    const dy = event.touches[0].pageY - event.touches[1].pageY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._zoomEnd.setValue(0, distance);
    Vector2.subtract(this._zoomEnd, this._zoomStart, this._zoomDelta);
    if (this._zoomDelta.y > 0) {
      this.zoomIn(this.getZoomScale());
    } else if (this._zoomDelta.y < 0) {
      this.zoomOut(this.getZoomScale());
    }
    this._zoomEnd.cloneTo(this._zoomStart);
  }
  handleTouchMovePan(event) {
    this._panEnd.setValue(event.touches[0].pageX, event.touches[0].pageY);
    Vector2.subtract(this._panEnd, this._panStart, this._panDelta);
    this.pan(this._panDelta.x, this._panDelta.y);
    this._panEnd.cloneTo(this._panStart);
  }
  onMouseDown(event) {
    if (this.enabled === false)
      return;
    event.preventDefault();
    this._isMouseUp = false;
    switch (event.button) {
      case this.mouseButtons.ORBIT:
        if (this.enableRotate === false)
          return;
        this.handleMouseDownRotate(event);
        this._state = this.STATE.ROTATE;
        break;
      case this.mouseButtons.ZOOM:
        if (this.enableZoom === false)
          return;
        this.handleMouseDownZoom(event);
        this._state = this.STATE.ZOOM;
        break;
      case this.mouseButtons.PAN:
        if (this.enablePan === false)
          return;
        this.handleMouseDownPan(event);
        this._state = this.STATE.PAN;
        break;
    }
    if (this._state !== this.STATE.NONE) {
      const element = this.domElement === document ? this.domElement.body : this.domElement;
      this.mainElement.addEventListener(this.mouseUpEvents[0].type, this.mouseUpEvents[0].listener, false);
      element.addEventListener(this.mouseUpEvents[1].type, this.mouseUpEvents[1].listener, false);
    }
  }
  onMouseMove(event) {
    if (this.enabled === false)
      return;
    event.preventDefault();
    switch (this._state) {
      case this.STATE.ROTATE:
        if (this.enableRotate === false)
          return;
        this.handleMouseMoveRotate(event);
        break;
      case this.STATE.ZOOM:
        if (this.enableZoom === false)
          return;
        this.handleMouseMoveZoom(event);
        break;
      case this.STATE.PAN:
        if (this.enablePan === false)
          return;
        this.handleMouseMovePan(event);
        break;
    }
  }
  onMouseUp() {
    if (this.enabled === false)
      return;
    this._isMouseUp = true;
    this.mouseUpEvents.forEach((ele) => {
      const element = this.domElement === document ? this.domElement.body : this.domElement;
      element.removeEventListener(ele.type, ele.listener, false);
      this.mainElement.removeEventListener(ele.type, ele.listener, false);
    });
    this._state = this.STATE.NONE;
  }
  onMouseWheel(event) {
    if (this.enabled === false || this.enableZoom === false || this._state !== this.STATE.NONE && this._state !== this.STATE.ROTATE)
      return;
    event.preventDefault();
    event.stopPropagation();
    this.handleMouseWheel(event);
  }
  onKeyDown(event) {
    if (this.enabled === false || this.enableKeys === false || this.enablePan === false)
      return;
    this.handleKeyDown(event);
  }
  onTouchStart(event) {
    if (this.enabled === false)
      return;
    this._isMouseUp = false;
    switch (event.touches.length) {
      case this.touchFingers.ORBIT:
        if (this.enableRotate === false)
          return;
        this.handleTouchStartRotate(event);
        this._state = this.STATE.TOUCH_ROTATE;
        break;
      case this.touchFingers.ZOOM:
        if (this.enableZoom === false)
          return;
        this.handleTouchStartZoom(event);
        this._state = this.STATE.TOUCH_ZOOM;
        break;
      case this.touchFingers.PAN:
        if (this.enablePan === false)
          return;
        this.handleTouchStartPan(event);
        this._state = this.STATE.TOUCH_PAN;
        break;
      default:
        this._state = this.STATE.NONE;
    }
  }
  onTouchMove(event) {
    if (this.enabled === false)
      return;
    event.preventDefault();
    event.stopPropagation();
    switch (event.touches.length) {
      case this.touchFingers.ORBIT:
        if (this.enableRotate === false)
          return;
        if (this._state !== this.STATE.TOUCH_ROTATE)
          return;
        this.handleTouchMoveRotate(event);
        break;
      case this.touchFingers.ZOOM:
        if (this.enableZoom === false)
          return;
        if (this._state !== this.STATE.TOUCH_ZOOM)
          return;
        this.handleTouchMoveZoom(event);
        break;
      case this.touchFingers.PAN:
        if (this.enablePan === false)
          return;
        if (this._state !== this.STATE.TOUCH_PAN)
          return;
        this.handleTouchMovePan(event);
        break;
      default:
        this._state = this.STATE.NONE;
    }
  }
  onTouchEnd() {
    if (this.enabled === false)
      return;
    this._isMouseUp = true;
    this._state = this.STATE.NONE;
  }
  onContextMenu(event) {
    if (this.enabled === false)
      return;
    event.preventDefault();
  }
}

export { FreeControl, OrbitControl };
