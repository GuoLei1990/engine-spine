import { resourceLoader, AssetType, Loader, AssetPromise, VertexElement, DataType, IndexFormat, VertexElementFormat, Material, Logger, SkinnedMeshRenderer, MeshRenderer, Entity, Animation, ConstantMaterial, PBRMaterial, EngineObject, Skin, Mesh, Primitive, SubPrimitive, PrimitiveTopology, AnimationClip, InterpolationType, Camera, Buffer, BufferBindFlag, BufferUsage, IndexBufferBinding, GLCapabilityType, Texture2D, GLCompressedTextureInternalFormat, TextureFormat, TextureCubeMap, TextureCubeFace, Component, Texture, ShaderMaterial, BlinnPhongMaterial, ObjectValues, EventDispatcher } from '@oasis-engine/core';
import { Vector4, Vector3, Matrix, Quaternion, Vector2 } from '@oasis-engine/math';
import { DRACODecoder } from '@oasis-engine/draco';

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorate = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
function isBase64(url) {
  return /^data:(.+?);base64,/.test(url);
}
let BufferLoader = class extends Loader {
  load(item) {
    const url = item.url;
    if (isBase64(url)) {
      return new AssetPromise((resolve) => {
        const base64Str = url.slice(13 + RegExp.$1.length);
        const result = Uint8Array.from(atob(base64Str), (c) => c.charCodeAt(0));
        resolve(result.buffer);
      });
    }
    return this.request(url, {
      ...item,
      type: "arraybuffer"
    });
  }
};
BufferLoader = __decorate([
  resourceLoader(AssetType.Buffer, ["bin", "r3bin"], false)
], BufferLoader);

const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function decodeText(array) {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(array);
  }
  let s = "";
  for (let i = 0, il = array.length; i < il; i++) {
    s += String.fromCharCode(array[i]);
  }
  return decodeURIComponent(encodeURIComponent(s));
}
function getAccessorTypeSize(accessorType) {
  const ACCESSOR_TYPE_SIZE = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  return ACCESSOR_TYPE_SIZE[accessorType];
}
function getComponentType(componentType) {
  return WEBGL_COMPONENT_TYPES[componentType];
}
function getAccessorData(gltf, accessor, buffers) {
  const bufferView = gltf.bufferViews[accessor.bufferView];
  const arrayBuffer = buffers[bufferView.buffer];
  const accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
  const bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
  const byteOffset = accessorByteOffset + bufferViewByteOffset;
  const accessorTypeSize = getAccessorTypeSize(accessor.type);
  const length = accessorTypeSize * accessor.count;
  const byteStride = bufferView.byteStride ?? 0;
  const arrayType = getComponentType(accessor.componentType);
  let uint8Array;
  if (byteStride) {
    uint8Array = new Uint8Array(length * arrayType.BYTES_PER_ELEMENT);
    const originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
    let viewAccessor = 0;
    const accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
    for (let i = 0; i < accessor.count; i++) {
      viewAccessor = i * byteStride + accessorByteOffset;
      for (let j = 0; j < accessorByteSize; j++) {
        uint8Array[i * accessorByteSize + j] = originalBufferView[viewAccessor + j];
      }
    }
  } else {
    uint8Array = new Uint8Array(arrayBuffer, byteOffset, length * arrayType.BYTES_PER_ELEMENT);
    uint8Array = new Uint8Array(uint8Array);
  }
  return new arrayType(uint8Array.buffer);
}
function getBufferData(bufferView, buffers) {
  const arrayBuffer = buffers[bufferView.buffer];
  const byteOffset = bufferView.byteOffset || 0;
  return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
}
function getVertexStride(accessor) {
  const size = getAccessorTypeSize(accessor.type);
  const componentType = getComponentType(accessor.componentType);
  return size * componentType.BYTES_PER_ELEMENT;
}
function createVertexElement(gltf, semantic, accessor, index) {
  const size = getAccessorTypeSize(accessor.type);
  return new VertexElement(semantic, 0, getElementFormat(accessor.componentType, size), index);
}
function getIndexFormat(type) {
  switch (type) {
    case DataType.UNSIGNED_BYTE:
      return IndexFormat.UInt8;
    case DataType.UNSIGNED_SHORT:
      return IndexFormat.UInt16;
    case DataType.UNSIGNED_INT:
      return IndexFormat.UInt32;
  }
}
function getElementFormat(type, size) {
  if (type == DataType.FLOAT) {
    switch (size) {
      case 1:
        return VertexElementFormat.Float;
      case 2:
        return VertexElementFormat.Vector2;
      case 3:
        return VertexElementFormat.Vector3;
      case 4:
        return VertexElementFormat.Vector4;
    }
  }
  if (type == DataType.UNSIGNED_SHORT) {
    switch (size) {
      case 2:
        return VertexElementFormat.UShort2;
      case 4:
        return VertexElementFormat.UShort4;
    }
  }
}
function loadImageBuffer(imageBuffer, type) {
  return new Promise((resolve, reject) => {
    const blob = new window.Blob([imageBuffer], {type});
    const img = new Image();
    img.src = URL.createObjectURL(blob);
    img.crossOrigin = "anonymous";
    img.onerror = function() {
      reject(new Error("Failed to load image buffer"));
    };
    img.onload = function() {
      requestAnimationFrame(() => {
        resolve(img);
      });
    };
  });
}
function isAbsoluteUrl(url) {
  return /^(?:http|blob|data:|\/)/.test(url);
}
function parseRelativeUrl(baseUrl, relativeUrl) {
  if (isAbsoluteUrl(relativeUrl)) {
    return relativeUrl;
  }
  return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
}

let decoder;
const glTFDracoMeshCompression = {
  init() {
    if (!decoder) {
      decoder = new DRACODecoder();
    }
  },
  parse(extension, gltfPrimitive, gltf, buffers) {
    const {bufferViews, accessors} = gltf;
    const bufferViewIndex = extension.bufferView;
    const gltfAttributeMap = extension.attributes;
    const attributeMap = {};
    const attributeTypeMap = {};
    for (let attributeName in gltfAttributeMap) {
      attributeMap[attributeName] = gltfAttributeMap[attributeName];
    }
    for (let attributeName in gltfPrimitive.attributes) {
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = accessors[gltfPrimitive.attributes[attributeName]];
        attributeTypeMap[attributeName] = getComponentType(accessorDef.componentType).name;
      }
    }
    const indexAccessor = accessors[gltfPrimitive.indices];
    const indexType = getComponentType(indexAccessor.componentType).name;
    const taskConfig = {
      attributeIDs: attributeMap,
      attributeTypes: attributeTypeMap,
      useUniqueIDs: true,
      indexType
    };
    const buffer = getBufferData(bufferViews[bufferViewIndex], buffers);
    return decoder.decode(buffer, taskConfig).then((parsedGeometry) => parsedGeometry);
  }
};

const TARGET_PATH_MAP = {
  translation: "position",
  rotation: "rotation",
  scale: "scale",
  weights: "weights"
};
let nodeCount = 0;
const RegistedObjs = {};
const RegistedCustomMaterials = {};
const getDefaultMaterial = function() {
  return (engine) => {
    let defaultMateril = new ConstantMaterial(engine, "default");
    defaultMateril.emission = new Vector4(0.749, 0.749, 0.749, 1);
    return defaultMateril;
  };
}();
const HandledExtensions = {
  PBRMaterial: "PBRMaterial",
  KHR_lights: "KHR_lights",
  KHR_materials_unlit: "KHR_materials_unlit",
  KHR_materials_pbrSpecularGlossiness: "KHR_materials_pbrSpecularGlossiness",
  KHR_techniques_webgl: "KHR_techniques_webgl",
  KHR_draco_mesh_compression: "KHR_draco_mesh_compression"
};
let KHR_lights = null;
const extensionParsers = {
  KHR_lights,
  KHR_materials_unlit: PBRMaterial,
  KHR_materials_pbrSpecularGlossiness: PBRMaterial,
  KHR_techniques_webgl: Material,
  KHR_draco_mesh_compression: glTFDracoMeshCompression
};
function RegistExtension(extobj) {
  Object.keys(extobj).forEach((name) => {
    if (RegistedObjs[name] === void 0) {
      RegistedObjs[name] = extobj[name];
      switch (name) {
        case HandledExtensions.PBRMaterial:
          extensionParsers.KHR_materials_unlit = PBRMaterial;
          break;
        case HandledExtensions.KHR_lights:
          KHR_lights = extobj[name];
          extensionParsers.KHR_lights = KHR_lights;
          break;
        default:
          if (Material.isPrototypeOf(extobj[name]) && extobj[name].TECH_NAME)
            RegistedCustomMaterials[extobj[name].TECH_NAME] = extobj[name];
          break;
      }
    }
  });
}
class GLTFResource extends EngineObject {
}
function parseGLTF(data, engine) {
  const resources = {
    engine,
    gltf: data.gltf,
    buffers: data.buffers,
    asset: new GLTFResource(engine)
  };
  resources.asset.textures = data.textures;
  resources.asset.meta = data.gltf;
  if (resources.gltf.asset && resources.gltf.asset.version) {
    resources.gltf.version = Number(resources.gltf.asset.version);
    resources.gltf.isGltf2 = resources.gltf.version >= 2 && resources.gltf.version <= 3;
  }
  parseExtensions(resources);
  return parseResources(resources, "materials", parseMaterial).then(() => parseResources(resources, "meshes", parseMesh)).then(() => parseResources(resources, "nodes", parseNode)).then(() => parseResources(resources, "scenes", parseScene)).then(() => parseResources(resources, "skins", parseSkin)).then(() => parseResources(resources, "animations", parseAnimation)).then(() => buildSceneGraph(resources));
}
function parseExtensions(resources) {
  const {gltf, asset} = resources;
  const {extensions, extensionsUsed, extensionsRequired} = gltf;
  if (extensionsUsed) {
    Logger.info("extensionsUsed: ", extensionsUsed);
    for (let i = 0; i < extensionsUsed.length; i++) {
      if (Object.keys(extensionParsers).indexOf(extensionsUsed[i]) > -1) {
        if (!extensionParsers[extensionsUsed[i]]) {
          Logger.warn("extension " + extensionsUsed[i] + " is used, you can add this extension into gltf");
        }
      } else {
        Logger.warn("extensionsUsed has unsupported extension " + extensionsUsed[i]);
      }
    }
  }
  if (extensionsRequired) {
    Logger.info(`extensionsRequired: ${extensionsRequired}`);
    for (let i = 0; i < extensionsRequired.length; i++) {
      if (Object.keys(extensionParsers).indexOf(extensionsRequired[i]) < 0 || !extensionParsers[extensionsRequired[i]]) {
        Logger.error(`model has not supported required extension ${extensionsRequired[i]}`);
      }
      if (extensionsRequired[i] === HandledExtensions.KHR_draco_mesh_compression) {
        extensionParsers.KHR_draco_mesh_compression.init();
      }
    }
  }
  if (extensions) {
    if (KHR_lights && extensions.KHR_lights) {
      asset.lights = KHR_lights.parseLights(extensions.KHR_lights.lights);
    }
  }
}
function parseResources(resources, name, handler) {
  const {gltf, asset} = resources;
  if (!asset[name]) {
    asset[name] = [];
  }
  if (gltf.hasOwnProperty(name)) {
    const entities = gltf[name] || [];
    Logger.debug(name + ":", entities);
    const promises = [];
    for (let i = entities.length - 1; i >= 0; i--) {
      promises.push(handler(entities[i], resources));
    }
    return Promise.all(promises).then((results) => {
      for (let i = 0; i < results.length; i++) {
        asset[name].push(results[i]);
      }
    });
  }
  return Promise.resolve();
}
function parseMaterial(gltfMaterial, resources) {
  const {gltf, asset} = resources;
  let material;
  if (gltf.isGltf2 && typeof gltfMaterial.technique === "undefined") {
    const uniformObj = {};
    const stateObj = {};
    const {
      pbrMetallicRoughness,
      normalTexture,
      emissiveTexture,
      emissiveFactor,
      occlusionTexture,
      alphaMode,
      alphaCutoff,
      doubleSided,
      extensions
    } = gltfMaterial;
    if (pbrMetallicRoughness) {
      const {
        baseColorFactor,
        baseColorTexture,
        metallicFactor,
        roughnessFactor,
        metallicRoughnessTexture
      } = pbrMetallicRoughness;
      if (baseColorTexture) {
        uniformObj.baseColorTexture = getItemByIdx("textures", baseColorTexture.index || 0, resources, false);
      }
      if (baseColorFactor) {
        uniformObj.baseColorFactor = new Vector4(...baseColorFactor);
      }
      uniformObj.metallicFactor = metallicFactor !== void 0 ? metallicFactor : 1;
      uniformObj.roughnessFactor = roughnessFactor !== void 0 ? roughnessFactor : 1;
      if (metallicRoughnessTexture) {
        uniformObj.metallicRoughnessTexture = getItemByIdx("textures", metallicRoughnessTexture.index || 0, resources, false);
      }
    }
    if (normalTexture) {
      const {index, texCoord, scale} = normalTexture;
      uniformObj.normalTexture = getItemByIdx("textures", index || 0, resources, false);
      if (typeof scale !== void 0) {
        uniformObj.normalScale = scale;
      }
    }
    if (emissiveTexture) {
      uniformObj.emissiveTexture = getItemByIdx("textures", emissiveTexture.index || 0, resources, false);
    }
    if (occlusionTexture) {
      uniformObj.occlusionTexture = getItemByIdx("textures", occlusionTexture.index || 0, resources, false);
      if (occlusionTexture.strength !== void 0) {
        uniformObj.occlusionStrength = occlusionTexture.strength;
      }
    }
    stateObj.doubleSided = !!doubleSided;
    stateObj.alphaMode = alphaMode || "OPAQUE";
    if (alphaMode === "MASK") {
      uniformObj.alphaCutoff = alphaCutoff === void 0 ? 0.5 : alphaCutoff;
    }
    if (extensions) {
      if (extensions.KHR_materials_unlit) {
        stateObj.unlit = true;
      }
      if (extensions.KHR_materials_pbrSpecularGlossiness) {
        const {
          diffuseFactor,
          diffuseTexture,
          specularFactor,
          glossinessFactor,
          specularGlossinessTexture
        } = extensions.KHR_materials_pbrSpecularGlossiness;
        stateObj.isMetallicWorkflow = false;
        if (diffuseFactor) {
          uniformObj.baseColorFactor = new Vector4(...diffuseFactor);
        }
        if (diffuseTexture) {
          uniformObj.baseColorTexture = getItemByIdx("textures", diffuseTexture.index || 0, resources, false);
        }
        if (specularFactor) {
          uniformObj.specularFactor = new Vector3(...specularFactor);
        }
        if (glossinessFactor !== void 0) {
          uniformObj.glossinessFactor = glossinessFactor;
        }
        if (specularGlossinessTexture) {
          uniformObj.specularGlossinessTexture = getItemByIdx("textures", specularGlossinessTexture.index || 0, resources, false);
        }
      }
    }
    const {unlit, srgb, gamma, blendFunc, depthMask} = gltfMaterial;
    if (unlit)
      stateObj.unlit = true;
    if (srgb)
      stateObj.srgb = true;
    if (gamma)
      stateObj.gamma = true;
    if (blendFunc)
      stateObj.blendFunc = blendFunc;
    if (depthMask !== void 0)
      stateObj.depthMask = depthMask;
    material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME, Object.assign({}, uniformObj, stateObj));
  } else {
    const techniqueName = gltfMaterial.technique;
    Logger.warn("Deprecated: Please use a model that meets the glTF 2.0 specification");
    if (techniqueName === "Texture") {
      material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME);
      material.unlit = true;
      const index = gltfMaterial.values._MainTex[0];
      material.baseColorTexture = getItemByIdx("textures", index || 0, resources, false);
    }
  }
  return Promise.resolve(material);
}
function parseSkin(gltfSkin, resources) {
  const {gltf, buffers} = resources;
  const jointCount = gltfSkin.joints.length;
  const skin = new Skin(gltfSkin.name);
  const accessor = gltf.accessors[gltfSkin.inverseBindMatrices];
  const buffer = getAccessorData(gltf, accessor, buffers);
  const MAT4_LENGTH = 16;
  for (let i = 0; i < jointCount; i++) {
    const startIdx = MAT4_LENGTH * i;
    const endIdx = startIdx + MAT4_LENGTH;
    skin.inverseBindMatrices[i] = new Matrix(...buffer.subarray(startIdx, endIdx));
  }
  for (let i = 0; i < jointCount; i++) {
    const node2 = getItemByIdx("nodes", gltfSkin.joints[i], resources);
    skin.joints[i] = node2.name;
  }
  const node = getItemByIdx("nodes", gltfSkin.skeleton == null ? gltfSkin.joints[0] : gltfSkin.skeleton, resources);
  skin.skeleton = node.name;
  return Promise.resolve(skin);
}
function parsePrimitiveVertex(mesh, primitive, primitiveGroup, gltfPrimitive, gltf, getVertexBufferData, getIndexBufferData, engine) {
  let i = 0;
  const vertexElements = [];
  for (const attributeSemantic in gltfPrimitive.attributes) {
    const accessorIdx = gltfPrimitive.attributes[attributeSemantic];
    const accessor = gltf.accessors[accessorIdx];
    const stride = getVertexStride(accessor);
    const vertexELement = createVertexElement(gltf, attributeSemantic, accessor, i);
    vertexElements.push(vertexELement);
    const bufferData = getVertexBufferData(attributeSemantic);
    const vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, bufferData.byteLength, BufferUsage.Static);
    vertexBuffer.setData(bufferData);
    primitive.setVertexBufferBinding(vertexBuffer, stride, i++);
    if (vertexELement.semantic == "POSITION") {
      const position = new Vector3();
      const vertexCount = bufferData.length / 3;
      const {min, max} = mesh.bounds;
      for (let i2 = 0; i2 < vertexCount; i2++) {
        const offset = i2 * 3;
        position.setValue(bufferData[offset], bufferData[offset + 1], bufferData[offset + 2]);
        Vector3.min(min, position, min);
        Vector3.max(max, position, max);
      }
    }
  }
  primitive.setVertexElements(vertexElements);
  const indexAccessor = gltf.accessors[gltfPrimitive.indices];
  const indexData = getIndexBufferData();
  const indexCount = indexAccessor.count;
  const indexFormat = getIndexFormat(indexAccessor.componentType);
  const indexByteSize = indexFormat == IndexFormat.UInt32 ? 4 : indexFormat == IndexFormat.UInt16 ? 2 : 1;
  const indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indexCount * indexByteSize, BufferUsage.Static);
  indexBuffer.setData(indexData);
  primitive.setIndexBufferBinding(new IndexBufferBinding(indexBuffer, indexFormat));
  primitiveGroup.start = 0;
  primitiveGroup.count = indexCount;
  return Promise.resolve(primitive);
}
function parseMesh(gltfMesh, resources) {
  const {gltf, buffers, engine} = resources;
  const mesh = new Mesh(gltfMesh.name);
  const primitivePromises = [];
  const groups = [];
  for (let i = 0; i < gltfMesh.primitives.length; i++) {
    primitivePromises.push(new Promise((resolve, reject) => {
      const gltfPrimitive = gltfMesh.primitives[i];
      const primitive = new Primitive(engine, gltfPrimitive.name || gltfMesh.name || i);
      const subPrimitive = new SubPrimitive();
      groups.push(subPrimitive);
      subPrimitive.topology = gltfPrimitive.mode == null ? PrimitiveTopology.Triangles : gltfPrimitive.mode;
      if (gltfPrimitive.hasOwnProperty("targets")) {
        primitive.targets = [];
        mesh.weights = gltfMesh.weights || new Array(gltfPrimitive.targets.length).fill(0);
      }
      let vertexPromise;
      if (gltfPrimitive.extensions && gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression]) {
        const extensionParser = extensionParsers.KHR_draco_mesh_compression;
        const extension = gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression];
        vertexPromise = extensionParser.parse(extension, gltfPrimitive, gltf, buffers).then((decodedGeometry) => {
          return parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, (attributeSemantic) => {
            for (let i2 = 0; i2 < decodedGeometry.attributes.length; i2++) {
              if (decodedGeometry.attributes[i2].name === attributeSemantic) {
                return decodedGeometry.attributes[i2].array;
              }
            }
            return null;
          }, () => {
            return decodedGeometry.index.array;
          }, resources.engine);
        });
      } else {
        vertexPromise = parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, (attributeSemantic) => {
          const accessorIdx = gltfPrimitive.attributes[attributeSemantic];
          const accessor = gltf.accessors[accessorIdx];
          return getAccessorData(gltf, accessor, buffers);
        }, () => {
          const indexAccessor = gltf.accessors[gltfPrimitive.indices];
          return getAccessorData(gltf, indexAccessor, buffers);
        }, resources.engine);
      }
      vertexPromise.then((processedPrimitive) => {
        resolve(processedPrimitive);
      }).catch((e) => {
        reject(e);
      });
    }));
  }
  return Promise.all(primitivePromises).then((primitives) => {
    for (let i = 0; i < primitives.length; i++) {
      mesh.primitives.push(primitives[i]);
      mesh.groups.push(groups[i]);
    }
    return mesh;
  });
}
function parseAnimation(gltfAnimation, resources) {
  const {gltf, buffers} = resources;
  const gltfSamplers = gltfAnimation.samplers || [];
  const gltfChannels = gltfAnimation.channels || [];
  const animationIdx = gltf.animations.indexOf(gltfAnimation);
  const animationClip = new AnimationClip(gltfAnimation.name || `Animation${animationIdx}`);
  let duration = -1;
  let durationIndex = -1;
  for (let i = 0; i < gltfSamplers.length; i++) {
    const gltfSampler = gltfSamplers[i];
    const inputAccessor = gltf.accessors[gltfSampler.input];
    const outputAccessor = gltf.accessors[gltfSampler.output];
    const input = getAccessorData(gltf, inputAccessor, buffers);
    const output = getAccessorData(gltf, outputAccessor, buffers);
    let outputAccessorSize = getAccessorTypeSize(outputAccessor.type);
    if (outputAccessorSize * input.length !== output.length)
      outputAccessorSize = output.length / input.length;
    let samplerInterpolation = InterpolationType.LINEAR;
    switch (gltfSampler.interpolation) {
      case "CUBICSPLINE":
        samplerInterpolation = InterpolationType.CUBICSPLINE;
        break;
      case "STEP":
        samplerInterpolation = InterpolationType.STEP;
        break;
    }
    const maxTime = input[input.length - 1];
    if (maxTime > duration) {
      duration = maxTime;
      durationIndex = i;
    }
    animationClip.addSampler(input, output, outputAccessorSize, samplerInterpolation);
  }
  animationClip.durationIndex = durationIndex;
  animationClip.duration = duration;
  for (let i = 0; i < gltfChannels.length; i++) {
    const gltfChannel = gltfChannels[i];
    const target = gltfChannel.target;
    const samplerIndex = gltfChannel.sampler;
    const targetNode = getItemByIdx("nodes", target.node, resources);
    const targetPath = TARGET_PATH_MAP[target.path];
    animationClip.addChannel(samplerIndex, targetNode.name, targetPath);
  }
  return Promise.resolve(animationClip);
}
function parseNode(gltfNode, resources) {
  const entity = new Entity(resources.engine, gltfNode.name || `GLTF_NODE_${nodeCount++}`);
  if (gltfNode.hasOwnProperty("matrix")) {
    const m = gltfNode.matrix;
    const mat = new Matrix();
    mat.setValueByArray(m);
    const pos = new Vector3();
    const scale = new Vector3(1, 1, 1);
    const rot = new Quaternion();
    mat.decompose(pos, rot, scale);
    entity.transform.position = pos;
    entity.transform.rotationQuaternion = rot;
    entity.transform.scale = scale;
  } else {
    for (const key in TARGET_PATH_MAP) {
      if (gltfNode.hasOwnProperty(key)) {
        const mapKey = TARGET_PATH_MAP[key];
        if (mapKey === "weights") {
          entity[mapKey] = gltfNode[key];
        } else {
          const arr = gltfNode[key];
          const len = arr.length;
          const obj = entity[mapKey];
          if (len === 2) {
            obj.setValue(arr[0], arr[1]);
          } else if (len === 3) {
            obj.setValue(arr[0], arr[1], arr[2]);
          } else if (len === 4) {
            obj.setValue(arr[0], arr[1], arr[2], arr[3]);
          }
          entity[mapKey] = obj;
        }
      }
    }
  }
  if (gltfNode.camera !== void 0) {
    const cameraOptions = resources.gltf.cameras[gltfNode.camera];
    const camera = entity.addComponent(Camera);
    if (cameraOptions.type === "orthographic") {
      camera.isOrthographic = true;
      let {ymag, xmag, zfar, znear} = cameraOptions.orthographic;
      if (znear !== void 0) {
        camera.nearClipPlane = znear;
      }
      if (zfar !== void 0) {
        camera.farClipPlane = zfar;
      }
      if (ymag && xmag) {
        camera.orthographicSize = Math.max(ymag, xmag) / 2;
      }
      if (ymag !== void 0 && xmag) {
        camera.orthographicSize = xmag / 2;
      }
      if (xmag !== void 0 && ymag) {
        camera.orthographicSize = ymag / 2;
      }
    } else {
      const {aspectRatio, yfov, zfar, znear} = cameraOptions.perspective;
      if (yfov !== void 0) {
        camera.fieldOfView = yfov;
      }
      if (zfar !== void 0) {
        camera.farClipPlane = zfar;
      }
      if (znear !== void 0) {
        camera.nearClipPlane = znear;
      }
    }
  }
  if (gltfNode.extensions) {
    if (KHR_lights && gltfNode.extensions.KHR_lights) {
      const lightIdx = gltfNode.extensions.KHR_lights.light;
      if (lightIdx !== void 0) {
        const light = getItemByIdx("lights", lightIdx, resources);
        if (light) {
          const lightCon = entity.addComponent(light.ability);
          Object.assign(lightCon, light.props);
        }
      }
    }
  }
  return Promise.resolve(entity);
}
function parseScene(gltfScene, resources) {
  const sceneNodes = [];
  for (let i = 0; i < gltfScene.nodes.length; i++) {
    const node = getItemByIdx("nodes", gltfScene.nodes[i], resources);
    sceneNodes.push(node);
  }
  if (gltfScene.extensions) {
    if (KHR_lights && gltfScene.extensions.KHR_lights) {
      const lightIdx = gltfScene.extensions.KHR_lights.light;
      if (lightIdx !== void 0) {
        const light = getItemByIdx("lights", lightIdx, resources);
        if (light)
          sceneNodes[0].addComponent(light.ability, light.props);
      }
    }
  }
  return Promise.resolve({
    nodes: sceneNodes
  });
}
function getItemByIdx(name, idx, resources, inverse = true) {
  const {asset} = resources;
  const itemIdx = inverse ? asset[name].length - idx - 1 : idx;
  return asset[name][itemIdx];
}
function buildSceneGraph(resources) {
  const {asset, gltf} = resources;
  const gltfNodes = gltf.nodes || [];
  const gltfMeshes = gltf.meshes;
  asset.defaultScene = getItemByIdx("scenes", gltf.scene ?? 0, resources);
  for (let i = gltfNodes.length - 1; i >= 0; i--) {
    const gltfNode = gltfNodes[i];
    const node = getItemByIdx("nodes", i, resources);
    if (gltfNode.hasOwnProperty("children")) {
      const children = gltfNode.children || [];
      for (let j = children.length - 1; j >= 0; j--) {
        const childNode = getItemByIdx("nodes", children[j], resources);
        node.addChild(childNode);
      }
    }
    if (gltfNode.hasOwnProperty("mesh")) {
      const meshIndex = gltfNode.mesh;
      node.meshIndex = meshIndex;
      const gltfMeshPrimitives = gltfMeshes[meshIndex].primitives;
      const mesh = getItemByIdx("meshes", meshIndex, resources);
      let renderer;
      if (gltfNode.hasOwnProperty("skin") || mesh.hasOwnProperty("weights")) {
        const skin = getItemByIdx("skins", gltfNode.skin, resources);
        const weights = mesh.weights;
        const skinRenderer = node.addComponent(SkinnedMeshRenderer);
        skinRenderer.mesh = mesh;
        skinRenderer.skin = skin;
        skinRenderer.setWeights(weights);
        renderer = skinRenderer;
      } else {
        renderer = node.addComponent(MeshRenderer);
        renderer.mesh = mesh;
      }
      for (let j = 0, m = gltfMeshPrimitives.length; j < m; j++) {
        const materialIndex = gltfMeshPrimitives[j].material;
        mesh.primitives[j].materialIndex = materialIndex;
        const material = materialIndex !== void 0 ? getItemByIdx("materials", materialIndex, resources) : getDefaultMaterial(node.engine);
        renderer.setSharedMaterial(j, material);
      }
    }
  }
  const nodes = asset.defaultScene.nodes;
  if (nodes.length === 1) {
    asset.defaultSceneRoot = nodes[0];
  } else {
    const rootNode = new Entity(resources.engine);
    for (let i = 0; i < nodes.length; i++) {
      rootNode.addChild(nodes[i]);
    }
    asset.defaultSceneRoot = rootNode;
  }
  const animator = asset.defaultSceneRoot.addComponent(Animation);
  const animations = asset.animations;
  if (animations) {
    animations.forEach((clip) => {
      animator.addAnimationClip(clip, clip.name);
    });
  }
  return resources.asset;
}

function parseGLB(glb) {
  const UINT32_LENGTH = 4;
  const GLB_HEADER_MAGIC = 1179937895;
  const GLB_HEADER_LENGTH = 12;
  const GLB_CHUNK_TYPES = {JSON: 1313821514, BIN: 5130562};
  const dataView = new DataView(glb);
  const header = {
    magic: dataView.getUint32(0, true),
    version: dataView.getUint32(UINT32_LENGTH, true),
    length: dataView.getUint32(2 * UINT32_LENGTH, true)
  };
  if (header.magic !== GLB_HEADER_MAGIC) {
    console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
    return null;
  }
  let chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
  let chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
  if (chunkType !== GLB_CHUNK_TYPES.JSON) {
    console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
    return null;
  }
  const glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
  const gltf = JSON.parse(decodeText(glTFData));
  const buffers = [];
  let byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
  while (byteOffset < header.length) {
    chunkLength = dataView.getUint32(byteOffset, true);
    chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
    if (chunkType !== GLB_CHUNK_TYPES.BIN) {
      console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
      return null;
    }
    const currentOffset = byteOffset + 2 * UINT32_LENGTH;
    const buffer = glb.slice(currentOffset, currentOffset + chunkLength);
    buffers.push(buffer);
    byteOffset += chunkLength + 2 * UINT32_LENGTH;
  }
  return {
    gltf,
    buffers
  };
}

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorate$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
let GLTFLoader = class extends Loader {
  constructor() {
    super(...arguments);
    this.requestGLTF = (item, resourceManager) => {
      return this.request(item.url, {
        ...item,
        type: "json"
      }).then((res) => this._loadGLTFResources(item, res, resourceManager));
    };
    this.requestGLB = (item, resourceManager) => {
      return this.request(item.url, {
        ...item,
        type: "arraybuffer"
      }).then(parseGLB).then((res) => {
        return {...res, baseUrl: item.url, resourceManager};
      }).then(this._loadImages);
    };
    this._loadImages = ({
      gltf,
      buffers,
      baseUrl,
      resourceManager
    }) => {
      if (!gltf.images) {
        return Promise.resolve({gltf, buffers});
      }
      let texturePromises = void 0;
      const rhi = resourceManager.engine._hardwareRenderer;
      if (gltf.astc && rhi.canIUse(GLCapabilityType.pvrtc)) {
        texturePromises = this._loadCompressedTexture(resourceManager, gltf.pvrtc, baseUrl);
      } else if (gltf.pvrtc && rhi.canIUse(GLCapabilityType.astc)) {
        texturePromises = this._loadCompressedTexture(resourceManager, gltf.astc, baseUrl);
      } else if (gltf.etc && rhi.canIUse(GLCapabilityType.etc)) {
        texturePromises = this._loadCompressedTexture(resourceManager, gltf.etc, baseUrl);
      } else {
        texturePromises = this._loadBasicImages(resourceManager, gltf.images, baseUrl, buffers, gltf);
      }
      return texturePromises.then((textures) => {
        return {gltf, buffers, textures};
      });
    };
    this._loadBasicImages = (resourceManager, images, baseUrl, buffers, gltf) => {
      return Promise.all(images.map(({uri, bufferView: bufferViewIndex, mimeType}) => {
        if (uri) {
          return resourceManager.load({url: parseRelativeUrl(baseUrl, uri), type: AssetType.Texture2D});
        } else {
          const bufferView = gltf.bufferViews[bufferViewIndex];
          const bufferData = getBufferData(bufferView, buffers);
          return loadImageBuffer(bufferData, mimeType).then((image) => {
            const tex = new Texture2D(resourceManager.engine, image.width, image.height);
            tex.setImageSource(image);
            tex.generateMipmaps();
            return tex;
          });
        }
      }));
    };
    this._loadCompressedTexture = (resourceManager, images, baseUrl) => {
      const promises = images.map((item) => {
        return resourceManager.load({url: parseRelativeUrl(baseUrl, item.uri), type: AssetType.KTX});
      });
      return Promise.all(promises);
    };
  }
  load(item, resourceManager) {
    return new AssetPromise((resolve, reject) => {
      const requestGLTFResource = this.isGLB(item.url) ? this.requestGLB : this.requestGLTF;
      requestGLTFResource(item, resourceManager).then((res) => {
        parseGLTF(res, resourceManager.engine).then((gltf) => {
          resolve(gltf);
        });
      }).catch((e) => {
        console.error(e);
        reject("Error loading glTF JSON from " + item.url);
      });
    });
  }
  isGLB(url) {
    return url.substring(url.lastIndexOf(".") + 1) === "glb";
  }
  _loadGLTFResources(item, gltf, resourceManager) {
    return this._loadBuffers(item.url, gltf, resourceManager).then(this._loadImages);
  }
  _loadBuffers(baseUrl, gltf, resourceManager) {
    if (gltf.buffers) {
      return Promise.all(gltf.buffers.map((item) => {
        if (item instanceof ArrayBuffer) {
          return Promise.resolve(item);
        }
        return resourceManager.load({
          url: parseRelativeUrl(baseUrl, item.uri),
          type: AssetType.Buffer
        });
      })).then((buffers) => {
        return {buffers, gltf, baseUrl, resourceManager};
      });
    }
    return Promise.resolve({baseUrl, gltf, resourceManager});
  }
};
GLTFLoader = __decorate$1([
  resourceLoader(AssetType.Perfab, ["gltf", "glb"])
], GLTFLoader);

var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorate$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
let JSONLoader = class extends Loader {
  load(item) {
    return this.request(item.url, {
      ...item,
      type: "json"
    });
  }
};
JSONLoader = __decorate$2([
  resourceLoader(AssetType.JSON, ["json"], false)
], JSONLoader);

const HEADER_LEN = 12 + 13 * 4;
const COMPRESSED_2D = 0;
function getMipmaps(ktxContainer, loadMipmaps) {
  const mipmaps = [];
  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
  var width = ktxContainer.pixelWidth;
  var height = ktxContainer.pixelHeight;
  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
  for (var level = 0; level < mipmapCount; level++) {
    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];
    dataOffset += 4;
    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
      mipmaps.push({data: byteArray, width, height});
      dataOffset += imageSize;
      dataOffset += 3 - (imageSize + 3) % 4;
    }
    width = Math.max(1, width * 0.5);
    height = Math.max(1, height * 0.5);
  }
  return mipmaps;
}
function isValid(data) {
  if (data.byteLength >= 12) {
    const identifier = new Uint8Array(data, 0, 12);
    if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
      return true;
    }
  }
  return false;
}
function getEngineFormat(internalFormat) {
  switch (internalFormat) {
    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
      return TextureFormat.DXT1;
    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      return TextureFormat.DXT5;
    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
      return TextureFormat.ETC1_RGB;
    case GLCompressedTextureInternalFormat.RGB8_ETC2:
      return TextureFormat.ETC2_RGB;
    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return TextureFormat.ETC2_RGBA5;
    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
      return TextureFormat.ETC2_RGBA8;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGB2;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA2;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGB4;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
      return TextureFormat.ASTC_4x4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
      return TextureFormat.ASTC_5x5;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
      return TextureFormat.ASTC_6x6;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
      return TextureFormat.ASTC_8x8;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
      return TextureFormat.ASTC_10x10;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
      return TextureFormat.ASTC_12x12;
    default:
      const formatName = GLCompressedTextureInternalFormat[internalFormat];
      throw new Error(`this format is not supported in Oasis Engine: ${formatName}`);
  }
}
const khronosTextureContainerParser = {
  parse(buffer, facesExpected, withMipmaps, mapEngineFormat = false) {
    if (!isValid(buffer)) {
      throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
    }
    const dataSize = Uint32Array.BYTES_PER_ELEMENT;
    const headerDataView = new DataView(buffer, 12, 13 * dataSize);
    const endianness = headerDataView.getUint32(0, true);
    const littleEndian = endianness === 67305985;
    const parsedResult = {
      buffer,
      glType: headerDataView.getUint32(1 * dataSize, littleEndian),
      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
      loadType: COMPRESSED_2D
    };
    if (parsedResult.glType !== 0) {
      throw new Error("only compressed formats currently supported");
    } else {
      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
    }
    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
      throw new Error("only 2D textures currently supported");
    }
    if (parsedResult.numberOfArrayElements !== 0) {
      throw new Error("texture arrays not currently supported");
    }
    if (parsedResult.numberOfFaces !== facesExpected) {
      throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
    }
    if (withMipmaps) {
      parsedResult.mipmaps = getMipmaps(parsedResult, true);
    }
    if (mapEngineFormat) {
      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
    }
    return parsedResult;
  }
};

function parseSingleKTX(data) {
  const ktx = khronosTextureContainerParser.parse(data, 1, true, true);
  return {
    mipmaps: ktx.mipmaps,
    engineFormat: ktx.engineFormat,
    internalFormat: ktx.glInternalFormat,
    width: ktx.pixelWidth,
    height: ktx.pixelHeight
  };
}
function parseCubeKTX(dataArray) {
  const mipmapsFaces = [];
  let internalFormat;
  let engineFormat;
  let width;
  let height;
  for (let i = 0; i < dataArray.length; i++) {
    const ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
    mipmapsFaces.push(ktx.mipmaps);
    if (i === 0) {
      width = ktx.pixelWidth;
      height = ktx.pixelHeight;
      internalFormat = ktx.glInternalFormat;
      engineFormat = ktx.engineFormat;
    }
  }
  return {
    mipmapsFaces,
    engineFormat,
    internalFormat,
    width,
    height
  };
}

var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorate$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
let KTXCubeLoader = class extends Loader {
  load(item, resourceManager) {
    return new AssetPromise((resolve, reject) => {
      Promise.all(item.urls.map((url) => this.request(url, {
        ...item,
        type: "arraybuffer"
      }))).then((data) => {
        const parsedData = parseCubeKTX(data);
        const {width, mipmapsFaces, engineFormat} = parsedData;
        const mipmap = mipmapsFaces[0].length > 1;
        const texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);
        for (let face = 0; face < 6; face++) {
          const length = mipmapsFaces[face].length;
          for (let miplevel = 0; miplevel < length; miplevel++) {
            const {data: data2, width: width2, height} = mipmapsFaces[face][miplevel];
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data2, miplevel, 0, 0, width2, height);
          }
        }
        resolve(texture);
      }).catch((e) => {
        reject(e);
      });
    });
  }
};
KTXCubeLoader = __decorate$3([
  resourceLoader(AssetType.KTXCube, [])
], KTXCubeLoader);

var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorate$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
let KTXLoader = class extends Loader {
  load(item, resourceManager) {
    return new AssetPromise((resolve, reject) => {
      this.request(item.url, {
        ...item,
        type: "arraybuffer"
      }).then((bin) => {
        const parsedData = parseSingleKTX(bin);
        const {width, height, mipmaps, engineFormat} = parsedData;
        const mipmap = mipmaps.length > 1;
        const texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
        for (let miplevel = 0; miplevel < mipmaps.length; miplevel++) {
          const {width: width2, height: height2, data} = mipmaps[miplevel];
          texture.setPixelBuffer(data, miplevel, 0, 0, width2, height2);
        }
        resolve(texture);
      }).catch((e) => {
        reject(e);
      });
    });
  }
};
KTXLoader = __decorate$4([
  resourceLoader(AssetType.KTX, ["ktx"])
], KTXLoader);

var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorate$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
let Texture2DLoader = class extends Loader {
  load(item, resourceManager) {
    return new AssetPromise((resolve, reject) => {
      this.request(item.url, {
        ...item,
        type: "image"
      }).then((image) => {
        const texture = new Texture2D(resourceManager.engine, image.width, image.height);
        if (!texture._glTexture)
          return;
        texture.setImageSource(image);
        texture.generateMipmaps();
        if (item.url.indexOf("data:") !== 0) {
          const splitPath = item.url.split("/");
          texture.name = splitPath[splitPath.length - 1];
        }
        resolve(texture);
      }).catch((e) => {
        reject(e);
      });
    });
  }
};
Texture2DLoader = __decorate$5([
  resourceLoader(AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"])
], Texture2DLoader);

var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorate$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
let TextureCubeLoader = class extends Loader {
  load(item, resourceManager) {
    return new AssetPromise((resolve, reject) => {
      Promise.all(item.urls.map((url) => this.request(url, {
        ...item,
        type: "image"
      }))).then((images) => {
        const {width, height} = images[0];
        if (width !== height) {
          console.error("The cube texture must have the same width and height");
          return;
        }
        const tex = new TextureCubeMap(resourceManager.engine, width);
        if (!tex._glTexture)
          return;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }
        tex.generateMipmaps();
        resolve(tex);
      }).catch((e) => {
        reject(e);
      });
    });
  }
};
TextureCubeLoader = __decorate$6([
  resourceLoader(AssetType.TextureCube, [""])
], TextureCubeLoader);

class GLTFModel extends Component {
  constructor(entity) {
    super(entity);
    this._hasBuiltNode = false;
  }
  get asset() {
    return this._asset;
  }
  set asset(value) {
    if (value && value.defaultSceneRoot === this.GLTFNode) {
      return;
    }
    if (!this._hasBuiltNode) {
      this.GLTFNode.clearChildren();
      if (value !== null) {
        if (this.GLTFNode) {
          this.GLTFNode.destroy();
        }
        this.GLTFNode = value.defaultSceneRoot.clone();
        this._animator = this.GLTFNode.getComponent(Animation);
        this.entity.addChild(this.GLTFNode);
      }
    }
    this._asset = value;
  }
  get animator() {
    return this._animator;
  }
  get autoPlay() {
    return this._autoPlay;
  }
  set autoPlay(value) {
    if (this._animator) {
      if (value) {
        this._animator.playAnimationClip(value, {
          wrapMode: this._loop
        });
      } else {
        this._animator.stop(false);
      }
    }
    this._autoPlay = value;
  }
  get loop() {
    return this._loop;
  }
  set loop(value) {
    if (this._animator && this.autoPlay) {
      this._animator.playAnimationClip(this._autoPlay, {
        wrapMode: value
      });
    }
    this._loop = value;
  }
  init(props) {
    const {asset = null, autoPlay, loop, isClone} = props;
    if (isClone) {
      const rootName = props.gltfRootName;
      if (rootName) {
        this.GLTFNode = this.entity.findByName(rootName);
      }
    }
    if (!this.GLTFNode) {
      const rootName = `GLTF-${Date.now()}`;
      props.gltfRootName = rootName;
      this.GLTFNode = this.entity.createChild(rootName);
      this._hasBuiltNode = false;
    } else {
      this._hasBuiltNode = true;
    }
    this.asset = asset;
    this.loop = loop;
    this.autoPlay = autoPlay;
    this.addEventListener("enabled", () => {
      this.GLTFNode.isActive = true;
    });
    this.addEventListener("disabled", () => {
      this.GLTFNode.isActive = false;
    });
  }
}

class PluginManager {
  constructor() {
    this.registeredPlugins = new Set();
    this.plugins = [];
  }
  register(plugin) {
    this.registeredPlugins.add(plugin);
  }
  boot(oasis) {
    for (let plugin of this.registeredPlugins.values()) {
      if (typeof plugin === "function") {
        plugin = plugin(oasis);
      }
      this.plugins.push(plugin);
    }
  }
  reset() {
    this.registeredPlugins.clear();
    this.plugins = [];
  }
  nodeAdded(entity) {
    this.delegateMethod("nodeAdded", entity);
  }
  delegateMethod(name, ...args) {
    this.plugins.forEach((plugin) => plugin[name] && plugin[name](...args));
  }
}
function pluginHook(options) {
  return function(target, propertyName, descriptor) {
    const method = descriptor.value;
    descriptor.value = function(...args) {
      options.before && this.oasis.pluginManager.delegateMethod(options.before, ...args);
      return Promise.resolve(method.apply(this, arguments)).then((returnObj) => {
        options.after && this.oasis.pluginManager.delegateMethod(options.after, returnObj);
        return returnObj;
      });
    };
  };
}

function switchElementsIndex(elements, currentIndex, targetIndex) {
  if (currentIndex === targetIndex || targetIndex === null || targetIndex === void 0) {
    return;
  }
  [elements[currentIndex], elements[targetIndex]] = [elements[targetIndex], elements[currentIndex]];
}
function isAsset(config) {
  return config && config.type === "asset";
}
function getAllGetters(obj) {
  const result = [];
  const prototype = Object.getPrototypeOf(obj);
  const prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);
  for (const [property, descriptor] of Object.entries(prototype_property_descriptors)) {
    if (typeof descriptor.get === "function") {
      result.push(property);
    }
  }
  return result;
}

class SchemaResource {
  constructor(resourceManager, _resource) {
    this.resourceManager = resourceManager;
    this._resource = _resource;
    this._meta = {};
    this._attachedResources = [];
    this.setMeta();
  }
  get resource() {
    return this._resource;
  }
  get meta() {
    return this._meta;
  }
  get attachedResources() {
    return this._attachedResources;
  }
  setMeta() {
  }
  loadWithAttachedResources(resourceLoader, assetConfig, oasis) {
    return new Promise((resolve, reject) => {
      this.load(resourceLoader, assetConfig, oasis).then(() => {
        resolve({
          resources: [this],
          structure: {
            index: 0,
            props: {}
          }
        });
      }).catch((e) => {
        reject(e);
      });
    });
  }
  getProps() {
    return {};
  }
  bind() {
  }
  attach() {
  }
  update(key, value) {
    if (isAsset(value)) {
      const resource = this.resourceManager.get(value.id);
      if (resource) {
        this._resource[key] = resource.resource;
      } else {
        Logger.warn(`SchemaResource: ${this.meta.name} can't find asset, which id is: ${value.id}`);
      }
    } else {
      this._resource[key] = value;
    }
  }
  updateMeta(key, value) {
    this._meta[key] = value;
  }
  onDestroy() {
  }
}

class TextureResource extends SchemaResource {
  load(resourceManager, assetConfig, oasis) {
    return new Promise((resolve, reject) => {
      let url;
      let assetType = AssetType.Texture2D;
      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {
        const rhi = oasis.engine._hardwareRenderer;
        const compressions = assetConfig.props.compression.compressions;
        for (let i = 0; i < compressions.length; i++) {
          const compression = compressions[i];
          if (compression.container === "ktx" && rhi.canIUse(GLCapabilityType[compression.type])) {
            url = compression.url;
            assetType = AssetType.KTX;
            break;
          }
        }
      }
      url = url ?? assetConfig.url;
      resourceManager.load({url, type: assetType}).then((res) => {
        this._resource = res;
        resolve(this);
      }).catch((e) => {
        reject(e);
      });
    });
  }
  setMeta() {
    if (this.resource) {
      this._meta.name = this.resource.name;
      if (this.resource.image) {
        this._meta.url = this.resource.image.src;
      }
    }
  }
}

class PBRMaterialResource extends SchemaResource {
  load(resourceManager, assetConfig) {
    return new Promise((resolve) => {
      const assetObj = new PBRMaterial(resourceManager.engine, assetConfig.name);
      this.configProps = assetConfig.props;
      for (let k in this.configProps) {
        if (!isAsset(this.configProps[k])) {
          assetObj[k] = this.configProps[k];
        }
      }
      this._resource = assetObj;
      this.setMeta();
      resolve(this);
    });
  }
  loadWithAttachedResources(resourceManager, assetConfig) {
    return new Promise((resolve, reject) => {
      let loadPromise;
      if (assetConfig.resource instanceof PBRMaterial) {
        loadPromise = new Promise((resolve2) => {
          this._resource = assetConfig.resource;
          this.setMeta();
          resolve2(this);
        });
      } else if (assetConfig.props) {
        loadPromise = this.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(() => {
          const result = {
            resources: [this],
            structure: {
              index: 0,
              props: {}
            }
          };
          const material = this._resource;
          getAllGetters(this._resource).forEach((attr) => {
            if (!(material[attr] instanceof Texture))
              return;
            const textureResource = new TextureResource(this.resourceManager, material[attr]);
            this.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  }
  setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  }
  getProps() {
    const result = {};
    const props = getAllGetters(this.resource);
    props.forEach((prop) => result[prop] = this.resource[prop]);
    return result;
  }
  bind() {
    const resource = this._resource;
    Object.keys(this.configProps).forEach((attr) => {
      const value = this.configProps[attr];
      if (isAsset(value)) {
        const textureResource = this.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          this._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn(`PBRMaterialResource: ${this.meta.name} can't find asset "${attr}", which id is: ${value.id}`);
        }
      } else {
        if (attr === "side") {
          return;
        }
        resource[attr] = value;
      }
    });
  }
}

class GLTFResource$1 extends SchemaResource {
  load(resourceManager, assetConfig, oasis) {
    if (!!assetConfig.props?.compression) {
      glTFDracoMeshCompression.init();
    }
    return resourceManager.load({url: assetConfig.url, type: AssetType.Perfab}).then((res) => {
      const gltf = res;
      if (assetConfig.props) {
        gltf.newMaterial = assetConfig.props.newMaterial;
      }
      this._resource = gltf;
    });
  }
  loadWithAttachedResources(resourceManager, assetConfig, oasis) {
    return new Promise((resolve) => {
      this.load(resourceManager, assetConfig, oasis).then(() => {
        const gltf = this.resource;
        const {materials} = gltf;
        const loadPromises = [];
        const result = {
          resources: [this],
          structure: {
            index: 0,
            props: {
              newMaterial: []
            }
          }
        };
        for (let i = 0; i < materials.length; i++) {
          const material = materials[i];
          const materialResource = new PBRMaterialResource(this.resourceManager);
          this._attachedResources.push(materialResource);
          loadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {
            type: "PBRMaterial",
            name: material.name,
            resource: material
          }));
        }
        Promise.all(loadPromises).then((res) => {
          const newMaterial = result.structure.props.newMaterial;
          res.forEach((mat) => {
            const matStructure = mat.structure;
            const matResource = mat.resources[matStructure.index];
            result.resources.push(matResource);
            matStructure.index = result.resources.length - 1;
            for (const key in matStructure.props) {
              if (matStructure.props.hasOwnProperty(key)) {
                const textureStructure = matStructure.props[key];
                const textureResource = mat.resources[textureStructure.index];
                result.resources.push(textureResource);
                textureStructure.index = result.resources.length - 1;
              }
            }
            newMaterial.push(matStructure);
          });
          resolve(result);
        });
      });
    });
  }
  setMeta(assetConfig) {
    if (assetConfig) {
      this.meta.name = assetConfig.name;
    }
  }
  bind() {
    const resource = this._resource;
    this.bindMaterials(resource.newMaterial);
  }
  update(key, value) {
    if (key === "newMaterial") {
      this.bindMaterials(value);
    } else {
      this._resource[key] = value;
    }
  }
  bindMaterials(materials) {
    if (!materials || !materials.length) {
      return;
    }
    const gltf = this._resource;
    const meshes = gltf.meshes;
    for (let i = 0; i < materials.length; i++) {
      const mtlResource = this.resourceManager.get(materials[i].id);
      if (mtlResource) {
        this._attachedResources.push(mtlResource);
        gltf.materials[i] = mtlResource.resource;
      } else {
        Logger.warn(`GLTFResource: ${this.meta.name} can't find asset "material", which id is: ${materials[i].id}`);
      }
    }
    for (let j = 0; j < meshes.length; j++) {
      const node = this.getNodeByMeshIndex(gltf.nodes, meshes.length - 1 - j);
      if (node) {
        for (let k = 0; k < meshes[j].primitives.length; k++) {
          const primitive = meshes[j].primitives[k];
          const meshRenderer = node.getComponent(MeshRenderer);
          const material = gltf.materials[gltf.materials.length - 1 - primitive.materialIndex];
          if (meshRenderer && material && material instanceof Material) {
            meshRenderer.setSharedMaterial(k, material);
          }
        }
      }
    }
  }
  getNodeByMeshIndex(nodes, index) {
    for (let i = 0; i <= nodes.length; i++) {
      const node = nodes[i];
      if (node.meshIndex === index) {
        return node;
      }
    }
    return null;
  }
}

class ShaderMaterialResource extends SchemaResource {
  loadShaderDefine(oasis) {
    return new Promise((resolve) => {
      const name = this.scripts[0].name;
      if (this.resourceManager.isLocal) {
        resolve(oasis.options?.scripts[name] ?? {});
      } else {
        const oldScriptDom = document.getElementById(name);
        if (oldScriptDom) {
          document.body.removeChild(oldScriptDom);
        }
        const scriptDom = document.createElement("script");
        scriptDom.crossOrigin = "anonymous";
        scriptDom.onload = () => {
          const scripts = window.o3Scripts;
          resolve((scripts && scripts[name]) ?? {});
        };
        scriptDom.id = name;
        scriptDom.src = this._meta.url;
        document.body.appendChild(scriptDom);
      }
    }).then((shaderMaterialDefine) => {
      const {
        vertexShader = "",
        fragmentShader = "",
        states = {},
        uniforms = {},
        attributes = {}
      } = shaderMaterialDefine;
      this._resource.uniforms = uniforms;
      this._resource.attributes = attributes;
      this._resource.vertexShader = vertexShader;
      this._resource.fragmentShader = fragmentShader;
      this._resource.renderStates = states;
    });
  }
  createMaterial(engine) {
    const material = new ShaderMaterial(engine, this.meta.name || "shader_mtl");
    this._resource = material;
  }
  load(resourceLoader, assetConfig, oasis) {
    this.setMeta(assetConfig);
    this.scripts = assetConfig.props.scripts;
    this.createMaterial(oasis.engine);
    return this.loadShaderDefine(oasis).then(() => new Promise((resolve, reject) => {
      try {
        for (let k in assetConfig.props) {
          this._resource[k] = assetConfig.props[k];
        }
        this._resource.updateTechnique();
        resolve(this);
      } catch {
        reject("[shader material] createTechnique error");
      }
    }));
  }
  setMeta(assetConfig) {
    if (assetConfig) {
      this._meta.name = assetConfig.name;
      this._meta.url = assetConfig.url;
      this._meta.source = assetConfig.source;
    }
  }
  updateMeta(key, value) {
    super.updateMeta(key, value);
    if (key === "url") {
      this.loadShaderDefine().then(() => {
        try {
          this._resource.updateTechnique();
        } catch {
          console.error("[shader material] createTechnique error");
        }
      });
    }
  }
  update(key, value) {
    this._resource[key] = value;
    this._resource.updateTechnique();
  }
}

const scriptAbility = {};
function script(name) {
  return (target) => {
    scriptAbility[name] = target;
  };
}
class ScriptResource extends SchemaResource {
  constructor() {
    super(...arguments);
    this.isInit = false;
  }
  initScriptContext() {
    if (this.isInit) {
      return;
    }
    this.isInit = true;
    window.__o3_script_context__ = {
      o3: Parser._components["o3"],
      script: (name) => {
        return (target) => {
          scriptAbility[name] = target;
        };
      }
    };
  }
  load(resourceLoader, assetConfig, oasis) {
    this.initScriptContext();
    return new Promise((resolve) => {
      const config = assetConfig;
      const scripts = config.props.scripts;
      if (!this.resourceManager.isLocal) {
        const scriptDom = document.createElement("script");
        scriptDom.crossOrigin = "anonymous";
        this.setMeta(assetConfig);
        scriptDom.onload = () => {
          const o3Scripts = window.o3Scripts;
          for (let i = 0; i < scripts.length; i++) {
            const name = scripts[i].name;
            this._resource = o3Scripts && o3Scripts[name];
            scriptAbility[name] = this._resource;
          }
          resolve(this);
        };
        scriptDom.src = assetConfig.url;
        document.body.appendChild(scriptDom);
      } else {
        for (let i = 0; i < scripts.length; i++) {
          const name = scripts[i].name;
          scriptAbility[name] = oasis.options?.scripts[name];
        }
        resolve(this);
      }
    });
  }
  setMeta(assetConfig) {
    if (assetConfig) {
      this._meta.name = assetConfig.name;
      this._meta.url = assetConfig.url;
      this._meta.source = assetConfig.source;
    }
  }
}

class BlinnPhongMaterialResource extends SchemaResource {
  load(resourceManager, assetConfig) {
    return new Promise((resolve) => {
      const assetObj = new BlinnPhongMaterial(resourceManager.engine, assetConfig.name);
      for (let k in assetConfig.props) {
        assetObj[k] = assetConfig.props[k];
      }
      this._resource = assetObj;
      this.setMeta();
      resolve(this);
    });
  }
  setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  }
}

const imageOrderMap = {
  px: 0,
  nx: 1,
  py: 2,
  ny: 3,
  pz: 4,
  nz: 5
};
class TextureCubeMapResource extends SchemaResource {
  load(resourceManager, assetConfig, oasis) {
    return new Promise((resolve, reject) => {
      const imageUrls = [];
      let type = AssetType.TextureCube;
      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {
        const rhi = oasis.engine._hardwareRenderer;
        const compressions = assetConfig.props.compression.compressions;
        for (let i = 0; i < compressions.length; i++) {
          const compression = compressions[i];
          if (compression.container === "ktx" && rhi.canIUse(GLCapabilityType[compression.type])) {
            for (const key in compression.files) {
              if (compression.files.hasOwnProperty(key)) {
                const image = compression.files[key];
                imageUrls[imageOrderMap[key]] = image.url;
              }
            }
            console.warn(compression.type);
            type = AssetType.KTXCube;
            break;
          }
        }
      }
      if (type === AssetType.TextureCube) {
        for (const key in assetConfig.props.images) {
          if (assetConfig.props.images.hasOwnProperty(key)) {
            const image = assetConfig.props.images[key];
            imageUrls[imageOrderMap[key]] = image.url;
          }
        }
      }
      resourceManager.load({
        urls: imageUrls,
        type
      }).then((res) => {
        this._resource = res;
        resolve(this);
      }).catch((e) => {
        reject(e);
      });
    });
  }
  setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  }
}

class BaseResource extends SchemaResource {
  load(resourceLoader, assetConfig) {
    return new Promise((resolve) => {
      this._resource = assetConfig;
      this.setMetaData("name", this.resource.name);
      this.setMetaData("url", this.resource.url);
      resolve(this);
    });
  }
  setMetaData(key, value) {
    this._meta[key] = value;
  }
}

var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorate$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$7(target, key, result);
  return result;
};
class AbilityManager {
  constructor(oasis) {
    this.oasis = oasis;
    this.abilityMap = {};
  }
  add(abilityConfig) {
    const {type, node: nodeId, props, id, index} = abilityConfig;
    const node = this.oasis.nodeManager.get(nodeId);
    const AbilityConstructor = this.getCompConstructor(type);
    if (!AbilityConstructor) {
      Logger.error(`${type} abiltiy is not defined`);
      return;
    }
    const abilityProps = this.mixPropsToExplicitProps(props);
    const ability = node.addComponent(AbilityConstructor);
    const {enabled} = abilityProps;
    if (enabled !== void 0) {
      ability.enabled = enabled;
    }
    if (type === "Model" || type === "GLTFModel" || type === "Particle") {
      ability.init(abilityProps);
    } else {
      for (let k in abilityProps) {
        if (abilityProps[k] !== null) {
          ability[k] = abilityProps[k];
        }
      }
    }
    const abilityArray = node._components;
    const currentIndex = abilityArray.length - 1;
    switchElementsIndex(abilityArray, currentIndex, index);
    ability.id = id;
    this.abilityMap[id] = ability;
    return ability;
  }
  update(id, key, value) {
    if (this.get(id).constructor.name === "Model") {
      if (value && this.checkIsAsset(value)) {
        this.get(id).setProp(key, this.oasis.resourceManager.get(value.id).resource);
      } else {
        this.get(id).setProp(key, value);
      }
    } else {
      if (value && this.checkIsAsset(value)) {
        this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;
      } else {
        this.get(id)[key] = value;
      }
    }
    return {id, key, value};
  }
  get(id) {
    return this.abilityMap[id];
  }
  delete(id) {
    const ability = this.abilityMap[id];
    ability.destroy();
    delete this.abilityMap[id];
    return id;
  }
  getCompConstructor(type) {
    const splits = type.split(".");
    if (splits[0] === "script") {
      return scriptAbility[splits[1]];
    }
    const constructor = Parser._components["o3"][type];
    if (!constructor) {
      throw new Error(`${type} is not defined`);
    }
    return constructor;
  }
  mixPropsToExplicitProps(props) {
    const explicitProps = {...props};
    for (let k in props) {
      const prop = props[k];
      if (prop && this.checkIsAsset(prop)) {
        const res = this.oasis.resourceManager.get(prop.id);
        if (res) {
          explicitProps[k] = res.resource;
        } else {
          explicitProps[k] = null;
          Logger.warn(`AbilityManager: can't get asset "${k}", which id is ${prop.id}`);
        }
      }
    }
    return explicitProps;
  }
  checkIsAsset(prop) {
    return prop.type === "asset";
  }
}
__decorate$7([
  pluginHook({after: "abilityAdded", before: "beforeAbilityAdded"})
], AbilityManager.prototype, "add", 1);
__decorate$7([
  pluginHook({before: "beforeAbilityUpdated", after: "abilityUpdated"})
], AbilityManager.prototype, "update", 1);
__decorate$7([
  pluginHook({after: "abilityDeleted", before: "beforeAbilityDeleted"})
], AbilityManager.prototype, "delete", 1);

var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorate$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$8(target, key, result);
  return result;
};
class NodeManager {
  constructor(oasis) {
    this.oasis = oasis;
    this.nodeMap = {};
    this.root = new Entity(this.oasis.engine, "root");
  }
  addRootEntity() {
    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);
  }
  add(nodeConfig) {
    this.create(nodeConfig);
    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);
    return this.get(nodeConfig.id);
  }
  update(id, key, value) {
    this.get(id)[key] = value;
    return {id, key, value};
  }
  get(id) {
    return this.nodeMap[id];
  }
  reset() {
    this.nodeMap = {};
  }
  delete(id) {
    this.nodeMap[id].destroy();
    delete this.nodeMap[id];
  }
  create(nodeConfig) {
    const {isActive, position, rotation, scale, id, name} = nodeConfig;
    const entity = new Entity(this.oasis.engine, name);
    entity.isActive = isActive;
    entity.transform.position = new Vector3(position[0], position[1], position[2]);
    entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);
    entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);
    entity.id = id;
    this.nodeMap[id] = entity;
    return entity;
  }
  append(childId, parentId, index) {
    const child = this.nodeMap[childId];
    const parent = this.nodeMap[parentId] || this.root;
    parent.addChild(child);
    const children = parent._children;
    const currentIndex = children.length - 1;
    switchElementsIndex(children, currentIndex, index);
  }
}
__decorate$8([
  pluginHook({after: "nodeAdded"})
], NodeManager.prototype, "add", 1);
__decorate$8([
  pluginHook({before: "beforeNodeUpdated", after: "nodeUpdated"})
], NodeManager.prototype, "update", 1);
__decorate$8([
  pluginHook({before: "beforeNodeDeleted"})
], NodeManager.prototype, "delete", 1);

var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorate$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$9(target, key, result);
  return result;
};
const RESOURCE_CLASS = {
  script: ScriptResource,
  gltf: GLTFResource$1,
  texture: TextureResource,
  cubeTexture: TextureCubeMapResource,
  PBRMaterial: PBRMaterialResource,
  PBRSpecularMaterial: PBRMaterialResource,
  unlitMaterial: PBRMaterialResource,
  ShaderMaterial: ShaderMaterialResource,
  BlinnPhongMaterial: BlinnPhongMaterialResource,
  base: BaseResource
};
const RESOURCE_TYPE = new Map();
for (const key in RESOURCE_CLASS) {
  if (RESOURCE_CLASS.hasOwnProperty(key)) {
    const element = RESOURCE_CLASS[key];
    if (element === PBRMaterialResource) {
      RESOURCE_TYPE.set(element, "PBRMaterial");
    } else {
      RESOURCE_TYPE.set(element, key);
    }
  }
}
const resourceFactory = {
  createResource(resourceManager, type) {
    return new RESOURCE_CLASS[type](resourceManager);
  }
};
function registerResource(type, resource) {
  if (!RESOURCE_CLASS.hasOwnProperty(type)) {
    RESOURCE_CLASS[type] = resource;
    RESOURCE_TYPE.set(resource, type);
  }
}
class SchemaResourceManager {
  constructor(oasis) {
    this.oasis = oasis;
    this.resourceMap = {};
    this.resourceIdMap = new WeakMap();
    this.maxId = 0;
    this.engineResourceManager = this.oasis.engine.resourceManager;
  }
  load(asset) {
    const resource = resourceFactory.createResource(this, asset.type);
    const loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);
    this.maxId = Math.max(+asset.id, this.maxId);
    loadPromise.then(() => {
      this.resourceMap[asset.id] = resource;
      this.resourceIdMap.set(resource, asset.id);
    });
    return loadPromise;
  }
  add(asset) {
    const resource = resourceFactory.createResource(this, asset.type);
    return new Promise((resolve) => {
      resource.loadWithAttachedResources(this.oasis.engine.resourceManager, asset, this.oasis).then((result) => {
        resolve(this.getAddResourceResult(result.resources, result.structure));
      });
    });
  }
  remove(id) {
    return new Promise((resolve) => {
      const resource = this.resourceMap[id];
      const result = [id];
      let hasAttachedResource = false;
      delete this.resourceMap[id];
      if (resource) {
        const attached = resource.attachedResources;
        for (let index = 0; index < attached.length; index++) {
          const attachedResource = attached[index];
          const attachedResourceId = this.resourceIdMap.get(attachedResource);
          if (attachedResourceId) {
            hasAttachedResource = true;
            this.remove(attachedResourceId).then((attachedResourceRemoveResult) => {
              result.push(...attachedResourceRemoveResult);
              resolve(result);
            });
          }
        }
      }
      if (!hasAttachedResource) {
        resolve(result);
      }
    });
  }
  update(id, key, value) {
    const resource = this.get(id);
    if (resource) {
      resource.update(key, value);
    }
    return {
      resource,
      id,
      key,
      value
    };
  }
  updateMeta(id, key, value) {
    const resource = this.get(id);
    if (resource) {
      resource.updateMeta(key, value);
    }
  }
  get(id) {
    return this.resourceMap[id];
  }
  getAll() {
    return ObjectValues(this.resourceMap);
  }
  getAddResourceResult(resources2, structure) {
    const addResourceResult = {};
    const resource = resources2[structure.index];
    const id = `${++this.maxId}`;
    this.resourceMap[id] = resource;
    this.resourceIdMap.set(resource, id);
    addResourceResult.id = this.maxId;
    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);
    addResourceResult.meta = resource.meta;
    addResourceResult.props = {};
    for (const key in structure.props) {
      if (structure.props.hasOwnProperty(key)) {
        const element = structure.props[key];
        if (element) {
          if (Array.isArray(element)) {
            addResourceResult.props[key] = element.map((child) => this.getAddResourceResult(resources2, child));
          } else {
            addResourceResult.props[key] = this.getAddResourceResult(resources2, element);
          }
        }
      }
    }
    return addResourceResult;
  }
  get isLocal() {
    return this.oasis.options.local;
  }
  get useCompressedTexture() {
    return this.oasis.options.useCompressedTexture ?? true;
  }
}
__decorate$9([
  pluginHook({before: "beforeResourceRemove"})
], SchemaResourceManager.prototype, "remove", 1);
__decorate$9([
  pluginHook({after: "resourceUpdated", before: "beforeResourceUpdate"})
], SchemaResourceManager.prototype, "update", 1);

var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorate$a = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$a(target, key, result);
  return result;
};
class Oasis extends EventDispatcher {
  constructor(_options, pluginManager) {
    super(_options.engine);
    this._options = _options;
    this.pluginManager = pluginManager;
    this.engine = null;
    this.oasis = this;
    this.engine = _options.engine;
    this.resetFeature();
    this.schema = _options.config;
    this.timeout = _options.timeout;
    _options.scripts = _options.scripts ?? {};
    this.nodeManager = new NodeManager(this);
    this.abilityManager = new AbilityManager(this);
    this.nodeManager.add = this.nodeManager.add.bind(this.nodeManager);
    this.abilityManager.add = this.abilityManager.add.bind(this.abilityManager);
    this.resourceManager = new SchemaResourceManager(this);
    if (_options.fps) {
      this.engine.targetFrameRate = _options.fps;
      this.engine.vSyncCount = 0;
    }
  }
  get canvas() {
    return this._options.canvas;
  }
  get options() {
    return this._options;
  }
  updateConfig(config) {
    this.schema = config;
    this.init();
  }
  init() {
    return this.loadResources().then(() => {
      this.bindResources();
      this.parseEntities();
      this.parseNodeAbilities();
      this.attach();
      this.nodeManager.addRootEntity();
      this.pluginManager.boot(this);
    });
  }
  loadResources() {
    const {assets = {}} = this.schema;
    const loadingPromises = ObjectValues(assets).filter((asset) => {
      if (RESOURCE_CLASS[asset.type]) {
        return true;
      }
      console.warn(`${asset.type} loader is not defined. the ${asset.type} type will be ignored.`);
      return false;
    }).map((asset) => this.resourceManager.load(asset));
    return Promise.all(loadingPromises);
  }
  bindResources() {
    this.resourceManager.getAll().forEach((resource) => {
      resource.bind();
    });
  }
  parseEntities() {
    const {nodes} = this.schema;
    const indices = this.bfsNodes();
    indices.map((index) => nodes[index]).forEach(this.nodeManager.add);
  }
  parseNodeAbilities() {
    const {abilities} = this.schema;
    Object.keys(abilities).map((id) => ({id, ...abilities[id]})).forEach(this.abilityManager.add);
  }
  bfsNodes() {
    const {nodes} = this.schema;
    const roots = ObjectValues(nodes).filter((node) => !nodes[node.parent]).map((node) => node.id);
    let result = [];
    const traverseChildren = (roots2) => {
      result = result.concat(roots2);
      roots2.forEach((id) => {
        const children = nodes[id].children;
        children && traverseChildren(children);
      });
    };
    traverseChildren(roots);
    return result;
  }
  resetFeature() {
    const scene = this.engine.sceneManager.activeScene;
    scene.features.splice(2, 1);
    scene.features.splice(3, 1);
    scene.hasFogFeature = void 0;
    scene.getFogMacro = void 0;
    scene.bindFogToMaterial = void 0;
  }
  attach() {
    this.resourceManager.getAll().forEach((resource) => {
      resource.attach();
    });
  }
  static create(options, pluginManager) {
    const oasis = new Oasis(options, pluginManager);
    return oasis.init().then(() => {
      options.autoPlay && oasis.engine.run();
      return oasis;
    });
  }
}
__decorate$a([
  pluginHook({after: "schemaParsed"})
], Oasis.prototype, "init", 1);

const _vec3Attribute = [
  "color",
  "center",
  "size",
  "__position",
  "__positionRandomness",
  "__color",
  "__velocity",
  "__velocityRandomness",
  "__acceleration",
  "__accelerationRandomness",
  "_center"
];
function compatibleToV2(config) {
  const {abilities = {}, assets = {}} = config;
  const ids = Object.keys(abilities);
  const assetKeys = Object.keys(assets);
  for (let i = 0, l = ids.length; i < l; ++i) {
    handleProps(abilities[ids[i]].props);
  }
  for (let i = 0, l = assetKeys.length; i < l; ++i) {
    handleAssets(assets[assetKeys[i]].props);
  }
  return config;
}
function handleProps(props) {
  const keys = Object.keys(props);
  for (let i = 0, l = keys.length; i < l; ++i) {
    const k = keys[i];
    const v = props[k];
    if (v !== null && typeof v === "object" && v.length > 1) {
      if (k === "backgroundColor" || k === "tintColor") {
        props[k] = new Vector4(v[0], v[1], v[2], v[3]);
      } else if (_vec3Attribute.indexOf(k) !== -1) {
        props[k] = new Vector3(v[0], v[1], v[2]);
      }
    }
  }
}
function handleAssets(props = {}) {
  if (!props) {
    return;
  }
  const keys = Object.keys(props);
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i];
    const value = props[key];
    if (key === "newMaterial" || key === "blendFuncSeparate" || key === "scripts") {
      continue;
    }
    switch (value?.length) {
      case 2:
        props[key] = new Vector2(value[0], value[1]);
        break;
      case 3:
        props[key] = new Vector3(value[0], value[1], value[2]);
        break;
      case 4:
        props[key] = new Vector4(value[0], value[1], value[2], value[3]);
        break;
    }
  }
}

const CURRENT_SCHEMA_VERSION = 3;
class Parser {
  constructor() {
    this.pluginManager = new PluginManager();
  }
  parse(options) {
    if (options?.config?.version !== CURRENT_SCHEMA_VERSION) {
      console.warn(`schema-parser: schema version "${options?.config?.version}" is out of date, please re-pull the latest version (version ${CURRENT_SCHEMA_VERSION}) of the schema`);
    }
    compatibleToV2(options.config);
    return Oasis.create(options, this.pluginManager);
  }
  register(plugin) {
    this.pluginManager.register(plugin);
  }
  resetPlugins() {
    this.pluginManager.reset();
  }
  static create() {
    const parser2 = new Parser();
    return parser2;
  }
  static registerComponents(namespace, components) {
    if (!this._components[namespace]) {
      this._components[namespace] = {};
    }
    Object.assign(this._components[namespace], components);
  }
}
Parser._components = {};
const parser = Parser.create();

export { GLTFModel, Oasis, Parser, RegistExtension, SchemaResource, parseSingleKTX, parser, registerResource, script };
//# sourceMappingURL=module.js.map
