import { E as EngineFeature, d as Engine, e as Entity, L as Logger } from '../common/module-a3d382dc.js';

function log(...args) {
  Logger.info("\u{1F680} [o3-engine-stats]", ...args);
}
function errorLog(...args) {
  Logger.error("\u{1F680} [o3-engine-stats]", ...args);
}

class DrawCallHook {
  constructor(gl) {
    this.drawCall = 0;
    this.triangles = 0;
    this.lines = 0;
    this.points = 0;
    this.realDrawElements = gl.drawElements;
    this.realDrawArrays = gl.drawArrays;
    gl.drawElements = this.hookedDrawElements.bind(this);
    gl.drawArrays = this.hookedDrawArrays.bind(this);
    this.hooked = true;
    this.gl = gl;
    log(`DrawCall is hooked.`);
  }
  hookedDrawElements(mode, count, type, offset) {
    this.realDrawElements.call(this.gl, mode, count, type, offset);
    this.update(count, mode);
  }
  hookedDrawArrays(mode, first, count) {
    this.realDrawArrays.call(this.gl, mode, first, count);
    this.update(count, mode);
  }
  update(count, mode) {
    const {gl} = this;
    this.drawCall++;
    switch (mode) {
      case gl.TRIANGLES:
        this.triangles += count / 3;
        break;
      case gl.TRIANGLE_STRIP:
      case gl.TRIANGLE_FAN:
        this.triangles += count - 2;
        break;
      case gl.LINES:
        this.lines += count / 2;
        break;
      case gl.LINE_STRIP:
        this.lines += count - 1;
        break;
      case gl.LINE_LOOP:
        this.lines += count;
        break;
      case gl.POINTS:
        this.points += count;
        break;
      default:
        errorLog(`Unknown draw mode: ${mode}`);
        break;
    }
  }
  reset() {
    this.drawCall = 0;
    this.triangles = 0;
    this.lines = 0;
    this.points = 0;
  }
  release() {
    if (this.hooked) {
      this.gl.drawElements = this.realDrawElements;
      this.gl.drawArrays = this.realDrawArrays;
    }
    this.hooked = false;
  }
}

class ShaderHook {
  constructor(gl) {
    this.shaders = 0;
    this.realAttachShader = gl.attachShader;
    this.realDetachShader = gl.detachShader;
    gl.attachShader = this.hookedAttachShader.bind(this);
    gl.detachShader = this.hookedDetachShader.bind(this);
    this.hooked = true;
    this.gl = gl;
    log(`Shader is hooked.`);
  }
  hookedAttachShader(program, shader) {
    this.realAttachShader.call(this.gl, program, shader);
    this.shaders++;
    log(`AttachShader:`, shader, `shaders: ${this.shaders}`);
  }
  hookedDetachShader(program, shader) {
    this.realDetachShader.call(this.gl, program, shader);
    this.shaders--;
    log(`DetachShader. shaders: ${this.shaders}`);
  }
  reset() {
    this.shaders = 0;
  }
  release() {
    if (this.hooked) {
      this.gl.attachShader = this.realAttachShader;
      this.gl.detachShader = this.realDetachShader;
    }
    this.hooked = false;
  }
}

class TextureHook {
  constructor(gl) {
    this.textures = 0;
    this.realCreateTexture = gl.createTexture;
    this.realDeleteTexture = gl.deleteTexture;
    gl.createTexture = this.hookedCreateTexture.bind(this);
    gl.deleteTexture = this.hookedDeleteTexture.bind(this);
    this.hooked = true;
    this.gl = gl;
    log(`Texture is hooked.`);
  }
  hookedCreateTexture() {
    let texture = this.realCreateTexture.call(this.gl);
    this.textures++;
    log(`CreateTexture:`, texture, `textures: ${this.textures}`);
    return texture;
  }
  hookedDeleteTexture(texture) {
    this.realDeleteTexture.call(this.gl, texture);
    this.textures--;
    log(`DeleteTexture. textures: ${this.textures}`);
  }
  reset() {
    this.textures = 0;
  }
  release() {
    if (this.hooked) {
      this.gl.createTexture = this.realCreateTexture;
      this.gl.deleteTexture = this.realDeleteTexture;
    }
    this.hooked = false;
  }
}

class Core {
  constructor(gl) {
    this.samplingFrames = 60;
    this.samplingIndex = 0;
    this.gl = gl;
    this.hook(gl);
  }
  hook(gl) {
    this.drawCallHook = new DrawCallHook(gl);
    this.textureHook = new TextureHook(gl);
    this.shaderHook = new ShaderHook(gl);
  }
  reset() {
    this.drawCallHook && this.drawCallHook.reset();
  }
  release() {
    this.drawCallHook && this.drawCallHook.release();
    this.textureHook && this.textureHook.release();
    this.shaderHook && this.shaderHook.release();
  }
  update() {
    let now = performance.now();
    let delta = now - this.now;
    this.now = now;
    if (this.samplingIndex !== this.samplingFrames) {
      this.reset();
      this.samplingIndex++;
      return;
    }
    this.samplingIndex = 0;
    let data = {
      fps: delta ? 1e3 / delta >> 0 : 0,
      memory: performance.memory && performance.memory.usedJSHeapSize / 1048576 >> 0,
      drawCall: this.drawCallHook.drawCall,
      triangles: this.drawCallHook.triangles,
      nodes: Entity._entitys.length,
      lines: this.drawCallHook.lines,
      points: this.drawCallHook.points,
      textures: this.textureHook.textures,
      shaders: this.shaderHook.shaders,
      webglContext: window.hasOwnProperty("WebGL2RenderingContext") && this.gl instanceof WebGL2RenderingContext ? "2.0" : "1.0"
    };
    this.reset();
    return data;
  }
}

let tpl = `
  <dl>
    <dt>FPS</dt>
    <dd>0</dd>
    <dt>Memory <span class="unit">(MB)</span></dt>
    <dd>0</dd>
    <dt>DrawCall</dt>
    <dd>0</dd>
    <dt>Triangles</dt>
    <dd>0</dd>
    <dt>Nodes</dt>
    <dd>0</dd>
    <dt>Textures</dt>
    <dd>0</dd>
    <dt>Shaders</dt>
    <dd>0</dd>
    <dt>WebGL</dt>
    <dd></dd>
  </dl>
`;
let css = `
  .gl-perf {
    pointer-events: none;
    user-select: none;
    position: fixed;
    top: 0;
    left: 0;
    padding: ${10 / 7.5}vh ${10 / 7.5}vh 0 ${10 / 7.5}vh;
    background: rgba(0, 0, 0, 0.3);
    color: #fff;
    font: ${10 / 7.5}vh arial;
  }

  .gl-perf dl,
  .gl-perf dt,
  .gl-perf dd {
    padding: 0;
    margin: 0;
  }

  .gl-perf dt {
    color: #fff;
    text-shadow: #000 0 0 1px;
  }

  .gl-perf dt .unit{
    font-size: ${10 / 7.5}vh;
  }

  .gl-perf dd {
    font-size: ${20 / 7.5}vh;
    padding: ${10 / 7.5}vh 0 ${10 / 7.5}vh;
  }
`;
class Monitor {
  constructor(gl) {
    this.core = new Core(gl);
    this.items = [];
    this.items = ["fps", "memory", "drawCall", "triangles", "nodes", "textures", "shaders", "webglContext"];
    this.createContainer();
    this.update = this.update.bind(this);
  }
  createContainer() {
    let container = document.createElement("div");
    container.classList.add("gl-perf");
    container.innerHTML = tpl;
    container.appendChild(this.createStyle());
    document.body.appendChild(container);
    this.doms = Array.prototype.slice.apply(container.querySelectorAll("dd"));
    this.container = container;
  }
  createStyle() {
    let style = document.createElement("style");
    style.type = "text/css";
    style.appendChild(document.createTextNode(css));
    return style;
  }
  update() {
    let data = this.core.update();
    if (data) {
      for (let i = 0, l = this.items.length; i < l; i++) {
        let dom = this.doms[i];
        let item = this.items[i];
        let value = data[item] || 0;
        requestAnimationFrame(() => {
          dom.innerText = value;
        });
      }
    }
  }
  reset() {
    this.core.reset();
  }
  release() {
    this.core.release();
  }
  destroy() {
    this.release();
    document.body.removeChild(this.container);
  }
}

class Stats extends EngineFeature {
  constructor() {
    super();
  }
  preTick(engine, currentScene) {
    if (!this.monitor) {
      const gl = currentScene.engine._hardwareRenderer.gl;
      if (gl) {
        this.monitor = new Monitor(gl);
      }
    }
  }
  postTick(engine, currentScene) {
    if (this.monitor) {
      this.monitor.update();
    }
  }
}

Engine.registerFeature(Stats);

export { Stats };
