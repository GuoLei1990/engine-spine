'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var miniprogram = require('oasis-engine/dist/miniprogram');
var miniprogramAdapter = require('@ali/miniprogram-adapter');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function log() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  miniprogram.Logger.info.apply(miniprogram.Logger, ["🚀 [o3-engine-stats]"].concat(args));
}
function errorLog() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  miniprogram.Logger.error.apply(miniprogram.Logger, ["🚀 [o3-engine-stats]"].concat(args));
}

/**
 * @class DrawCallHook
 */

var DrawCallHook = /*#__PURE__*/function () {
  function DrawCallHook(gl) {
    _classCallCheck(this, DrawCallHook);

    this.drawCall = 0;
    this.triangles = 0;
    this.lines = 0;
    this.points = 0;
    this.hooked = void 0;
    this.realDrawElements = void 0;
    this.realDrawArrays = void 0;
    this.gl = void 0;
    this.realDrawElements = gl.drawElements;
    this.realDrawArrays = gl.drawArrays;
    gl.drawElements = this.hookedDrawElements.bind(this);
    gl.drawArrays = this.hookedDrawArrays.bind(this);
    this.hooked = true;
    this.gl = gl;
    log("DrawCall is hooked.");
  }

  _createClass(DrawCallHook, [{
    key: "hookedDrawElements",
    value: function hookedDrawElements(mode, count, type, offset) {
      this.realDrawElements.call(this.gl, mode, count, type, offset);
      this.update(count, mode);
    }
  }, {
    key: "hookedDrawArrays",
    value: function hookedDrawArrays(mode, first, count) {
      this.realDrawArrays.call(this.gl, mode, first, count);
      this.update(count, mode);
    }
  }, {
    key: "update",
    value: function update(count, mode) {
      var gl = this.gl;
      this.drawCall++;

      switch (mode) {
        case gl.TRIANGLES:
          this.triangles += count / 3;
          break;

        case gl.TRIANGLE_STRIP:
        case gl.TRIANGLE_FAN:
          this.triangles += count - 2;
          break;

        case gl.LINES:
          this.lines += count / 2;
          break;

        case gl.LINE_STRIP:
          this.lines += count - 1;
          break;

        case gl.LINE_LOOP:
          this.lines += count;
          break;

        case gl.POINTS:
          this.points += count;
          break;

        default:
          errorLog("Unknown draw mode: ".concat(mode));
          break;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.drawCall = 0;
      this.triangles = 0;
      this.lines = 0;
      this.points = 0;
    }
  }, {
    key: "release",
    value: function release() {
      if (this.hooked) {
        this.gl.drawElements = this.realDrawElements;
        this.gl.drawArrays = this.realDrawArrays;
      }

      this.hooked = false;
    }
  }]);

  return DrawCallHook;
}();

/**
 * @class ShaderHook
 */

var ShaderHook = /*#__PURE__*/function () {
  function ShaderHook(gl) {
    _classCallCheck(this, ShaderHook);

    this.shaders = 0;
    this.realAttachShader = void 0;
    this.realDetachShader = void 0;
    this.hooked = void 0;
    this.gl = void 0;
    this.realAttachShader = gl.attachShader;
    this.realDetachShader = gl.detachShader;
    gl.attachShader = this.hookedAttachShader.bind(this);
    gl.detachShader = this.hookedDetachShader.bind(this);
    this.hooked = true;
    this.gl = gl;
    log("Shader is hooked.");
  }

  _createClass(ShaderHook, [{
    key: "hookedAttachShader",
    value: function hookedAttachShader(program, shader) {
      this.realAttachShader.call(this.gl, program, shader);
      this.shaders++;
      log("AttachShader:", shader, "shaders: ".concat(this.shaders));
    }
  }, {
    key: "hookedDetachShader",
    value: function hookedDetachShader(program, shader) {
      this.realDetachShader.call(this.gl, program, shader);
      this.shaders--;
      log("DetachShader. shaders: ".concat(this.shaders));
    }
  }, {
    key: "reset",
    value: function reset() {
      this.shaders = 0;
    }
  }, {
    key: "release",
    value: function release() {
      if (this.hooked) {
        this.gl.attachShader = this.realAttachShader;
        this.gl.detachShader = this.realDetachShader;
      }

      this.hooked = false;
    }
  }]);

  return ShaderHook;
}();

/**
 * @class TextureHook
 */

var TextureHook = /*#__PURE__*/function () {
  function TextureHook(gl) {
    _classCallCheck(this, TextureHook);

    this.textures = 0;
    this.realCreateTexture = void 0;
    this.realDeleteTexture = void 0;
    this.hooked = void 0;
    this.gl = void 0;
    this.realCreateTexture = gl.createTexture;
    this.realDeleteTexture = gl.deleteTexture;
    gl.createTexture = this.hookedCreateTexture.bind(this);
    gl.deleteTexture = this.hookedDeleteTexture.bind(this);
    this.hooked = true;
    this.gl = gl;
    log("Texture is hooked.");
  }

  _createClass(TextureHook, [{
    key: "hookedCreateTexture",
    value: function hookedCreateTexture() {
      var texture = this.realCreateTexture.call(this.gl);
      this.textures++;
      log("CreateTexture:", texture, "textures: ".concat(this.textures));
      return texture;
    }
  }, {
    key: "hookedDeleteTexture",
    value: function hookedDeleteTexture(texture) {
      this.realDeleteTexture.call(this.gl, texture);
      this.textures--;
      log("DeleteTexture. textures: ".concat(this.textures));
    }
  }, {
    key: "reset",
    value: function reset() {
      this.textures = 0;
    }
  }, {
    key: "release",
    value: function release() {
      if (this.hooked) {
        this.gl.createTexture = this.realCreateTexture;
        this.gl.deleteTexture = this.realDeleteTexture;
      }

      this.hooked = false;
    }
  }]);

  return TextureHook;
}();

/**
 * @class Core
 */
var Core = /*#__PURE__*/function () {
  function Core(gl) {
    _classCallCheck(this, Core);

    this.gl = void 0;
    this.drawCallHook = void 0;
    this.textureHook = void 0;
    this.shaderHook = void 0;
    this.samplingFrames = 60;
    this.samplingIndex = 0;
    this.now = void 0;
    this.gl = gl;
    this.hook(gl);
  }

  _createClass(Core, [{
    key: "hook",
    value: function hook(gl) {
      this.drawCallHook = new DrawCallHook(gl);
      this.textureHook = new TextureHook(gl);
      this.shaderHook = new ShaderHook(gl);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.drawCallHook && this.drawCallHook.reset();
    }
  }, {
    key: "release",
    value: function release() {
      this.drawCallHook && this.drawCallHook.release();
      this.textureHook && this.textureHook.release();
      this.shaderHook && this.shaderHook.release();
    }
  }, {
    key: "update",
    value: function update() {
      var now = miniprogramAdapter.performance.now();
      var delta = now - this.now;
      this.now = now;

      if (this.samplingIndex !== this.samplingFrames) {
        this.reset();
        this.samplingIndex++;
        return;
      }

      this.samplingIndex = 0;
      var data = {
        fps: delta ? 1000 / delta >> 0 : 0,
        memory: miniprogramAdapter.performance.memory && miniprogramAdapter.performance.memory.usedJSHeapSize / 1048576 >> 0,
        drawCall: this.drawCallHook.drawCall,
        triangles: this.drawCallHook.triangles,
        //@ts-ignorets-ignore
        nodes: miniprogram.Entity._entitys.length,
        lines: this.drawCallHook.lines,
        points: this.drawCallHook.points,
        textures: this.textureHook.textures,
        shaders: this.shaderHook.shaders,
        webglContext: miniprogramAdapter.window.hasOwnProperty("WebGL2RenderingContext") && this.gl instanceof WebGL2RenderingContext ? "2.0" : "1.0"
      };
      this.reset();
      return data;
    }
  }]);

  return Core;
}();

var tpl = "\n  <dl>\n    <dt>FPS</dt>\n    <dd>0</dd>\n    <dt>Memory <span class=\"unit\">(MB)</span></dt>\n    <dd>0</dd>\n    <dt>DrawCall</dt>\n    <dd>0</dd>\n    <dt>Triangles</dt>\n    <dd>0</dd>\n    <dt>Nodes</dt>\n    <dd>0</dd>\n    <dt>Textures</dt>\n    <dd>0</dd>\n    <dt>Shaders</dt>\n    <dd>0</dd>\n    <dt>WebGL</dt>\n    <dd></dd>\n  </dl>\n";
var css = "\n  .gl-perf {\n    pointer-events: none;\n    user-select: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    padding: ".concat(10 / 7.5, "vh ").concat(10 / 7.5, "vh 0 ").concat(10 / 7.5, "vh;\n    background: rgba(0, 0, 0, 0.3);\n    color: #fff;\n    font: ").concat(10 / 7.5, "vh arial;\n  }\n\n  .gl-perf dl,\n  .gl-perf dt,\n  .gl-perf dd {\n    padding: 0;\n    margin: 0;\n  }\n\n  .gl-perf dt {\n    color: #fff;\n    text-shadow: #000 0 0 1px;\n  }\n\n  .gl-perf dt .unit{\n    font-size: ").concat(10 / 7.5, "vh;\n  }\n\n  .gl-perf dd {\n    font-size: ").concat(20 / 7.5, "vh;\n    padding: ").concat(10 / 7.5, "vh 0 ").concat(10 / 7.5, "vh;\n  }\n");

var Monitor = /*#__PURE__*/function () {
  function Monitor(gl) {
    _classCallCheck(this, Monitor);

    this.core = void 0;
    this.doms = void 0;
    this.items = void 0;
    this.container = void 0;
    this.core = new Core(gl);
    this.items = [];
    this.items = ["fps", "memory", "drawCall", "triangles", "nodes", "textures", "shaders", "webglContext"];
    this.createContainer();
    this.update = this.update.bind(this);
  }

  _createClass(Monitor, [{
    key: "createContainer",
    value: function createContainer() {
      var container = miniprogramAdapter.document.createElement("div");
      container.classList.add("gl-perf");
      container.innerHTML = tpl;
      container.appendChild(this.createStyle());
      miniprogramAdapter.document.body.appendChild(container);
      this.doms = Array.prototype.slice.apply(container.querySelectorAll("dd"));
      this.container = container;
    }
  }, {
    key: "createStyle",
    value: function createStyle() {
      var style = miniprogramAdapter.document.createElement("style");
      style.type = "text/css";
      style.appendChild(miniprogramAdapter.document.createTextNode(css));
      return style;
    }
    /**
     * Update per frame
     */

  }, {
    key: "update",
    value: function update() {
      var _this = this;

      var data = this.core.update();

      if (data) {
        var _loop = function _loop(i, l) {
          var dom = _this.doms[i];
          var item = _this.items[i];
          var value = data[item] || 0; // see: http://wilsonpage.co.uk/preventing-layout-thrashing/

          miniprogramAdapter.requestAnimationFrame(function () {
            dom.innerText = value;
          });
        };

        for (var i = 0, l = this.items.length; i < l; i++) {
          _loop(i, l);
        }
      }
    }
    /**
     * reset all hooks
     */

  }, {
    key: "reset",
    value: function reset() {
      this.core.reset();
    }
    /**
     * release all hooks
     */

  }, {
    key: "release",
    value: function release() {
      this.core.release();
    }
    /**
     * destory the instance
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.release();
      miniprogramAdapter.document.body.removeChild(this.container);
    }
  }]);

  return Monitor;
}();

/**
 * Engine Feature：显示 FPS 等引擎状态数据
 */

var Stats = /*#__PURE__*/function (_EngineFeature) {
  _inherits(Stats, _EngineFeature);

  var _super = _createSuper(Stats);

  /**
   * 构造函数
   */
  function Stats() {
    var _this;

    _classCallCheck(this, Stats);

    _this = _super.call(this);
    _this.monitor = void 0;
    return _this;
  }
  /**
   * tick 前置回调
   */


  _createClass(Stats, [{
    key: "preTick",
    value: function preTick(engine, currentScene) {
      if (!this.monitor) {
        var gl = currentScene.engine._hardwareRenderer.gl;

        if (gl) {
          this.monitor = new Monitor(gl);
        }
      }
    }
    /**
     * tick 后置回调
     */

  }, {
    key: "postTick",
    value: function postTick(engine, currentScene) {
      if (this.monitor) {
        this.monitor.update();
      }
    }
  }]);

  return Stats;
}(miniprogram.EngineFeature);

miniprogram.Engine.registerFeature(Stats);

exports.Stats = Stats;
