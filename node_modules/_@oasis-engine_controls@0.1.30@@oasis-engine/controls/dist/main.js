'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var o3 = require('@alipay/o3');
var o3Tween = require('@alipay/o3-tween');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

var ESP = o3.MathUtil.zeroTolerance;

function includes(array) {
  for (var _len = arguments.length, filterArray = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    filterArray[_key - 1] = arguments[_key];
  }

  return filterArray.some(function (e) {
    return array.indexOf(e) !== -1;
  });
}

var tween = new o3Tween.Tween();
/**
 * 相机的的漫游控制器，可以上下左右位移，转转视角。
 */

var FreeControl = /*#__PURE__*/function (_Script) {
  _inherits(FreeControl, _Script);

  var _super = _createSuper(FreeControl);

  /** 每秒运动距离，单位为MVP转换前的单位
   * @member {number}
   * */

  /** 一个canvas的高宽度旋转Math.PI* this.rotateSpeed
   * @member {number}
   * */

  /** 模拟一个地面用来jump，替代碰撞体
   * @member {boolean}
   * */

  /** 模拟地面高度
   * @member {number}
   * */

  /**
   * the heightY jump to
   * @member {number}
   * */

  /**
   * the amount of the jumping time, jumpUpDuration+jumpDownDuration
   * unit:ms
   * @member {number}
   * */

  /** only rotate when press=true
   * @member {boolean}
   * */

  /**
   * radian of spherical.theta
   * @member {number}
   * */

  /**
   * radian of spherical.phi
   * @member {number}
   * */

  /**
   * 漫游控制器构造函数
   * @param {Entity} entity 挂载节点
   * @param {Object} props 轨道控制器参数，包含以下项
   * @property {Canvas|HTMLElement} [props.mainElement=RHI.canvas] 获取事件的HTMLElement对象，推荐使用绘制的canvas
   * @property {HTMLElement} [props.domElement=document] 获取顶级事件的HTMLElement对象。
   */
  function FreeControl(entity, props) {
    var _this;

    _classCallCheck(this, FreeControl);

    _this = _super.call(this, entity);
    _this._forward = new o3.Vector3();
    _this._right = new o3.Vector3();
    _this.camera = void 0;
    _this.mainElement = void 0;
    _this.domElement = void 0;
    _this.movementSpeed = void 0;
    _this.rotateSpeed = void 0;
    _this.floorMock = void 0;
    _this.floorY = void 0;
    _this.jumpY = void 0;
    _this.jumpDuration = void 0;
    _this.press = void 0;
    _this.keysForward = void 0;
    _this.keysBackward = void 0;
    _this.keysLeft = void 0;
    _this.keysRight = void 0;
    _this.keysJump = void 0;
    _this._theta = void 0;
    _this._phi = void 0;
    _this._moveForward = void 0;
    _this._moveBackward = void 0;
    _this._moveLeft = void 0;
    _this._moveRight = void 0;
    _this._moveJump = void 0;
    _this._v3Cache = void 0;
    _this._spherical = void 0;
    _this._rotateOri = void 0;
    _this._events = void 0;
    _this.tempVec3 = new o3.Vector3();
    _this.camera = entity; //@ts-ignore @todo 未来移除对html元素的依赖，通过封装引擎的input实现

    _this.mainElement = props.mainElement || _this.scene.engine.canvas._webCanvas;
    _this.domElement = props.domElement || document;

    if (!(_this.mainElement instanceof HTMLCanvasElement)) {
      o3.Logger.warn("AFreeControls must have a legal mainElement");
      return _possibleConstructorReturn(_this, null);
    }

    _this.movementSpeed = 1.0;
    _this.rotateSpeed = 1.0;
    _this.floorMock = true;
    _this.floorY = 0;
    _this.jumpY = 1;
    _this.jumpDuration = 600;
    _this.press = false;
    _this.keysForward = ["KeyW", "ArrowUp"];
    _this.keysBackward = ["KeyS", "ArrowDown"];
    _this.keysLeft = ["KeyA", "ArrowLeft"];
    _this.keysRight = ["KeyD", "ArrowRight"];
    _this.keysJump = ["Space"];
    _this._theta = 0;
    _this._phi = 0; // private variables

    _this._moveForward = false;
    _this._moveBackward = false;
    _this._moveLeft = false;
    _this._moveRight = false;
    _this._moveJump = false;
    _this._v3Cache = new o3.Vector3();
    _this._spherical = new o3.Spherical();
    _this._rotateOri = [0, 0];
    _this._events = [{
      type: "mousemove",
      listener: _this.onMouseMove.bind(_assertThisInitialized(_this))
    }, {
      type: "touchmove",
      listener: _this.onMouseMove.bind(_assertThisInitialized(_this))
    }, {
      type: "mousedown",
      listener: _this.onMouseDown.bind(_assertThisInitialized(_this))
    }, {
      type: "touchstart",
      listener: _this.onMouseDown.bind(_assertThisInitialized(_this))
    }, {
      type: "mouseup",
      listener: _this.onMouseUp.bind(_assertThisInitialized(_this))
    }, {
      type: "touchend",
      listener: _this.onMouseUp.bind(_assertThisInitialized(_this))
    }, {
      type: "keydown",
      listener: _this.onKeyDown.bind(_assertThisInitialized(_this)),
      element: window
    }, {
      type: "keyup",
      listener: _this.onKeyUp.bind(_assertThisInitialized(_this)),
      element: window
    }, {
      type: "contextmenu",
      listener: _this.onContextMenu.bind(_assertThisInitialized(_this))
    }];

    _this.initEvents(); // init spherical


    _this.updateSpherical();

    return _this;
  }
  /**
   * 浏览器右键事件
   * @private
   * */


  _createClass(FreeControl, [{
    key: "onContextMenu",
    value: function onContextMenu(event) {
      event.preventDefault();
    }
    /**
     * 键盘按下事件
     * @private
     * */

  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var code = event.code,
          key = event.key,
          keyCode = event.keyCode;

      if (includes(this.keysForward, code, key, keyCode)) {
        this._moveForward = true;
      } else if (includes(this.keysBackward, code, key, keyCode)) {
        this._moveBackward = true;
      } else if (includes(this.keysLeft, code, key, keyCode)) {
        this._moveLeft = true;
      } else if (includes(this.keysRight, code, key, keyCode)) {
        this._moveRight = true;
      } else if (includes(this.keysJump, code, key, keyCode)) {
        this.jump();
      }
    }
    /**
     * 键盘抬起事件
     * @private
     * */

  }, {
    key: "onKeyUp",
    value: function onKeyUp(event) {
      var code = event.code,
          key = event.key,
          keyCode = event.keyCode;

      if (includes(this.keysForward, code, key, keyCode)) {
        this._moveForward = false;
      } else if (includes(this.keysBackward, code, key, keyCode)) {
        this._moveBackward = false;
      } else if (includes(this.keysLeft, code, key, keyCode)) {
        this._moveLeft = false;
      } else if (includes(this.keysRight, code, key, keyCode)) {
        this._moveRight = false;
      }
    }
    /**
     * 手势按下事件
     * @private
     * */

  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      event.stopPropagation();
      event = event.changedTouches && event.changedTouches[0] || event;

      if (this.domElement !== document) {
        this.domElement.focus();
      }

      this.press = true;
      this._rotateOri = [event.clientX, event.clientY];
    }
    /**
     * 手势抬起事件
     * @private
     * */

  }, {
    key: "onMouseUp",
    value: function onMouseUp(event) {
      event.preventDefault();
      event.stopPropagation();
      this.press = false;
    }
    /**
     * 手势滑动事件
     * @private
     * */

  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      if (this.press === false) return;
      if (this.enabled === false) return;
      event.preventDefault();
      event.stopPropagation();
      event = event.changedTouches && event.changedTouches[0] || event;
      var movementX = event.clientX - this._rotateOri[0];
      var movementY = event.clientY - this._rotateOri[1];
      this._rotateOri[0] = event.clientX;
      this._rotateOri[1] = event.clientY;
      var factorX = 180 / this.mainElement.width;
      var factorY = 180 / this.mainElement.height;
      var actualX = movementX * factorX;
      var actualY = movementY * factorY;
      this.rotate(-actualX, actualY);
    }
    /**
     * 分别绕y轴，x轴旋转的角度
     * unit:deg
     * @param {number} alpha - 绕y轴旋转的deg
     * @param {number} beta - 绕x轴旋转的deg
     * */

  }, {
    key: "rotate",
    value: function rotate() {
      var alpha = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var beta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._theta += o3.MathUtil.degreeToRadian(alpha);
      this._phi += o3.MathUtil.degreeToRadian(beta);
      this._phi = o3.MathUtil.clamp(this._phi, ESP, Math.PI - ESP);
      this._spherical.theta = this._theta;
      this._spherical.phi = this._phi;

      this._spherical.setToVec3(this._v3Cache);

      o3.Vector3.add(this.camera.position, this._v3Cache, this._v3Cache);
      this.camera.transform.lookAt(this._v3Cache, new o3.Vector3(0, 1, 0));
    }
    /**
     * 跳跃，根据jumpY确定高度，jumpDuration确定时间，floorY确定地面高度
     * */

  }, {
    key: "jump",
    value: function jump() {
      var _this2 = this;

      if (this._moveJump) return;
      this._moveJump = true;
      var p = this.camera.position;
      o3Tween.doTransform.Translate(this.camera, new o3.Vector3(p.x, this.jumpY, p.z), this.jumpDuration / 2, {
        easing: o3Tween.Easing.easeOutSine,
        onComplete: function onComplete() {
          o3Tween.doTransform.Translate(_this2.camera, new o3.Vector3(p.x, _this2.floorY, p.z), _this2.jumpDuration / 2, {
            easing: o3Tween.Easing.easeInSine,
            onComplete: function onComplete() {
              _this2._moveJump = false;
            }
          }).start(tween);
        }
      }).start(tween);
    }
    /**
     * transform vec3 on axis by distance
     * */

  }, {
    key: "translateOnAxis",
    value: function translateOnAxis(axis, distance) {
      var v3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.camera.position;
      var diff = new o3.Vector3();
      o3.Vector3.normalize(axis, diff);
      v3.add(diff.scale(distance));
    }
  }, {
    key: "onUpdate",

    /**
     * @override
     * translate camera per tick
     * @param  delta - tick gap
     * */
    value: function onUpdate(delta) {
      if (this.enabled === false) return;
      var actualMoveSpeed = delta / 1000 * this.movementSpeed;
      this.camera.transform.getWorldForward(this._forward);
      this.camera.transform.getWorldRight(this._right);

      if (this._moveForward) {
        this.translateOnAxis(this._forward, actualMoveSpeed);
      }

      if (this._moveBackward) {
        this.translateOnAxis(this._forward, -actualMoveSpeed);
      }

      if (this._moveLeft) {
        this.translateOnAxis(this._right, -actualMoveSpeed);
      }

      if (this._moveRight) {
        this.translateOnAxis(this._right, actualMoveSpeed);
      }

      tween.update(delta);
      var position = this.camera.transform.position;

      if (this.floorMock && !this._moveJump) {
        // this.camera.position[1] = this.floorY;
        // const pos = this.camera.transform.position;
        position.setValue(position.x, this.floorY, position.z);
        this.camera.transform.position = position;
      }
    }
    /**注册浏览器事件*/

  }, {
    key: "initEvents",
    value: function initEvents() {
      var _this3 = this;

      this._events.forEach(function (ele) {
        if (ele.element) {
          ele.element.addEventListener(ele.type, ele.listener, false);
        } else {
          _this3.mainElement.addEventListener(ele.type, ele.listener, false);
        }
      });
    }
    /**
     * dispose all events
     * */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this4 = this;

      this._events.forEach(function (ele) {
        if (ele.element) {
          ele.element.removeEventListener(ele.type, ele.listener, false);
        } else {
          _this4.mainElement.removeEventListener(ele.type, ele.listener, false);
        }
      });

      _get(_getPrototypeOf(FreeControl.prototype), "destroy", this).call(this);
    }
    /**
     * must updateSpherical after quaternion has been changed
     * @example
     * Entity#lookAt([0,1,0],[0,1,0]);
     * AFreeControls#updateSpherical();
     * */

  }, {
    key: "updateSpherical",
    value: function updateSpherical() {
      this._v3Cache.setValue(0, 0, -1);

      o3.Vector3.transformByQuat(this._v3Cache, this.camera.rotation, this._v3Cache);

      this._spherical.setFromVec3(this._v3Cache);

      this._theta = this._spherical.theta;
      this._phi = this._spherical.phi;
    }
  }]);

  return FreeControl;
}(o3.Script);

/**
 * 相机的的轨道控制器，可以旋转，缩放，平移，支持鼠标和触摸事件。
 */

var OrbitControl = /*#__PURE__*/function (_Script) {
  _inherits(OrbitControl, _Script);

  var _super = _createSuper(OrbitControl);

  /**
   * 轨道控制器构造函数
   * @param {Entity} entity 挂载节点
   * @param {Object} props 轨道控制器参数，包含以下项
   * @property {Canvas|HTMLElement} [props.mainElement=RHI.canvas] 获取事件的HTMLElement对象，推荐使用绘制的canvas
   * @property {HTMLElement} [props.domElement=document] 获取顶级事件的HTMLElement对象。
   * @property {fov} [props.fov=45] 透视相机的视场角大小，影响控制器的控制精度
   * @property {Vector3} [props.target=[0,0,0]] 围绕的目标点，默认原点
   */
  function OrbitControl(entity, props) {
    var _this;

    _classCallCheck(this, OrbitControl);

    _this = _super.call(this, entity);
    _this.camera = void 0;
    _this.domElement = void 0;
    _this.mainElement = void 0;
    _this.fov = void 0;
    _this.target = void 0;
    _this.up = void 0;
    _this.minDistance = void 0;
    _this.maxDistance = void 0;
    _this.minZoom = void 0;
    _this.maxZoom = void 0;
    _this.enableDamping = void 0;
    _this.zoomFactor = void 0;
    _this.enableRotate = void 0;
    _this.keyPanSpeed = void 0;
    _this.minPolarAngle = void 0;
    _this.maxPolarAngle = void 0;
    _this.minAzimuthAngle = void 0;
    _this.maxAzimuthAngle = void 0;
    _this.enableZoom = void 0;
    _this.dampingFactor = void 0;
    _this.zoomSpeed = void 0;
    _this.enablePan = void 0;
    _this.autoRotate = void 0;
    _this.autoRotateSpeed = void 0;
    _this.rotateSpeed = void 0;
    _this.enableKeys = void 0;
    _this.keys = void 0;
    _this.mouseButtons = void 0;
    _this.touchFingers = void 0;
    _this._position = void 0;
    _this._offset = void 0;
    _this._spherical = void 0;
    _this._sphericalDelta = void 0;
    _this._sphericalDump = void 0;
    _this._zoomFrag = void 0;
    _this._scale = void 0;
    _this._panOffset = void 0;
    _this._isMouseUp = void 0;
    _this._vPan = void 0;
    _this.constEvents = void 0;
    _this._state = void 0;
    _this._rotateStart = void 0;
    _this._rotateEnd = void 0;
    _this._rotateDelta = void 0;
    _this._panStart = void 0;
    _this._panEnd = void 0;
    _this._panDelta = void 0;
    _this._zoomStart = void 0;
    _this._zoomEnd = void 0;
    _this._zoomDelta = void 0;
    _this.STATE = void 0;
    _this.mouseUpEvents = void 0;
    _this.camera = entity; //@ts-ignore @todo 未来移除对html元素的依赖，通过封装引擎的input实现

    _this.mainElement = props.mainElement || _this.scene.engine.canvas._webCanvas;
    _this.domElement = props.domElement || document;
    _this.fov = props.fov || 45;

    if (!(_this.mainElement instanceof HTMLCanvasElement)) {
      o3.Logger.warn("OrbitControls must have a legal mainElement");
      return _possibleConstructorReturn(_this, null);
    } // 目标点


    _this.target = props.target || new o3.Vector3(); // up向量

    _this.up = new o3.Vector3(0, 1, 0); // 最大最小距离

    /**
     * 最小距离，默认为0.1，应大于0
     * @member {Number}
     */

    _this.minDistance = 0.1;
    /**
     * 最大距离，默认为无穷，应大于最小距离
     * @member {Number}
     */

    _this.maxDistance = Infinity; // 最大最小缩放速度

    /**
     * 最小缩放速度，默认为0.0
     * @member {Number}
     */

    _this.minZoom = 0.0;
    /**
     * 最大缩放速度，默认为正无穷
     * @member {Number}
     */

    _this.maxZoom = Infinity; // 垂直方向旋转范围

    /**
     * 垂直方向最小弧度，默认为0弧度，取值范围 0 － Math.PI
     * @member {Number}
     */

    _this.minPolarAngle = 0;
    /**
     * 垂直方向最大弧度，默认为Math.PI，取值范围 0 － Math.PI
     * @member {Number}
     */

    _this.maxPolarAngle = Math.PI; // 水平方向旋转范围

    /**
     * 垂直方向最小弧度，默认为负无穷
     * @member {Number}
     */

    _this.minAzimuthAngle = -Infinity;
    /**
     * 垂直方向最小弧度，默认为正无穷
     * @member {Number}
     */

    _this.maxAzimuthAngle = Infinity; // 缓冲参数

    /**
     * 是否开启镜头缓冲，默认为 true
     * @member {Boolean}
     */

    _this.enableDamping = true;
    /**
     * 旋转缓冲参数，默认为 0.1
     * @member {Number}
     */

    _this.dampingFactor = 0.1;
    /**
     * 缩放缓冲参数，默认为0.2
     * @member {Number}
     */

    _this.zoomFactor = 0.2; // 缩放控制

    /**
     * 是否启用缩放，默认为true
     * @member {Boolean}
     */

    _this.enableZoom = true;
    /**
     * 镜头缩放速度，默认为1.0
     * @member {Number}
     */

    _this.zoomSpeed = 1.0; // 旋转控制

    /**
     * 是否开启旋转，默认为true
     * @member {Boolean}
     */

    _this.enableRotate = true;
    /**
     * 旋转速度，默认为1.0
     * @member {Number}
     */

    _this.rotateSpeed = 1.0; // 平移控制

    /**
     * 是否开启平移，默认为true
     * @member {Number}
     */

    _this.enablePan = true;
    /**
     * 键盘平移速度，默认为7.0
     * @member {Number}
     */

    _this.keyPanSpeed = 7.0; // 自动旋转

    /**
     * 是否自动旋转镜头，默认为false
     * @member {Boolean}
     */

    _this.autoRotate = false;
    /**
     * 自动旋转一圈所需的时间，默认为2.0s
     * @member {Number}
     */

    _this.autoRotateSpeed = 2.0; // 旋转 2PI 所用的时间 s
    // 键盘平移

    /**
     * 是否启用键盘平移，默认为false
     * @member {Boolean}
     */

    _this.enableKeys = false;
    _this.keys = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      BOTTOM: 40
    }; // 控制键位

    _this.mouseButtons = {
      ORBIT: 0,
      ZOOM: 1,
      PAN: 2
    };
    _this.touchFingers = {
      ORBIT: 1,
      ZOOM: 2,
      PAN: 3
    }; // 复用对象 防止栈分配过多
    // update

    _this._position = new o3.Vector3();
    _this._offset = new o3.Vector3();
    _this._spherical = new o3.Spherical();
    _this._sphericalDelta = new o3.Spherical();
    _this._sphericalDump = new o3.Spherical();
    _this._zoomFrag = 0;
    _this._scale = 1;
    _this._panOffset = new o3.Vector3();
    _this._isMouseUp = true; // pan

    _this._vPan = new o3.Vector3(); // state

    _this._rotateStart = new o3.Vector2();
    _this._rotateEnd = new o3.Vector2();
    _this._rotateDelta = new o3.Vector2();
    _this._panStart = new o3.Vector2();
    _this._panEnd = new o3.Vector2();
    _this._panDelta = new o3.Vector2();
    _this._zoomStart = new o3.Vector2();
    _this._zoomEnd = new o3.Vector2();
    _this._zoomDelta = new o3.Vector2();
    _this.STATE = {
      NONE: -1,
      ROTATE: 0,
      ZOOM: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_ZOOM: 4,
      TOUCH_PAN: 5
    };
    _this._state = _this.STATE.NONE;
    _this.constEvents = [{
      type: "mousedown",
      listener: _this.onMouseDown.bind(_assertThisInitialized(_this))
    }, {
      type: "wheel",
      listener: _this.onMouseWheel.bind(_assertThisInitialized(_this))
    }, {
      type: "keydown",
      listener: _this.onKeyDown.bind(_assertThisInitialized(_this)),
      element: window
    }, {
      type: "touchstart",
      listener: _this.onTouchStart.bind(_assertThisInitialized(_this))
    }, {
      type: "touchmove",
      listener: _this.onTouchMove.bind(_assertThisInitialized(_this))
    }, {
      type: "touchend",
      listener: _this.onTouchEnd.bind(_assertThisInitialized(_this))
    }, {
      type: "contextmenu",
      listener: _this.onContextMenu.bind(_assertThisInitialized(_this))
    }];
    _this.mouseUpEvents = [{
      type: "mousemove",
      listener: _this.onMouseMove.bind(_assertThisInitialized(_this))
    }, {
      type: "mouseup",
      listener: _this.onMouseUp.bind(_assertThisInitialized(_this))
    }];

    _this.constEvents.forEach(function (ele) {
      if (ele.element) {
        ele.element.addEventListener(ele.type, ele.listener, false);
      } else {
        _this.mainElement.addEventListener(ele.type, ele.listener, false);
      }
    });

    _this.addEventListener("disabled", function () {
      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      _this.mainElement.removeEventListener(_this.mouseUpEvents[0].type, _this.mouseUpEvents[0].listener, false);

      element.removeEventListener(_this.mouseUpEvents[1].type, _this.mouseUpEvents[1].listener, false);
    });

    return _this;
  }
  /**
   * 销毁，释放事件监听
   * @private
   */


  _createClass(OrbitControl, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.constEvents.forEach(function (ele) {
        if (ele.element) {
          ele.element.removeEventListener(ele.type, ele.listener, false);
        } else {
          _this2.mainElement.removeEventListener(ele.type, ele.listener, false);
        }
      });
      var element = this.domElement === document ? this.domElement.body : this.domElement;
      this.mainElement.removeEventListener(this.mouseUpEvents[0].type, this.mouseUpEvents[0].listener, false);
      element.removeEventListener(this.mouseUpEvents[1].type, this.mouseUpEvents[1].listener, false);

      _get(_getPrototypeOf(OrbitControl.prototype), "destroy", this).call(this);
    }
    /**
     * 在触屏上用单指控制旋转，三指控制平移
     */

  }, {
    key: "setOneFingerRotate",
    value: function setOneFingerRotate() {
      this.touchFingers.ORBIT = 1;
      this.touchFingers.ZOOM = 2;
      this.touchFingers.PAN = 3;
    }
    /**
     * 在触屏上用单指控制平移，三指控制旋转
     */

  }, {
    key: "setOneFingerPan",
    value: function setOneFingerPan() {
      this.touchFingers.ORBIT = 3;
      this.touchFingers.ZOOM = 2;
      this.touchFingers.PAN = 1;
    }
    /**
     * 每帧更新
     * @private
     * @param {Number} dtime 和上次绘制的事件间隔 ms
     */

  }, {
    key: "onUpdate",
    value: function onUpdate(dtime) {
      if (!this.enabled) return;

      _get(_getPrototypeOf(OrbitControl.prototype), "onUpdate", this).call(this, dtime);

      var position = this.camera.position;
      position.cloneTo(this._offset);

      this._offset.subtract(this.target);

      this._spherical.setFromVec3(this._offset);

      if (this.autoRotate && this._state === this.STATE.NONE) {
        this.rotateLeft(this.getAutoRotationAngle(dtime));
      }

      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
      this._spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, this._spherical.theta));
      this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));

      this._spherical.makeSafe();

      if (this._scale !== 1) {
        this._zoomFrag = this._spherical.radius * (this._scale - 1);
      }

      this._spherical.radius += this._zoomFrag;
      this._spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this._spherical.radius));
      this.target.add(this._panOffset);

      this._spherical.setToVec3(this._offset);

      this.target.cloneTo(this._position);

      this._position.add(this._offset);

      this.camera.position = this._position;
      this.camera.transform.lookAt(this.target, this.up);

      if (this.enableDamping === true) {
        this._sphericalDump.theta *= 1 - this.dampingFactor;
        this._sphericalDump.phi *= 1 - this.dampingFactor;
        this._zoomFrag *= 1 - this.zoomFactor;

        if (this._isMouseUp) {
          this._sphericalDelta.theta = this._sphericalDump.theta;
          this._sphericalDelta.phi = this._sphericalDump.phi;
        } else {
          this._sphericalDelta.set(0, 0, 0);
        }
      } else {
        this._sphericalDelta.set(0, 0, 0);

        this._zoomFrag = 0;
      }

      this._scale = 1;

      this._panOffset.setValue(0, 0, 0);
    }
    /**
     * 获取自动旋转的弧度
     * @private
     */

  }, {
    key: "getAutoRotationAngle",
    value: function getAutoRotationAngle(dtime) {
      return 2 * Math.PI / this.autoRotateSpeed / 1000 * dtime;
    }
    /**
     * 获取缩放值
     * @private
     */

  }, {
    key: "getZoomScale",
    value: function getZoomScale() {
      return Math.pow(0.95, this.zoomSpeed);
    }
    /**
     * 向左旋转一定弧度
     * @property {Number} radian 旋转的弧度值
     */

  }, {
    key: "rotateLeft",
    value: function rotateLeft(radian) {
      this._sphericalDelta.theta -= radian;

      if (this.enableDamping) {
        this._sphericalDump.theta = -radian;
      }
    }
    /**
     * 向上旋转一定弧度
     * @property {Number} radian 旋转的弧度值
     */

  }, {
    key: "rotateUp",
    value: function rotateUp(radian) {
      this._sphericalDelta.phi -= radian;

      if (this.enableDamping) {
        this._sphericalDump.phi = -radian;
      }
    }
    /**
     * 向左平移
     * @private
     */

  }, {
    key: "panLeft",
    value: function panLeft(distance, worldMatrix) {
      var e = worldMatrix.elements;

      this._vPan.setValue(e[0], e[1], e[2]);

      this._vPan.scale(distance);

      this._panOffset.add(this._vPan);
    }
    /**
     * 向右平移
     * @private
     */

  }, {
    key: "panUp",
    value: function panUp(distance, worldMatrix) {
      var e = worldMatrix.elements;

      this._vPan.setValue(e[4], e[5], e[6]);

      this._vPan.scale(distance);

      this._panOffset.add(this._vPan);
    }
    /**
     * 平移
     * @property {Number} deltaX x方向的平移量，屏幕距离
     * @property {Number} deltaY y方向的平移量，屏幕距离
     */

  }, {
    key: "pan",
    value: function pan(deltaX, deltaY) {
      var element = this.domElement === document ? this.domElement.body : this.domElement; // perspective only

      var position = this.camera.position;
      position.cloneTo(this._vPan);

      this._vPan.subtract(this.target);

      var targetDistance = this._vPan.length();

      targetDistance *= this.fov / 2 * (Math.PI / 180);
      this.panLeft(-2 * deltaX * (targetDistance / element.clientHeight), this.camera.transform.worldMatrix);
      this.panUp(2 * deltaY * (targetDistance / element.clientHeight), this.camera.transform.worldMatrix);
    }
    /**
     * 放大
     * @private
     */

  }, {
    key: "zoomIn",
    value: function zoomIn(zoomScale) {
      // perspective only
      this._scale *= zoomScale;
    }
    /**
     * 缩小
     * @private
     */

  }, {
    key: "zoomOut",
    value: function zoomOut(zoomScale) {
      // perspective only
      this._scale /= zoomScale;
    }
    /**
     * 鼠标点击时旋转参数更新
     * @private
     */

  }, {
    key: "handleMouseDownRotate",
    value: function handleMouseDownRotate(event) {
      this._rotateStart.setValue(event.clientX, event.clientY);
    }
    /**
     * 鼠标点击时缩放参数更新
     * @private
     */

  }, {
    key: "handleMouseDownZoom",
    value: function handleMouseDownZoom(event) {
      this._zoomStart.setValue(event.clientX, event.clientY);
    }
    /**
     * 鼠标点击时平移参数更新
     * @private
     */

  }, {
    key: "handleMouseDownPan",
    value: function handleMouseDownPan(event) {
      this._panStart.setValue(event.clientX, event.clientY);
    }
    /**
     * 鼠标移动时旋转参数更新
     * @private
     */

  }, {
    key: "handleMouseMoveRotate",
    value: function handleMouseMoveRotate(event) {
      this._rotateEnd.setValue(event.clientX, event.clientY);

      o3.Vector2.subtract(this._rotateEnd, this._rotateStart, this._rotateDelta);
      var element = this.domElement === document ? document.body : this.domElement;
      this.rotateLeft(2 * Math.PI * (this._rotateDelta.x / element.clientWidth) * this.rotateSpeed);
      this.rotateUp(2 * Math.PI * (this._rotateDelta.y / element.clientHeight) * this.rotateSpeed);

      this._rotateEnd.cloneTo(this._rotateStart);
    }
    /**
     * 鼠标移动时缩放参数更新
     * @private
     */

  }, {
    key: "handleMouseMoveZoom",
    value: function handleMouseMoveZoom(event) {
      this._zoomEnd.setValue(event.clientX, event.clientY);

      o3.Vector2.subtract(this._zoomEnd, this._zoomStart, this._zoomDelta);

      if (this._zoomDelta[1] > 0) {
        this.zoomOut(this.getZoomScale());
      } else if (this._zoomDelta[1] < 0) {
        this.zoomIn(this.getZoomScale());
      }

      this._zoomEnd.cloneTo(this._zoomStart);
    }
    /**
     * 鼠标移动时平移参数更新
     * @private
     */

  }, {
    key: "handleMouseMovePan",
    value: function handleMouseMovePan(event) {
      this._panEnd.setValue(event.clientX, event.clientY);

      o3.Vector2.subtract(this._panEnd, this._panStart, this._panDelta);
      this.pan(this._panDelta.x, this._panDelta.y);

      this._panEnd.cloneTo(this._panStart);
    }
    /**
     * 鼠标滚轮滚动时缩放参数更新
     * @private
     */

  }, {
    key: "handleMouseWheel",
    value: function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        this.zoomIn(this.getZoomScale());
      } else if (event.deltaY > 0) {
        this.zoomOut(this.getZoomScale());
      }
    }
    /**
     * 键盘按下时平移参数更新
     * @private
     */

  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(event) {
      switch (event.keyCode) {
        case this.keys.UP:
          this.pan(0, this.keyPanSpeed);
          break;

        case this.keys.BOTTOM:
          this.pan(0, -this.keyPanSpeed);
          break;

        case this.keys.LEFT:
          this.pan(this.keyPanSpeed, 0);
          break;

        case this.keys.RIGHT:
          this.pan(-this.keyPanSpeed, 0);
          break;
      }
    }
    /**
     * 触摸落下时旋转参数更新
     * @private
     */

  }, {
    key: "handleTouchStartRotate",
    value: function handleTouchStartRotate(event) {
      this._rotateStart.setValue(event.touches[0].pageX, event.touches[0].pageY);
    }
    /**
     * 触摸落下时缩放参数更新
     * @private
     */

  }, {
    key: "handleTouchStartZoom",
    value: function handleTouchStartZoom(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);

      this._zoomStart.setValue(0, distance);
    }
    /**
     * 触摸落下时平移参数更新
     * @private
     */

  }, {
    key: "handleTouchStartPan",
    value: function handleTouchStartPan(event) {
      this._panStart.setValue(event.touches[0].pageX, event.touches[0].pageY);
    }
    /**
     * 触摸移动时旋转参数更新
     * @private
     */

  }, {
    key: "handleTouchMoveRotate",
    value: function handleTouchMoveRotate(event) {
      this._rotateEnd.setValue(event.touches[0].pageX, event.touches[0].pageY);

      o3.Vector2.subtract(this._rotateEnd, this._rotateStart, this._rotateDelta);
      var element = this.domElement === document ? this.domElement.body : this.domElement;
      this.rotateLeft(2 * Math.PI * this._rotateDelta.x / element.clientWidth * this.rotateSpeed);
      this.rotateUp(2 * Math.PI * this._rotateDelta.y / element.clientHeight * this.rotateSpeed);

      this._rotateEnd.cloneTo(this._rotateStart);
    }
    /**
     * 触摸移动时缩放参数更新
     * @private
     */

  }, {
    key: "handleTouchMoveZoom",
    value: function handleTouchMoveZoom(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);

      this._zoomEnd.setValue(0, distance);

      o3.Vector2.subtract(this._zoomEnd, this._zoomStart, this._zoomDelta);

      if (this._zoomDelta[1] > 0) {
        this.zoomIn(this.getZoomScale());
      } else if (this._zoomDelta[1] < 0) {
        this.zoomOut(this.getZoomScale());
      }

      this._zoomEnd.cloneTo(this._zoomStart);
    }
    /**
     * 触摸移动时平移参数更新
     * @private
     */

  }, {
    key: "handleTouchMovePan",
    value: function handleTouchMovePan(event) {
      this._panEnd.setValue(event.touches[0].pageX, event.touches[0].pageY);

      o3.Vector2.subtract(this._panEnd, this._panStart, this._panDelta);
      this.pan(this._panDelta.x, this._panDelta.y);

      this._panEnd.cloneTo(this._panStart);
    }
    /**
     * 鼠标按下事件总处理
     * @private
     */

  }, {
    key: "onMouseDown",
    value: function onMouseDown(event) {
      if (this.enabled === false) return;
      event.preventDefault();
      this._isMouseUp = false;

      switch (event.button) {
        case this.mouseButtons.ORBIT:
          if (this.enableRotate === false) return;
          this.handleMouseDownRotate(event);
          this._state = this.STATE.ROTATE;
          break;

        case this.mouseButtons.ZOOM:
          if (this.enableZoom === false) return;
          this.handleMouseDownZoom(event);
          this._state = this.STATE.ZOOM;
          break;

        case this.mouseButtons.PAN:
          if (this.enablePan === false) return;
          this.handleMouseDownPan(event);
          this._state = this.STATE.PAN;
          break;
      }

      if (this._state !== this.STATE.NONE) {
        var element = this.domElement === document ? this.domElement.body : this.domElement;
        this.mainElement.addEventListener(this.mouseUpEvents[0].type, this.mouseUpEvents[0].listener, false);
        element.addEventListener(this.mouseUpEvents[1].type, this.mouseUpEvents[1].listener, false);
      }
    }
    /**
     * 鼠标移动事件总处理
     * @private
     */

  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      if (this.enabled === false) return;
      event.preventDefault();

      switch (this._state) {
        case this.STATE.ROTATE:
          if (this.enableRotate === false) return;
          this.handleMouseMoveRotate(event);
          break;

        case this.STATE.ZOOM:
          if (this.enableZoom === false) return;
          this.handleMouseMoveZoom(event);
          break;

        case this.STATE.PAN:
          if (this.enablePan === false) return;
          this.handleMouseMovePan(event);
          break;
      }
    }
    /**
     * 鼠标抬起事件总处理
     * @private
     */

  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      var _this3 = this;

      if (this.enabled === false) return;
      this._isMouseUp = true;
      this.mouseUpEvents.forEach(function (ele) {
        var element = _this3.domElement === document ? _this3.domElement.body : _this3.domElement;
        element.removeEventListener(ele.type, ele.listener, false);

        _this3.mainElement.removeEventListener(ele.type, ele.listener, false);
      });
      this._state = this.STATE.NONE;
    }
    /**
     * 鼠标滚轮滚动事件处理
     * @private
     */

  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(event) {
      if (this.enabled === false || this.enableZoom === false || this._state !== this.STATE.NONE && this._state !== this.STATE.ROTATE) return;
      event.preventDefault();
      event.stopPropagation();
      this.handleMouseWheel(event);
    }
    /**
     * 键盘按下事件总处理
     * @private
     */

  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      if (this.enabled === false || this.enableKeys === false || this.enablePan === false) return;
      this.handleKeyDown(event);
    }
    /**
     * 触摸按下事件总处理
     * @private
     */

  }, {
    key: "onTouchStart",
    value: function onTouchStart(event) {
      if (this.enabled === false) return;
      this._isMouseUp = false;

      switch (event.touches.length) {
        case this.touchFingers.ORBIT:
          if (this.enableRotate === false) return;
          this.handleTouchStartRotate(event);
          this._state = this.STATE.TOUCH_ROTATE;
          break;

        case this.touchFingers.ZOOM:
          if (this.enableZoom === false) return;
          this.handleTouchStartZoom(event);
          this._state = this.STATE.TOUCH_ZOOM;
          break;

        case this.touchFingers.PAN:
          if (this.enablePan === false) return;
          this.handleTouchStartPan(event);
          this._state = this.STATE.TOUCH_PAN;
          break;

        default:
          this._state = this.STATE.NONE;
      }
    }
    /**
     * 触摸移动事件总处理
     * @private
     */

  }, {
    key: "onTouchMove",
    value: function onTouchMove(event) {
      if (this.enabled === false) return;
      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {
        case this.touchFingers.ORBIT:
          if (this.enableRotate === false) return;
          if (this._state !== this.STATE.TOUCH_ROTATE) return;
          this.handleTouchMoveRotate(event);
          break;

        case this.touchFingers.ZOOM:
          if (this.enableZoom === false) return;
          if (this._state !== this.STATE.TOUCH_ZOOM) return;
          this.handleTouchMoveZoom(event);
          break;

        case this.touchFingers.PAN:
          if (this.enablePan === false) return;
          if (this._state !== this.STATE.TOUCH_PAN) return;
          this.handleTouchMovePan(event);
          break;

        default:
          this._state = this.STATE.NONE;
      }
    }
    /**
     * 触摸抬起事件总处理
     * @private
     */

  }, {
    key: "onTouchEnd",
    value: function onTouchEnd() {
      if (this.enabled === false) return;
      this._isMouseUp = true;
      this._state = this.STATE.NONE;
    }
    /**
     * 上下文事件隐藏
     * @private
     */

  }, {
    key: "onContextMenu",
    value: function onContextMenu(event) {
      if (this.enabled === false) return;
      event.preventDefault();
    }
  }]);

  return OrbitControl;
}(o3.Script);

exports.FreeControl = FreeControl;
exports.OrbitControl = OrbitControl;
//# sourceMappingURL=main.js.map
