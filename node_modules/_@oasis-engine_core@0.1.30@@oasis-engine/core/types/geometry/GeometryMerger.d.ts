/**
 * GeometryMerger 用于合并相同材质的静态 Geometry, 减少 draw call 开销
 *
 * 示例：
 *
 *   let geometries = [];
 *   for (...) {
 *     geometries.push(generateGeometry(...)); // 这里需要给 geometry.primitive.material 赋值
 *   }
 *
 *   let mergedGeometry = new GeometryMerger(geometries).merge(); // 这样用
 *
 *   for (let geometry of mergedGeometry) { // add to scene
 *     let renderer = rootNode.createChild('node_name').addComponent(GeometryRenderer);
 *     renderer.geometry = geometry;
 *     renderer.setMaterial(geometry.primitive.material);
 *   }
 *
 */
export declare class GeometryMerger {
    private _geometryList;
    private _mergedGeometry;
    /**
     * 初始化
     * @param {Geometry[]} geometries 想要合并的 geometry 列表
     *
     * 为了正确分类请确保:
     * 1. **所有使用相同材质的 geometry 有完全相同的顶点 layout** (非常重要)
     * 2. geometry.primitive.material 已正确设置（否则所有传入的 geometry 都会合并在一起）
     */
    constructor(geometries: any);
    /**
     * 添加 geometry
     * @param {Geometry} geometry 在已初始化的基础上继续添加 geometry
     *
     * 限制条件与构造函数相同
     * @sa constructor
     */
    add(geometry: any): void;
    /**
     * 执行合并操作
     * @return {Geometry[]}
     *
     * 返回 Geometry 列表 -
     * * 已合并的 geometry 每个材质对应一个 geometry;
     * * 动态物件或不支持合并的 geometry 会保持原样返回
     */
    merge(): any[];
    _mergeBufferGeometry(merged: any, raw: any): void;
    _mergeIndexBufferGeometry(merged: any, raw: any): void;
}
