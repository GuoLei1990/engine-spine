{"version":3,"file":"module.js","sources":["../src/BufferLoader.ts","../src/gltf/Util.ts","../src/gltf/glTFDracoMeshCompression.ts","../src/gltf/glTF.ts","../src/gltf/glb.ts","../src/GLTFLoader.ts","../src/JSONLoader.ts","../src/compressed-texture/KhronosTextureContainer.ts","../src/compressed-texture/index.ts","../src/KTXCubeLoader.ts","../src/KTXLoader.ts","../src/Texture2DLoader.ts","../src/TextureCubeLoader.ts","../src/GLTFModel.ts","../src/scene-loader/plugins/PluginManager.ts","../src/scene-loader/utils.ts","../src/scene-loader/resources/SchemaResource.ts","../src/scene-loader/resources/TextureResource.ts","../src/scene-loader/resources/PBRMaterialResource.ts","../src/scene-loader/resources/GLTFResource.ts","../src/scene-loader/resources/ShaderMaterialResource.ts","../src/scene-loader/resources/ScriptResource.ts","../src/scene-loader/resources/BlinnPhongMaterialResource.ts","../src/scene-loader/resources/TextureCubeMapResource.ts","../src/scene-loader/resources/BaseResource.ts","../src/scene-loader/AbilityManager.ts","../src/scene-loader/NodeManager.ts","../src/scene-loader/ResourceManager.ts","../src/scene-loader/Oasis.ts","../src/scene-loader/temp.compatible.ts","../src/scene-loader/Parser.ts"],"sourcesContent":["import { resourceLoader, Loader, AssetPromise, AssetType, LoadItem } from \"@oasis-engine/core\";\n\nfunction isBase64(url) {\n  return /^data:(.+?);base64,/.test(url);\n}\n@resourceLoader(AssetType.Buffer, [\"bin\", \"r3bin\"], false)\nclass BufferLoader extends Loader<ArrayBuffer> {\n  load(item: LoadItem): AssetPromise<ArrayBuffer> {\n    const url = item.url;\n    if (isBase64(url)) {\n      return new AssetPromise((resolve) => {\n        const base64Str = url.slice(13 + RegExp.$1.length);\n        const result = Uint8Array.from(atob(base64Str), (c) => c.charCodeAt(0));\n        resolve(result.buffer);\n      });\n    }\n    return this.request(url, {\n      ...item,\n      type: \"arraybuffer\"\n    });\n  }\n}\n","import { DataType, IndexFormat, VertexElement, VertexElementFormat } from \"@oasis-engine/core\";\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\n/**\n * 解析二进制文本 用于 glb loader\n * @param array\n * @returns String\n * @private\n */\nexport function decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n\n  // TextDecoder polyfill\n  let s = \"\";\n\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n\n  return decodeURIComponent(encodeURIComponent(s));\n}\n\n/**\n * 根据 glTF 中的 paramters[name] 来查找 uniform 对象\n * @param obj\n * @param key\n * @param value\n * @returns {object}\n * @private\n */\nexport function findByKeyValue(obj, key, value) {\n  for (const name in obj) {\n    if (obj[name][key] === value) {\n      return obj[name];\n    }\n  }\n  return null;\n}\n\n/** 获取 accessor type 占用字节数\n * @return {number}\n * @param {string} accessorType\n * @private\n */\nexport function getAccessorTypeSize(accessorType) {\n  const ACCESSOR_TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n  };\n  return ACCESSOR_TYPE_SIZE[accessorType];\n}\n\n/** 获取 component type 对应的 TypedArray\n * @return {function}\n * @param {string} componentType\n */\nexport function getComponentType(componentType) {\n  return WEBGL_COMPONENT_TYPES[componentType];\n}\n\n/**\n * 获取 accessor 数据\n * @param gltf\n * @param accessor\n * @param buffers\n * @private\n */\nexport function getAccessorData(gltf, accessor, buffers) {\n  const bufferView = gltf.bufferViews[accessor.bufferView];\n  const arrayBuffer = buffers[bufferView.buffer];\n  const accessorByteOffset = accessor.hasOwnProperty(\"byteOffset\") ? accessor.byteOffset : 0;\n  const bufferViewByteOffset = bufferView.hasOwnProperty(\"byteOffset\") ? bufferView.byteOffset : 0;\n  const byteOffset = accessorByteOffset + bufferViewByteOffset;\n  const accessorTypeSize = getAccessorTypeSize(accessor.type);\n  const length = accessorTypeSize * accessor.count;\n  const byteStride = bufferView.byteStride ?? 0;\n\n  const arrayType = getComponentType(accessor.componentType);\n  let uint8Array;\n  if (byteStride) {\n    uint8Array = new Uint8Array(length * arrayType.BYTES_PER_ELEMENT);\n    const originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);\n    let viewAccessor = 0;\n    const accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;\n    for (let i = 0; i < accessor.count; i++) {\n      viewAccessor = i * byteStride + accessorByteOffset;\n      for (let j = 0; j < accessorByteSize; j++) {\n        uint8Array[i * accessorByteSize + j] = originalBufferView[viewAccessor + j];\n      }\n    }\n  } else {\n    uint8Array = new Uint8Array(arrayBuffer, byteOffset, length * arrayType.BYTES_PER_ELEMENT);\n    uint8Array = new Uint8Array(uint8Array);\n  }\n\n  return new arrayType(uint8Array.buffer);\n}\n\n/**\n * 获取 buffer 数据\n * @param bufferView\n * @param buffers\n * @returns {Blob|ArrayBuffer|Array.<T>|string}\n * @private\n */\nexport function getBufferData(bufferView, buffers) {\n  // get bufferView\n  const arrayBuffer = buffers[bufferView.buffer];\n  const byteOffset = bufferView.byteOffset || 0;\n  return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);\n}\n\nexport function getVertexStride(accessor): number {\n  const size = getAccessorTypeSize(accessor.type);\n  const componentType = getComponentType(accessor.componentType);\n  return size * componentType.BYTES_PER_ELEMENT;\n}\n\nexport function createVertexElement(gltf, semantic, accessor, index: number): VertexElement {\n  const size = getAccessorTypeSize(accessor.type);\n  return new VertexElement(semantic, 0, getElementFormat(accessor.componentType, size), index);\n}\n\nexport function getIndexFormat(type: number): IndexFormat {\n  switch (type) {\n    case DataType.UNSIGNED_BYTE:\n      return IndexFormat.UInt8;\n    case DataType.UNSIGNED_SHORT:\n      return IndexFormat.UInt16;\n    case DataType.UNSIGNED_INT:\n      return IndexFormat.UInt32;\n  }\n}\n\nexport function getElementFormat(type: number, size: number): VertexElementFormat {\n  if (type == DataType.FLOAT) {\n    switch (size) {\n      case 1:\n        return VertexElementFormat.Float;\n      case 2:\n        return VertexElementFormat.Vector2;\n      case 3:\n        return VertexElementFormat.Vector3;\n      case 4:\n        return VertexElementFormat.Vector4;\n    }\n  }\n  if (type == DataType.UNSIGNED_SHORT) {\n    switch (size) {\n      case 2:\n        return VertexElementFormat.UShort2;\n      case 4:\n        return VertexElementFormat.UShort4;\n    }\n  }\n}\n\n/**\n * 加载 image buffer\n * @param imageBuffer\n * @param type\n * @param callback\n */\nexport function loadImageBuffer(imageBuffer: ArrayBuffer, type: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const blob = new window.Blob([imageBuffer], { type });\n    const img = new Image();\n    img.src = URL.createObjectURL(blob);\n\n    img.crossOrigin = \"anonymous\";\n    img.onerror = function () {\n      reject(new Error(\"Failed to load image buffer\"));\n    };\n    img.onload = function () {\n      // Call requestAnimationFrame to avoid iOS's bug.\n      requestAnimationFrame(() => {\n        resolve(img);\n      });\n    };\n  });\n}\n\nfunction isRelativeUrl(url: string): boolean {\n  // 47 is /\n  return url.charCodeAt(0) !== 47 && url.match(/:\\/\\//) === null;\n}\n\nfunction isAbsoluteUrl(url: string): boolean {\n  return /^(?:http|blob|data:|\\/)/.test(url);\n}\n\nexport function parseRelativeUrl(baseUrl: string, relativeUrl: string): string {\n  if (isAbsoluteUrl(relativeUrl)) {\n    return relativeUrl;\n  }\n  // TODO: implement ../path\n  return baseUrl.substring(0, baseUrl.lastIndexOf(\"/\") + 1) + relativeUrl;\n}\n","import { DRACODecoder } from \"@oasis-engine/draco\";\nimport { getComponentType, getBufferData } from \"./Util\";\n\nlet decoder;\n\nexport const glTFDracoMeshCompression = {\n  init() {\n    if (!decoder) {\n      decoder = new DRACODecoder();\n    }\n  },\n  parse(extension, gltfPrimitive, gltf, buffers) {\n    const { bufferViews, accessors } = gltf;\n    const bufferViewIndex = extension.bufferView;\n    const gltfAttributeMap = extension.attributes;\n    const attributeMap = {};\n    const attributeTypeMap = {};\n\n    for (let attributeName in gltfAttributeMap) {\n      attributeMap[attributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (let attributeName in gltfPrimitive.attributes) {\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = accessors[gltfPrimitive.attributes[attributeName]];\n        attributeTypeMap[attributeName] = getComponentType(accessorDef.componentType).name;\n      }\n    }\n    const indexAccessor = accessors[gltfPrimitive.indices];\n    const indexType = getComponentType(indexAccessor.componentType).name;\n    const taskConfig = {\n      attributeIDs: attributeMap,\n      attributeTypes: attributeTypeMap,\n      useUniqueIDs: true,\n      indexType\n    };\n    const buffer = getBufferData(bufferViews[bufferViewIndex], buffers);\n\n    return decoder.decode(buffer, taskConfig).then((parsedGeometry) => parsedGeometry);\n  }\n};\n","import {\n  Animation,\n  AnimationClip,\n  Buffer,\n  BufferBindFlag,\n  BufferUsage,\n  ConstantMaterial,\n  DataType,\n  Engine,\n  EngineObject,\n  Entity,\n  IndexBufferBinding,\n  IndexFormat,\n  InterpolationType,\n  Logger,\n  Material,\n  Mesh,\n  MeshRenderer,\n  PBRMaterial,\n  Primitive,\n  PrimitiveTopology,\n  Scene,\n  Skin,\n  SkinnedMeshRenderer,\n  SubPrimitive,\n  Texture2D,\n  TypedArray,\n  Util,\n  VertexBufferBinding,\n  VertexElement,\n  Camera as OasisCamera\n} from \"@oasis-engine/core\";\nimport { Matrix, Quaternion, Vector3, Vector4 } from \"@oasis-engine/math\";\nimport { Camera, LoadedGLTFResource } from \"../GLTF\";\nimport { Oasis } from \"../scene-loader\";\nimport { glTFDracoMeshCompression } from \"./glTFDracoMeshCompression\";\nimport {\n  createVertexElement,\n  findByKeyValue,\n  getAccessorData,\n  getAccessorTypeSize,\n  getIndexFormat,\n  getVertexStride\n} from \"./Util\";\n\n// KHR_lights:  https://github.com/MiiBond/glTF/tree/khr_lights_v1/extensions/2.0/Khronos/KHR_lights\n//              https://github.com/KhronosGroup/glTF/pull/1223\n//              https://github.com/KhronosGroup/glTF/issues/945\n// KHR_materials_common:  https://github.com/donmccurdy/glTF/tree/donmccurdy-KHR_materials_common/extensions/Khronos/KHR_materials_common_v2\n//                        https://github.com/KhronosGroup/glTF/pull/1150\n//                        https://github.com/KhronosGroup/glTF/issues/947\n\nconst TARGET_PATH_MAP = {\n  translation: \"position\",\n  rotation: \"rotation\",\n  scale: \"scale\",\n  weights: \"weights\"\n};\n\nlet nodeCount = 0;\n\nconst RegistedObjs = {};\nconst RegistedCustomMaterials = {};\n\nconst getDefaultMaterial = (function () {\n  // let defaultMateril: ConstantMaterial;\n  return (engine: Engine) => {\n    // if (!defaultMateril) {\n    let defaultMateril: ConstantMaterial = new ConstantMaterial(engine, \"default\");\n    defaultMateril.emission = new Vector4(0.749, 0.749, 0.749, 1);\n    // }\n    return defaultMateril;\n  };\n})();\n\n/**\n * 扩展专用注册键值\n */\nexport const HandledExtensions = {\n  PBRMaterial: \"PBRMaterial\",\n  KHR_lights: \"KHR_lights\",\n  KHR_materials_unlit: \"KHR_materials_unlit\",\n  KHR_materials_pbrSpecularGlossiness: \"KHR_materials_pbrSpecularGlossiness\",\n  KHR_techniques_webgl: \"KHR_techniques_webgl\",\n  KHR_draco_mesh_compression: \"KHR_draco_mesh_compression\"\n};\n\nlet KHR_lights = null;\n\nconst extensionParsers = {\n  KHR_lights: KHR_lights,\n  KHR_materials_unlit: PBRMaterial, // Also have other materials\n  KHR_materials_pbrSpecularGlossiness: PBRMaterial,\n  KHR_techniques_webgl: Material,\n  KHR_draco_mesh_compression: glTFDracoMeshCompression\n};\n\n/**\n * 注册扩展组件到 glTF loader\n * @param {Object} extobj 需要添加的扩展\n */\nexport function RegistExtension(extobj) {\n  Object.keys(extobj).forEach((name) => {\n    if (RegistedObjs[name] === undefined) {\n      RegistedObjs[name] = extobj[name];\n\n      switch (name) {\n        case HandledExtensions.PBRMaterial:\n          extensionParsers.KHR_materials_unlit = PBRMaterial;\n          break;\n        case HandledExtensions.KHR_lights:\n          KHR_lights = extobj[name];\n          extensionParsers.KHR_lights = KHR_lights;\n          break;\n        default:\n          if (Material.isPrototypeOf(extobj[name]) && extobj[name].TECH_NAME)\n            RegistedCustomMaterials[extobj[name].TECH_NAME] = extobj[name];\n          break;\n      }\n    }\n  });\n}\n\nexport interface GLTFParsed extends LoadedGLTFResource {\n  asset: Partial<GLTFResource>;\n  engine?: Engine;\n}\n\nexport class GLTFResource extends EngineObject {\n  defaultSceneRoot: Entity;\n  defaultScene: Scene;\n  scenes: Scene[];\n  textures?: Texture2D[];\n  animations?: AnimationClip[];\n  materials?: Material[];\n  meshes?: Mesh[];\n  skins?: Skin[];\n  cameras?: OasisCamera[];\n  meta: any;\n}\n\n/**\n * 解析 glTF 结构\n * @param resource\n * @returns {*}\n * @private\n */\nexport function parseGLTF(data: LoadedGLTFResource, engine: Engine): Promise<GLTFResource> {\n  // 开始处理 glTF 数据\n  const resources: GLTFParsed = {\n    engine,\n    gltf: data.gltf,\n    buffers: data.buffers,\n    asset: new GLTFResource(engine)\n  };\n  resources.asset.textures = data.textures;\n  resources.asset.meta = data.gltf;\n\n  if (resources.gltf.asset && resources.gltf.asset.version) {\n    resources.gltf.version = Number(resources.gltf.asset.version);\n    resources.gltf.isGltf2 = resources.gltf.version >= 2 && resources.gltf.version <= 3;\n  }\n\n  parseExtensions(resources);\n  // parse all related resources\n  return (\n    parseResources(resources, \"materials\", parseMaterial)\n      .then(() => parseResources(resources, \"meshes\", parseMesh))\n      // .then(() => parseResources(resources, \"cameras\", parseCamera))\n      .then(() => parseResources(resources, \"nodes\", parseNode))\n      .then(() => parseResources(resources, \"scenes\", parseScene))\n      .then(() => parseResources(resources, \"skins\", parseSkin))\n      .then(() => parseResources(resources, \"animations\", parseAnimation))\n      .then(() => buildSceneGraph(resources))\n  );\n}\n\nfunction parseExtensions(resources) {\n  const { gltf, asset } = resources;\n  const { extensions, extensionsUsed, extensionsRequired } = gltf;\n  if (extensionsUsed) {\n    Logger.info(\"extensionsUsed: \", extensionsUsed);\n    for (let i = 0; i < extensionsUsed.length; i++) {\n      if (Object.keys(extensionParsers).indexOf(extensionsUsed[i]) > -1) {\n        if (!extensionParsers[extensionsUsed[i]]) {\n          Logger.warn(\"extension \" + extensionsUsed[i] + \" is used, you can add this extension into gltf\");\n        }\n      } else {\n        Logger.warn(\"extensionsUsed has unsupported extension \" + extensionsUsed[i]);\n      }\n    }\n  }\n\n  if (extensionsRequired) {\n    Logger.info(`extensionsRequired: ${extensionsRequired}`);\n    for (let i = 0; i < extensionsRequired.length; i++) {\n      if (\n        Object.keys(extensionParsers).indexOf(extensionsRequired[i]) < 0 ||\n        !extensionParsers[extensionsRequired[i]]\n      ) {\n        Logger.error(`model has not supported required extension ${extensionsRequired[i]}`);\n      }\n      if (extensionsRequired[i] === HandledExtensions.KHR_draco_mesh_compression) {\n        extensionParsers.KHR_draco_mesh_compression.init();\n      }\n    }\n  }\n\n  if (extensions) {\n    if (KHR_lights && extensions.KHR_lights) {\n      asset.lights = KHR_lights.parseLights(extensions.KHR_lights.lights);\n    }\n  }\n}\n\n/**\n * 通用资源解析方法\n * @param resources 现有资源\n * @param name glTF 中资源\n * @param handler 资源解析器\n * @private\n */\nfunction parseResources(resources: GLTFParsed, name: string, handler) {\n  const { gltf, asset } = resources;\n  if (!asset[name]) {\n    asset[name] = [];\n  }\n  if (gltf.hasOwnProperty(name)) {\n    const entities = gltf[name] || [];\n    Logger.debug(name + \":\", entities);\n    const promises = [];\n    for (let i = entities.length - 1; i >= 0; i--) {\n      promises.push(handler(entities[i], resources));\n    }\n    return Promise.all(promises).then((results) => {\n      for (let i = 0; i < results.length; i++) {\n        asset[name].push(results[i]);\n      }\n    });\n  }\n  return Promise.resolve();\n}\n\n/**\n * 解析 材质\n * @param gltfMaterial\n * @param resources\n * @private\n */\nexport function parseMaterial(gltfMaterial, resources) {\n  const { gltf, asset } = resources;\n  let material;\n\n  if (gltf.isGltf2 && typeof gltfMaterial.technique === \"undefined\") {\n    const uniformObj: any = {};\n    const stateObj: any = {};\n    const {\n      pbrMetallicRoughness,\n      normalTexture,\n      emissiveTexture,\n      emissiveFactor,\n      occlusionTexture,\n      alphaMode,\n      alphaCutoff,\n      doubleSided,\n      extensions\n    } = gltfMaterial;\n\n    if (pbrMetallicRoughness) {\n      const {\n        baseColorFactor,\n        baseColorTexture,\n        metallicFactor,\n        roughnessFactor,\n        metallicRoughnessTexture\n      } = pbrMetallicRoughness;\n      if (baseColorTexture) {\n        uniformObj.baseColorTexture = getItemByIdx(\"textures\", baseColorTexture.index || 0, resources, false);\n      }\n      if (baseColorFactor) {\n        uniformObj.baseColorFactor = new Vector4(...baseColorFactor);\n      }\n      uniformObj.metallicFactor = metallicFactor !== undefined ? metallicFactor : 1;\n      uniformObj.roughnessFactor = roughnessFactor !== undefined ? roughnessFactor : 1;\n      if (metallicRoughnessTexture) {\n        uniformObj.metallicRoughnessTexture = getItemByIdx(\n          \"textures\",\n          metallicRoughnessTexture.index || 0,\n          resources,\n          false\n        );\n      }\n    }\n\n    if (normalTexture) {\n      const { index, texCoord, scale } = normalTexture;\n      uniformObj.normalTexture = getItemByIdx(\"textures\", index || 0, resources, false);\n\n      if (typeof scale !== undefined) {\n        uniformObj.normalScale = scale;\n      }\n    }\n\n    if (emissiveTexture) {\n      uniformObj.emissiveTexture = getItemByIdx(\"textures\", emissiveTexture.index || 0, resources, false);\n    }\n\n    if (occlusionTexture) {\n      uniformObj.occlusionTexture = getItemByIdx(\"textures\", occlusionTexture.index || 0, resources, false);\n\n      if (occlusionTexture.strength !== undefined) {\n        uniformObj.occlusionStrength = occlusionTexture.strength;\n      }\n    }\n\n    stateObj.doubleSided = !!doubleSided;\n    stateObj.alphaMode = alphaMode || \"OPAQUE\";\n    if (alphaMode === \"MASK\") {\n      uniformObj.alphaCutoff = alphaCutoff === undefined ? 0.5 : alphaCutoff;\n    }\n\n    if (extensions) {\n      if (extensions.KHR_materials_unlit) {\n        stateObj.unlit = true;\n      }\n\n      // 高光光泽度\n      if (extensions.KHR_materials_pbrSpecularGlossiness) {\n        const {\n          diffuseFactor,\n          diffuseTexture,\n          specularFactor,\n          glossinessFactor,\n          specularGlossinessTexture\n        } = extensions.KHR_materials_pbrSpecularGlossiness;\n\n        stateObj.isMetallicWorkflow = false;\n        if (diffuseFactor) {\n          uniformObj.baseColorFactor = new Vector4(...diffuseFactor);\n        }\n        if (diffuseTexture) {\n          uniformObj.baseColorTexture = getItemByIdx(\"textures\", diffuseTexture.index || 0, resources, false);\n        }\n        if (specularFactor) {\n          uniformObj.specularFactor = new Vector3(...specularFactor);\n        }\n        if (glossinessFactor !== undefined) {\n          uniformObj.glossinessFactor = glossinessFactor;\n        }\n        if (specularGlossinessTexture) {\n          uniformObj.specularGlossinessTexture = getItemByIdx(\n            \"textures\",\n            specularGlossinessTexture.index || 0,\n            resources,\n            false\n          );\n        }\n      }\n    }\n\n    // private parameters\n    const { unlit, srgb, gamma, blendFunc, depthMask } = gltfMaterial;\n    if (unlit) stateObj.unlit = true;\n    if (srgb) stateObj.srgb = true;\n    if (gamma) stateObj.gamma = true;\n    if (blendFunc) stateObj.blendFunc = blendFunc;\n    if (depthMask !== undefined) stateObj.depthMask = depthMask;\n\n    material = new PBRMaterial(\n      resources.engine,\n      gltfMaterial.name || PBRMaterial.MATERIAL_NAME,\n      Object.assign({}, uniformObj, stateObj)\n    );\n  } else {\n    const techniqueName = gltfMaterial.technique;\n    Logger.warn(\"Deprecated: Please use a model that meets the glTF 2.0 specification\");\n    // TODO: 加坨 shi，未来支持 KHR_UNLIT_MATERIAL\n    if (techniqueName === \"Texture\") {\n      material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME);\n      material.unlit = true;\n      const index = gltfMaterial.values._MainTex[0];\n      material.baseColorTexture = getItemByIdx(\"textures\", index || 0, resources, false);\n    }\n  }\n  return Promise.resolve(material);\n}\n\n/**\n * 解析蒙皮\n * @param gltfSkin\n * @param resources\n * @private\n */\nexport function parseSkin(gltfSkin, resources) {\n  const { gltf, buffers } = resources;\n\n  const jointCount = gltfSkin.joints.length;\n\n  // FIXME: name is null\n  const skin = new Skin(gltfSkin.name);\n  // parse IBM\n  const accessor = gltf.accessors[gltfSkin.inverseBindMatrices];\n  const buffer = getAccessorData(gltf, accessor, buffers);\n  const MAT4_LENGTH = 16;\n\n  for (let i = 0; i < jointCount; i++) {\n    const startIdx = MAT4_LENGTH * i;\n    const endIdx = startIdx + MAT4_LENGTH;\n    skin.inverseBindMatrices[i] = new Matrix(...buffer.subarray(startIdx, endIdx));\n  }\n\n  // get joints\n  for (let i = 0; i < jointCount; i++) {\n    const node = getItemByIdx(\"nodes\", gltfSkin.joints[i], resources);\n    skin.joints[i] = node.name;\n  }\n\n  // get skeleton\n  const node = getItemByIdx(\"nodes\", gltfSkin.skeleton == null ? gltfSkin.joints[0] : gltfSkin.skeleton, resources);\n  skin.skeleton = node.name;\n\n  return Promise.resolve(skin);\n}\n\nfunction parsePrimitiveVertex(\n  mesh: Mesh,\n  primitive: Primitive,\n  primitiveGroup: SubPrimitive,\n  gltfPrimitive,\n  gltf,\n  getVertexBufferData: (string) => TypedArray,\n  getIndexBufferData: () => TypedArray,\n  engine\n) {\n  // load vertices\n  let i = 0;\n  const vertexElements: VertexElement[] = [];\n  for (const attributeSemantic in gltfPrimitive.attributes) {\n    const accessorIdx = gltfPrimitive.attributes[attributeSemantic];\n    const accessor = gltf.accessors[accessorIdx];\n    const stride = getVertexStride(accessor);\n    const vertexELement = createVertexElement(gltf, attributeSemantic, accessor, i);\n\n    vertexElements.push(vertexELement);\n    const bufferData = getVertexBufferData(attributeSemantic);\n    const vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, bufferData.byteLength, BufferUsage.Static);\n    vertexBuffer.setData(bufferData);\n    primitive.setVertexBufferBinding(vertexBuffer, stride, i++);\n\n    // compute bounds\n    if (vertexELement.semantic == \"POSITION\") {\n      const position = new Vector3();\n      const vertexCount = bufferData.length / 3;\n      const { min, max } = mesh.bounds;\n      for (let i = 0; i < vertexCount; i++) {\n        const offset = i * 3;\n        position.setValue(bufferData[offset], bufferData[offset + 1], bufferData[offset + 2]);\n        Vector3.min(min, position, min);\n        Vector3.max(max, position, max);\n      }\n    }\n  }\n  primitive.setVertexElements(vertexElements);\n\n  // load indices\n  const indexAccessor = gltf.accessors[gltfPrimitive.indices];\n  const indexData = getIndexBufferData();\n\n  const indexCount = indexAccessor.count;\n  const indexFormat = getIndexFormat(indexAccessor.componentType);\n  const indexByteSize = indexFormat == IndexFormat.UInt32 ? 4 : indexFormat == IndexFormat.UInt16 ? 2 : 1;\n  const indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indexCount * indexByteSize, BufferUsage.Static);\n\n  indexBuffer.setData(indexData);\n  primitive.setIndexBufferBinding(new IndexBufferBinding(indexBuffer, indexFormat));\n  primitiveGroup.start = 0;\n  primitiveGroup.count = indexCount;\n  return Promise.resolve(primitive);\n}\n\nfunction parserPrimitiveTarget(primitive, gltfPrimitive, gltf, buffers) {}\n\n/**\n * 解析 Mesh\n * @param gltfMesh\n * @param resources\n * @private\n */\nexport function parseMesh(gltfMesh, resources) {\n  const { gltf, buffers, engine } = resources;\n\n  const mesh = new Mesh(gltfMesh.name);\n  // mesh.type = resources.assetType;\n  // parse all primitives then link to mesh\n  // TODO: use hash cached primitives\n  const primitivePromises = [];\n  const groups = [];\n  for (let i = 0; i < gltfMesh.primitives.length; i++) {\n    primitivePromises.push(\n      new Promise((resolve, reject) => {\n        const gltfPrimitive = gltfMesh.primitives[i];\n        // FIXME: use index as primitive's name\n        const primitive = new Primitive(engine, gltfPrimitive.name || gltfMesh.name || i);\n        const subPrimitive = new SubPrimitive();\n        groups.push(subPrimitive);\n        // primitive.type = resources.assetType;\n        subPrimitive.topology = gltfPrimitive.mode == null ? PrimitiveTopology.Triangles : gltfPrimitive.mode;\n        if (gltfPrimitive.hasOwnProperty(\"targets\")) {\n          primitive.targets = [];\n          (mesh as any).weights = gltfMesh.weights || new Array(gltfPrimitive.targets.length).fill(0);\n        }\n        let vertexPromise;\n        if (gltfPrimitive.extensions && gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression]) {\n          const extensionParser = extensionParsers.KHR_draco_mesh_compression;\n          const extension = gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression];\n          vertexPromise = extensionParser.parse(extension, gltfPrimitive, gltf, buffers).then((decodedGeometry) => {\n            return parsePrimitiveVertex(\n              mesh,\n              primitive,\n              subPrimitive,\n              gltfPrimitive,\n              gltf,\n              (attributeSemantic) => {\n                for (let i = 0; i < decodedGeometry.attributes.length; i++) {\n                  if (decodedGeometry.attributes[i].name === attributeSemantic) {\n                    return decodedGeometry.attributes[i].array;\n                  }\n                }\n                return null;\n              },\n              () => {\n                return decodedGeometry.index.array;\n              },\n              resources.engine\n            );\n          });\n        } else {\n          vertexPromise = parsePrimitiveVertex(\n            mesh,\n            primitive,\n            subPrimitive,\n            gltfPrimitive,\n            gltf,\n            (attributeSemantic) => {\n              const accessorIdx = gltfPrimitive.attributes[attributeSemantic];\n              const accessor = gltf.accessors[accessorIdx];\n              return getAccessorData(gltf, accessor, buffers);\n            },\n            () => {\n              const indexAccessor = gltf.accessors[gltfPrimitive.indices];\n              return getAccessorData(gltf, indexAccessor, buffers);\n            },\n            resources.engine\n          );\n        }\n        vertexPromise\n          .then((processedPrimitive) => {\n            parserPrimitiveTarget(processedPrimitive, gltfPrimitive, gltf, buffers);\n            resolve(processedPrimitive);\n          })\n          .catch((e) => {\n            reject(e);\n          });\n      })\n    );\n  }\n  return Promise.all(primitivePromises).then((primitives: Primitive[]) => {\n    for (let i = 0; i < primitives.length; i++) {\n      mesh.primitives.push(primitives[i]);\n      mesh.groups.push(groups[i]);\n    }\n    return mesh;\n  });\n}\n\n/**\n * 解析动画\n * @param gltfAnimation\n * @param resources\n * @returns {*}\n * @private\n */\nexport function parseAnimation(gltfAnimation, resources) {\n  const { gltf, buffers } = resources;\n  const gltfSamplers = gltfAnimation.samplers || [];\n  const gltfChannels = gltfAnimation.channels || [];\n\n  const animationIdx = gltf.animations.indexOf(gltfAnimation);\n  const animationClip = new AnimationClip(gltfAnimation.name || `Animation${animationIdx}`);\n\n  let duration = -1;\n  let durationIndex = -1;\n  // parse samplers\n  for (let i = 0; i < gltfSamplers.length; i++) {\n    const gltfSampler = gltfSamplers[i];\n    // input\n    const inputAccessor = gltf.accessors[gltfSampler.input];\n    const outputAccessor = gltf.accessors[gltfSampler.output];\n    const input = getAccessorData(gltf, inputAccessor, buffers);\n    const output = getAccessorData(gltf, outputAccessor, buffers);\n    let outputAccessorSize = getAccessorTypeSize(outputAccessor.type);\n    if (outputAccessorSize * input.length !== output.length) outputAccessorSize = output.length / input.length;\n\n    // TODO: support\n    // LINEAR, STEP, CUBICSPLINE\n    let samplerInterpolation = InterpolationType.LINEAR;\n    switch (gltfSampler.interpolation) {\n      case \"CUBICSPLINE\":\n        samplerInterpolation = InterpolationType.CUBICSPLINE;\n        break;\n      case \"STEP\":\n        samplerInterpolation = InterpolationType.STEP;\n        break;\n    }\n    const maxTime = input[input.length - 1];\n    if (maxTime > duration) {\n      duration = maxTime;\n      durationIndex = i;\n    }\n    animationClip.addSampler(input, output, outputAccessorSize, samplerInterpolation);\n  }\n\n  animationClip.durationIndex = durationIndex;\n  animationClip.duration = duration;\n\n  for (let i = 0; i < gltfChannels.length; i++) {\n    const gltfChannel = gltfChannels[i];\n    const target = gltfChannel.target;\n    const samplerIndex = gltfChannel.sampler;\n    const targetNode = getItemByIdx(\"nodes\", target.node, resources);\n    const targetPath = TARGET_PATH_MAP[target.path];\n\n    animationClip.addChannel(samplerIndex, targetNode.name, targetPath);\n  }\n\n  return Promise.resolve(animationClip);\n}\n\n/**\n * 解析 glTF 节点\n * @param gltfNode\n * @param resources\n * @private\n */\nexport function parseNode(gltfNode, resources: GLTFParsed) {\n  // TODO: undefined name?\n  const entity = new Entity(resources.engine, gltfNode.name || `GLTF_NODE_${nodeCount++}`);\n\n  if (gltfNode.hasOwnProperty(\"matrix\")) {\n    const m = gltfNode.matrix;\n    const mat = new Matrix();\n    mat.setValueByArray(m);\n    const pos = new Vector3();\n    const scale = new Vector3(1, 1, 1);\n    const rot = new Quaternion();\n    mat.decompose(pos, rot, scale);\n\n    entity.transform.position = pos;\n    entity.transform.rotationQuaternion = rot;\n    entity.transform.scale = scale;\n  } else {\n    for (const key in TARGET_PATH_MAP) {\n      if (gltfNode.hasOwnProperty(key)) {\n        const mapKey = TARGET_PATH_MAP[key];\n        if (mapKey === \"weights\") {\n          entity[mapKey] = gltfNode[key];\n        } else {\n          const arr = gltfNode[key];\n          const len = arr.length;\n          const obj = entity[mapKey];\n          if (len === 2) {\n            obj.setValue(arr[0], arr[1]);\n          } else if (len === 3) {\n            obj.setValue(arr[0], arr[1], arr[2]);\n          } else if (len === 4) {\n            obj.setValue(arr[0], arr[1], arr[2], arr[3]);\n          }\n          entity[mapKey] = obj;\n        }\n      }\n    }\n  }\n\n  if (gltfNode.camera !== undefined) {\n    const cameraOptions = resources.gltf.cameras[gltfNode.camera];\n    const camera = entity.addComponent(OasisCamera);\n    if (cameraOptions.type === \"orthographic\") {\n      camera.isOrthographic = true;\n      let { ymag, xmag, zfar, znear } = cameraOptions.orthographic;\n      if (znear !== undefined) {\n        camera.nearClipPlane = znear;\n      }\n      if (zfar !== undefined) {\n        camera.farClipPlane = zfar;\n      }\n      if (ymag && xmag) {\n        camera.orthographicSize = Math.max(ymag, xmag) / 2;\n      }\n      if (ymag !== undefined && xmag) {\n        camera.orthographicSize = xmag / 2;\n      }\n      if (xmag !== undefined && ymag) {\n        camera.orthographicSize = ymag / 2;\n      }\n    } else {\n      const { aspectRatio, yfov, zfar, znear } = cameraOptions.perspective;\n      // 移动端相机普遍根据设备的宽高比去定义 aspectRatio，不以导出的相机参数为准。\n      // if (aspectRatio !== undefined) {\n      // camera.aspectRatio = aspectRatio;\n      // }\n      if (yfov !== undefined) {\n        camera.fieldOfView = yfov;\n      }\n      if (zfar !== undefined) {\n        camera.farClipPlane = zfar;\n      }\n      if (znear !== undefined) {\n        camera.nearClipPlane = znear;\n      }\n    }\n  }\n\n  if (gltfNode.extensions) {\n    if (KHR_lights && gltfNode.extensions.KHR_lights) {\n      const lightIdx = gltfNode.extensions.KHR_lights.light;\n      if (lightIdx !== undefined) {\n        const light = getItemByIdx(\"lights\", lightIdx, resources);\n        if (light) {\n          const lightCon = entity.addComponent(light.ability);\n          Object.assign(lightCon, light.props);\n        }\n      }\n    }\n  }\n\n  return Promise.resolve(entity);\n}\n\n/**\n * 解析 glTF 场景\n * @param gltfScene\n * @param resources\n * @returns {{nodes: Array}}\n * @private\n */\nexport function parseScene(gltfScene, resources) {\n  const sceneNodes = [];\n  for (let i = 0; i < gltfScene.nodes.length; i++) {\n    const node = getItemByIdx(\"nodes\", gltfScene.nodes[i], resources);\n    sceneNodes.push(node);\n  }\n\n  if (gltfScene.extensions) {\n    if (KHR_lights && gltfScene.extensions.KHR_lights) {\n      const lightIdx = gltfScene.extensions.KHR_lights.light;\n      if (lightIdx !== undefined) {\n        const light = getItemByIdx(\"lights\", lightIdx, resources);\n        if (light) sceneNodes[0].addComponent(light.ability, light.props);\n      }\n    }\n  }\n\n  return Promise.resolve({\n    nodes: sceneNodes\n  });\n}\n\n/**\n * 通过索引获得内容\n * @param name\n * @param idx\n * @param resources\n * @returns {*}\n * @private\n */\nexport function getItemByIdx(name, idx, resources, inverse: boolean = true) {\n  const { asset } = resources;\n\n  const itemIdx = inverse ? asset[name].length - idx - 1 : idx;\n  return asset[name][itemIdx];\n}\n\n/**\n * 构造 scene graph，根据节点配置创建 Ability\n * @param resources\n * @private\n */\nexport function buildSceneGraph(resources: GLTFParsed): GLTFResource {\n  const { asset, gltf } = resources;\n\n  const gltfNodes = gltf.nodes || [];\n  const gltfMeshes = gltf.meshes;\n\n  asset.defaultScene = getItemByIdx(\"scenes\", gltf.scene ?? 0, resources);\n\n  for (let i = gltfNodes.length - 1; i >= 0; i--) {\n    const gltfNode = gltfNodes[i];\n    const node = getItemByIdx(\"nodes\", i, resources);\n\n    if (gltfNode.hasOwnProperty(\"children\")) {\n      const children = gltfNode.children || [];\n      for (let j = children.length - 1; j >= 0; j--) {\n        const childNode = getItemByIdx(\"nodes\", children[j], resources);\n\n        node.addChild(childNode);\n      }\n    }\n\n    // link mesh\n    if (gltfNode.hasOwnProperty(\"mesh\")) {\n      const meshIndex = gltfNode.mesh;\n      node.meshIndex = meshIndex;\n      const gltfMeshPrimitives = gltfMeshes[meshIndex].primitives;\n      const mesh = getItemByIdx(\"meshes\", meshIndex, resources);\n\n      let renderer: MeshRenderer;\n      if (gltfNode.hasOwnProperty(\"skin\") || mesh.hasOwnProperty(\"weights\")) {\n        const skin = getItemByIdx(\"skins\", gltfNode.skin, resources);\n        const weights = mesh.weights;\n        const skinRenderer: SkinnedMeshRenderer = node.addComponent(SkinnedMeshRenderer);\n        skinRenderer.mesh = mesh;\n        skinRenderer.skin = skin;\n        skinRenderer.setWeights(weights);\n        renderer = skinRenderer;\n      } else {\n        renderer = node.addComponent(MeshRenderer);\n        renderer.mesh = mesh;\n      }\n      for (let j = 0, m = gltfMeshPrimitives.length; j < m; j++) {\n        const materialIndex = gltfMeshPrimitives[j].material;\n        mesh.primitives[j].materialIndex = materialIndex;\n        const material =\n          materialIndex !== undefined\n            ? getItemByIdx(\"materials\", materialIndex, resources)\n            : getDefaultMaterial(node.engine);\n        renderer.setSharedMaterial(j, material);\n      }\n    }\n  }\n\n  //@ts-ignore\n  const nodes = asset.defaultScene.nodes;\n  if (nodes.length === 1) {\n    asset.defaultSceneRoot = nodes[0];\n  } else {\n    const rootNode = new Entity(resources.engine);\n    for (let i = 0; i < nodes.length; i++) {\n      rootNode.addChild(nodes[i]);\n    }\n    asset.defaultSceneRoot = rootNode;\n  }\n\n  const animator = asset.defaultSceneRoot.addComponent(Animation);\n  const animations = asset.animations;\n  if (animations) {\n    animations.forEach((clip: AnimationClip) => {\n      animator.addAnimationClip(clip, clip.name);\n    });\n  }\n  return resources.asset as GLTFResource;\n}\n","import { decodeText } from \"./Util\";\n\n/**\n * 解析 glb 格式\n * @param glb 二进制数据\n * @returns Object glb 中 glTF 信息与 bin 信息\n * @private\n */\nexport function parseGLB(glb) {\n  const UINT32_LENGTH = 4;\n  const GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'\n  const GLB_HEADER_LENGTH = 12;\n  const GLB_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 };\n\n  const dataView = new DataView(glb);\n\n  // read header\n  const header = {\n    magic: dataView.getUint32(0, true),\n    version: dataView.getUint32(UINT32_LENGTH, true),\n    length: dataView.getUint32(2 * UINT32_LENGTH, true)\n  };\n\n  if (header.magic !== GLB_HEADER_MAGIC) {\n    console.error(\"Invalid glb magic number. Expected 0x46546C67, found 0x\" + header.magic.toString(16));\n    return null;\n  }\n\n  // read main data\n  let chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);\n  let chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);\n\n  // read glTF json\n  if (chunkType !== GLB_CHUNK_TYPES.JSON) {\n    console.error(\"Invalid glb chunk type. Expected 0x004E4942, found 0x\" + chunkType.toString(16));\n    return null;\n  }\n\n  const glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);\n  const gltf = JSON.parse(decodeText(glTFData));\n\n  // read all buffers\n  const buffers = [];\n  let byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;\n\n  while (byteOffset < header.length) {\n    chunkLength = dataView.getUint32(byteOffset, true);\n    chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);\n\n    if (chunkType !== GLB_CHUNK_TYPES.BIN) {\n      console.error(\"Invalid glb chunk type. Expected 0x004E4942, found 0x\" + chunkType.toString(16));\n      return null;\n    }\n\n    const currentOffset = byteOffset + 2 * UINT32_LENGTH;\n    const buffer = glb.slice(currentOffset, currentOffset + chunkLength);\n    buffers.push(buffer);\n\n    byteOffset += chunkLength + 2 * UINT32_LENGTH;\n  }\n\n  // start parse glTF\n  return {\n    gltf,\n    buffers\n  };\n}\n","import {\n  resourceLoader,\n  Loader,\n  AssetPromise,\n  AssetType,\n  LoadItem,\n  ResourceManager,\n  Texture2D,\n  GLCapabilityType\n} from \"@oasis-engine/core\";\nimport { GlTf, LoadedGLTFResource } from \"./GLTF\";\nimport { parseGLTF, GLTFResource } from \"./gltf/glTF\";\nimport { parseGLB } from \"./gltf/glb\";\nimport { loadImageBuffer, getBufferData, parseRelativeUrl } from \"./gltf/Util\";\n\n@resourceLoader(AssetType.Perfab, [\"gltf\", \"glb\"])\nexport class GLTFLoader extends Loader<GLTFResource> {\n  private baseUrl: string;\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<GLTFResource> {\n    return new AssetPromise((resolve, reject) => {\n      const requestGLTFResource = this.isGLB(item.url) ? this.requestGLB : this.requestGLTF;\n      requestGLTFResource(item, resourceManager)\n        .then((res) => {\n          parseGLTF(res, resourceManager.engine).then((gltf) => {\n            resolve(gltf);\n          });\n        })\n        .catch((e) => {\n          console.error(e);\n          reject(\"Error loading glTF JSON from \" + item.url);\n        });\n    });\n  }\n\n  private requestGLTF = (item: LoadItem, resourceManager: ResourceManager): Promise<LoadedGLTFResource> => {\n    return this.request<GlTf>(item.url, {\n      ...item,\n      type: \"json\"\n    }).then((res) => this._loadGLTFResources(item, res, resourceManager));\n  };\n\n  private requestGLB = (item: LoadItem, resourceManager: ResourceManager): Promise<LoadedGLTFResource> => {\n    return this.request<GlTf>(item.url, {\n      ...item,\n      type: \"arraybuffer\"\n    })\n      .then(parseGLB)\n      .then((res) => {\n        return { ...res, baseUrl: item.url, resourceManager };\n      })\n      .then(this._loadImages);\n  };\n\n  private isGLB(url: string): boolean {\n    return url.substring(url.lastIndexOf(\".\") + 1) === \"glb\";\n  }\n\n  /**\n   * 加载 gltf 内的资源\n   * @param gltf\n   * @param resourceManager\n   */\n  private _loadGLTFResources(\n    item: LoadItem,\n    gltf: GlTf,\n    resourceManager: ResourceManager\n  ): Promise<LoadedGLTFResource> {\n    // 必须先加载 Buffer 再加载图片\n    return this._loadBuffers(item.url, gltf, resourceManager).then(this._loadImages);\n  }\n\n  private _loadBuffers(baseUrl: string, gltf: GlTf, resourceManager: ResourceManager): Promise<LoadedGLTFResource> {\n    if (gltf.buffers) {\n      return Promise.all(\n        gltf.buffers.map((item) => {\n          if (item instanceof ArrayBuffer) {\n            return Promise.resolve(item);\n          }\n          return resourceManager.load<ArrayBuffer>({\n            url: parseRelativeUrl(baseUrl, item.uri),\n            type: AssetType.Buffer\n          });\n        })\n      ).then((buffers) => {\n        return { buffers, gltf, baseUrl, resourceManager };\n      });\n    }\n    return Promise.resolve({ baseUrl, gltf, resourceManager });\n  }\n\n  private _loadImages = ({\n    gltf,\n    buffers,\n    baseUrl,\n    resourceManager\n  }: LoadedGLTFResource & { baseUrl: string; resourceManager: ResourceManager }) => {\n    if (!gltf.images) {\n      return Promise.resolve({ gltf, buffers });\n    }\n    let texturePromises = undefined;\n    const rhi = resourceManager.engine._hardwareRenderer;\n    if (gltf.astc && rhi.canIUse(GLCapabilityType.pvrtc)) {\n      texturePromises = this._loadCompressedTexture(resourceManager, gltf.pvrtc, baseUrl);\n    } else if (gltf.pvrtc && rhi.canIUse(GLCapabilityType.astc)) {\n      texturePromises = this._loadCompressedTexture(resourceManager, gltf.astc, baseUrl);\n    } else if (gltf.etc && rhi.canIUse(GLCapabilityType.etc)) {\n      texturePromises = this._loadCompressedTexture(resourceManager, gltf.etc, baseUrl);\n    } else {\n      texturePromises = this._loadBasicImages(resourceManager, gltf.images, baseUrl, buffers, gltf);\n    }\n    return texturePromises.then((textures) => {\n      return { gltf, buffers, textures };\n    });\n  };\n\n  private _loadBasicImages = (\n    resourceManager: ResourceManager,\n    images: any,\n    baseUrl: string,\n    buffers: any,\n    gltf: any\n  ) => {\n    return Promise.all(\n      images.map(({ uri, bufferView: bufferViewIndex, mimeType }) => {\n        if (uri) {\n          // 使用 base64 或 url\n          return resourceManager.load({ url: parseRelativeUrl(baseUrl, uri), type: AssetType.Texture2D });\n        } else {\n          // 使用 bufferView\n          const bufferView = gltf.bufferViews[bufferViewIndex];\n          const bufferData = getBufferData(bufferView, buffers);\n          return loadImageBuffer(bufferData, mimeType).then((image) => {\n            const tex = new Texture2D(resourceManager.engine, image.width, image.height);\n            tex.setImageSource(image);\n            tex.generateMipmaps();\n            return tex;\n          });\n        }\n      })\n    );\n  };\n\n  private _loadCompressedTexture = (resourceManager: ResourceManager, images: any, baseUrl: string) => {\n    const promises = images.map((item: any) => {\n      return resourceManager.load({ url: parseRelativeUrl(baseUrl, item.uri), type: AssetType.KTX });\n    });\n\n    return Promise.all(promises);\n  };\n}\n","import { resourceLoader, Loader, AssetPromise, AssetType, LoadItem } from \"@oasis-engine/core\";\n\n@resourceLoader(AssetType.JSON, [\"json\"], false)\nclass JSONLoader extends Loader<string> {\n  load(item: LoadItem): AssetPromise<string> {\n    return this.request(item.url, {\n      ...item,\n      type: \"json\"\n    });\n  }\n}\n","/**\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nimport { Mipmap, KTXContainer } from \"./type\";\nimport { GLCompressedTextureInternalFormat, TextureFormat } from \"@oasis-engine/core\";\n\nconst HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n\n// load types\nconst COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\nconst COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\nconst TEX_2D = 2; // uses a gl.texImage2D()\nconst TEX_3D = 3; // uses a gl.texImage3D()\n\nfunction getMipmaps(ktxContainer: KTXContainer, loadMipmaps: boolean): Mipmap[] {\n  const mipmaps = [];\n\n  // initialize width & height for level 1\n  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;\n  var width = ktxContainer.pixelWidth;\n  var height = ktxContainer.pixelHeight;\n  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;\n\n  for (var level = 0; level < mipmapCount; level++) {\n    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n    dataOffset += 4; // size of the image + 4 for the imageSize field\n\n    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {\n      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);\n\n      mipmaps.push({ data: byteArray, width: width, height: height });\n\n      dataOffset += imageSize;\n      dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\n    }\n    width = Math.max(1.0, width * 0.5);\n    height = Math.max(1.0, height * 0.5);\n  }\n\n  return mipmaps;\n}\n\n/**\n * Checks if the given data starts with a KTX file identifier.\n * @param data the data to check\n * @returns true if the data is a KTX file or false otherwise\n */\nfunction isValid(data: ArrayBuffer): boolean {\n  if (data.byteLength >= 12) {\n    // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\\r', '\\n', '\\x1A', '\\n'\n    const identifier = new Uint8Array(data, 0, 12);\n    if (\n      identifier[0] === 0xab &&\n      identifier[1] === 0x4b &&\n      identifier[2] === 0x54 &&\n      identifier[3] === 0x58 &&\n      identifier[4] === 0x20 &&\n      identifier[5] === 0x31 &&\n      identifier[6] === 0x31 &&\n      identifier[7] === 0xbb &&\n      identifier[8] === 0x0d &&\n      identifier[9] === 0x0a &&\n      identifier[10] === 0x1a &&\n      identifier[11] === 0x0a\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getEngineFormat(internalFormat: GLint): TextureFormat {\n  switch (internalFormat) {\n    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:\n    // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:\n    // break;\n    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:\n      return TextureFormat.DXT1;\n    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:\n      return TextureFormat.DXT5;\n    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:\n      return TextureFormat.ETC1_RGB;\n    case GLCompressedTextureInternalFormat.RGB8_ETC2:\n      return TextureFormat.ETC2_RGB;\n    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:\n      return TextureFormat.ETC2_RGBA5;\n    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:\n      return TextureFormat.ETC2_RGBA8;\n    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:\n      return TextureFormat.PVRTC_RGB2;\n    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:\n      return TextureFormat.PVRTC_RGBA2;\n    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:\n      return TextureFormat.PVRTC_RGB4;\n    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:\n      return TextureFormat.PVRTC_RGBA4;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:\n      return TextureFormat.ASTC_4x4;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:\n      return TextureFormat.ASTC_5x5;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:\n      return TextureFormat.ASTC_6x6;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:\n      return TextureFormat.ASTC_8x8;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:\n      return TextureFormat.ASTC_10x10;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:\n      return TextureFormat.ASTC_12x12;\n    default:\n      const formatName: any = GLCompressedTextureInternalFormat[internalFormat];\n      throw new Error(`this format is not supported in Oasis Engine: ${formatName}`);\n  }\n}\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n */\nexport const khronosTextureContainerParser = {\n  /**\n   *\n   * @param buffer contents of the KTX container file\n   * @param facesExpected should be either 1 or 6, based whether a cube texture or or\n   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented\n   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented\n   * @param mapEngineFormat get Oasis Engine native TextureFormat?\n   */\n  parse(\n    buffer: ArrayBuffer,\n    facesExpected: number,\n    withMipmaps: boolean,\n    mapEngineFormat: boolean = false\n  ): KTXContainer {\n    if (!isValid(buffer)) {\n      throw new Error(\"khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier\");\n    }\n\n    // load the reset of the header in native 32 bit uint\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT;\n    const headerDataView = new DataView(buffer, 12, 13 * dataSize);\n    const endianness = headerDataView.getUint32(0, true);\n    const littleEndian = endianness === 0x04030201;\n\n    const parsedResult: KTXContainer = {\n      buffer: buffer,\n      glType: headerDataView.getUint32(1 * dataSize, littleEndian), // must be 0 for compressed textures\n      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian), // must be 1 for compressed textures\n      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian), // must be 0 for compressed textures\n      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian), // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian), // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian), // used for texture arrays\n      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian), // used for cubemap textures, should either be 1 or 6\n      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian), // number of levels; disregard possibility of 0 for compressed textures\n      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian), // the amount of space after the header for meta-data\n      // would need to make this more elaborate & adjust checks above to support more than one load type\n      loadType: COMPRESSED_2D\n    };\n\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n    if (parsedResult.glType !== 0) {\n      throw new Error(\"only compressed formats currently supported\");\n    } else {\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);\n    }\n\n    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {\n      throw new Error(\"only 2D textures currently supported\");\n    }\n\n    if (parsedResult.numberOfArrayElements !== 0) {\n      throw new Error(\"texture arrays not currently supported\");\n    }\n\n    if (parsedResult.numberOfFaces !== facesExpected) {\n      throw new Error(\"number of faces expected\" + facesExpected + \", but found \" + parsedResult.numberOfFaces);\n    }\n\n    if (withMipmaps) {\n      parsedResult.mipmaps = getMipmaps(parsedResult, true);\n    }\n\n    if (mapEngineFormat) {\n      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);\n    }\n    return parsedResult;\n  }\n};\n","import { CompressedTextureData, CompressedCubeData } from \"./type\";\nimport { khronosTextureContainerParser } from \"./KhronosTextureContainer\";\nimport { TextureFormat } from \"@oasis-engine/core\";\n\nexport function parseSingleKTX(data: ArrayBuffer): CompressedTextureData {\n  const ktx = khronosTextureContainerParser.parse(data, 1, true, true);\n  return {\n    mipmaps: ktx.mipmaps,\n    engineFormat: ktx.engineFormat,\n    internalFormat: ktx.glInternalFormat,\n    width: ktx.pixelWidth,\n    height: ktx.pixelHeight\n  };\n}\n\nexport function parseCubeKTX(dataArray: ArrayBuffer[]): CompressedCubeData {\n  const mipmapsFaces = [];\n  let internalFormat: number;\n  let engineFormat: TextureFormat;\n  let width: number;\n  let height: number;\n  for (let i = 0; i < dataArray.length; i++) {\n    const ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);\n    mipmapsFaces.push(ktx.mipmaps);\n    if (i === 0) {\n      width = ktx.pixelWidth;\n      height = ktx.pixelHeight;\n      internalFormat = ktx.glInternalFormat;\n      engineFormat = ktx.engineFormat;\n    }\n  }\n  return {\n    mipmapsFaces,\n    engineFormat,\n    internalFormat,\n    width,\n    height\n  };\n}\n","import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  TextureCubeFace,\n  TextureCubeMap\n} from \"@oasis-engine/core\";\nimport { parseCubeKTX } from \"./compressed-texture\";\n\n@resourceLoader(AssetType.KTXCube, [])\nclass KTXCubeLoader extends Loader<TextureCubeMap> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<TextureCubeMap> {\n    return new AssetPromise((resolve, reject) => {\n      Promise.all(\n        item.urls.map((url) =>\n          this.request<ArrayBuffer>(url, {\n            ...item,\n            type: \"arraybuffer\"\n          })\n        )\n      )\n        .then((data) => {\n          const parsedData = parseCubeKTX(data);\n          const { width, mipmapsFaces, engineFormat } = parsedData;\n          const mipmap = mipmapsFaces[0].length > 1;\n          const texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);\n\n          for (let face = 0; face < 6; face++) {\n            const length = mipmapsFaces[face].length;\n\n            for (let miplevel = 0; miplevel < length; miplevel++) {\n              const { data, width, height } = mipmapsFaces[face][miplevel];\n\n              texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, miplevel, 0, 0, width, height);\n            }\n          }\n\n          resolve(texture);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n","import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  Texture2D\n} from \"@oasis-engine/core\";\nimport { parseSingleKTX } from \"./compressed-texture\";\n\n@resourceLoader(AssetType.KTX, [\"ktx\"])\nexport class KTXLoader extends Loader<Texture2D> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<Texture2D> {\n    return new AssetPromise((resolve, reject) => {\n      this.request<ArrayBuffer>(item.url, {\n        ...item,\n        type: \"arraybuffer\"\n      })\n        .then((bin) => {\n          const parsedData = parseSingleKTX(bin);\n          const { width, height, mipmaps, engineFormat } = parsedData;\n          const mipmap = mipmaps.length > 1;\n          const texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);\n\n          for (let miplevel = 0; miplevel < mipmaps.length; miplevel++) {\n            const { width, height, data } = mipmaps[miplevel];\n            texture.setPixelBuffer(data, miplevel, 0, 0, width, height);\n          }\n\n          resolve(texture);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n","import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  Texture2D\n} from \"@oasis-engine/core\";\n\n@resourceLoader(AssetType.Texture2D, [\"png\", \"jpg\", \"webp\", \"jpeg\"])\nclass Texture2DLoader extends Loader<Texture2D> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<Texture2D> {\n    return new AssetPromise((resolve, reject) => {\n      this.request<HTMLImageElement>(item.url, {\n        ...item,\n        type: \"image\"\n      })\n        .then((image) => {\n          const texture = new Texture2D(resourceManager.engine, image.width, image.height);\n          if (!texture._glTexture) return;\n          texture.setImageSource(image);\n          texture.generateMipmaps();\n\n          if (item.url.indexOf(\"data:\") !== 0) {\n            const splitPath = item.url.split(\"/\");\n            texture.name = splitPath[splitPath.length - 1];\n          }\n          resolve(texture);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n","import {\n  AssetPromise,\n  AssetType,\n  Loader,\n  LoadItem,\n  resourceLoader,\n  ResourceManager,\n  TextureCubeFace,\n  TextureCubeMap\n} from \"@oasis-engine/core\";\n\n@resourceLoader(AssetType.TextureCube, [\"\"])\nclass TextureCubeLoader extends Loader<TextureCubeMap> {\n  load(item: LoadItem, resourceManager: ResourceManager): AssetPromise<TextureCubeMap> {\n    return new AssetPromise((resolve, reject) => {\n      Promise.all(\n        item.urls.map((url) =>\n          this.request<HTMLImageElement>(url, {\n            ...item,\n            type: \"image\"\n          })\n        )\n      )\n        .then((images) => {\n          const { width, height } = images[0];\n\n          if (width !== height) {\n            console.error(\"The cube texture must have the same width and height\");\n            return;\n          }\n\n          const tex = new TextureCubeMap(resourceManager.engine, width);\n\n          if (!tex._glTexture) return;\n\n          for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n            tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);\n          }\n\n          tex.generateMipmaps();\n          resolve(tex);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n","import { Component, Entity, WrapMode, Animation } from \"@oasis-engine/core\";\nimport { GLTFResource } from \"./gltf/glTF\";\n\n/**\n * @deprecated\n * 暂时只为编辑器使用\n * 待编辑器完成 gltf 变成 prefab 移除\n */\nexport class GLTFModel extends Component {\n  get asset() {\n    return this._asset;\n  }\n\n  set asset(value: GLTFResource) {\n    if (value && value.defaultSceneRoot === this.GLTFNode) {\n      return;\n    }\n    if (!this._hasBuiltNode) {\n      (this.GLTFNode as any).clearChildren();\n      if (value !== null) {\n        if (this.GLTFNode) {\n          this.GLTFNode.destroy();\n        }\n        this.GLTFNode = value.defaultSceneRoot.clone();\n        this._animator = this.GLTFNode.getComponent(Animation);\n        this.entity.addChild(this.GLTFNode);\n      }\n    }\n    this._asset = value;\n  }\n\n  get animator() {\n    return this._animator;\n  }\n\n  get autoPlay() {\n    return this._autoPlay;\n  }\n\n  set autoPlay(value: string) {\n    if (this._animator) {\n      // 播放骨骼动画\n      if (value) {\n        this._animator.playAnimationClip(value, {\n          wrapMode: this._loop\n        });\n      } else {\n        this._animator.stop(false);\n      }\n    }\n    this._autoPlay = value;\n  }\n\n  get loop() {\n    return this._loop;\n  }\n\n  set loop(value: WrapMode) {\n    if (this._animator && this.autoPlay) {\n      // 播放骨骼动画\n      this._animator.playAnimationClip(this._autoPlay, {\n        wrapMode: value\n      });\n    }\n    this._loop = value;\n  }\n\n  public _animator: Animation;\n  public animationsNames: String[];\n\n  private _asset: GLTFResource;\n  private GLTFNode: Entity;\n  private _loop: number;\n  private _autoPlay: string;\n  private _hasBuiltNode: boolean = false;\n\n  constructor(entity) {\n    super(entity);\n  }\n\n  /**\n   * 初始化。\n   * @param props - 初始化属性\n   */\n  init(props): void {\n    const { asset = null, autoPlay, loop, isClone } = props;\n    if (isClone) {\n      const rootName = (props as any).gltfRootName;\n      if (rootName) {\n        this.GLTFNode = this.entity.findByName(rootName);\n      }\n    }\n    if (!this.GLTFNode) {\n      const rootName = `GLTF-${Date.now()}`;\n      (props as any).gltfRootName = rootName;\n      this.GLTFNode = this.entity.createChild(rootName);\n      this._hasBuiltNode = false;\n    } else {\n      this._hasBuiltNode = true;\n    }\n\n    this.asset = asset;\n    this.loop = loop;\n    this.autoPlay = autoPlay;\n\n    this.addEventListener(\"enabled\", () => {\n      this.GLTFNode.isActive = true;\n    });\n    this.addEventListener(\"disabled\", () => {\n      this.GLTFNode.isActive = false;\n    });\n  }\n}\n","import { Component, Entity } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { SchemaResource } from \"../resources\";\nimport { Plugin } from \"./Plugin\";\nexport class PluginManager implements PluginHook {\n  private registeredPlugins: Set<Plugin> = new Set();\n  private plugins: PluginHook[] = [];\n\n  register(plugin: Plugin) {\n    this.registeredPlugins.add(plugin);\n  }\n\n  boot(oasis: Oasis) {\n    for (let plugin of this.registeredPlugins.values()) {\n      if (typeof plugin === \"function\") {\n        plugin = plugin(oasis);\n      }\n      this.plugins.push(plugin);\n    }\n  }\n\n  reset() {\n    this.registeredPlugins.clear();\n    this.plugins = [];\n  }\n\n  nodeAdded(entity: Entity) {\n    this.delegateMethod(\"nodeAdded\", entity);\n  }\n\n  private delegateMethod(name: keyof PluginHook, ...args) {\n    this.plugins.forEach((plugin) => plugin[name] && (plugin[name] as any)(...args));\n  }\n}\n\nexport interface PluginHook {\n  oasis?: Oasis;\n  nodeAdded?(entity: Entity): any;\n  beforeNodeUpdated?(id: string, key: string, value: any): any;\n  nodeUpdated?(updateConfig?: { id: string; key: string; value: any }): any;\n  abilityAdded?(ability: Component): any;\n  beforeAbilityAdded?(config: any): any;\n  beforeAbilityUpdated?(id: string, key: string, value: any): any;\n  abilityUpdated?(updateConfig?: { id: string; key: string; value: any }): any;\n  schemaParsed?(): any;\n  abilityDeleted?(id: string): any;\n  beforeAbilityDeleted?(id: string): any;\n  beforeNodeDeleted?(config: any): any;\n  beforeResourceRemove?(id: string): any;\n  resourceUpdated?(info: { resource: SchemaResource; id: string; key: string; value: any }): any;\n  beforeResourceUpdate?(id: string, key: string, value: any): any;\n  // todo type\n  beforeResourceAdd?(resource: any): any;\n  resourceAdded?(resource: any): any;\n}\n\nexport function pluginHook(options: Partial<{ before: keyof PluginHook; after: keyof PluginHook }>): MethodDecorator {\n  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<any>) {\n    const method = descriptor.value;\n\n    descriptor.value = function (...args: any[]) {\n      options.before && this.oasis.pluginManager.delegateMethod(options.before, ...args);\n      return Promise.resolve(method.apply(this, arguments)).then((returnObj) => {\n        options.after && this.oasis.pluginManager.delegateMethod(options.after, returnObj);\n        return returnObj;\n      });\n    };\n  };\n}\n","export function switchElementsIndex(elements: any[], currentIndex: number, targetIndex: number) {\n  if (currentIndex === targetIndex || targetIndex === null || targetIndex === undefined) {\n    return;\n  }\n  [elements[currentIndex], elements[targetIndex]] = [elements[targetIndex], elements[currentIndex]];\n}\n\nexport function isAsset(config: any): boolean {\n  return config && config.type === \"asset\";\n}\n\nexport function getAllGetters(obj: any): Array<string> {\n  const result = [];\n  const prototype = Object.getPrototypeOf(obj);\n  const prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);\n  for (const [property, descriptor] of Object.entries(prototype_property_descriptors)) {\n    if (typeof descriptor.get === \"function\") {\n      result.push(property);\n    }\n  }\n  return result;\n}\n\n// 求数组并集\nexport function union(arr1: Array<any>, arr2: Array<any>): Array<any> {\n  return arr1.concat(arr2.filter((v) => !(arr1.indexOf(v) > -1)));\n}\n\n// https://github.com/BabylonJS/Babylon.js/blob/d780145531ac1b1cee85cbfba4d836dcc24ab58e/src/Engines/Extensions/engine.textureSelector.ts#L70\n// Intelligently add supported compressed formats in order to check for.\n// Check for ASTC support first as it is most powerful and to be very cross platform.\n// Next PVRTC & DXT, which are probably superior to ETC1/2.\n// Likely no hardware which supports both PVR & DXT, so order matters little.\n// ETC2 is newer and handles ETC1 (no alpha capability), so check for first.\nexport const compressedTextureLoadOrder = {\n  astc: 1,\n  s3tc: 2,\n  pvrtc: 3,\n  etc: 4,\n  etc1: 5\n};\n","import { Logger, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { SchemaResourceManager } from \"../ResourceManager\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { isAsset } from \"../utils\";\n\ninterface IResourceMeta {\n  name?: string;\n  url?: string;\n  size?: number;\n  source?: string;\n}\n\nexport abstract class SchemaResource {\n  protected _meta: IResourceMeta = {};\n  protected _attachedResources: Array<SchemaResource> = [];\n\n  /**\n   * 资源\n   */\n  get resource() {\n    return this._resource;\n  }\n\n  get meta(): IResourceMeta {\n    return this._meta;\n  }\n\n  get attachedResources() {\n    return this._attachedResources;\n  }\n\n  protected setMeta() {}\n\n  constructor(protected resourceManager: SchemaResourceManager, protected _resource?: any) {\n    this.setMeta();\n  }\n\n  abstract load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<SchemaResource>;\n  loadWithAttachedResources(\n    resourceLoader: any,\n    assetConfig: AssetConfig,\n    oasis: Oasis\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      this.load(resourceLoader, assetConfig, oasis)\n        .then(() => {\n          resolve({\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          });\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  getProps(): any {\n    return {};\n  }\n\n  bind(): void {}\n  attach(): void {}\n\n  update(key: string, value: any) {\n    if (isAsset(value)) {\n      const resource = this.resourceManager.get(value.id);\n      if (resource) {\n        this._resource[key] = resource.resource;\n      } else {\n        Logger.warn(`SchemaResource: ${this.meta.name} can't find asset, which id is: ${value.id}`);\n      }\n    } else {\n      this._resource[key] = value;\n    }\n  }\n\n  updateMeta(key: string, value: any) {\n    this._meta[key] = value;\n  }\n\n  onDestroy() {}\n}\n","import { AssetType, GLCapabilityType, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\n\nexport class TextureResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<TextureResource> {\n    return new Promise((resolve, reject) => {\n      let url: string;\n      let assetType = AssetType.Texture2D;\n      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {\n        const rhi = oasis.engine._hardwareRenderer;\n        const compressions = assetConfig.props.compression.compressions;\n        for (let i = 0; i < compressions.length; i++) {\n          const compression = compressions[i];\n          if (compression.container === \"ktx\" && rhi.canIUse(GLCapabilityType[compression.type])) {\n            url = compression.url;\n            assetType = AssetType.KTX;\n            break;\n          }\n        }\n      }\n\n      url = url ?? assetConfig.url;\n\n      resourceManager\n        .load({ url, type: assetType })\n        .then((res) => {\n          this._resource = res;\n          resolve(this);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this._meta.name = this.resource.name;\n      if (this.resource.image) {\n        this._meta.url = this.resource.image.src;\n      }\n    }\n  }\n}\n","import { Logger, PBRMaterial, ResourceManager, Texture } from \"@oasis-engine/core\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { getAllGetters, isAsset } from \"../utils\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { TextureResource } from \"./TextureResource\";\n\nexport class PBRMaterialResource extends SchemaResource {\n  private configProps;\n\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<PBRMaterialResource> {\n    return new Promise((resolve) => {\n      const assetObj = new PBRMaterial(resourceManager.engine, assetConfig.name);\n      this.configProps = assetConfig.props;\n\n      for (let k in this.configProps) {\n        if (!isAsset(this.configProps[k])) {\n          assetObj[k] = this.configProps[k];\n        }\n      }\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof PBRMaterial) {\n        loadPromise = new Promise((resolve) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load PBRMaterial Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result: any = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n\n          const material = this._resource;\n          getAllGetters(this._resource).forEach((attr) => {\n            if (!(material[attr] instanceof Texture)) return;\n            const textureResource = new TextureResource(this.resourceManager, material[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n\n  getProps() {\n    const result = {};\n    const props = getAllGetters(this.resource);\n    props.forEach((prop) => (result[prop] = this.resource[prop]));\n    return result;\n  }\n\n  bind() {\n    // 替换PBR材质中的纹理\n    const resource = this._resource;\n    Object.keys(this.configProps).forEach((attr) => {\n      const value = this.configProps[attr];\n      if (isAsset(value)) {\n        const textureResource = this.resourceManager.get(value.id);\n        if (textureResource && textureResource instanceof TextureResource) {\n          resource[attr] = textureResource.resource;\n          this._attachedResources.push(textureResource);\n        } else {\n          resource[attr] = null;\n          Logger.warn(`PBRMaterialResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`);\n        }\n      } else {\n        if (attr === \"side\") {\n          return;\n        }\n\n        resource[attr] = value;\n      }\n    });\n  }\n}\n","import { AssetType, Logger, ResourceManager, MeshRenderer, Material } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig, LoadAttachedResourceResult } from \"../types\";\nimport { PBRMaterialResource } from \"./PBRMaterialResource\";\nimport { SchemaResource } from \"./SchemaResource\";\nimport { glTFDracoMeshCompression } from \"../../gltf/glTFDracoMeshCompression\";\n\nexport class GLTFResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<any> {\n    if (!!assetConfig.props?.compression) {\n      glTFDracoMeshCompression.init();\n    }\n    return resourceManager\n      .load<any>({ url: assetConfig.url, type: AssetType.Perfab })\n      .then((res) => {\n        const gltf = res;\n        if (assetConfig.props) {\n          gltf.newMaterial = (assetConfig.props as any).newMaterial;\n        }\n        this._resource = gltf;\n      });\n  }\n\n  loadWithAttachedResources(\n    resourceManager: ResourceManager,\n    assetConfig: AssetConfig,\n    oasis: Oasis\n  ): Promise<LoadAttachedResourceResult> {\n    return new Promise((resolve) => {\n      this.load(resourceManager, assetConfig, oasis).then(() => {\n        const gltf = this.resource;\n        const { materials } = gltf;\n        const loadPromises = [];\n        const result = {\n          resources: [this],\n          structure: {\n            index: 0,\n            props: {\n              newMaterial: []\n            }\n          }\n        };\n        for (let i = 0; i < materials.length; i++) {\n          const material = materials[i];\n\n          const materialResource = new PBRMaterialResource(this.resourceManager);\n          this._attachedResources.push(materialResource);\n          loadPromises.push(\n            materialResource.loadWithAttachedResources(resourceManager, {\n              type: \"PBRMaterial\",\n              name: material.name,\n              resource: material\n            })\n          );\n        }\n        Promise.all(loadPromises).then((res) => {\n          const newMaterial = result.structure.props.newMaterial;\n          res.forEach((mat) => {\n            const matStructure = mat.structure;\n            const matResource = mat.resources[matStructure.index];\n            result.resources.push(matResource);\n            matStructure.index = result.resources.length - 1;\n            for (const key in matStructure.props) {\n              if (matStructure.props.hasOwnProperty(key)) {\n                const textureStructure = matStructure.props[key];\n                const textureResource = mat.resources[textureStructure.index];\n                result.resources.push(textureResource);\n                textureStructure.index = result.resources.length - 1;\n              }\n            }\n            newMaterial.push(matStructure);\n          });\n          resolve(result);\n        });\n      });\n    });\n  }\n\n  setMeta(assetConfig?: AssetConfig) {\n    if (assetConfig) {\n      this.meta.name = assetConfig.name;\n    }\n  }\n\n  bind() {\n    const resource = this._resource;\n    this.bindMaterials(resource.newMaterial);\n  }\n\n  update(key: string, value: any) {\n    if (key === \"newMaterial\") {\n      this.bindMaterials(value);\n    } else {\n      this._resource[key] = value;\n    }\n  }\n\n  private bindMaterials(materials) {\n    if (!materials || !materials.length) {\n      return;\n    }\n    const gltf = this._resource;\n    const meshes = gltf.meshes;\n\n    for (let i = 0; i < materials.length; i++) {\n      const mtlResource = this.resourceManager.get(materials[i].id);\n      if (mtlResource) {\n        this._attachedResources.push(mtlResource);\n        gltf.materials[i] = mtlResource.resource;\n      } else {\n        Logger.warn(`GLTFResource: ${this.meta.name} can't find asset \"material\", which id is: ${materials[i].id}`);\n      }\n    }\n    for (let j = 0; j < meshes.length; j++) {\n      const node = this.getNodeByMeshIndex(gltf.nodes, meshes.length - 1 - j);\n      if (node) {\n        for (let k = 0; k < meshes[j].primitives.length; k++) {\n          const primitive = meshes[j].primitives[k];\n          const meshRenderer = node.getComponent(MeshRenderer);\n          const material = gltf.materials[gltf.materials.length - 1 - primitive.materialIndex];\n          if (meshRenderer && material && material instanceof Material) {\n            meshRenderer.setSharedMaterial(k, material);\n          }\n        }\n      }\n    }\n  }\n\n  private getNodeByMeshIndex(nodes, index) {\n    for (let i = 0; i <= nodes.length; i++) {\n      const node = nodes[i];\n      if (node.meshIndex === index) {\n        return node;\n      }\n    }\n    return null;\n  }\n}\n","import { Engine, ShaderMaterial } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\ntype ShaderMaterialDefine = {\n  vertexShader: string;\n  fragmentShader: string;\n  states: object;\n  uniforms: object;\n  attributes: object;\n};\nexport class ShaderMaterialResource extends SchemaResource {\n  private scripts: Array<any>;\n\n  private loadShaderDefine(oasis?: Oasis) {\n    return new Promise((resolve) => {\n      const name = this.scripts[0].name;\n      if (this.resourceManager.isLocal) {\n        resolve(oasis.options?.scripts[name] ?? {});\n      } else {\n        const oldScriptDom = document.getElementById(name);\n        if (oldScriptDom) {\n          document.body.removeChild(oldScriptDom);\n        }\n\n        const scriptDom = document.createElement(\"script\");\n        scriptDom.crossOrigin = \"anonymous\";\n        scriptDom.onload = () => {\n          const scripts = (window as any).o3Scripts;\n          resolve((scripts && scripts[name]) ?? {});\n        };\n        scriptDom.id = name;\n        scriptDom.src = this._meta.url;\n        document.body.appendChild(scriptDom);\n      }\n    }).then((shaderMaterialDefine: ShaderMaterialDefine) => {\n      const {\n        vertexShader = \"\",\n        fragmentShader = \"\",\n        states = {},\n        uniforms = {},\n        attributes = {}\n      } = shaderMaterialDefine;\n      this._resource.uniforms = uniforms;\n      this._resource.attributes = attributes;\n      this._resource.vertexShader = vertexShader;\n      this._resource.fragmentShader = fragmentShader;\n      this._resource.renderStates = states;\n    });\n  }\n\n  private createMaterial(engine: Engine) {\n    const material = new ShaderMaterial(engine, this.meta.name || \"shader_mtl\");\n    this._resource = material;\n  }\n\n  load(resourceLoader: any, assetConfig: AssetConfig, oasis: Oasis): Promise<ShaderMaterialResource> {\n    this.setMeta(assetConfig);\n    this.scripts = assetConfig.props.scripts;\n    this.createMaterial(oasis.engine);\n\n    return this.loadShaderDefine(oasis).then(\n      () =>\n        new Promise((resolve, reject) => {\n          try {\n            for (let k in assetConfig.props) {\n              this._resource[k] = assetConfig.props[k];\n            }\n            this._resource.updateTechnique();\n            resolve(this);\n          } catch {\n            reject(\"[shader material] createTechnique error\");\n          }\n        })\n    );\n  }\n\n  setMeta(assetConfig?: AssetConfig) {\n    if (assetConfig) {\n      this._meta.name = assetConfig.name;\n      this._meta.url = assetConfig.url;\n      this._meta.source = assetConfig.source;\n    }\n  }\n\n  updateMeta(key: string, value: any) {\n    super.updateMeta(key, value);\n    if (key === \"url\") {\n      this.loadShaderDefine().then(() => {\n        try {\n          this._resource.updateTechnique();\n        } catch {\n          console.error(\"[shader material] createTechnique error\");\n        }\n      });\n    }\n  }\n\n  update(key: string, value: any) {\n    this._resource[key] = value;\n    this._resource.updateTechnique();\n  }\n}\n","import { SchemaResource } from \"./SchemaResource\";\nimport { AssetConfig } from \"../types\";\nimport { Oasis } from \"../Oasis\";\nimport { Parser } from \"../Parser\";\n\nexport const scriptAbility = {};\nexport function script(name: string) {\n  return (target: any) => {\n    scriptAbility[name] = target;\n  };\n}\nexport class ScriptResource extends SchemaResource {\n  private isInit = false;\n\n  private initScriptContext() {\n    if (this.isInit) {\n      return;\n    }\n    this.isInit = true;\n    (window as any).__o3_script_context__ = {\n      o3: Parser._components[\"o3\"],\n      script: (name: string) => {\n        return (target: any) => {\n          scriptAbility[name] = target;\n        };\n      }\n    };\n  }\n\n  load(resourceLoader, assetConfig: AssetConfig, oasis: Oasis): Promise<ScriptResource> {\n    this.initScriptContext();\n    return new Promise((resolve) => {\n      const config = assetConfig as any;\n      const scripts = config.props.scripts;\n\n      if (!this.resourceManager.isLocal) {\n        const scriptDom = document.createElement(\"script\");\n        scriptDom.crossOrigin = \"anonymous\";\n        this.setMeta(assetConfig);\n        scriptDom.onload = () => {\n          const o3Scripts = (window as any).o3Scripts;\n          for (let i = 0; i < scripts.length; i++) {\n            const name = scripts[i].name;\n            this._resource = o3Scripts && o3Scripts[name];\n            scriptAbility[name] = this._resource;\n          }\n          resolve(this);\n        };\n        scriptDom.src = assetConfig.url;\n        document.body.appendChild(scriptDom);\n      } else {\n        for (let i = 0; i < scripts.length; i++) {\n          const name = scripts[i].name;\n          scriptAbility[name] = oasis.options?.scripts[name];\n        }\n        resolve(this);\n      }\n    });\n  }\n\n  setMeta(assetConfig?: AssetConfig) {\n    if (assetConfig) {\n      this._meta.name = assetConfig.name;\n      this._meta.url = assetConfig.url;\n      this._meta.source = assetConfig.source;\n    }\n  }\n}\n","import { BlinnPhongMaterial, ResourceManager } from \"@oasis-engine/core\";\nimport { AssetConfig } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\n\nexport class BlinnPhongMaterialResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig): Promise<BlinnPhongMaterialResource> {\n    return new Promise((resolve) => {\n      const assetObj = new BlinnPhongMaterial(resourceManager.engine, assetConfig.name);\n      for (let k in assetConfig.props) {\n        assetObj[k] = assetConfig.props[k];\n      }\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n}\n","import { AssetType, GLCapabilityType, ResourceManager } from \"@oasis-engine/core\";\nimport { Oasis } from \"../Oasis\";\nimport { AssetConfig } from \"../types\";\nimport { SchemaResource } from \"./SchemaResource\";\n\nconst imageOrderMap = {\n  px: 0,\n  nx: 1,\n  py: 2,\n  ny: 3,\n  pz: 4,\n  nz: 5\n};\n\nexport class TextureCubeMapResource extends SchemaResource {\n  load(resourceManager: ResourceManager, assetConfig: AssetConfig, oasis: Oasis): Promise<TextureCubeMapResource> {\n    return new Promise((resolve, reject) => {\n      const imageUrls = [];\n      let type = AssetType.TextureCube;\n      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {\n        const rhi = oasis.engine._hardwareRenderer;\n        const compressions = assetConfig.props.compression.compressions;\n        for (let i = 0; i < compressions.length; i++) {\n          const compression = compressions[i];\n          if (compression.container === \"ktx\" && rhi.canIUse(GLCapabilityType[compression.type])) {\n            for (const key in compression.files) {\n              if (compression.files.hasOwnProperty(key)) {\n                const image = compression.files[key];\n                imageUrls[imageOrderMap[key]] = image.url;\n              }\n            }\n            console.warn(compression.type);\n            type = AssetType.KTXCube;\n            break;\n          }\n        }\n      }\n\n      if (type === AssetType.TextureCube) {\n        for (const key in assetConfig.props.images) {\n          if (assetConfig.props.images.hasOwnProperty(key)) {\n            const image = assetConfig.props.images[key];\n            imageUrls[imageOrderMap[key]] = image.url;\n          }\n        }\n      }\n\n      resourceManager\n        .load({\n          urls: imageUrls,\n          type: type\n        })\n        .then((res) => {\n          this._resource = res;\n          resolve(this);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n}\n","import { SchemaResource } from \"./SchemaResource\";\nimport { AssetConfig } from \"../types\";\n\nexport class BaseResource extends SchemaResource {\n  load(resourceLoader, assetConfig: AssetConfig): Promise<BaseResource> {\n    return new Promise((resolve) => {\n      this._resource = assetConfig;\n      this.setMetaData(\"name\", this.resource.name);\n      this.setMetaData(\"url\", this.resource.url);\n      resolve(this);\n    });\n  }\n\n  setMetaData(key, value) {\n    this._meta[key] = value;\n  }\n}\n","import { Component, Logger } from \"@oasis-engine/core\";\nimport { Oasis } from \"./Oasis\";\nimport { Parser } from \"./Parser\";\nimport { pluginHook } from \"./plugins/PluginManager\";\nimport { scriptAbility } from \"./resources\";\nimport { AbilityConfig, Props } from \"./types\";\nimport { switchElementsIndex } from \"./utils\";\n\nexport class AbilityManager {\n  private abilityMap: { [id: string]: Component } = {};\n\n  constructor(private oasis: Oasis) {}\n\n  @pluginHook({ after: \"abilityAdded\", before: \"beforeAbilityAdded\" })\n  public add(abilityConfig: AbilityConfig) {\n    const { type, node: nodeId, props, id, index } = abilityConfig;\n\n    const node = this.oasis.nodeManager.get(nodeId);\n    const AbilityConstructor = this.getCompConstructor(type);\n    if (!AbilityConstructor) {\n      Logger.error(`${type} abiltiy is not defined`);\n      return;\n    }\n\n    const abilityProps = this.mixPropsToExplicitProps(props);\n    const ability = node.addComponent(AbilityConstructor);\n    const { enabled } = abilityProps;\n    if (enabled !== undefined) {\n      ability.enabled = enabled;\n    }\n\n    if (type === \"Model\" || type === \"GLTFModel\" || type === \"Particle\") {\n      // TODO\n      (ability as any).init(abilityProps);\n    } else {\n      for (let k in abilityProps) {\n        if (abilityProps[k] !== null) {\n          ability[k] = abilityProps[k];\n        }\n      }\n    }\n\n    //@ts-ignore\n    const abilityArray = node._components;\n    const currentIndex = abilityArray.length - 1;\n    switchElementsIndex(abilityArray, currentIndex, index);\n    (ability as any).id = id;\n    this.abilityMap[id] = ability;\n    return ability;\n  }\n\n  @pluginHook({ before: \"beforeAbilityUpdated\", after: \"abilityUpdated\" })\n  public update(id: string, key: string, value: any) {\n    if (this.get(id).constructor.name === \"Model\") {\n      // TODO\n      if (value && this.checkIsAsset(value)) {\n        (this.get(id) as any).setProp(key, this.oasis.resourceManager.get(value.id).resource);\n      } else {\n        (this.get(id) as any).setProp(key, value);\n      }\n    } else {\n      if (value && this.checkIsAsset(value)) {\n        this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;\n      } else {\n        this.get(id)[key] = value;\n      }\n    }\n\n    return { id, key, value };\n  }\n\n  public get(id: string): Component {\n    return this.abilityMap[id];\n  }\n\n  @pluginHook({ after: \"abilityDeleted\", before: \"beforeAbilityDeleted\" })\n  public delete(id: string) {\n    const ability = this.abilityMap[id];\n    ability.destroy();\n    delete this.abilityMap[id];\n    return id;\n  }\n\n  private getCompConstructor(type: string) {\n    const splits = type.split(\".\");\n    // script\n    if (splits[0] === \"script\") {\n      return scriptAbility[splits[1]];\n    }\n\n    const constructor = Parser._components[\"o3\"][type];\n    if (!constructor) {\n      throw new Error(`${type} is not defined`);\n    }\n    return constructor;\n  }\n\n  private mixPropsToExplicitProps(props: Props) {\n    const explicitProps = { ...props };\n    for (let k in props) {\n      const prop = props[k];\n      if (prop && this.checkIsAsset(prop)) {\n        const res = this.oasis.resourceManager.get(prop.id);\n        if (res) {\n          explicitProps[k] = res.resource;\n        } else {\n          explicitProps[k] = null;\n          Logger.warn(`AbilityManager: can't get asset \"${k}\", which id is ${prop.id}`);\n        }\n      }\n    }\n    return explicitProps;\n  }\n\n  private checkIsAsset(prop: any): boolean {\n    return prop.type === \"asset\";\n  }\n}\n","import { Entity } from \"@oasis-engine/core\";\nimport { Vector3 } from \"@oasis-engine/math\";\nimport { Oasis } from \"./Oasis\";\nimport { pluginHook } from \"./plugins/PluginManager\";\nimport { NodeConfig } from \"./types\";\nimport { switchElementsIndex } from \"./utils\";\n\nexport class NodeManager {\n  private nodeMap: { [id: string]: Entity } = {};\n  private readonly root: Entity;\n\n  constructor(private oasis: Oasis) {\n    this.root = new Entity(this.oasis.engine, \"root\");\n  }\n\n  public addRootEntity() {\n    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);\n  }\n\n  @pluginHook({ after: \"nodeAdded\" })\n  public add(nodeConfig: NodeConfig) {\n    this.create(nodeConfig);\n    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);\n    return this.get(nodeConfig.id);\n  }\n\n  @pluginHook({ before: \"beforeNodeUpdated\", after: \"nodeUpdated\" })\n  public update(id: string, key: string, value: any) {\n    this.get(id)[key] = value;\n    return { id, key, value };\n  }\n\n  public get(id: string): Entity {\n    return this.nodeMap[id];\n  }\n\n  public reset() {\n    this.nodeMap = {};\n  }\n\n  @pluginHook({ before: \"beforeNodeDeleted\" })\n  public delete(id: string) {\n    this.nodeMap[id].destroy();\n    delete this.nodeMap[id];\n  }\n\n  /**\n   * 创建节点\n   * @param nodeConfig\n   */\n  private create(nodeConfig: NodeConfig): Entity {\n    const { isActive, position, rotation, scale, id, name } = nodeConfig;\n    const entity = new Entity(this.oasis.engine, name);\n    entity.isActive = isActive;\n    entity.transform.position = new Vector3(position[0], position[1], position[2]);\n    entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);\n    entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);\n    (entity as any).id = id;\n    this.nodeMap[id] = entity;\n    return entity;\n  }\n\n  /**\n   * append 节点到 parent\n   * @param childId\n   * @param parentId\n   * @param index\n   */\n  private append(childId: string, parentId: string, index: number) {\n    const child = this.nodeMap[childId];\n    const parent = this.nodeMap[parentId] || this.root;\n    parent.addChild(child);\n    //@ts-ignore\n    const children = parent._children;\n    const currentIndex = children.length - 1;\n    switchElementsIndex(children, currentIndex, index);\n  }\n}\n","import { ResourceManager, ObjectValues } from \"@oasis-engine/core\";\nimport { Oasis } from \"./Oasis\";\nimport { pluginHook } from \"./plugins/PluginManager\";\nimport {\n  BaseResource,\n  BlinnPhongMaterialResource,\n  GLTFResource,\n  PBRMaterialResource,\n  SchemaResource,\n  ScriptResource,\n  ShaderMaterialResource,\n  TextureCubeMapResource,\n  TextureResource\n} from \"./resources\";\nimport { AssetConfig } from \"./types\";\n\nexport const RESOURCE_CLASS = {\n  script: ScriptResource,\n  gltf: GLTFResource,\n  texture: TextureResource,\n  // 'image': TextureResource,\n  cubeTexture: TextureCubeMapResource,\n  PBRMaterial: PBRMaterialResource,\n  PBRSpecularMaterial: PBRMaterialResource,\n  unlitMaterial: PBRMaterialResource,\n  ShaderMaterial: ShaderMaterialResource,\n  BlinnPhongMaterial: BlinnPhongMaterialResource,\n  // Animation: Animation,\n  base: BaseResource\n};\n\nconst RESOURCE_TYPE: Map<SchemaResource, string> = new Map();\nfor (const key in RESOURCE_CLASS) {\n  if (RESOURCE_CLASS.hasOwnProperty(key)) {\n    const element = RESOURCE_CLASS[key];\n\n    // TODO：材质模块待重构，默认设置成 PBRMaterial\n    if (element === PBRMaterialResource) {\n      RESOURCE_TYPE.set(element, \"PBRMaterial\");\n    } else {\n      RESOURCE_TYPE.set(element, key);\n    }\n  }\n}\n\nconst resourceFactory = {\n  createResource(resourceManager: SchemaResourceManager, type: string): SchemaResource {\n    return new RESOURCE_CLASS[type](resourceManager);\n  }\n};\n\nexport function registerResource(type: string, resource: any) {\n  if (!RESOURCE_CLASS.hasOwnProperty(type)) {\n    RESOURCE_CLASS[type] = resource;\n    RESOURCE_TYPE.set(resource, type);\n  }\n}\n\nexport class SchemaResourceManager {\n  private resourceMap: { [id: string]: SchemaResource } = {};\n  private resourceIdMap: WeakMap<SchemaResource, string> = new WeakMap();\n  private maxId = 0;\n  private readonly engineResourceManager: ResourceManager;\n\n  constructor(private oasis: Oasis) {\n    this.engineResourceManager = this.oasis.engine.resourceManager;\n  }\n\n  // 从schema中加载资源\n  load(asset: AssetConfig): Promise<SchemaResource> {\n    const resource = resourceFactory.createResource(this, asset.type);\n    //TODO 脏代码\n    const loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);\n    this.maxId = Math.max(+asset.id, this.maxId);\n    loadPromise.then(() => {\n      this.resourceMap[asset.id] = resource;\n      this.resourceIdMap.set(resource, asset.id);\n    });\n    return loadPromise;\n  }\n\n  // 新增资源\n  add(asset: AssetConfig): Promise<any> {\n    const resource = resourceFactory.createResource(this, asset.type);\n    return new Promise((resolve) => {\n      //TODO 脏代码\n      resource.loadWithAttachedResources(this.oasis.engine.resourceManager, asset, this.oasis).then((result) => {\n        resolve(this.getAddResourceResult(result.resources, result.structure));\n      });\n    });\n  }\n\n  @pluginHook({ before: \"beforeResourceRemove\" })\n  remove(id: string): Promise<Array<string>> {\n    return new Promise((resolve) => {\n      const resource = this.resourceMap[id];\n      const result = [id];\n      let hasAttachedResource = false;\n      delete this.resourceMap[id];\n      if (resource) {\n        const attached = resource.attachedResources;\n        for (let index = 0; index < attached.length; index++) {\n          const attachedResource = attached[index];\n          const attachedResourceId = this.resourceIdMap.get(attachedResource);\n          if (attachedResourceId) {\n            hasAttachedResource = true;\n            this.remove(attachedResourceId).then((attachedResourceRemoveResult) => {\n              result.push(...attachedResourceRemoveResult);\n              resolve(result);\n            });\n          }\n        }\n      }\n      if (!hasAttachedResource) {\n        resolve(result);\n      }\n    });\n  }\n\n  @pluginHook({ after: \"resourceUpdated\", before: \"beforeResourceUpdate\" })\n  update(id: string, key: string, value: any) {\n    const resource = this.get(id);\n    if (resource) {\n      resource.update(key, value);\n    }\n    return {\n      resource,\n      id,\n      key,\n      value\n    };\n  }\n\n  updateMeta(id: string, key: string, value: any) {\n    const resource = this.get(id);\n    if (resource) {\n      resource.updateMeta(key, value);\n    }\n  }\n\n  get(id: string): SchemaResource {\n    return this.resourceMap[id];\n  }\n\n  getAll(): Array<SchemaResource> {\n    return ObjectValues(this.resourceMap);\n  }\n\n  private getAddResourceResult(resources, structure) {\n    const addResourceResult: any = {};\n    const resource = resources[structure.index];\n    const id = `${++this.maxId}`;\n    this.resourceMap[id] = resource;\n    this.resourceIdMap.set(resource, id);\n\n    addResourceResult.id = this.maxId;\n    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);\n    addResourceResult.meta = resource.meta;\n    addResourceResult.props = {};\n    for (const key in structure.props) {\n      if (structure.props.hasOwnProperty(key)) {\n        const element = structure.props[key];\n        if (element) {\n          if (Array.isArray(element)) {\n            addResourceResult.props[key] = element.map((child) => this.getAddResourceResult(resources, child));\n          } else {\n            addResourceResult.props[key] = this.getAddResourceResult(resources, element);\n          }\n        }\n      }\n    }\n    return addResourceResult;\n  }\n\n  get isLocal(): boolean {\n    return this.oasis.options.local;\n  }\n\n  get useCompressedTexture(): boolean {\n    return this.oasis.options.useCompressedTexture ?? true;\n  }\n}\n","import { Engine, EventDispatcher, ObjectValues } from \"@oasis-engine/core\";\nimport { AbilityManager } from \"./AbilityManager\";\nimport { NodeManager } from \"./NodeManager\";\nimport { pluginHook, PluginManager } from \"./plugins/PluginManager\";\nimport { RESOURCE_CLASS, SchemaResourceManager } from \"./ResourceManager\";\nimport { Options, Schema } from \"./types\";\n\nexport class Oasis extends EventDispatcher {\n  public readonly engine: Engine = null;\n  public readonly nodeManager: NodeManager;\n  public readonly abilityManager: AbilityManager;\n  public resourceManager: SchemaResourceManager;\n  public _canvas: HTMLCanvasElement;\n  private schema: Schema;\n  public timeout: number; // 全局资源超时配置\n  // hook 重点\n  private oasis = this;\n\n  private constructor(private _options: Options, public readonly pluginManager: PluginManager) {\n    super(_options.engine);\n    this.engine = _options.engine;\n    this.resetFeature();\n    this.schema = _options.config;\n    this.timeout = _options.timeout;\n    _options.scripts = _options.scripts ?? {};\n    this.nodeManager = new NodeManager(this);\n    this.abilityManager = new AbilityManager(this);\n    this.nodeManager.add = this.nodeManager.add.bind(this.nodeManager);\n    this.abilityManager.add = this.abilityManager.add.bind(this.abilityManager);\n    this.resourceManager = new SchemaResourceManager(this);\n    if (_options.fps) {\n      this.engine.targetFrameRate = _options.fps;\n      this.engine.vSyncCount = 0;\n    }\n  }\n\n  public get canvas(): HTMLCanvasElement {\n    return this._options.canvas;\n  }\n\n  public get options(): Readonly<Options> {\n    return this._options;\n  }\n\n  public updateConfig(config: Schema): void {\n    this.schema = config;\n\n    this.init();\n  }\n\n  @pluginHook({ after: \"schemaParsed\" })\n  private init(): Promise<any> {\n    return this.loadResources().then(() => {\n      this.bindResources();\n      this.parseEntities();\n      this.parseNodeAbilities();\n      // TODO 临时使用 用于运行时asset把id转化为各种实例\n      this.attach();\n      // 延迟添加 root entity。\n      this.nodeManager.addRootEntity();\n      this.pluginManager.boot(this);\n    });\n  }\n\n  /**\n   * 加载资源\n   */\n  private loadResources(): Promise<any> {\n    const { assets = {} } = this.schema;\n\n    const loadingPromises = ObjectValues(assets)\n      .filter((asset) => {\n        if (RESOURCE_CLASS[asset.type]) {\n          return true;\n        }\n        console.warn(`${asset.type} loader is not defined. the ${asset.type} type will be ignored.`);\n        return false;\n      })\n      .map((asset) => this.resourceManager.load(asset));\n\n    return Promise.all(loadingPromises);\n  }\n\n  /**\n   * 资源绑定\n   */\n  private bindResources() {\n    this.resourceManager.getAll().forEach((resource) => {\n      resource.bind();\n    });\n  }\n\n  /**\n   * 解析 nodes\n   */\n  private parseEntities(): void {\n    const { nodes } = this.schema;\n    const indices = this.bfsNodes();\n    indices.map((index) => nodes[index]).forEach(this.nodeManager.add);\n  }\n\n  /**\n   * 解析 Component\n   */\n  private parseNodeAbilities(): void {\n    const { abilities } = this.schema;\n    Object.keys(abilities)\n      .map((id) => ({ id, ...abilities[id] }))\n      .forEach(this.abilityManager.add);\n  }\n\n  /**\n   * 广度优先遍历，对 nodes 进行排序\n   */\n  private bfsNodes(): number[] {\n    const { nodes } = this.schema;\n    const roots = ObjectValues(nodes)\n      .filter((node) => !nodes[node.parent])\n      .map((node) => node.id);\n\n    let result = [];\n    const traverseChildren = (roots: string[]) => {\n      result = result.concat(roots);\n      roots.forEach((id) => {\n        const children = nodes[id].children;\n        children && traverseChildren(children);\n      });\n    };\n    traverseChildren(roots);\n    return result;\n  }\n\n  /**\n   * 重置 Feature\n   */\n  private resetFeature() {\n    // TODO 脏代码，delete\n    const scene = this.engine.sceneManager.activeScene;\n    scene.features.splice(2, 1);\n    scene.features.splice(3, 1);\n    (scene as any).hasFogFeature = undefined;\n    (scene as any).getFogMacro = undefined;\n    (scene as any).bindFogToMaterial = undefined;\n  }\n  private attach() {\n    this.resourceManager.getAll().forEach((resource) => {\n      resource.attach();\n    });\n  }\n\n  static create(options: Options, pluginManager: PluginManager): Promise<Oasis> {\n    const oasis = new Oasis(options, pluginManager);\n    return oasis.init().then(() => {\n      options.autoPlay && oasis.engine.run();\n      return oasis;\n    });\n  }\n}\n","import { Vector2, Vector3, Vector4 } from \"@oasis-engine/math\";\n\n// TODO  临时方案 用来将编辑器中用的数组转为引擎需要的数据类型，而不修改编辑器本身逻辑\nconst _vec3Attribute = [\n  \"color\",\n  \"center\",\n  \"size\",\n  \"__position\",\n  \"__positionRandomness\",\n  \"__color\",\n  \"__velocity\",\n  \"__velocityRandomness\",\n  \"__acceleration\",\n  \"__accelerationRandomness\",\n  \"_center\"\n];\n\n/**\n * 临时兼容到 v2 的 schema 数据\n * @param config\n */\nexport function compatibleToV2(config) {\n  const { abilities = {}, assets = {} } = config;\n  const ids = Object.keys(abilities);\n  const assetKeys = Object.keys(assets);\n\n  for (let i = 0, l = ids.length; i < l; ++i) {\n    handleProps(abilities[ids[i]].props);\n  }\n\n  for (let i = 0, l = assetKeys.length; i < l; ++i) {\n    handleAssets(assets[assetKeys[i]].props);\n  }\n\n  return config;\n}\n\n// TODO 临时方案\nfunction handleProps(props) {\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const k = keys[i];\n    const v = props[k];\n\n    if (v !== null && typeof v === \"object\" && v.length > 1) {\n      if (k === \"backgroundColor\" || k === \"tintColor\") {\n        props[k] = new Vector4(v[0], v[1], v[2], v[3]);\n      } else if (_vec3Attribute.indexOf(k) !== -1) {\n        props[k] = new Vector3(v[0], v[1], v[2]);\n      }\n    }\n  }\n}\n\nfunction handleAssets(props: any = {}) {\n  if (!props) {\n    return;\n  }\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = props[key];\n    if (key === \"newMaterial\" || key === \"blendFuncSeparate\" || key === \"scripts\") {\n      continue;\n    }\n    switch (value?.length) {\n      case 2:\n        props[key] = new Vector2(value[0], value[1]);\n        break;\n      case 3:\n        props[key] = new Vector3(value[0], value[1], value[2]);\n        break;\n      case 4:\n        props[key] = new Vector4(value[0], value[1], value[2], value[3]);\n        break;\n    }\n  }\n}\n","import { Component } from \"@oasis-engine/core\";\nimport { Oasis } from \"./Oasis\";\nimport { Plugin } from \"./plugins/Plugin\";\nimport { PluginManager } from \"./plugins/PluginManager\";\nimport { Options } from \"./types\";\nimport { compatibleToV2 } from \"./temp.compatible\";\n\nconst CURRENT_SCHEMA_VERSION = 3;\n\nexport class Parser {\n  private pluginManager: PluginManager = new PluginManager();\n  public parse(options: Options): Promise<Oasis> {\n    if (options?.config?.version !== CURRENT_SCHEMA_VERSION) {\n      console.warn(\n        `schema-parser: schema version \"${options?.config?.version}\" is out of date, please re-pull the latest version (version ${CURRENT_SCHEMA_VERSION}) of the schema`\n      );\n    }\n    compatibleToV2(options.config);\n    return Oasis.create(options, this.pluginManager);\n  }\n\n  register(plugin: Plugin) {\n    this.pluginManager.register(plugin);\n  }\n\n  resetPlugins() {\n    this.pluginManager.reset();\n  }\n\n  private constructor() {}\n\n  static create(): Parser {\n    const parser = new Parser();\n    return parser;\n  }\n\n  /** @internal */\n  public static _components: { [namespace: string]: { [compName: string]: Component } } = {};\n  /**\n   * 注册解析组件\n   * @param namespace 命名空间\n   * @param components 组件\n   */\n  static registerComponents(namespace: string, components: { [key: string]: any }) {\n    if (!this._components[namespace]) {\n      this._components[namespace] = {};\n    }\n    Object.assign(this._components[namespace], components);\n  }\n}\n\nexport const parser = Parser.create();\n"],"names":["glTFDracoMeshCompression2","OasisCamera","SchemaResource2","TextureResource2","PBRMaterialResource2","Parser2","__decorate","GLTFResource","NodeManager2","AbilityManager2","PluginManager2","Oasis2"],"mappings":"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"}