import { InterpolationType } from "./AnimationConst";
import { IChannel, ISample, List, Value } from "./types";
import { AssetObject } from "../asset/AssetObject";
export declare enum TagetType {
    position = 0,
    rotation = 1,
    scale = 2,
    other = 3
}
/**
 * Data for an animation, set of Samples and Channels
 * @extends AssetObject
 */
export declare class AnimationClip extends AssetObject {
    readonly name: string;
    private static _tagetTypeMap;
    duration: number;
    durationIndex: number;
    samplers: ISample[];
    channels: IChannel[];
    /**
     * @constructor
     * @param {string} name
     */
    constructor(name: string);
    /**
     * 添加一个 sampler
     * @param {Float32Array} _input
     * @param {Float32Array} _output
     * @param {number} _outputSize
     * @param {constant} _interpolation
     */
    addSampler(_input: List, _output: List, _outputSize: number, _interpolation?: InterpolationType): void;
    /**
     * 添加 channel
     * @param {number} samplerIndex
     * @param {string} targetID, Entity name
     * @param {string} targetPath, Transform property name: position, rotation, scale
     */
    addChannel(samplerIndex: number, targetID: string, targetPath: string): void;
    /**
     * 取得 channel 的总数
     * @return {number} number of channels
     */
    getChannelCount(): number;
    /**
     * 取得 channel 的作用的 object
     * @return channel objects
     * @param {number} channelIndex
     */
    getChannelObject(channelIndex: number): IChannel;
    /**
     * 取得 channel 的 frame count
     * @return channel frame count
     * @param {number} channelIndex
     */
    getFrameCount(channelIndex: number): number;
    /**
     * 取得 channel 的 frame time
     * @return channel frame time
     * @param {number} channelIndex
     * @param {number} frameIndex
     */
    getFrameTime(channelIndex: number, frameIndex: number): number;
    /**
     * 取得 channel 的时间长度
     * @return channel time length
     * @param {number} channelIndex
     */
    getChannelTimeLength(channelIndex: number): number;
    /**
     * 取得 channel 的值
     * @return channel value
     * @param {number} channelIndex
     */
    createChannelValue(channelIndex: number): number | Float32Array | number[];
    /**
     * @private
     * @param {Value} outValue
     * @param {number} channelIndex
     * @param {number} frameIndex
     * @param {number} nextFrameIndex
     * @param {number} alpha
     */
    evaluate(outValue: Value, channelIndex: number, frameIndex: number, nextFrameIndex: number, alpha: number): Value;
    evaluateCubicSpline(outValue: Value, output: List, outputSize: number, frameIndex: number, nextFrameIndex: number, alpha: number): void;
    evaluateLinear(outValue: Value, output: List, outputSize: number, frameIndex: number, nextFrameIndex: number, alpha: number): void;
    private _quaSlerp;
}
